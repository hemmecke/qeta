-- Via jupytext this file can be shown as a jupyter notebook.
-- For that one would have to move or link it to a file with
-- extension ".input".

)clear complete
assertEquals(x,y)==>(x=y)@Boolean
assertTrue x ==> x

)cd /home/hemmecke/g/qeta/tmp

)r projectlibs )quiet
)r etamacros.input )quiet

)set mess type on
)set output linear on
)set output algebra off

)set mess time on


-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q
L ==> F1 C
X ==> X1 C
S(CX) ==> UnivariateLaurentSeries(CX, 'q, 0)

-- The following function simply maps the integer coefficients of the
-- series into the localized coefficient domain or into the rational
-- number domain Q.

abmap(A, B, x) ==> _
  map((c: A): B +-> c::B, x)$Finite0SeriesFunctions2(A, B, 'q, 'q, 0, 0)
zcmap(x) ==> abmap(Z, C, x)
cqmap(x) ==> abmap(C, Q, x)
zqmap(x) ==> abmap(Z, Q, x)

PolC ==> Pol C; LC ==> F1 C
PolZ ==> Pol Z; LZ ==> F1 Z

asP x ==> x pretend P
asLP x ==> x pretend List(P)

numOfGaps(ab) == (_
  t := multiplier ab; _
  n := qetaGrade(t)::P; _
  grades := [qetaGrade(first basis(ab, i))::P for i in 1..n-1]; _
  numberOfGaps(n, grades)$QAuxiliaryModularEtaQuotientPackage)

QEQEV ==> QEtaQuotientExponentVectors4ti2

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

-- # Relations in terms of the $M_i$'s

-- +
-------------------------------------------------------------------
--test:Zudilin128
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 128). The variable `rgens` corresponds to the generators
-- of $R^\infty(128)$.

level := 128;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;

rgensExpected: List List Z := [_
    [0, 0, 0, 0, - 1, 2, 1, - 2], [0, 0, 0, 0, 0, - 2, 6, - 4],_
    [0, 0, 0, - 2, 5, - 2, 1, - 2], [0, 0, 0, 2, - 1, 0, 1, - 2],_
    [0, - 2, 5, - 2, 0, 0, 1, - 2], [0, 2, - 1, 0, 0, 0, 1, - 2],_
    [0, 0, 0, - 1, 2, - 1, 4, - 4], [0, 0, - 2, 5, - 2, - 1, 4, - 4],_
    [0, 0, 2, - 1, 0, - 1, 4, - 4], [- 2, 5, - 2, 0, 0, - 1, 4, - 4],_
    [2, - 1, 0, 0, 0, - 1, 4, - 4], [0, 0, - 2, 4, 0, 0, 2, - 4],_
    [0, 0, 2, - 2, 2, 0, 2, - 4], [- 2, 5, - 2, - 1, 2, 0, 2, - 4],_
    [2, - 1, 0, - 1, 2, 0, 2, - 4], [0, 0, 0, - 1, 0, 5, 0, - 4],_
    [0, 0, - 2, 5, - 4, 5, 0, - 4], [0, 0, 2, - 1, - 2, 5, 0, - 4],_
    [- 2, 5, - 2, 0, - 2, 5, 0, - 4], [2, - 1, 0, 0, - 2, 5, 0, - 4],_
    [0, 0, 0, 0, - 4, 10, - 2, - 4], [- 2, 5, - 4, 5, - 2, 0, 2, - 4],_
    [2, - 1, - 2, 5, - 2, 0, 2, - 4], [0, 0, - 4, 10, - 4, 0, 2, - 4],_
    [- 2, 5, 0, - 1, 0, 0, 2, - 4], [2, - 1, 2, - 1, 0, 0, 2, - 4],_
    [- 4, 10, - 4, 0, 0, 0, 2, - 4], [4, - 2, 0, 0, 0, 0, 2, - 4]];
assertEquals(rgens, rgensExpected)

divs := divisors(level)$IntegerNumberTheoryFunctions;
etaquotgensZ: List EtaQuotient(Z, LZ) := [etaQuotient(divs, r) for r in rgens];
for x in etaquotgensZ repeat assertTrue(zero? prefactor x)

eqgensZ: List LZ := [retract x for x in etaquotgensZ];
eqgens: List L := [zcmap x for x in eqgensZ];
assertEquals([qetaGrade x for x in eqgens],_
  [6, 8, 8, 8, 8, 8, 11, 12, 12, 12, 12, 15, 15, 15, 15, 15, _
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])

msyms := indexedSymbols("M", #eqgens)

xeqgens: List X := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X := xeqgens.1
abex := samba(tex, xeqgens)$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 9)
assertEquals(numOfGaps(abex), 9)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_128

q := monomial(1,1)$F1(C)
f128 := q - 2*q^3 + 6*q^5 - 20*q^7 - 23*q^9 - 14*q^11 + 54*q^13 - 12*q^15 - _
  66*q^17 - 162*q^19 + 40*q^21 - 172*q^23 - 89*q^25 + 100*q^27 - 2*q^29 + _
  128*q^31 + 28*q^33 - 120*q^35 + 158*q^37 - 108*q^39 + 202*q^41 + _
  298*q^43 - 138*q^45 + 408*q^47 + 57*q^49 + 132*q^51 - 690*q^53 - 84*q^55 _
  + 324*q^57 + 322*q^59 - 298*q^61 + 460*q^63 + 324*q^65 - 202*q^67 + _
  344*q^69 + 700*q^71 - 418*q^73 + 178*q^75 + 280*q^77 - 744*q^79 + _
  421*q^81 + 678*q^83 - 396*q^85 + 4*q^87 - 82*q^89 - 1080*q^91 - 256*q^93 _
  - 972*q^95 - 1122*q^97 + 322*q^99 + 1390*q^101 - 788*q^103 + 240*q^105 - _
  1614*q^107 + 2014*q^109 - 316*q^111 - 542*q^113 - 1032*q^115 - _
  1242*q^117 + 1320*q^119 - 1135*q^121 - 404*q^123 - 1284*q^125 - _
  1712*q^127 - 596*q^129 + 2118*q^131 + 3240*q^133 + 600*q^135 - 486*q^137 _
  - 1286*q^139 - 816*q^141 - 756*q^143 - 12*q^145 - 114*q^147 - 2666*q^149 _
  - 172*q^151 + 1518*q^153 + 768*q^155 + 838*q^157 + 1380*q^159 + _
  3440*q^161 - 1346*q^163 + 168*q^165 + 1052*q^167 + 719*q^169 + _
  3726*q^171 + 38*q^173 + 1780*q^175 - 644*q^177 + 2790*q^179 - 3418*q^181 _
  + 596*q^183 + 948*q^185 + 924*q^187 - 2000*q^189 + 1968*q^191 - _
  1058*q^193 - 648*q^195 + 726*q^197 - 4116*q^199 + 404*q^201 + 40*q^203 + _
  1212*q^205 + 3956*q^207 + 2268*q^209 - 1482*q^211 - 1400*q^213 + _
  1788*q^215 - 2560*q^217 + 836*q^219 - 3564*q^221 + 896*q^223 + _
  2047*q^225 - 3410*q^227 + 4502*q^229 - 560*q^231 + 2302*q^233 + _
  2448*q^235 + 1488*q^237 - 4024*q^239 - 3586*q^241 - 3542*q^243 + _
  342*q^245 - 8748*q^247 - 1356*q^249 + 1250*q^251 + 2408*q^253 + _
  792*q^255 - 6638*q^257 - 3160*q^259 + 46*q^261 + 1724*q^263 - 4140*q^265 _
  + 164*q^267 + 4814*q^269 + 1640*q^271 + 2160*q^273 + 1246*q^275 + _
  3982*q^277 - 2944*q^279 + 4126*q^281 - 3446*q^283 + 1944*q^285 - _
  4040*q^287 - 557*q^289 + 2244*q^291 - 1514*q^293 + 1932*q^295 - _
  1400*q^297 - 9288*q^299

rwgens := etaQuotientExponentVectors(level, [1,2,3,4,5,6,7], -8)$QEQEV;

rcofactor := first rwgens
assertEquals(rcofactor, [0, 0, 0, 0, -1, 2, 9, -18])
eqcofactor := retract etaQuotient(divs, rcofactor)$EtaQuotient(C, L)
eqcofactors := [retract etaQuotient(divs, r)$EtaQuotient(C, L) for r in rwgens];
assertEquals([qetaGrade x for x in eqcofactors],_
  [70, 72, 72, 72, 72, 72, 75, 76, 76, 76, 76, 79, 79, 79, 79, 79, _
  80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80])


f := f128 * eqcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 1024*xfr
pol := second(ixfr)::PolC + F  -- This corresponds to the mod func f.

assertEquals(pol,_
  ((-2*M1^8-24*M1^7+8*M1^6-56*M1^5+336*M1^4+368*M1^3+256*M1^2)*M6+2*M1^9_
  -56*M1^8+12*M1^7-128*M1^6+400*M1^5+704*M1^4-224*M1^3-1024*M1^2-1024*M1)*M7_
  +(M1^9-20*M1^8+48*M1^7-136*M1^6+96*M1^5+288*M1^4+160*M1^3+64*M1^2-64*M1)*M16)

pol0 := M0*pol -- Corresponds to the original f128.
assertEquals(# monomials pol0, 25)

h(l) == E1^l.1*E2^l.2*E4^l.3*E8^l.4*E16^l.5*E32^l.6*E64^l.7*E128^l.8

rgens0 := members(- vector rcofactor)
vals := cons(h(rgens0), [h x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

FPZ ==> Fraction PolZ
PE==>PolynomialEvaluation(Z, FPZ)

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

epol := (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol);
epoln := numer epol;
epold := denom epol;

esyms := indexedSymbols("E", divs)
dim: N := #esyms
DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

E ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, E)
e(l) ==> retract etaQuotient(divs, l)$ETA(C)

rpoln := toRZ epoln
rpold := degree toRZ epold
irpold := (-rpold)::RZ
rpol := rpoln * irpold
ms := [leadingCoefficient x * e members degree x for x in monomials rpol];
z := reduce(_+, ms) - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- But we kill all the given coefficients for f128.

assertEquals(order(z::L, 300), 231)

-- Show nicely

num := rez rpoln
den := rez(rpold :: RZ)




-- Now we do the same thing for the modular form f128 itself.
epol0 := (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol0);
epol0n := numer epol0;
epol0d := denom epol0;

rpol0n := toRZ epol0n
rpol0d := degree toRZ epol0d
irpol0d := (-rpol0d)::RZ
rpol0 := rpol0n * irpol0d
ms0 := [leadingCoefficient x * e members degree x for x in monomials rpol0];
z0 := reduce(_+, ms0) - f128

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.

assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])
assertEquals(#monomials(rez rpol0n), 25)

-- Show nicely

num0 := rez rpol0n
den0 := rez(rpol0d :: RZ)

-------------------------------------------------------------------
-- Mail Zudillin 17-Feb-2020:

equ(l) ==> etaQuotient(divs, l)$ETA(C)

brunaultterms := [_
  [   1, 2, 1,3, 3,-1,0,0,0],_
  [   2, 0, 2,3, 2, 1,0,0,0],_
  [   8, 0, 0,2, 2, 2,2,0,0],_
  [ -24, 0, 0,2, 0, 2,4,0,0],_
  [ -16, 0, 2,1, 2,-1,0,4,0],_
  [ -64, 0, 0,0, 1, 2,3,2,0],_
  [  32, 0, 0,0,-1, 2,5,2,0],_
  [ -32, 0, 0,4, 1,-1,1,1,2],_
  [ -64, 0, 0,0, 1, 3,1,1,2],_
  [-256, 0, 0,0,-1, 3,3,1,2],_
  [ 128, 0, 0,2, 0,-1,2,3,2],_
  [-256, 0, 0,4,-1, 0,1,0,4],_
  [-128, 0, 0,0,-1, 4,1,0,4],_
  [-512, 0, 0,2, 0, 0,0,2,4]_
 ]

f128brunault := reduce(_+, [first(x)*retract(equ rest x) for x in brunaultterms])
z := f128brunault - f128
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])

-------------------------------------------------------------------
-- Finding other symmetry group for f_128.
-------------------------------------------------------------------

o := reduce(_+, [width(level, denom cusp) for cusp in cuspsOfGamma0(level)])
assertEquals(o, indexOfGamma0 level)
reps := rightCosetRepresentatives level;
assertEquals(# reps, o)
reta24 := [24, 0,0,0,0,0,0,0] -- exponent vector for delta(\tau)=eta^24
eta24 := e reta24 -- = eta^(-24)

-- f128^3/eta24 = f^3*(eta24*eqcofactor^3)
-- f6 is modular function with poles only at the cusps, but not necessarily
-- only at infinity.

cvector := - (vector reta24 + 3*vector rcofactor)
f3 := f^3  / (        eta24 *         eqcofactor^3)

-- f^6 corresponds to xf^6, i.e., pol^6. To each of the variables Mi in pol
-- corresponds the r-vector rgens.i

assertTrue(zero? reduce(_+, members cvector))

yeq3g(l, g) ==> etaQuotient(level, asLP divs, l, g)$YETAQG
eq3g(l, g) ==> expansion(etaQuotient(yeq3g(l,g))$ETAQG(C,CX))

-- Check that cvector indeed belongs to a modular eta-quotient for Gamma0(45).

idmat := matrix [[1,0],[0,1]]
yeq := yeq3g(members cvector, idmat);
modular? yeq

xiord := 24*level
CX := UnityRootExtension(C, xiord); xi := generator()$CX
eq := etaQuotient(yeq)$ETAQG(C,CX);
expansion eq

-- We change to all cusps, i.e., we also change some domains.

equn(r) ==> etaQuotient(level, r, 1, [0], 1, 0, cusps)$YMSETAQ
expand e ==> expansions(expandAtAllCusps(e)$MSETAQ(C, CX))::Fn(CX);

cusps := cuspsOfGamma0(level)
ycogen := equn members cvector;
minimalRootOfUnity ycogen
mcogen := expand ycogen;
qetaGrades mcogen

-- Now we can multiply rpol^6 with the monomial corresponding to cvector.
-- This will give a representation of f45^6/eta24 as a Q-linear combination
-- of eta-quotients.
-- We cannot reduce this representation by our samba basis abex, because
-- f45^6/eta24 does not only have poles at infinity.

cpol := directProduct(cvector)$DZ::RZ
f3pol := rpol^3 * cpol;
mons3 := monomials f3pol;

-- Obviously, the coefficients are integers, so we can form a list of
-- vectors similar to brunaultterms.

terms3 := [cons(leadingCoefficient(m)::Z, members degree m) for m in mons3];

-- terms6 corresponds to a sum of eta-quotients.

-- Check that we do not need a bigger root of unity.

ygens3 := [equn rest x for x in terms3];
assertTrue(xiord > max [minimalRootOfUnity y for y in ygens3])

-- Check that all eta-quotients in terms6 correspond really to modular
-- functions.

assertEquals(removeDuplicates [modular? yeq3g(rest x, idmat) for x in terms3], [true])


-- We now apply SL2Z transformations to each of the summands and check
-- whether we obtain equal power series expansions. The
-- transformations are the indexOfGamma0(level)
-- reps:=rightCosetRepresentatives(level) stored in the variable reps.

tsum(terms, gamma) == reduce(_+, [first(x)*eq3g(rest x, gamma) for x in terms])

-- Safety check whether the identity matrix gives the already known
-- expansion.

f3id := tsum(terms3, first reps) -- first reps = identity matrix
f3x := abmap(C, CX, f3)::S(CX)
fdiff := f3id - f3x
assertEquals(removeDuplicates [coefficient(fdiff, i) for i in -20..50], [0])

-- Now we can compute all the expansions at all other gamma from reps.

tsers :=[tsum(terms3, gamma) for gamma in reps];

)set stream calc 4

findSimilarExpansions(qseries: List S CX): List List Z == (_
    REC ==> Record(fo: Z, fi: Z, fc: S CX);_
    oics := [[order x, i, x]$REC for x in qseries for i in 1..#qseries];_
    l := oics;_
    result := empty()$List(List Z);_
    while not empty? l repeat (_
        a := first l;_
        l2 := rest l;_
        while not empty? l2 repeat (_
            b := first l2;_
            if a.fo = b.fo then (_
                ser := a.fc/b.fc;_
                cs := [coefficient(ser, i) for i in 1..20];_
                if removeDuplicates [zero? c for c in cs] = [true] then (_
                    print(hconcat [[a.fi, b.fi]::OF, [ser]::OF]);_
                    result := cons([a.fi, b.fi], result)));_
            l2 := rest l2);_
        l := rest l);_
    result);

result := findSimilarExpansions(tsers);
#result

-- +
-------------------------------------------------------------------
-- Find the expansion of f_128 at the cusp 0.
-------------------------------------------------------------------
WIDTH(cusp) ==> width(level, denom cusp)$QAuxMEQ
TOMAT(cusp) ==> cuspToMatrix(level, cusp)
IMAT(mat) ==> inverse(mat)::MZ
rmons := monomials rpol;
rterms := [cons(leadingCoefficient(m)::Z, members degree m) for m in rmons];
creps := [TOMAT(cusp) for cusp in cusps]
hmat := matrix [[1,1],[0,1]]
[WIDTH(cusp) for cusp in cusps]
xreps := concat [(gamma:=TOMAT(cusp); [gamma*((hmat^i)::MZ) for i in 0..WIDTH(cusp)-1]) for cusp in cusps];

findEquivalentMatrix(mat: MZ, mats: List MZ): List Z == (_
    res: List Z := empty();_
    imat := IMAT mat;_
    for m in mats for i in 1.. repeat (_
        if zero? positiveRemainder((m * imat)(2,1), level) then (_
            res := cons(i, res))_
    );_
    res);

indexPermutation := [first findEquivalentMatrix(reps.i, xreps) for i in 1..#reps]

tseratcusps := [tsum(rterms, gamma) for gamma in creps];
xseratcusps := [tsum(rterms, gamma) for gamma in xreps];
rsers := [tsum(rterms, gamma) for gamma in reps];
#xseratcusps
result := findSimilarExpansions(tseratcusps);
xresult := findSimilarExpansions(xseratcusps);
#xresult
rresult := findSimilarExpansions(rsers);
#rresult


xtsers :=[tsum(terms3, gamma) for gamma in xreps];
ctsers :=[tsum(terms3, gamma) for gamma in creps];
x3result := findSimilarExpansions(xtsers);
#x3result


)set stream calc 4
for i in 1..#xreps repeat (_
    print("-----------------"::Symbol);_
    print([[i]]);_
    print(xreps.i);_
    print(tsum(rterms, xreps.i)))

-- +
-------------------------------------------------------------------
-- Create a modular function with expansion at all cusps.
-------------------------------------------------------------------

msum(terms) == reduce(_+, [first(x)*expand(equn(rest x)) for x in terms])
fAtAllCusps := msum(rterms);
f3AtAllCusps := msum(terms3);

cseries := [series(fAtAllCusps, i) - tseratcusps.i for i in 1..#cusps];
assertEquals(removeDuplicates [removeDuplicates [coefficient(x, i) for i in -60..20] for x in cseries], [[0]])

-- +
-------------------------------------------------------------------
-- Adjust f to other cofactor. Then g := f*fadjust is a modular function,
-- but with poles not only at infinity.
-------------------------------------------------------------------

idivs := empty()$List(Z)
z:=zsolve4ti2(level, idivs, concat([0 for i in idivs], -8))$QEQEV;
vmodadjust := (first z.zinhom)(1..#divs) - vector rcofactor
radjustterms := [cons(first x, members(vector rest x + vmodadjust)) for x in rterms]
fadjustAtAllCusps := msum(radjustterms);

-- fadjustAtAllCusps has series expansion of the form q*series(q^2) at
-- every cusp.

qetaGrades fadjustAtAllCusps
xtadjustsers :=[tsum(radjustterms, gamma) for gamma in xreps];
xadjustresult := findSimilarExpansions(xtadjustsers);
#xadjustresult
ser := xtadjustsers.3 - xtadjustsers.145
cs := [coefficient(ser, i) for i in -24..100]

-- +
-------------------------------------------------------------------
-- Try to find an adjustment with just poles at cusp 1/1.
-------------------------------------------------------------------
reta := [-24,24,0,0,0,0,0,0]
yeta := equn reta;
eeta := expand yeta;
qetaGrades eeta
fadjusteta := fadjustAtAllCusps * eeta;
qetaGrades fadjusteta

-- We can do the samba computation just for the cusp 1/1.

)set stream calc 2
)set stream showall off
nn := level
--rs := eqmevx level
rs64 := etaQuotientMonoidExponentVectors(64, [2,3,4,5,6,7])$QEQEV;
cusps64 := cuspsOfGamma0 64
cusps := cusps64
equn64(r) ==> etaQuotient(64, r, 1, [0], 1, 0, cusps64)$YMSETAQ
qsyms64 := indexedSymbols("Q", #rs64)
ygens64 := [equn64 rsi for rsi in rs64];
--xiord := max [minimalRootOfUnity y for y in ygens64]
egens64 := [expand y for y in ygens64];
[qetaGrades x for x in egens64]

)read /home/hemmecke/g/qeta/input/tracing.input
)read /home/hemmecke/g/qeta/input/tracingpower.input

--ab64 := samba(xgens64,onetnStep!)$QXSAMBAn(CX);
--ab64 := samba(xgens64)$QXSAMBAn(CX);

-- The above computation does not work, so we do the compuation just
-- at the cusp 1/1.

xgens64 := [toX1(CX, series(x, 1)::F1(CX), s) for x in egens64 for s in qsyms64]
tex64 := 2*xgens64.1
abex64 := samba(tex64, xgens64)$QXTOPSAMBA1(CX)
assertEquals(genusOfGamma0(64), numOfGaps(abex64))
fadjusteta1 := series(fadjusteta, 1)::F1(CX)
[qetaCoefficient(fadjusteta1, i) for i in 0..95]
)set stream calc 20
abex64
xfadjusteta1 := toX1(CX, fadjusteta1, 'F);
xfr64 := reduce(xfadjusteta1, abex64)$QXTOPRED1(CX)
512*xfr64

f3eta1 := series(f3AtAllCusps*eeta, 1)::F1(CX)
xf3eta1 := toX1(CX, f3eta1, 'F3);
xf3r64 := reduce(xf3eta1, abex64)$QXTOPRED1(CX); -- takes > 30 min

qetaGrades fadjustAtAllCusps


idivs := [1,2,3,4,5,6]
z:=zsolve4ti2(64, idivs, concat([31*24,31*24,0,0,0,0], [0,0,12]))$QEQEV;
rcofac64 := concat(members((z.zinhom.1)(1..7)), 0)
fadjust2 := expand equn rcofac64
fadjusted := fadjustAtAllCusps * fadjust2
qetaGrades fadjusted

[[WIDTH x, width(64, denom x)$QAuxMEQ,x] for x in cusps]
[[cusps.i, WIDTH(cusps.i), width(64, denom(cusps.i))$QAuxMEQ, series(fadjusted, i)] for i in 1..#cusps]

-- fadjusted is, in fact a modular function for Gamma_0(64). So let's
-- multiply with another nice eta-quotient that brings it to M^\infty(64).



-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------




-- +
-------------------------------------------------------------------
--test:Zudilin45
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 45). The variable `rgens` corresponds to the generators
-- of $R^\infty(45)$.

level := 45;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;

divs := divisors(level)$IntegerNumberTheoryFunctions;
etaquotgensZ: List EtaQuotient(Z, LZ) := [etaQuotient(divs, r) for r in rgens];
for x in etaquotgensZ repeat assertTrue(zero? prefactor x)

eqgensZ: List LZ := [retract x for x in etaquotgensZ];

eqgens: List L := [zcmap x for x in eqgensZ];
assertEquals([qetaGrade x for x in eqgens],_
    [4, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11,_
    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15,_
    16, 16, 16, 16, 17, 18])

msyms := indexedSymbols("M", #eqgens)
xeqgens: List X := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X := xeqgens.1
abex := samba(tex, xeqgens)$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 3)
assertEquals(numOfGaps(abex), 3)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_45

q := monomial(1,1)$F1(C)

-- Zudilin (Mail Silviu "Date: Thu, 6 Feb 2020 14:16:19 +0100")
-- f_45(\tau) = eta^(1,1,1,0,1,0) + eta^(0,1,0,1,1,1) + 2*eta^(0,1,0,0,3,0) -
--              4*eta^(0,1,0,0,1,2)*q^(7/2)*
--              geneta(45, [3,9,12,-18,-27,33,36,42])

f45silviu := 1*q+1*q^2-1*q^4-1*q^5-3*q^8-1*q^10+4*q^11-2*q^13-1*q^16-2*q^17 _
  +4*q^19+1*q^20+4*q^22+1*q^25-2*q^26+2*q^29+5*q^32-2*q^34-10*q^37 _
  +4*q^38+3*q^40-10*q^41+4*q^43-4*q^44-8*q^47-7*q^49+1*q^50+2*q^52 _
  +10*q^53-4*q^55+2*q^58+4*q^59-2*q^61+7*q^64+2*q^65+12*q^67+2*q^68 _
  +8*q^71+10*q^73-10*q^74-4*q^76+1*q^80-10*q^82-12*q^83+2*q^85+4*q^86 _
  -12*q^88+6*q^89-8*q^94-4*q^95+2*q^97-7*q^98

-- generalized eta-quotient
a(n,k)==(1-q^(45*n+k))
xn(n) == reduce(_*, [a(n,k) for k in [3,9,12,33,36,42]])
xd(n) == reduce(_*, [a(n,k) for k in [18,27]])
s := reduce(_*, [xn(n)/xd(n) for n in 0..10])
equ(l) ==> etaQuotient(divs, l)$ETA(C)
equs(l) ==> series equ l
l := [0,1,0,0,1,2]
f45trunc := equs[1,1,1,0,1,0] + equs[0,1,0,1,1,1] + 2*equs[0,1,0,0,3,0] _
  - 4*q^(((7*12+prefactor equ l) exquo 24)::Z)*equs(l)*s

QF ==> QFunctions(C, F1 C)
p(i) ==> qPochhammer(1, i, 45)$QF
ns := reduce(_*, [p k for k in [3,9,12,33,36,42]])
ds := reduce(_*, [p k for k in [18,27]])
s := ns/ds

f45 := equs[1,1,1,0,1,0] + equs[0,1,0,1,1,1] + 2*equs[0,1,0,0,3,0] _
  - 4*q^(((7*12+prefactor equ l) exquo 24)::Z)*equs(l)*s

z := f45 - f45trunc

idivs := [i for i in 1.. #divs-1]
rwgens := etaQuotientExponentVectors(level, idivs,-4)$QEQEV;

rcofactor := rwgens.1
assertEquals(rcofactor, [0, -2, 0, 6, 4, -12])
eqcofactor := retract etaQuotient(divs, rcofactor)$EtaQuotient(C, L)
eqcofactors := [retract etaQuotient(divs, r)$EtaQuotient(C, L) for r in rwgens];
assertEquals([qetaGrade x for x in eqcofactors], _
  [18, 20, 20, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 24, 24, 24, _
  25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, _
  28, 28, 28, 28, 28, 29, 30, 30, 30, 30, 31, 32])

f := f45 * eqcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..200], [0])

ixfr := 5 * xfr
pol := ((second(ixfr)::PolC + F)::PolZ)

-- pol corresponds to the modular function f_45 * eqcofactor
assertEquals(pol, (-M1^3+3*M1^2)*M3+(M1^3-6*M1^2-5*M1)*M2+4*M1^3-M1^2-5*M1)

pol0 := M0*pol
# monomials pol0
vars := sort(variables pol0)
assertEquals(vars, [M0, M1, M2, M3])

h(l) == E1^l.1*E3^l.2*E5^l.3*E9^l.4*E15^l.5*E45^l.6

rgens0 := members(- vector rcofactor)
vals := cons(h(rgens0), [h x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

FPZ ==> Fraction PolZ
PE==>PolynomialEvaluation(Z, FPZ)

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

epol := (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol);
assertEquals(epol, _
  (-E1*E15^4*E45*E5*E9^11+E15^8*E9^10+4*E15^3*E3*E45^5*E9^9 _
   +3*E1*E15^3*E3*E45^4*E5*E9^8-6*E15^7*E3*E45^3*E9^7 _
   -E15^2*E3^2*E45^8*E9^6-5*E15^6*E3^2*E45^6*E9^4-5*E15*E3^3*E45^11*E9^3)_
   /_
   (E3^4*E45^14))

epoln := numer epol;
epold := denom epol;

esyms := indexedSymbols("E", divs)
dim: N := #esyms
DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

E ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, E)
e(l) ==> retract etaQuotient(divs, l)$ETA(C)

rpoln := toRZ epoln
rpold := degree toRZ epold
irpold := (-rpold)::RZ
rpol := rpoln * irpold
ms := [leadingCoefficient x * e members degree x for x in monomials rpol];
z := reduce(_+, ms) - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- Show nicely

num := rez rpoln
den := rez(rpold :: RZ)

-------------------------------------------------------------------
-- # Problem: Zudilin has a relation with only 7 terms for f_45.
-------------------------------------------------------------------
-- Just multiplying a "smaller" cofactor does not work, because we would
-- not work in M^\infty(45).
-- Zudilin suggested the following cofactor eta-quotient, because
-- he had already found a 7-term relation for f_45, namely,
-- (mail wzudilin@gmail.com "Fri, 7 Feb 2020 11:40:38 +0100")

)if IGNORE
( 3*q^4 * eta(q^9)^4 * eta(q^15)^4
-15*q^8 * eta(q^3) * eta(q^9) * eta(q^15)^3 * eta(q^45)^3
-5*q^3 * eta(q^3) * eta(q^5)^3 * eta(q^9) * eta(q^15)^3
+4*q^3 * eta(q^3)^2 * eta(q^9)^4 * eta(q^15)^2
+q^7 * eta(q^3)^3 * eta(q^9) * eta(q^15) * eta(q^45)^3
+q^5 * eta(q) * eta(q^3)^3 * eta(q^5) * eta(q^15) * eta(q^45)^2
+q^3 * eta(q)^3 * eta(q^9) * eta(q^15)^4 )
/
( q^4 * eta(q^3)^2 * eta(q^45)^2 )
)endif

-- where eta(q) is obviously the EulerProduct.

-- We store the terms as a list of [coeff, etaexponents].

brunaultterms := [_
  [  3, 0,-2,0,4,4,-2],_
  [-15, 0,-1,0,1,3, 1],_
  [- 5, 0,-1,3,1,3,-2],_
  [  4, 0, 0,0,4,2,-2],_
  [  1, 0, 1,0,1,1, 1],_
  [  1, 3,-2,0,1,4,-2],_
  [  1, 1, 1,1,0,1, 0] _
 ]

f45brunault := reduce(_+, [first(x)*retract(equ rest x) for x in brunaultterms])
f45diff := f45brunault-f45;
coeffsf45 :=  [qetaCoefficient(f45diff, -i) for i in 0..300];
assertEquals(removeDuplicates coeffsf45, [0])


rbrunault := rest(brunaultterms.1)
-- It corresponds to the denominator (exponent 2) and the monomial
-- eta(q^9)^4*eta(q^15).

-- In the following we aim at finding the above relation by means of
-- powersamba.

equn(r) ==> etaQuotient(level, r, 1, [0], 1, 0, cusps)$YMSETAQ
expand e ==> expansions(expandAtAllCusps(e)$MSETAQ(C, CX))::Fn(CX);

-------------------------------------------------------------------
-- We use powersamba to overcome the above problem
-------------------------------------------------------------------

-- We represent f45 by an expression from pol where the Mi are replaced
-- by the respective (power) eta-quotient expressions.

-- First let's compute a powersamba basis.

QEQMEVS ==> QEtaQuotientMonoidExponentVectorsStar
eqmevx ==> etaQuotientMonoidExponentVectorsX$QEQMEVS

)set stream calc 2
)set stream showall off
nn := level
--rs := eqmevx level
rs := etaQuotientMonoidExponentVectors(level, [2,3,4,5])$QEQEV;

allcusps := cuspsOfGamma0 level
cusps := [1, 1/45]

qsyms := indexedSymbols("Q", #rs)
ygens := [equn rsi for rsi in rs];
xiord := max [minimalRootOfUnity y for y in ygens]
if xiord < 3 then (CX := Q; xi := -(1$CX)) else _
  (CX := UnityRootExtension(C, xiord); xi := generator()$CX)
egens := [expand y for y in ygens];
[qetaGrades x for x in egens]


assertEquals([qetaGrades x for x in egens], [_
  [1, 3], [4, 2], [2, 4], [4, 4], [5, 1], [6, -2], [6, 2], [0, 6],_
  [7, -1], [8, -8], [8, 0], [-4, 8], [-8, 8], [9, -3], [10, -4], _
  [10, -2], [11, -7], [12, -6], [12, -4], [14, -8], [16, -12]])

xgens := [toXn(CX, x, s) for x in egens for s in qsyms];

)read /home/hemmecke/g/qeta/input/tracing.input
)read /home/hemmecke/g/qeta/input/tracingpower.input

--ab := samba(xgens, onetnStep!)$QXSAMBAn(CX);
ab := samba(xgens)$QXSAMBAn(CX);

xlm := entries multipliers ab
xlb := concat concat [entries x for x in members basisElements ab]
xl := concat(xlm, xlb)
--ab2 := samba(xl, onetnStep!)$QXSAMBAn(CX);
ab2 := samba(xl)$QXSAMBAn(CX);

mults := multipliers ab;
idx := indexPermutation ab
ms := [mults idx i for i in 1..#idx]
qs := [qetaGrades x for x in ms]



-------------------------------------------------------------------
-- Reduction
-------------------------------------------------------------------

-------------------------------------------------------------------

-- In pol, We have to replace the Mi by eta-quotient corresponding to
-- rgens(i).

valsn := [toXn(CX, expand equn r, msym) for r in rgens for msym in msyms];
PEX==>PolynomialEvaluation(Z, Xn CX)

1$Xn(CX)
3 * 1$Xn(CX)
id(c: Z): Xn(CX) == c*1$Xn(CX)
id(5)
xmfn := (eval(id, msyms, valsn)$PEX)(pol);
qetaGrades xmfn
assertEquals(qetaGrades xmfn, [-1, 17])
-- xmfn corresponds to the same modular function as xf, but with expansion
-- at the cusps given by the variable "cusps".

[[order series(x,i::P) for i in 1..#cusps] for x in egens]
mf := (first(xmfn)::Fn(CX))
[order series(mf,i::P) for i in 1..#cusps]
xfn := toXn(CX, mf, 'F)
xfr := reduce(xfn, ab)$QXREDn(CX)
xfr2 := reduce(xfn, ab2)$QXREDn(CX);

assertTrue(zero? xfr)
assertTrue(zero? xfr2)

assertEquals(removeDuplicates [order(series(first(xfr)::Fn(CX), i), 9) for i in 1..#cusps], [9])

-- Find an eta-quotient that reduces the pole order at infinity at the cost
-- of increasing the pole order at 0.
-- We have already such eta-quotients given by rs (or egens).
-- Multiplying xfn by xgens.1

z := zsolve4ti2(level, [2,3,4,5,6], [0,0,0,0,24*17])
zi := [x(1..#divs) for x in z.zinhom]
zsyms := indexedSymbols("Z", #zi)
xzi := [toXn(CX, expand equn x, s) for x in zi for s in zsyms];
xzisorted := sort((a1:Xn(CX),a2:Xn(CX)):Boolean +-> qetaGrades a1 < qetaGrades a2, xzi)

xfn1 := xfn*first(xzisorted)
xfr1 := reduce(xfn1, ab)$QXREDn(CX)
assertEquals(removeDuplicates [order(series(first(xfr1)::Fn(CX), i), 9) for i in 1..#cusps], [9])

zero? xfr1

qpol := 183708000*(-(second(xfr1))::Pol(CX) + F*Z13)
sort variables qpol
#monomials qpol

zh := [x(1..#divs) for x in z.zhom];
hsyms := indexedSymbols("H", #zh)
xzh := [toXn(CX, expand equn x, s) for x in zh for s in hsyms];
xzhsorted := sort((a1:Xn(CX),a2:Xn(CX)):Boolean +-> qetaGrades a1 < qetaGrades a2, xzh)
[qetaGrades x for x in xzhsorted]

abh := samba(xzhsorted)$QXSAMBAn(CX);
xfhr1 := reduce(xfn1, abh)$QXREDn(CX)
assertTrue(zero? xfhr1)

-------------------------------------------------------------------
-- Finding other symmetry group for f_45.
-------------------------------------------------------------------

o := reduce(_+, [width(level, denom cusp) for cusp in cuspsOfGamma0(level)])
assertEquals(o, indexOfGamma0 level)
reps := rightCosetRepresentatives level;
assertEquals(# reps, o)
reta24 := [24, 0,0,0,0,0] -- exponent vector for delta(\tau)=eta^24
eta24 := e reta24 -- = eta^(-24)

-- f45^6/eta24 = f^6*(eta24*eqcofactor^6)
-- f6 is modular function with poles only at the cusps, but not necessarily
-- only at infinity.

cvector := - (vector reta24 + 6*vector rcofactor)
f6 := f^6  / (        eta24 *         eqcofactor^6)

-- f^6 corresponds to xf^6, i.e., pol^6. To each of the variables Mi in pol
-- corresponds the r-vector rgens.i

assertTrue(zero? reduce(_+, members cvector))

-- Now we can multiply rpol^6 with the monomial corresponding to cvector.
-- This will give a representation of f45^6/eta24 as a Q-linear combination
-- of eta-quotients.
-- We cannot reduce this representation by our samba basis abex, because
-- f45^6/eta24 does not only have poles at infinity.

cpol := directProduct(cvector)$DZ::RZ
f6pol := rpol^6 * cpol;
mons6 := monomials f6pol;

-- Obviously, the coefficients are integers, so we can form a list of
-- vectors similar to brunaultterms.

terms6 := [cons(leadingCoefficient(m)::Z, members degree m) for m in mons6];

-- For each of the terms and for each of the right coset
-- representatives that are given through reps, we compute an element of
-- SymbolicEtaQuotientGamma to figure out which root of unity is needed.

yeq6g(l, g) ==> etaQuotient(level, asLP divs, l, g)$YETAQG
--yeq6g(l, g) ==> etaQuotient(level, asLP divs, l, asP 1, 0 pretend Z, g pretend MZ)$YSETAQG
ygterms := [[yeq6g(rest x, gamma) for x in terms6] for gamma in reps];
xiord := 24*max [max [minimalRootOfUnity y for y in l] for l in ygterms]
CX := UnityRootExtension(C, xiord); xi := generator()$CX

assertEquals(removeDuplicates [removeDuplicates [modular? y for y in l] for l in ygterms], [[true]])

tsum(terms, gamma) == reduce(_+, [first(x)*eq6g(rest x, gamma) for x in terms])

eq6g(l, g) ==> expansion(etaQuotient(yeq6g(l,g))$ETAQG(C,CX))

-- Check that cvector indeed belongs to a modular eta-quotient for Gamma0(45).

idmat := matrix [[1,0],[0,1]]
yeq := yeq6g(members(cvector)$Vector(Z), idmat);
minimalRootOfUnity yeq
assertTrue(modular? yeq)

eq := etaQuotient(yeq)$ETAQG(C,CX);
expansion eq

-- We change to all cusps, i.e., we also change some domains.

cusps := allcusps
ycogen := equn members cvector;
minimalRootOfUnity ycogen
mcogen := expand ycogen
qetaGrades mcogen

-- Check that all eta-quotients in terms6 correspond really to modular
-- functions.

assertEquals(removeDuplicates [modular? yeq6g(rest x, idmat) for x in terms6], [true])


-- We now apply SL2Z transformations to each of the summands and check
-- whether we obtain equal power series expansions. The
-- transformations are the indexOfGamma0(level)
-- reps:=rightCosetRepresentatives(level) stored in the variable reps.

tsum(terms, gamma) == reduce(_+, [first(x)*eq6g(rest x, gamma) for x in terms])

-- Safety check whether the identity matrix gives the already known
-- expansion.

f6id := tsum(terms6, first reps) -- first reps = identity matrix
f6x := abmap(C, CX, f6)::S(CX)
fdiff := f6id - f6x
assertEquals(removeDuplicates [coefficient(fdiff, i) for i in -20..50], [0])

-- Now we can compute all the expansions at all other gamma from reps.

tsers :=[tsum(terms6, gamma) for gamma in reps];

)set stream calc 4

oics := [[order x, i, x]$Record(fo: Z, fi: Z, fc: S CX) for x in tsers for i in 1..#tsers];

l := oics;
while not empty? l repeat (_
  a := first l;_
  l2 := rest l;_
  while not empty? l2 repeat (_
    b := first l2;_
    if a.fo = b.fo then (_
        ser := a.fc/b.fc;_
        csz := removeDuplicates [zero? coefficient(ser, i) for i in 1..20];_
        if csz = [true] then (print([a.fi, b.fi]); print(ser)));_
    l2 := rest l2);_
  l := rest l)

mcusps := [cuspToMatrix(level, x) for x in cuspsOfGamma0(45)]
mats := concat(mcusps, reps);
l := mats;
while not empty? l repeat (_
  a := first l;_
  l2 := rest l;_
  while not empty? l2 repeat (_
    mat := a * (inverse(first l2)::MZ);_
    if zero? positiveRemainder(mat(2,1), level) then print([a, first l2, mat]);_
    l2 := rest l2);_
  l := rest l)

-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
