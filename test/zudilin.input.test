-- Via jupytext this file can be shown as a jupyter notebook.
-- For that one would have to move or link it to a file with
-- extension ".input".

)clear complete
assertEquals(x,y)==>(x=y)@Boolean
assertTrue x ==> x

)cd /home/hemmecke/g/qeta/tmp

)r projectlibs )quiet
)r etamacros.input )quiet

)set mess type on
)set output linear on
)set output algebra off

)set mess time on


-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q

-- The following function simply maps the integer coefficients of the
-- series into the localized coefficient domain or into the rational
-- number domain Q.

abmap(A, B, x) ==> _
  map((c: A): B +-> c::B, x)$Finite0SeriesFunctions2(A, B, 'q, 'q, 0, 0)
zcmap(x) ==> abmap(Z, C, x)
cqmap(x) ==> abmap(C, Q, x)
zqmap(x) ==> abmap(Z, Q, x)

PolC ==> Pol C
PolZ ==> Pol Z
FPZ ==> Fraction PolZ
PE ==> PolynomialEvaluation(Z, FPZ)
EVALFPZ(vars, vals, pol) ==> (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol)

asP x ==> x pretend P
asLP x ==> x pretend List(P)

DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

PERZ ==> PolynomialEvaluation(C, RZ)
EVALRZ(vars, vals, pol) ==> (eval((c:C):RZ +-> c, vars, vals)$PERZ)(pol)

monRZ(l: List Z): RZ == monomial(1, directProduct(l)$DZ)

-- A "term" here is a coefficient (Integer) cons'd to a list of
-- exponents for every divisor of level. See brunaultterms.

termRZ(term: List Z): RZ == monomial(first term, directProduct(rest term)$DZ)
polyRZ(terms: List List Z): RZ == reduce(_+, [termRZ x for x in terms], 0$RZ)

rzToA1C(x: RZ): A1(C) == _
    reduce(_+, [leadingCoefficient(mon)*EQA1C(members degree mon) _
                for mon in monomials x])
rzToL1CX(x: RZ, gamma: SL2Z): L1(CX) == _
    reduce(_+, [leadingCoefficient(mon)*EQGL1CX(members degree mon, gamma) _
                for mon in monomials x])
rzToAnCX(x: RZ): An(CX) == _
    reduce(_+, [leadingCoefficient(mon)*EQAnCX(members degree mon) _
                for mon in monomials x])


E ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, E)

-- Implicit global variables:
-- C: The coefficient ring where we consider the q-expansions.
-- level: We consider the modular group Gamma_0(level).
YEQ1C(r) ==> etaQuotient(level, r)$ETA(C)
EQA1C(r) ==> expansion YEQ1C r -- expansion at infinity (element of A1(C)

-- Implicit global variables:
-- level:   We consider the modular group Gamma_0(level).
-- spitzen: The cusps at which to expand.
-- xiord:   We compute with the xiord-th root of unity
-- xi:      A xiord-th root of unity in CX
-- CX:      An C-Algebra containing xi.
-- Call macro EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi).
YEQn(r) ==> etaQuotient(level, r, spitzen)$YETAQ
EXPAND x ==> expansions(x::METAQ(C, CX))::An(CX);
EQAnCX(r) ==> EXPAND YEQn r -- expansion at all cusps for moduler eta-quotients

YEQG1(l, g) ==> etaQuotient(level, l, g)$YETAQG
EQGL1CX(l, g) ==> expansion(YEQG1(l, g)::ETAQG(C, CX))$ETAQG(C,CX)

TOMAT(cusp) ==> cuspToMatrix(level, cusp)
IMAT(mat) ==> inverse(mat)::MZ

QEQEV ==> QEtaQuotientExponentVectors4ti2


numOfGaps(ab) == (_
  t := multiplier ab; _
  n := qetaGrade(t)::P; _
  grades := [qetaGrade(first basis(ab, i))::P for i in 1..n-1]; _
  numberOfGaps(n, grades)$QAuxiliaryModularEtaQuotientPackage)

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

-- # Relations in terms of the $M_i$'s

-- +
-------------------------------------------------------------------
--test:Zudilin128
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 128). The variable `rgens` corresponds to the generators
-- of $R^\infty(128)$.

level := 128;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;

rgensExpected: List List Z := [_
    [0, 0, 0, 0, - 1, 2, 1, - 2], [0, 0, 0, 0, 0, - 2, 6, - 4],_
    [0, 0, 0, - 2, 5, - 2, 1, - 2], [0, 0, 0, 2, - 1, 0, 1, - 2],_
    [0, - 2, 5, - 2, 0, 0, 1, - 2], [0, 2, - 1, 0, 0, 0, 1, - 2],_
    [0, 0, 0, - 1, 2, - 1, 4, - 4], [0, 0, - 2, 5, - 2, - 1, 4, - 4],_
    [0, 0, 2, - 1, 0, - 1, 4, - 4], [- 2, 5, - 2, 0, 0, - 1, 4, - 4],_
    [2, - 1, 0, 0, 0, - 1, 4, - 4], [0, 0, - 2, 4, 0, 0, 2, - 4],_
    [0, 0, 2, - 2, 2, 0, 2, - 4], [- 2, 5, - 2, - 1, 2, 0, 2, - 4],_
    [2, - 1, 0, - 1, 2, 0, 2, - 4], [0, 0, 0, - 1, 0, 5, 0, - 4],_
    [0, 0, - 2, 5, - 4, 5, 0, - 4], [0, 0, 2, - 1, - 2, 5, 0, - 4],_
    [- 2, 5, - 2, 0, - 2, 5, 0, - 4], [2, - 1, 0, 0, - 2, 5, 0, - 4],_
    [0, 0, 0, 0, - 4, 10, - 2, - 4], [- 2, 5, - 4, 5, - 2, 0, 2, - 4],_
    [2, - 1, - 2, 5, - 2, 0, 2, - 4], [0, 0, - 4, 10, - 4, 0, 2, - 4],_
    [- 2, 5, 0, - 1, 0, 0, 2, - 4], [2, - 1, 2, - 1, 0, 0, 2, - 4],_
    [- 4, 10, - 4, 0, 0, 0, 2, - 4], [4, - 2, 0, 0, 0, 0, 2, - 4]];
assertEquals(rgens, rgensExpected)

eqgens := [EQA1C r for r in rgens];
assertEquals([qetaGrade x for x in eqgens],_
  [6, 8, 8, 8, 8, 8, 11, 12, 12, 12, 12, 15, 15, 15, 15, 15, _
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])

msyms := indexedSymbols("M", #eqgens)

xeqgens: List X1 C := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X1 C := xeqgens.1
abex := samba(tex, xeqgens)$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 9)
assertEquals(numOfGaps(abex), 9)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_128

q := monomial(1,1)$A1(C)
f128 := q - 2*q^3 + 6*q^5 - 20*q^7 - 23*q^9 - 14*q^11 + 54*q^13 - 12*q^15 - _
  66*q^17 - 162*q^19 + 40*q^21 - 172*q^23 - 89*q^25 + 100*q^27 - 2*q^29 + _
  128*q^31 + 28*q^33 - 120*q^35 + 158*q^37 - 108*q^39 + 202*q^41 + _
  298*q^43 - 138*q^45 + 408*q^47 + 57*q^49 + 132*q^51 - 690*q^53 - 84*q^55 _
  + 324*q^57 + 322*q^59 - 298*q^61 + 460*q^63 + 324*q^65 - 202*q^67 + _
  344*q^69 + 700*q^71 - 418*q^73 + 178*q^75 + 280*q^77 - 744*q^79 + _
  421*q^81 + 678*q^83 - 396*q^85 + 4*q^87 - 82*q^89 - 1080*q^91 - 256*q^93 _
  - 972*q^95 - 1122*q^97 + 322*q^99 + 1390*q^101 - 788*q^103 + 240*q^105 - _
  1614*q^107 + 2014*q^109 - 316*q^111 - 542*q^113 - 1032*q^115 - _
  1242*q^117 + 1320*q^119 - 1135*q^121 - 404*q^123 - 1284*q^125 - _
  1712*q^127 - 596*q^129 + 2118*q^131 + 3240*q^133 + 600*q^135 - 486*q^137 _
  - 1286*q^139 - 816*q^141 - 756*q^143 - 12*q^145 - 114*q^147 - 2666*q^149 _
  - 172*q^151 + 1518*q^153 + 768*q^155 + 838*q^157 + 1380*q^159 + _
  3440*q^161 - 1346*q^163 + 168*q^165 + 1052*q^167 + 719*q^169 + _
  3726*q^171 + 38*q^173 + 1780*q^175 - 644*q^177 + 2790*q^179 - 3418*q^181 _
  + 596*q^183 + 948*q^185 + 924*q^187 - 2000*q^189 + 1968*q^191 - _
  1058*q^193 - 648*q^195 + 726*q^197 - 4116*q^199 + 404*q^201 + 40*q^203 + _
  1212*q^205 + 3956*q^207 + 2268*q^209 - 1482*q^211 - 1400*q^213 + _
  1788*q^215 - 2560*q^217 + 836*q^219 - 3564*q^221 + 896*q^223 + _
  2047*q^225 - 3410*q^227 + 4502*q^229 - 560*q^231 + 2302*q^233 + _
  2448*q^235 + 1488*q^237 - 4024*q^239 - 3586*q^241 - 3542*q^243 + _
  342*q^245 - 8748*q^247 - 1356*q^249 + 1250*q^251 + 2408*q^253 + _
  792*q^255 - 6638*q^257 - 3160*q^259 + 46*q^261 + 1724*q^263 - 4140*q^265 _
  + 164*q^267 + 4814*q^269 + 1640*q^271 + 2160*q^273 + 1246*q^275 + _
  3982*q^277 - 2944*q^279 + 4126*q^281 - 3446*q^283 + 1944*q^285 - _
  4040*q^287 - 557*q^289 + 2244*q^291 - 1514*q^293 + 1932*q^295 - _
  1400*q^297 - 9288*q^299

rwgens := etaQuotientExponentVectors(level, [1,2,3,4,5,6,7], -8)$QEQEV;

rcofactor := first rwgens
assertEquals(rcofactor, [0, 0, 0, 0, -1, 2, 9, -18])
fcofactor := EQA1C rcofactor
fcofactors := [EQA1C r for r in rwgens];
assertEquals([qetaGrade x for x in fcofactors],_
  [70, 72, 72, 72, 72, 72, 75, 76, 76, 76, 76, 79, 79, 79, 79, 79, _
  80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80])


f := f128 * fcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 1024*xfr
pol := second(ixfr)::PolC + F  -- This corresponds to the mod func f.

assertEquals(pol,_
  ((-2*M1^8-24*M1^7+8*M1^6-56*M1^5+336*M1^4+368*M1^3+256*M1^2)*M6+2*M1^9_
  -56*M1^8+12*M1^7-128*M1^6+400*M1^5+704*M1^4-224*M1^3-1024*M1^2-1024*M1)*M7_
  +(M1^9-20*M1^8+48*M1^7-136*M1^6+96*M1^5+288*M1^4+160*M1^3+64*M1^2-64*M1)*M16)

pol0 := M0*pol -- Corresponds to the original f128.
assertEquals(# monomials pol0, 25)

-- We convert the polynomial in the Mi into a Laurent polynomial in
-- the Ei variables.

esyms := indexedSymbols("E", DIVISORS level)
dim: N := #esyms

rgens0 := members(- vector rcofactor)
vals := cons(monRZ rgens0, [monRZ x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

 -- The Laurent polynomial (in Ei variables) that belongs to f.
fpolRZ := EVALRZ(vars, vals, pol)

-- clear denominator
minEntries(x: DZ, y: DZ): DZ == (_
    directProduct vector [min(x.i, y.i) for i in 1..#x]);

dzs := [degree mon for mon in monomials fpolRZ]
denRZ := (- reduce(minEntries, dzs, 0$DZ)$List(DZ))::RZ

z := rzToA1C fpolRZ - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- But we kill all the given coefficients for f128.

assertEquals(order(z, 300), 231)

-- Show nicely
rez denRZ
rez(fpolRZ * denRZ)

-- Now we do the same thing for the modular form f128 itself.

fpol0RZ := EVALRZ(vars, vals, pol0)
dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ
z0 := rzToA1C fpol0RZ - f128
assertEquals(order(z0, 301), 301)

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.

assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])
assertEquals(#monomials(rez fpol0RZ), 25)

-- Show nicely

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-------------------------------------------------------------------
-- Mail Zudillin 17-Feb-2020:

brunaultterms := [_
  [   1, 2, 1,3, 3,-1,0,0,0],_
  [   2, 0, 2,3, 2, 1,0,0,0],_
  [   8, 0, 0,2, 2, 2,2,0,0],_
  [ -24, 0, 0,2, 0, 2,4,0,0],_
  [ -16, 0, 2,1, 2,-1,0,4,0],_
  [ -64, 0, 0,0, 1, 2,3,2,0],_
  [  32, 0, 0,0,-1, 2,5,2,0],_
  [ -32, 0, 0,4, 1,-1,1,1,2],_
  [ -64, 0, 0,0, 1, 3,1,1,2],_
  [-256, 0, 0,0,-1, 3,3,1,2],_
  [ 128, 0, 0,2, 0,-1,2,3,2],_
  [-256, 0, 0,4,-1, 0,1,0,4],_
  [-128, 0, 0,0,-1, 4,1,0,4],_
  [-512, 0, 0,2, 0, 0,0,2,4]_
 ]

f128brunault := rzToA1C polyRZ brunaultterms

z := f128brunault - f128b
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])

-------------------------------------------------------------------
-- Finding other symmetry group for f_128.
-------------------------------------------------------------------

spitzen := cuspsOfGamma0 level
o := reduce(_+, [width(level, denom cusp) for cusp in spitzen])
assertEquals(o, indexOfGamma0 level)
reps := rightCosetRepresentatives level;
assertEquals(# reps, o)
reta24 := [24, 0,0,0,0,0,0,0] -- exponent vector for delta(\tau)=eta^24
eta24 := EQA1C reta24 -- = eta^(24)

-- f128^3/eta24 = f^3*(eta24*fcofactor^3)
-- f6 is modular function with poles only at the cusps, but not necessarily
-- only at infinity.

cvector := - (vector reta24 + 3*vector rcofactor)
f3 := f^3  / (        eta24 *          fcofactor^3)

-- f^6 corresponds to xf^6, i.e., pol^6. To each of the variables Mi in pol
-- corresponds the r-vector rgens.i

assertTrue(zero? reduce(_+, members cvector))

-- Check that cvector indeed belongs to a modular eta-quotient for Gamma0(45).

idmat := matrix [[1,0],[0,1]]
yeq := YEQG1(members cvector, idmat);
modular? yeq

xiord := 24*level
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
eq := EQGL1CX(members cvector, idmat)
eq := EQGL1CX(members cvector, matrix [[0,-1],[1,0]])

-- We change to all cusps, i.e., we also change some domains.

ycogen := YEQn members cvector;
minimalRootOfUnity ycogen
mcogen := EQAnCX members cvector;
qetaGrades mcogen

-- Now we can multiply rpol^6 with the monomial corresponding to cvector.
-- This will give a representation of f45^6/eta24 as a Q-linear combination
-- of eta-quotients.
-- We cannot reduce this representation by our samba basis abex, because
-- f45^6/eta24 does not only have poles at infinity.

cpolRZ := monRZ members cvector
f3polRZ := fpolRZ^3 * cpolRZ;

-- Obviously, the coefficients are integers, so we can form a list of
-- vectors similar to brunaultterms.

-- Check that all eta-quotients in terms6 correspond really to modular
-- functions.

assertEquals(removeDuplicates [modular? YEQG1(rest x, idmat) for x in terms3], [true])

-- Safety check whether the identity matrix gives the already known
-- expansion.

f3id := rzToL1CX(f3polRZ, first reps) -- first reps = identity matrix
f3x := abmap(C, CX, f3)::L1(CX)
fdiff := f3id - f3x
assertEquals(removeDuplicates [coefficient(fdiff, i) for i in -20..50], [0])

-- Now we can compute all the expansions at all other gamma from reps.

f3sers :=[rzToL1CX(f3polRZ, gamma) for gamma in reps];

)set stream calc 4

findSimilarExpansions(qseries: List L1 CX): List List Z == (_
    REC ==> Record(fo: Z, fi: Z, fc: L1 CX);_
    oics := [[order x, i, x]$REC for x in qseries for i in 1..#qseries];_
    l := oics;_
    result := empty()$List(List Z);_
    while not empty? l repeat (_
        a := first l;_
        l2 := rest l;_
        while not empty? l2 repeat (_
            b := first l2;_
            if a.fo = b.fo then (_
                ser := a.fc/b.fc;_
                cs := [coefficient(ser, i) for i in 1..20];_
                if removeDuplicates [zero? c for c in cs] = [true] then (_
                    print(hconcat [[a.fi, b.fi]::OF, [ser]::OF]);_
                    result := cons([a.fi, b.fi], result)));_
            l2 := rest l2);_
        l := rest l);_
    result);

result := findSimilarExpansions(f3sers);
#result

-- +
-------------------------------------------------------------------
-- Find the expansion of f_128 at the cusp 0.
-------------------------------------------------------------------

creps := [TOMAT(cusp) for cusp in spitzen]
hmat := matrix [[1,1],[0,1]]
[WIDTH(level, denom cusp) for cusp in spitzen]
xreps := concat [(gamma:=TOMAT(cusp); [gamma*((hmat^i)::MZ) for i in 0..WIDTH(level, denom cusp)-1]) for cusp in spitzen];

findEquivalentMatrix(mat: MZ, mats: List MZ): List Z == (_
    res: List Z := empty();_
    imat := IMAT mat;_
    for m in mats for i in 1.. repeat (_
        if zero? positiveRemainder((m * imat)(2,1), level) then (_
            res := cons(i, res))_
    );_
    res);

indexPermutation := [first findEquivalentMatrix(reps.i, xreps) for i in 1..#reps]

-- +
-------------------------------------------------------------------
-- Don't consider f^3, but f itself.
-------------------------------------------------------------------

fser := rzToAnCX fpolRZ
fserreps  := [rzToL1CX(fpolRZ, gamma) for gamma in reps];
fserxreps := [rzToL1CX(fpolRZ, gamma) for gamma in xreps];

result := findSimilarExpansions(fserreps);
xresult := findSimilarExpansions(fserxreps);
#xresult
fresult := findSimilarExpansions([series(fser, i) for i in 1..#spitzen]);
#fresult


)set stream calc 4
for i in 1..#xreps repeat (_
    print("-----------------"::Symbol);_
    print([[i]]);_
    print(xreps.i);_
    print(fserxreps.i))

-- +
-------------------------------------------------------------------
-- Adjust f to other cofactor. Then g := f*fadjust is a modular function,
-- but with poles not only at infinity.
-------------------------------------------------------------------

divs := DIVISORS level
idivs := empty()$List(Z)
z:=zsolve4ti2(level, idivs, concat([0 for i in idivs], -8))$QEQEV;
zzi := (z.zinhom.1)(1..#divs)

rcofactor2 := members(zzi - vector rcofactor)

-- Safety check whether this factor is a modular eta quotient for
-- Gamma_0(128).

modular?(YEQn.rcofactor2.1)

fcofactor2 := EQAnCX rcofactor2

fser2 := fser * fcofactor2

-- fser2 has series expansion of the form q*series(q^2) at every cusp.

qetaGrades fser2

-- +
-------------------------------------------------------------------

-- Try to find another cofactor fcofactor3 such that the respective
-- series fser3 is, in fact a modular function for Gamma_0(64). So
-- let's multiply with another nice eta-quotient that brings it to
-- M^\infty(64).

-------------------------------------------------------------------

idivs := [1,2,3,4,5,6]

-- Note that we look for an approprivate eta-quotient that does not
-- involve eta(128*tau), i.e., the first argument is 64.

z:=zsolve4ti2(64, idivs, concat([0 for i in idivs], [-8,0,12]))$QEQEV

-- We consider the resulting vectors as eta-quotient expinent vectors
-- where the entry for eta_128 is equal to zero.

liftTo128(vs: List Vector Z): List List Z == (_
    n := # DIVISORS 128;_
    [(v := copy x(1..n); v.n := 0; v) for x in vs]);

zzi := liftTo128 z.zinhom

assertEquals(zzi,[_
  [0, 0, 0, 2, -2, 12, -20, 0], [0, 0, 0, 0, 4, 8, -20, 0],_
  [0, -2, 5, 0, -1, 10, -20, 0], [0, 2, -1, 2, -1, 10, -20, 0]])
assertEquals([qetaGrade EQA1C r for r in zzi], [38, 40, 40, 40])

[qetaGrade EQA1C r for r in zzi]

zzh := liftTo128 z.zhom
assertEquals(zzh, [_
  [0, 2, -1, 0, -1, 4, -4, 0], [0, -2, 5, -4, 5, 0, -4, 0],_
  [0, 0, 0, -4, 10, -2, -4, 0], [0, -4, 10, -4, 0, 2, -4, 0],_
  [0, 0, 0, 0, -2, 6, -4, 0], [0, -2, 5, -2, -1, 4, -4, 0],_
  [2, -1, 0, 0, 0, 1, -2, 0], [-2, 5, -2, 0, 0, 1, -2, 0],_
  [0, 0, 2, -1, 0, 1, -2, 0], [0, 2, -1, -2, 5, 0, -4, 0],_
  [0, 0, -2, 5, -2, 1, -2, 0], [0, 0, 0, -1, 2, 1, -2, 0]])

[qetaGrades(EQAnCX r)(15..16) for r in zzh]

zzf := liftTo128 z.zfree
assertEquals(zzf, [])

rcofactor3 := members(vector(zzi.1) - vector rcofactor)
--assertEquals(rcofactor3, [0, 0, 0, 1, 0, -3, 6, -4])
--assertEquals(rcofactor3, [0, -2, 5, 0, 0, 8, -29, 18])
assertEquals(rcofactor3, [0, 0, 0, 2, -1, 10, -29, 18])

fcofactor3 := EQAnCX rcofactor3

fser3 := fser * fcofactor3

-- According to the orders of the expansions at all cusps,
-- fser3 corresponds to a modular function in M(128) that only has
-- poles at the cusps 1/64 and 1/128.

qetaGrades fser3

-- fser 3 has expansions at the cusps of 128 that have the following form.

for cusp in spitzen for i in 1..#spitzen repeat (_
    print([[cusp, WIDTH(128, denom cusp)/WIDTH(64, denom cusp)]]);_
    print series(fser3, i));

-- That is, if the quotient of the widths is 2, then the series is a
-- series in q^2.
-- In particular the series expansions for the cusp 1/64 agrees with
-- the series expansion of the cusp 1/128 (=infinity).

[spitzen.15, spitzen.16]
ser := series(fser3, 15) - series(fser3, 16)
assertEquals(order(ser, 100), 100)

-- Let us consider the expansion of g := series(fser3, 16) and try to
-- reduce it by the samba series of eta-quotients in M^\infty(64).

gx := series(fser3, 16)::A1(CX)
g := map(retract, gx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)

-- Now we want to compute in level 64, i.e. modular function for Gamma_0(64).

level := 64
rs64 := etaQuotientMonoidExponentVectors(level)$QEQEV;
assertEquals(rs64, [_
  [0, 0, 0, -1, 2, 1, -2], [0, 0, 0, 0, -2, 6, -4],_
  [0, 0, -2, 5, -2, 1, -2], [0, 0, 2, -1, 0, 1, -2],_
  [-2, 5, -2, 0, 0, 1, -2], [2, -1, 0, 0, 0, 1, -2],_
  [0, -2, 5, -2, -1, 4, -4], [0, 2, -1, 0, -1, 4, -4],_
  [0, -2, 5, -4, 5, 0, -4], [0, 2, -1, -2, 5, 0, -4],_
  [0, 0, 0, -4, 10, -2, -4], [0, -4, 10, -4, 0, 2, -4]])

assertEquals(sort [concat(x,0) for x in rs64], sort zzh)

egens64 := [EQA1C r for r in rs64]
[qetaGrade x for x in egens64]

qsyms64 := indexedSymbols("Q", #rs64)
xgens64 := [toX1(C, x, s) for x in egens64 for s in qsyms64]

tx64 := first xgens64
abx64 := samba(tx64, xgens64)$QXTOPSAMBA1(C)

xg := toX1(C, g, 'G)
xgr := reduce(xg, abx64)$QXTOPRED1(C)
zero? xgr
gpol := 8192 * second(xgr)::PolC + G
# monomials gpol

rgens640 := members(- vector(zzi.1))

-- We must append a zero to the rs64 vectors, because we do evaluation
-- into a domain that contains an entry for E128.

-- Now we go back to level 128 to check.
level := 128
vals64 := cons(monRZ rgens640, [monRZ concat(x, 0) for x in rs64])

gpolRZ := EVALRZ(cons('Q0, qsyms64), vals64, gpol)
rez gpolRZ

zero?(g - rzToA1C gpolRZ)

gpol0 := Q0 * gpol
gpol0RZ := EVALRZ(cons('Q0, qsyms64), vals64, gpol0)
rez gpol0RZ

dzs0 := [degree mon for mon in monomials gpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ

q0pol := 'Q0::PolC
EVALRZ(cons('Q0, qsyms64), vals64, q0pol)

z0 := rzToA1C gpol0RZ - f128
assertEquals(order(z0, 301), 301)

num0 := rez (gpol0RZ * den0RZ)
den0 := rez(den0RZ)





-- +
-------------------------------------------------------------------
-- Compute cofactor for f_128 such that there is only a pole at cusp
-- 1/1 and at all cusps where the the width(64. cusp) is different
-- from width(128, cusp), the series should be a series in q^2.
-------------------------------------------------------------------

-- rterms ar the terms of f.



divs := DIVISORS level
idivs := empty()$List(Z)
z:=zsolve4ti2(level, idivs, concat([0 for i in idivs], -8))$QEQEV;
zzi := (z.zinhom.1)(1..#divs)
zzfree := [x(1..#divs) for x in z.zfree];
zzf := first sort((x1,x2)+->(x1(#divs) > x2(#divs)), zzfree)$List(Vector Z)

-- We subtract 9*zff such that there is no eta(128*tau) factor.

vmodadjust := zzi - vector rcofactor - 9*zzf
rmodadjust := members vmodadjust






-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------




-- +
-------------------------------------------------------------------
--test:Zudilin45
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 45). The variable `rgens` corresponds to the generators
-- of $R^\infty(45)$.

level := 45;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;

eqgens := [EQA1C r for r in rgens];
assertEquals([qetaGrade x for x in eqgens],_
    [4, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11,_
    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15,_
    16, 16, 16, 16, 17, 18])

msyms := indexedSymbols("M", #eqgens)
xeqgens: List X1 C := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X1 C := xeqgens.1
abex := samba(tex, xeqgens)$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 3)
assertEquals(numOfGaps(abex), 3)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_45

q := monomial(1,1)$A1(C)

-- Zudilin (Mail Silviu "Date: Thu, 6 Feb 2020 14:16:19 +0100")
-- f_45(\tau) = eta^(1,1,1,0,1,0) + eta^(0,1,0,1,1,1) + 2*eta^(0,1,0,0,3,0) -
--              4*eta^(0,1,0,0,1,2)*q^(7/2)*
--              geneta(45, [3,9,12,-18,-27,33,36,42])

f45silviu := 1*q+1*q^2-1*q^4-1*q^5-3*q^8-1*q^10+4*q^11-2*q^13-1*q^16-2*q^17 _
  +4*q^19+1*q^20+4*q^22+1*q^25-2*q^26+2*q^29+5*q^32-2*q^34-10*q^37 _
  +4*q^38+3*q^40-10*q^41+4*q^43-4*q^44-8*q^47-7*q^49+1*q^50+2*q^52 _
  +10*q^53-4*q^55+2*q^58+4*q^59-2*q^61+7*q^64+2*q^65+12*q^67+2*q^68 _
  +8*q^71+10*q^73-10*q^74-4*q^76+1*q^80-10*q^82-12*q^83+2*q^85+4*q^86 _
  -12*q^88+6*q^89-8*q^94-4*q^95+2*q^97-7*q^98

-- generalized eta-quotient
-- From: Cristian-Silviu Radu <sradu@risc.jku.at>
-- Date: Thu, 6 Feb 2020 14:16:19 +0100

a(n,k)==(1-q^(45*n+k))
xn(n) == reduce(_*, [a(n,k) for k in [3,9,12,33,36,42]])
xd(n) == reduce(_*, [a(n,k) for k in [18,27]])
s1 := reduce(_*, [xn(n)/xd(n) for n in 0..10])
geqprefactor := expansion((q24(7*12)$ETA(C)) * YEQ1C[0,1,0,0,1,2])
f45etapart := EQA1C[1,1,1,0,1,0] + EQA1C[0,1,0,1,1,1] + 2*EQA1C[0,1,0,0,3,0]
f45trunc := f45etapart - 4 * geqprefactor * s1

QF ==> QFunctions(C, A1 C)
p(i) ==> qPochhammer(1, i, 45)$QF
ns := reduce(_*, [p k for k in [3,9,12,33,36,42]])
ds := reduce(_*, [p k for k in [18,27]])
s2 := ns/ds

f45 := f45etapart - 4 * geqprefactor * s2

z := f45 - f45trunc

divs := DIVISORS level
idivs := [i for i in 1.. #divs-1]
rwgens := etaQuotientExponentVectors(level, idivs, -4)$QEQEV;

rcofactor := rwgens.1
assertEquals(rcofactor, [0, -2, 0, 6, 4, -12])
fcofactor := EQA1C rcofactor
fcofactors := [EQA1C r for r in rwgens];
assertEquals([qetaGrade x for x in fcofactors], _
  [18, 20, 20, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 24, 24, 24, _
  25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, _
  28, 28, 28, 28, 28, 29, 30, 30, 30, 30, 31, 32])

f := f45 * fcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..200], [0])

ixfr := 5 * xfr
pol := ((second(ixfr)::PolC + F)::PolZ)

-- pol corresponds to the modular function f_45 * fcofactor
assertEquals(pol, (-M1^3+3*M1^2)*M3+(M1^3-6*M1^2-5*M1)*M2+4*M1^3-M1^2-5*M1)

pol0 := M0*pol
# monomials pol0
vars := sort(variables pol0)
assertEquals(vars, [M0, M1, M2, M3])

h(l) == E1^l.1*E3^l.2*E5^l.3*E9^l.4*E15^l.5*E45^l.6

rgens0 := members(- vector rcofactor)
vals := cons(h(rgens0), [h x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

epol := EVALFPZ(vars, vals, pol);
assertEquals(epol, _
  (-E1*E15^4*E45*E5*E9^11+E15^8*E9^10+4*E15^3*E3*E45^5*E9^9 _
   +3*E1*E15^3*E3*E45^4*E5*E9^8-6*E15^7*E3*E45^3*E9^7 _
   -E15^2*E3^2*E45^8*E9^6-5*E15^6*E3^2*E45^6*E9^4-5*E15*E3^3*E45^11*E9^3)_
   /_
   (E3^4*E45^14))

epoln := numer epol;
epold := denom epol;

esyms := indexedSymbols("E", divs)
dim: N := #esyms

rpoln := toRZ epoln
rpold := degree toRZ epold
irpold := (-rpold)::RZ
rpol := rpoln * irpold
ms := [leadingCoefficient x * EQA1C members degree x for x in monomials rpol];
z := reduce(_+, ms) - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- Show nicely

num := rez rpoln
den := rez(rpold :: RZ)

-------------------------------------------------------------------
-- # Problem: Zudilin has a relation with only 7 terms for f_45.
-------------------------------------------------------------------
-- Just multiplying a "smaller" cofactor does not work, because we would
-- not work in M^\infty(45).
-- Zudilin suggested the following cofactor eta-quotient, because
-- he had already found a 7-term relation for f_45, namely,
-- (mail wzudilin@gmail.com "Fri, 7 Feb 2020 11:40:38 +0100")

)if IGNORE
( 3*q^4 * eta(q^9)^4 * eta(q^15)^4
-15*q^8 * eta(q^3) * eta(q^9) * eta(q^15)^3 * eta(q^45)^3
-5*q^3 * eta(q^3) * eta(q^5)^3 * eta(q^9) * eta(q^15)^3
+4*q^3 * eta(q^3)^2 * eta(q^9)^4 * eta(q^15)^2
+q^7 * eta(q^3)^3 * eta(q^9) * eta(q^15) * eta(q^45)^3
+q^5 * eta(q) * eta(q^3)^3 * eta(q^5) * eta(q^15) * eta(q^45)^2
+q^3 * eta(q)^3 * eta(q^9) * eta(q^15)^4 )
/
( q^4 * eta(q^3)^2 * eta(q^45)^2 )
)endif

-- where eta(q) is obviously the EulerProduct.

-- We store the terms as a list of [coeff, etaexponents].

brunaultterms := [_
  [  3, 0,-2,0,4,4,-2],_
  [-15, 0,-1,0,1,3, 1],_
  [- 5, 0,-1,3,1,3,-2],_
  [  4, 0, 0,0,4,2,-2],_
  [  1, 0, 1,0,1,1, 1],_
  [  1, 3,-2,0,1,4,-2],_
  [  1, 1, 1,1,0,1, 0] _
 ]

f45brunault := reduce(_+, [first(x) * (EQA1C rest x) for x in brunaultterms])
f45diff := f45brunault-f45;
coeffsf45 :=  [qetaCoefficient(f45diff, -i) for i in 0..300];
assertEquals(removeDuplicates coeffsf45, [0])


rbrunault := rest(brunaultterms.1)
-- It corresponds to the denominator (exponent 2) and the monomial
-- eta(q^9)^4*eta(q^15).

-- In the following we aim at finding the above relation by means of
-- powersamba.

-------------------------------------------------------------------
-- We use powersamba to overcome the above problem
-------------------------------------------------------------------

-- We represent f45 by an expression from pol where the Mi are replaced
-- by the respective (power) eta-quotient expressions.

-- First let's compute a powersamba basis.

QEQMEVS ==> QEtaQuotientMonoidExponentVectorsStar
eqmevx ==> etaQuotientMonoidExponentVectorsX$QEQMEVS

)set stream calc 2
)set stream showall off
nn := level
--rs := eqmevx level
rs := etaQuotientMonoidExponentVectors(level, [2,3,4,5])$QEQEV;

allcusps := cuspsOfGamma0 level
spitzen := [1, 1/45]

qsyms := indexedSymbols("Q", #rs)
xiord := max [minimalRootOfUnity YEQn r for r in rs]
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
egens := [EQAnCX r for r in rs];
[qetaGrades x for x in egens]


assertEquals([qetaGrades x for x in egens], [_
  [1, 3], [4, 2], [2, 4], [4, 4], [5, 1], [6, -2], [6, 2], [0, 6],_
  [7, -1], [8, -8], [8, 0], [-4, 8], [-8, 8], [9, -3], [10, -4], _
  [10, -2], [11, -7], [12, -6], [12, -4], [14, -8], [16, -12]])

xgens := [toXn(CX, x, s) for x in egens for s in qsyms];

)read /home/hemmecke/g/qeta/input/tracing.input
)read /home/hemmecke/g/qeta/input/tracingpower.input

--ab := samba(xgens, onetnStep!)$QXSAMBAn(CX);
ab := samba(xgens)$QXSAMBAn(CX);

xlm := entries multipliers ab
xlb := concat concat [entries x for x in members basisElements ab]
xl := concat(xlm, xlb)
--ab2 := samba(xl, onetnStep!)$QXSAMBAn(CX);
ab2 := samba(xl)$QXSAMBAn(CX);

mults := multipliers ab;
idx := indexPermutation ab
ms := [mults idx i for i in 1..#idx]
qs := [qetaGrades x for x in ms]



-------------------------------------------------------------------
-- Reduction
-------------------------------------------------------------------

-------------------------------------------------------------------

-- In pol, We have to replace the Mi by eta-quotient corresponding to
-- rgens(i).

valsn := [toXn(CX, EQAnCX r, msym) for r in rgens for msym in msyms];

1$Xn(CX)
3 * 1$Xn(CX)
id(c: Z): Xn(CX) == c*1$Xn(CX)
id(5)
xmfn := (eval(id, msyms, valsn)$PolynomialEvaluation(Z, Xn CX))(pol);
qetaGrades xmfn
assertEquals(qetaGrades xmfn, [-1, 17])
-- xmfn corresponds to the same modular function as xf, but with expansion
-- at the cusps given by the variable "cusps".

[[order series(x,i::P) for i in 1..#spitzen] for x in egens]
mf := (first(xmfn)::An(CX))
[order series(mf,i::P) for i in 1..#spitzen]
xfn := toXn(CX, mf, 'F)
xfr := reduce(xfn, ab)$QXREDn(CX)
xfr2 := reduce(xfn, ab2)$QXREDn(CX);

assertTrue(zero? xfr)
assertTrue(zero? xfr2)

assertEquals(removeDuplicates [order(series(first(xfr)::An(CX), i), 9) for i in 1..#spitzen], [9])

-- Find an eta-quotient that reduces the pole order at infinity at the cost
-- of increasing the pole order at 0.
-- We have already such eta-quotients given by rs (or egens).
-- Multiplying xfn by xgens.1

z := zsolve4ti2(level, [2,3,4,5,6], [0,0,0,0,24*17])
zi := [x(1..#divs) for x in z.zinhom]
zsyms := indexedSymbols("Z", #zi)
xzi := [toXn(CX, EQAnCX x, s) for x in zi for s in zsyms];
xzisorted := sort((a1:Xn(CX),a2:Xn(CX)):Boolean +-> qetaGrades a1 < qetaGrades a2, xzi)

xfn1 := xfn*first(xzisorted)
xfr1 := reduce(xfn1, ab)$QXREDn(CX)
assertEquals(removeDuplicates [order(series(first(xfr1)::An(CX), i), 9) for i in 1..#spitzen], [9])

zero? xfr1

qpol := 183708000*(-(second(xfr1))::Pol(CX) + F*Z13)
sort variables qpol
#monomials qpol

zh := [x(1..#divs) for x in z.zhom];
hsyms := indexedSymbols("H", #zh)
xzh := [toXn(CX, EQAnCX x, s) for x in zh for s in hsyms];
xzhsorted := sort((a1:Xn(CX),a2:Xn(CX)):Boolean +-> qetaGrades a1 < qetaGrades a2, xzh)
[qetaGrades x for x in xzhsorted]

abh := samba(xzhsorted)$QXSAMBAn(CX);
xfhr1 := reduce(xfn1, abh)$QXREDn(CX)
assertTrue(zero? xfhr1)

-------------------------------------------------------------------
-- Finding other symmetry group for f_45.
-------------------------------------------------------------------

o := reduce(_+, [width(level, denom cusp) for cusp in cuspsOfGamma0(level)])
assertEquals(o, indexOfGamma0 level)
reps := rightCosetRepresentatives level;
assertEquals(# reps, o)
reta24 := [24, 0,0,0,0,0] -- exponent vector for delta(\tau)=eta^24
eta24 := EQA1C reta24 -- = eta^(-24)

-- f45^6/eta24 = f^6*(eta24*fcofactor^6)
-- f6 is modular function with poles only at the cusps, but not necessarily
-- only at infinity.

cvector := - (vector reta24 + 6*vector rcofactor)
f6 := f^6  / (        eta24 *          fcofactor^6)

-- f^6 corresponds to xf^6, i.e., pol^6. To each of the variables Mi in pol
-- corresponds the r-vector rgens.i

assertTrue(zero? reduce(_+, members cvector))

-- Now we can multiply rpol^6 with the monomial corresponding to cvector.
-- This will give a representation of f45^6/eta24 as a Q-linear combination
-- of eta-quotients.
-- We cannot reduce this representation by our samba basis abex, because
-- f45^6/eta24 does not only have poles at infinity.

cpol := monRZ members cvector
f6pol := rpol^6 * cpol;
mons6 := monomials f6pol;

-- Obviously, the coefficients are integers, so we can form a list of
-- vectors similar to brunaultterms.

terms6 := [cons(leadingCoefficient(m)::Z, members degree m) for m in mons6];

-- For each of the terms and for each of the right coset
-- representatives that are given through reps, we compute an element of
-- SymbolicEtaQuotientGamma to figure out which root of unity is needed.

ygterms := [[YEQG1(rest x, gamma) for x in terms6] for gamma in reps];
xiord := 24 * max [max [minimalRootOfUnity y for y in l] for l in ygterms]
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

assertEquals(removeDuplicates [removeDuplicates [modular? y for y in l] for l in ygterms], [[true]])

tsum(terms, gamma) == reduce(_+, [first(x) * EQGL1CX(rest x, gamma) for x in terms])

-- Check that cvector indeed belongs to a modular eta-quotient for Gamma0(45).

idmat := matrix [[1,0],[0,1]]
yeq := YEQG1(members(cvector)$Vector(Z), idmat);
minimalRootOfUnity yeq
assertTrue(modular? yeq)

eq := EQGL1CX(members(cvector)$Vector(Z), idmat)

-- We change to all cusps, i.e., we also change some domains.

spitzen := allcusps
mcogen := EQAnCX members cvector
qetaGrades mcogen

-- Check that all eta-quotients in terms6 correspond really to modular
-- functions.

assertEquals(removeDuplicates [modular? YEQG1(rest x, idmat) for x in terms6], [true])


-- We now apply SL2Z transformations to each of the summands and check
-- whether we obtain equal power series expansions. The
-- transformations are the indexOfGamma0(level)
-- reps:=rightCosetRepresentatives(level) stored in the variable reps.

-- Safety check whether the identity matrix gives the already known
-- expansion.

f6id := tsum(terms6, first reps) -- first reps = identity matrix
f6x := abmap(C, CX, f6)::L1(CX)
fdiff := f6id - f6x
assertEquals(removeDuplicates [coefficient(fdiff, i) for i in -20..50], [0])

-- Now we can compute all the expansions at all other gamma from reps.

tsers :=[tsum(terms6, gamma) for gamma in reps];

)set stream calc 4

findSimilarExpansions(qseries: List L1 CX): List List Z == (_
    REC ==> Record(fo: Z, fi: Z, fc: L1 CX);_
    oics := [[order x, i, x]$REC for x in qseries for i in 1..#qseries];_
    l := oics;_
    result := empty()$List(List Z);_
    while not empty? l repeat (_
        a := first l;_
        l2 := rest l;_
        while not empty? l2 repeat (_
            b := first l2;_
            if a.fo = b.fo then (_
                ser := a.fc/b.fc;_
                cs := [coefficient(ser, i) for i in 1..20];_
                if removeDuplicates [zero? c for c in cs] = [true] then (_
                    print(hconcat [[a.fi, b.fi]::OF, [ser]::OF]);_
                    result := cons([a.fi, b.fi], result)));_
            l2 := rest l2);_
        l := rest l);_
    result);

findSimilarExpansions(tsers)

findEquivalentMatrix(mat: MZ, mats: List MZ): List Z == (_
    res: List Z := empty();_
    imat := IMAT mat;_
    for m in mats for i in 1.. repeat (_
        if zero? positiveRemainder((m * imat)(2,1), level) then (_
            res := cons(i, res))_
    );_
    res);

mcusps := [cuspToMatrix(level, x) for x in cuspsOfGamma0(45)]
mats := concat(mcusps, reps);
l := mats
res := empty()$List(List Z)
while not empty? l repeat (_
  a := first l;_
  res := cons(findEquivalentMatrix(a, rest l), res);_
  l := rest l)
res := reverse! res

assertTrue(false)

-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
