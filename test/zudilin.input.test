-- Via jupytext this file can be shown as a jupyter notebook.
-- For that one would have to move or link it to a file with
-- extension ".input".

)clear complete
assertEquals(x,y)==>(if (x=y)@Boolean then true else (print x; false))
assertTrue x ==> x

)cd /home/hemmecke/g/qeta/tmp

)set mess type off
)set mess time off

)r projectlibs )quiet
)r etamacros.input )quiet

)set output linear on
)set output algebra off


-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q
VZ ==> Vector Z
MZ ==> Matrix Z


)set mess type off
)set mess time off
)read /home/hemmecke/g/qeta/input/convenience.input )quiet

numOfGaps(ab) == (_
  t := multiplier ab; _
  n := qetaGrade(t)::P; _
  grades := [qetaGrade(first basis(ab, i))::P for i in 1..n-1]; _
  numberOfGaps(n, grades)$QAuxiliaryModularEtaQuotientPackage)

)set mess type on
)set mess time on

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

-- # Relations in terms of the $M_i$'s

-- +
-------------------------------------------------------------------
--test:Zudilin128
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 128). The variable `rgens` corresponds to the generators
-- of $R^\infty(128)$.

level := 128;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;
rgensExpected: List List Z := [_
    [0, 0, 0, 0, - 1, 2, 1, - 2], [0, 0, 0, 0, 0, - 2, 6, - 4],_
    [0, 0, 0, - 2, 5, - 2, 1, - 2], [0, 0, 0, 2, - 1, 0, 1, - 2],_
    [0, - 2, 5, - 2, 0, 0, 1, - 2], [0, 2, - 1, 0, 0, 0, 1, - 2],_
    [0, 0, 0, - 1, 2, - 1, 4, - 4], [0, 0, - 2, 5, - 2, - 1, 4, - 4],_
    [0, 0, 2, - 1, 0, - 1, 4, - 4], [- 2, 5, - 2, 0, 0, - 1, 4, - 4],_
    [2, - 1, 0, 0, 0, - 1, 4, - 4], [0, 0, - 2, 4, 0, 0, 2, - 4],_
    [0, 0, 2, - 2, 2, 0, 2, - 4], [- 2, 5, - 2, - 1, 2, 0, 2, - 4],_
    [2, - 1, 0, - 1, 2, 0, 2, - 4], [0, 0, 0, - 1, 0, 5, 0, - 4],_
    [0, 0, - 2, 5, - 4, 5, 0, - 4], [0, 0, 2, - 1, - 2, 5, 0, - 4],_
    [- 2, 5, - 2, 0, - 2, 5, 0, - 4], [2, - 1, 0, 0, - 2, 5, 0, - 4],_
    [0, 0, 0, 0, - 4, 10, - 2, - 4], [- 2, 5, - 4, 5, - 2, 0, 2, - 4],_
    [2, - 1, - 2, 5, - 2, 0, 2, - 4], [0, 0, - 4, 10, - 4, 0, 2, - 4],_
    [- 2, 5, 0, - 1, 0, 0, 2, - 4], [2, - 1, 2, - 1, 0, 0, 2, - 4],_
    [- 4, 10, - 4, 0, 0, 0, 2, - 4], [4, - 2, 0, 0, 0, 0, 2, - 4]];
assertEquals(rgens, rgensExpected)

eqgens := [EQA1C r for r in rgens];
assertEquals([qetaGrade x for x in eqgens],_
  [6, 8, 8, 8, 8, 8, 11, 12, 12, 12, 12, 15, 15, 15, 15, 15, _
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])

msyms := indexedSymbols("M", #eqgens)
xeqgens: List X1 C := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X1 C := xeqgens.1
abex := samba(tex, xeqgens, 0, oneVerboseStep!(1,1,1,2))$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 9)
assertEquals(numOfGaps(abex), 9)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_128

q := monomial(1,1)$A1(C)
f128 := q - 2*q^3 + 6*q^5 - 20*q^7 - 23*q^9 - 14*q^11 + 54*q^13 - 12*q^15 - _
  66*q^17 - 162*q^19 + 40*q^21 - 172*q^23 - 89*q^25 + 100*q^27 - 2*q^29 + _
  128*q^31 + 28*q^33 - 120*q^35 + 158*q^37 - 108*q^39 + 202*q^41 + _
  298*q^43 - 138*q^45 + 408*q^47 + 57*q^49 + 132*q^51 - 690*q^53 - 84*q^55 _
  + 324*q^57 + 322*q^59 - 298*q^61 + 460*q^63 + 324*q^65 - 202*q^67 + _
  344*q^69 + 700*q^71 - 418*q^73 + 178*q^75 + 280*q^77 - 744*q^79 + _
  421*q^81 + 678*q^83 - 396*q^85 + 4*q^87 - 82*q^89 - 1080*q^91 - 256*q^93 _
  - 972*q^95 - 1122*q^97 + 322*q^99 + 1390*q^101 - 788*q^103 + 240*q^105 - _
  1614*q^107 + 2014*q^109 - 316*q^111 - 542*q^113 - 1032*q^115 - _
  1242*q^117 + 1320*q^119 - 1135*q^121 - 404*q^123 - 1284*q^125 - _
  1712*q^127 - 596*q^129 + 2118*q^131 + 3240*q^133 + 600*q^135 - 486*q^137 _
  - 1286*q^139 - 816*q^141 - 756*q^143 - 12*q^145 - 114*q^147 - 2666*q^149 _
  - 172*q^151 + 1518*q^153 + 768*q^155 + 838*q^157 + 1380*q^159 + _
  3440*q^161 - 1346*q^163 + 168*q^165 + 1052*q^167 + 719*q^169 + _
  3726*q^171 + 38*q^173 + 1780*q^175 - 644*q^177 + 2790*q^179 - 3418*q^181 _
  + 596*q^183 + 948*q^185 + 924*q^187 - 2000*q^189 + 1968*q^191 - _
  1058*q^193 - 648*q^195 + 726*q^197 - 4116*q^199 + 404*q^201 + 40*q^203 + _
  1212*q^205 + 3956*q^207 + 2268*q^209 - 1482*q^211 - 1400*q^213 + _
  1788*q^215 - 2560*q^217 + 836*q^219 - 3564*q^221 + 896*q^223 + _
  2047*q^225 - 3410*q^227 + 4502*q^229 - 560*q^231 + 2302*q^233 + _
  2448*q^235 + 1488*q^237 - 4024*q^239 - 3586*q^241 - 3542*q^243 + _
  342*q^245 - 8748*q^247 - 1356*q^249 + 1250*q^251 + 2408*q^253 + _
  792*q^255 - 6638*q^257 - 3160*q^259 + 46*q^261 + 1724*q^263 - 4140*q^265 _
  + 164*q^267 + 4814*q^269 + 1640*q^271 + 2160*q^273 + 1246*q^275 + _
  3982*q^277 - 2944*q^279 + 4126*q^281 - 3446*q^283 + 1944*q^285 - _
  4040*q^287 - 557*q^289 + 2244*q^291 - 1514*q^293 + 1932*q^295 - _
  1400*q^297 - 9288*q^299

divs := DIVISORS level
idivs := [i for i in 1.. #divs-1]
wght := 4
rwgens := etaQuotientExponentVectors(level, idivs, -2*wght)$QEQEV;

rcofactor := rwgens.1
assertEquals(rcofactor,[0, 0, 0, 0, 0, 0, 8, - 16])
fcofactor := EQA1C rcofactor
fcofactors := [EQA1C r for r in rwgens];
assertEquals([qetaGrade x for x in fcofactors], [64])


f := f128 * fcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 1024*xfr
pol := second(ixfr)::PolC + F  -- This corresponds to the mod func f.

assertEquals(pol, (_
    (-2*M1^7-24*M1^6+8*M1^5-56*M1^4+336*M1^3+368*M1^2+256*M1)*M6+2*M1^8_
     -56*M1^7+12*M1^6-128*M1^5+400*M1^4+704*M1^3-224*M1^2-1024*M1-1024)*M7_
    +(M1^8-20*M1^7+48*M1^6-136*M1^5+96*M1^4+288*M1^3+160*M1^2+64*M1-64)*M16)

pol0 := M0*pol -- Corresponds to the original f128.
assertEquals(# monomials pol0, 25)

-- We convert the polynomial in the Mi into a Laurent polynomial in
-- the Ei variables.

esyms := indexedSymbols("E", divs)
dim: N := #esyms

rgens0 := members(- vector rcofactor)
vals := cons(monRZ rgens0, [monRZ x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

 -- The Laurent polynomial (in Ei variables) that belongs to f.
fpolRZ := EVALRZ(vars, vals, pol);

z := rzToA1C fpolRZ - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- But we kill all the given coefficients for f128.

assertEquals(order(z, 300), 237)

-- Show nicely
-- find common denominator
minEntries(x: DZ, y: DZ): DZ == (_
    directProduct vector [min(x.i, y.i) for i in 1..#x]);

dzs := [degree mon for mon in monomials fpolRZ]
denRZ := (- reduce(minEntries, dzs, 0$DZ)$List(DZ))::RZ

rez denRZ
rez(fpolRZ * denRZ)

-- Now we do the same thing for the modular form f128 itself.

fpol0RZ := EVALRZ(vars, vals, pol0)
dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ
z0 := rzToA1C fpol0RZ - f128
assertEquals(order(z0, 301), 301)

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.

assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])
assertEquals(#monomials(rez fpol0RZ), 25)

-- Show nicely

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-------------------------------------------------------------------
-- Mail Zudillin 17-Feb-2020:

brunaultterms := [_
  [   1, 2, 1,3, 3,-1,0,0,0],_
  [   2, 0, 2,3, 2, 1,0,0,0],_
  [   8, 0, 0,2, 2, 2,2,0,0],_
  [ -24, 0, 0,2, 0, 2,4,0,0],_
  [ -16, 0, 2,1, 2,-1,0,4,0],_
  [ -64, 0, 0,0, 1, 2,3,2,0],_
  [  32, 0, 0,0,-1, 2,5,2,0],_
  [ -32, 0, 0,4, 1,-1,1,1,2],_
  [ -64, 0, 0,0, 1, 3,1,1,2],_
  [-256, 0, 0,0,-1, 3,3,1,2],_
  [ 128, 0, 0,2, 0,-1,2,3,2],_
  [-256, 0, 0,4,-1, 0,1,0,4],_
  [-128, 0, 0,0,-1, 4,1,0,4],_
  [-512, 0, 0,2, 0, 0,0,2,4]_
 ]

# brunaultterms

f128brunault := rzToA1C polyRZ brunaultterms

z := f128brunault - f128
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])

-------------------------------------------------------------------
-- Finding other symmetry group for f_128.
-------------------------------------------------------------------

spitzen := cuspsOfGamma0 level
o := reduce(_+, [width(level, denom cusp) for cusp in spitzen])
assertEquals(o, indexOfGamma0 level)
reps := rightCosetRepresentatives level;
assertEquals(# reps, o)

xiord := 24*level
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

)set stream calc 4

findSimilarExpansions(qseries: List L1 CX): List List Z == (_
    REC ==> Record(fo: Z, fi: Z, fc: L1 CX);_
    oics := [[order x, i, x]$REC for x in qseries for i in 1..#qseries];_
    l := oics;_
    result := empty()$List(List Z);_
    while not empty? l repeat (_
        a := first l;_
        l2 := rest l;_
        while not empty? l2 repeat (_
            b := first l2;_
            if a.fo = b.fo then (_
                ser := a.fc/b.fc;_
                cs := [coefficient(ser, i) for i in 1..20];_
                if removeDuplicates [zero? c for c in cs] = [true] then (_
                    print(hconcat [[a.fi, b.fi]::OF, [ser]::OF]);_
                    result := cons([a.fi, b.fi], result)));_
            l2 := rest l2);_
        l := rest l);_
    result);

)if false
result := findSimilarExpansions(f3sers);
#result
)endif

-- +
-------------------------------------------------------------------
-- Find the expansion of f_128 at the cusp 0.
-------------------------------------------------------------------

creps := [TOMAT(cusp) for cusp in spitzen]
hmat := matrix [[1,1],[0,1]]
[WIDTH(level, denom cusp) for cusp in spitzen]
xreps := concat [(gamma:=TOMAT(cusp); [gamma*((hmat^i)::MZ) for i in 0..WIDTH(level, denom cusp)-1]) for cusp in spitzen];

findEquivalentMatrix(mat: MZ, mats: List MZ): List Z == (_
    res: List Z := empty();_
    imat := IMAT mat;_
    for m in mats for i in 1.. repeat (_
        if zero? positiveRemainder((m * imat)(2,1), level) then (_
            res := cons(i, res))_
    );_
    res);

idxPermutation := [first findEquivalentMatrix(reps.i, xreps) for i in 1..#reps]

-- +
-------------------------------------------------------------------
-- Don't consider f^3, but f itself.
-------------------------------------------------------------------

fser := rzToAnCX fpolRZ
fserreps  := [rzToL1CX(fpolRZ, gamma) for gamma in reps];
fserxreps := [rzToL1CX(fpolRZ, gamma) for gamma in xreps];

)if false
result := findSimilarExpansions(fserreps);
xresult := findSimilarExpansions(fserxreps);
#xresult
fresult := findSimilarExpansions([series(fser, i) for i in 1..#spitzen]);
#fresult
)endif

)set stream calc 4
for i in 1..#xreps repeat (_
    print("-----------------"::Symbol);_
    print([[i]]);_
    print(xreps.i);_
    print(fserxreps.i))

-- +
-------------------------------------------------------------------
-- Adjust f to other cofactor. Then g := f*fadjust is a modular function,
-- but with poles not only at infinity.
-------------------------------------------------------------------

divs := DIVISORS level
idivs := empty()$List(Z)
z:=zsolve4ti2(level, idivs, concat([0 for i in idivs], -2*wght))$QEQEV;
zzi := (z.zinhom.1)(1..#divs)

rcofactor2 := members(zzi - vector rcofactor)

-- Safety check whether this factor is a modular eta quotient for
-- Gamma_0(128).

modular?(YEQn.rcofactor2.1)

fcofactor2 := EQAnCX rcofactor2

fser2 := fser * fcofactor2

-- fser2 has series expansion of the form q*series(q^2) at every cusp.

qetaGrades fser2

-- +
-------------------------------------------------------------------

-- Try to find another cofactor fcofactor3 such that the respective
-- series fser3 is, in fact a modular function for Gamma_0(64). So
-- let's multiply with another nice eta-quotient that brings it to
-- M^\infty(64).

-------------------------------------------------------------------

idivs := [1,2,3,4,5,6]

-- Note that we look for an approprivate eta-quotient that does not
-- involve eta(128*tau), i.e., the first argument is 64.

z:=zsolve4ti2(64, idivs, concat([0 for i in idivs], [-2*wght,0,12]))$QEQEV

-- We consider the resulting vectors as eta-quotient expinent vectors
-- where the entry for eta_128 is equal to zero.

liftTo128(vs: List Vector Z): List List Z == (_
    n := # DIVISORS 128;_
    [(v := copy x(1..n); v.n := 0; v) for x in vs]);

zzi := liftTo128 z.zinhom

assertEquals(zzi,[_
  [0, 0, 0, 2, -2, 12, -20, 0], [0, 0, 0, 0, 4, 8, -20, 0],_
  [0, -2, 5, 0, -1, 10, -20, 0], [0, 2, -1, 2, -1, 10, -20, 0]])
assertEquals([qetaGrade EQA1C r for r in zzi], [38, 40, 40, 40])

[qetaGrade EQA1C r for r in zzi]

zzh := liftTo128 z.zhom
assertEquals(zzh, [_
  [0, 2, -1, 0, -1, 4, -4, 0], [0, -2, 5, -4, 5, 0, -4, 0],_
  [0, 0, 0, -4, 10, -2, -4, 0], [0, -4, 10, -4, 0, 2, -4, 0],_
  [0, 0, 0, 0, -2, 6, -4, 0], [0, -2, 5, -2, -1, 4, -4, 0],_
  [2, -1, 0, 0, 0, 1, -2, 0], [-2, 5, -2, 0, 0, 1, -2, 0],_
  [0, 0, 2, -1, 0, 1, -2, 0], [0, 2, -1, -2, 5, 0, -4, 0],_
  [0, 0, -2, 5, -2, 1, -2, 0], [0, 0, 0, -1, 2, 1, -2, 0]])

[qetaGrades(EQAnCX r)(15..16) for r in zzh]

zzf := liftTo128 z.zfree
assertEquals(zzf, [])

--assertEquals(rcofactor3, [0, 0, 0, 1, 0, -3, 6, -4])
--assertEquals(rcofactor3, [0, -2, 5, 0, 0, 8, -29, 18])

--rcofactor3 := members(vector(zzi.1) - vector rcofactor)
--assertEquals(rcofactor3, [0, 0, 0, 2, -1, 10, -29, 18])

rcofactor3 := members(vector(zzi.1) - vector(zzh.12) - vector rcofactor)
assertEquals(rcofactor3, [0, 0, 0, 3, - 4, 11, - 26, 16])
fcofactor3 := EQAnCX rcofactor3

fser3 := fser * fcofactor3

-- According to the orders of the expansions at all cusps,
-- fser3 corresponds to a modular function in M(128) that only has
-- poles at the cusps 1/64 and 1/128.

qetaGrades fser3

-- fser3 has expansions at the cusps of 128 that have the following form.

for cusp in spitzen for i in 1..#spitzen repeat (_
    print([[cusp, WIDTH(128, denom cusp)/WIDTH(64, denom cusp)]]);_
    print series(fser3, i));

-- That is, if the quotient of the widths is 2, then the series is a
-- series in q^2.
-- In particular the series expansions for the cusp 1/64 agrees with
-- the series expansion of the cusp 1/128 (=infinity).

[spitzen.15, spitzen.16]
ser := series(fser3, 15) - series(fser3, 16)
assertEquals(order(ser, 100), 100)

-- Let us consider the expansion of g := series(fser3, 16) and try to
-- reduce it by the samba series of eta-quotients in M^\infty(64).

gx := series(fser3, 16)::A1(CX)
g := map(retract, gx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)

-- Now we want to compute in level 64, i.e. modular function for Gamma_0(64).

level := 64
rgens64 := etaQuotientMonoidExponentVectors(level)$QEQEV;
assertEquals(rgens64, [_
  [0, 0, 0, -1, 2, 1, -2], [0, 0, 0, 0, -2, 6, -4],_
  [0, 0, -2, 5, -2, 1, -2], [0, 0, 2, -1, 0, 1, -2],_
  [-2, 5, -2, 0, 0, 1, -2], [2, -1, 0, 0, 0, 1, -2],_
  [0, -2, 5, -2, -1, 4, -4], [0, 2, -1, 0, -1, 4, -4],_
  [0, -2, 5, -4, 5, 0, -4], [0, 2, -1, -2, 5, 0, -4],_
  [0, 0, 0, -4, 10, -2, -4], [0, -4, 10, -4, 0, 2, -4]])

rgens64x := [concat(x,0) for x in rgens64]
assertEquals(sort rgens64x, sort zzh)

egens64 := [EQA1C r for r in rgens64]
[qetaGrade x for x in egens64]

usyms64 := indexedSymbols("U", #rgens64)
xgens64 := [toX1(C, x, s) for x in egens64 for s in usyms64]

tx64 := first xgens64
abx64 := samba(tx64, xgens64)$QXTOPSAMBA1(C)

xg := toX1(C, g, 'G)
xgr := reduce(xg, abx64)$QXTOPRED1(C)
zero? xgr
gpol := 8192 * second(xgr)::PolC + G
assertEquals(# monomials gpol, 23)
assertEquals(gpol,_
  (U1^10-20*U1^8-24*U1^6-128*U1^4-512*U1^2+2048)*U5_
 +(-2*U1^8-36*U1^6+208*U1^4-224*U1^2+1024)*U11_
 -2*U1^11+4*U1^10+40*U1^9+56*U1^8+48*U1^7+368*U1^6+256*U1^5-1024*U1^4+1024*U1^3+2048*U1^2-4096*U1-8192)

rgens640 := members(-(vector rcofactor3 + vector rcofactor))

-- We must append a zero to the rgens64 vectors, because we do evaluation
-- into a domain that contains an entry for E128.

-- Now we go back to level 128 to check.

level := 128
vals64 := cons(monRZ rgens640, [monRZ concat(x, 0) for x in rgens64])

gpolRZ := EVALRZ(cons('U0, usyms64), vals64, gpol)
rez gpolRZ

zero?(g - rzToA1C gpolRZ)

gpol0 := U0 * gpol
gpol0RZ := EVALRZ(cons('U0, usyms64), vals64, gpol0)
rez gpol0RZ

series(fser3, 16)
EQA1C rgens640


dzs0 := [degree mon for mon in monomials gpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ

q0pol := 'U0::PolC
EVALRZ(cons('U0, usyms64), vals64, q0pol)

z0 := rzToA1C gpol0RZ - f128
assertEquals(order(z0, 301), 301)

num0 := rez (gpol0RZ * den0RZ)
den0 := rez(den0RZ)

-- +
-------------------------------------------------------------------
-- Manual reduction of fser3 by means of elemens created by rgens64x
-------------------------------------------------------------------

)if false
abx64t := samba(tx64, [xgens64.i for i in [6,5,4,3,2,1,7,8,9,10,11,12]])$QXTOPSAMBA1(C)
xgrt := reduce(xg, abx64t)$QXTOPRED1(C)
gpolt := 4096 * second(xgrt)::PolC + G
assertEquals(gpolt,_
  (U1^10-20*U1^8-24*U1^6-128*U1^4-512*U1^2+2048)*U2_
  +(-2*U1^8-36*U1^6+208*U1^4-224*U1^2+1024)*U11_
  +6*U1^10+16*U1^8+320*U1^6-1280*U1^4+1024*U1^2-4096)
assertEquals(# monomials gpolt, 17)
#monomials gpolt

[(pp := second(reduce(x, abx64)$QXTOPRED1(C))::PolC; if zero? pp then 0else 1/coefficient(pp,degree pp)*pp) for x in xgens64]
)endif

-------------------------------------------------------------------

egens64x := [EQAnCX r for r in rgens64x];
xgens64x := [toXn(CX, x, s) for x in egens64x for s in usyms64];
u:=egens64x;
for x in u for i in 1.. repeat print [i, qetaGrades x]
qetaGrades fser3

LCi(x, idxs) ==> [leadingCoefficient(series(x, i)) for i in idxs]
LMi(x, idxs) ==> [leadingMonomial(series(x, i)) for i in idxs]
LC(x) ==> LCi(x, ixs)
LM(x) ==> LMi(x, ixs)

ixs := [9,10,11,12, 16]
lmu := [LM x for x in u];
for x in lmu for i in 1.. repeat print([i, x])


ser := fser3/(u.4*u.1^2*u.3) - u.4*u.7*u.12^3/(u.4*u.1^2*u.3)  + 16*u.8^3*u.2/u.3 + 172*u.12^2
sx := series(ser, 16)::A1(CX)
s := map(retract, sx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)
xs := toX1(C, s, 'S)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 12288*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S
assertEquals(# monomials spol, 9)

isyms64 := indexedSymbols("I", #rgens64)
irgens64x := [members(-vector x) for x in rgens64x]
iegens64x := [EQAnCX r for r in irgens64x];
ixgens64x := [toXn(CX, x, s) for x in iegens64x for s in isyms64];

assertTrue(zero?(xgens64x.1 * ixgens64x.1 - 1$Xn(CX)))

fpol := spol*U1^2*U3*U4_
        + U4*U7*U12^3 - 16*U1^2*U2*U4*U8^3 - 172*U1^2*U3*U4*U12^2

ser := fser3


fpolRZ := EVALRZ(cons('U0, usyms64), vals64, fpol)
rez fpolRZ
g
rzToA1C fpolRZ
zero?(g - rzToA1C fpolRZ)


fpol0 := U0 * fpol
fpol0RZ := EVALRZ(cons('U0, usyms64), vals64, fpol0)
rez fpol0RZ
z0 := rzToA1C fpol0RZ - f128
assertEquals(order(z0, 301), 301)

dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-- +
-------------------------------------------------------------------
-- Is every eta-quotient in the sum holonomic?
-------------------------------------------------------------------

vexponents := [vector members degree m for m in monomials fpol0RZ]
ords :=[(1/24*matrixLigozat(level)*v) for v in vexponents]
assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true, false], [true]])

-- No, it isn't.

-- +
-------------------------------------------------------------------
-- Find a basis for all eta-quotients of weight 4 that are modular forms
-------------------------------------------------------------------
-- -

level := 64
divs := DIVISORS level
idivs := [i for i in 1..#divs]
spitzen := cuspsOfGamma0 level
rhs := concat([0 for i in idivs], 2*wght)
zmodform := zsolve4ti2(level, idivs, rhs)$QEQEV; -- takes about 3min40sec
vdivs := vector(divs)$VZ -- part of the Ligozat matrix that gives the order
zmodformzi := [members x(1..#divs) for x in zmodform.zinhom];
assertEquals(#zmodformzi, 8757)

-- Sort the generating exponents according to the resulting series expansion

vmodformgens := [vector x for x in zmodformzi];
vmodformgenss := sort((x1,x2)+->dot(vdivs,x1)<dot(vdivs,x2), vmodformgens);
rmodformgens := [members x for x in vmodformgenss];

mat := matrixLigozatRStar(level, idivs)$QAuxMEQ
rmat := mat(1..nrows(mat), 1..#divs)
rmat * vector rmodformgens.1


[order EQA1C r for r in rmodformgens]
)set out algebra on
)set out linear off
(matrix [qetaGrades YEQn x for x in rmodformgens])(1..20, 1..#spitzen)

emodformgens := [EQA1C r for r in rmodformgens];
[order x for x in emodformgens]

-- +
-------------------------------------------------------------------
-- Check whether there is a Q-linear combinationn of holomorphic
-- eta-quotients of level 42 that is equal to f21.
-------------------------------------------------------------------
-- -

--$ sage: dimension_modular_forms(Gamma0(64),2)
--: 30

dimM := 30
ncoefs := 32
nmodformgens := # rmodformgens
cmodformgens := [[coefficient(x, i) for i in 0..ncoefs] for x in emodformgens];
assertEquals(rank matrix cmodformgens, dimM)

matmodforms := transpose matrix cmodformgens;
cf128 := [coefficient(f128, i) for i in 0..ncoefs]
rels: VZ := new(nrows matmodforms, 0);
zmodforms := zsolve(matmodforms, rels, vector cf128)$X4ti2;
zmodformszi := zmodforms.zinhom;
assertTrue(empty? zmodformszi)
zmodformszf := zmodforms.zfree;

sol := solve(matmodforms, vector cf128);
assertTrue(sol.particular case "failed")

-- Unfortunately no solution. :-(





-- +
-------------------------------------------------------------------
-- It follows the commands that were tried to figure out the above relation.
-------------------------------------------------------------------

)if false
ser1 := fser3
ser2 := fser3 - u.4*u.7*u.12^3
ser3 := ser2/(u.4*u.1^2)
ser := ser3

sx := series(ser, 16)::A1(CX)
s := map(retract, sx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)
xs := toX1(C, s, 'S3)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 4096*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S3
assertEquals(# monomials spol, 13)

ixs := [5,6,7,8,16]
lmu := [LM x for x in u];
for x in lmu for i in 1.. repeat print([i, x])

ser4 := (ser3 + 16*u.8^3*u.2)/u.3
sx := series(ser, 16)::A1(CX)
s := map(retract, sx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)
xs := toX1(C, s, 'S4)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 1280*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S4
assertEquals(# monomials spol, 11)

ser5 := ser4 + 172*u.12^2
sx := series(ser5, 16)::A1(CX)
s := map(retract, sx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)
xs := toX1(C, s, 'S5)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 12288*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S5
assertEquals(# monomials spol, 9)
)endif



-- +
-------------------------------------------------------------------
-- Groebner basis reduction
-------------------------------------------------------------------

assertTrue(false) -- stop here

-- Now we want to reduce this relation with respect to a GrÃ¶bner basis
-- of the eta relations of level 64.

-- etaRelations64 := etaRelations(64)$QEtaIdealHemmeckeCached(C, A1(C))

E ==> Monomials(dim, N, DN, esyms) -- show DirectProduct as monomials.
RE ==> PolynomialRing(C, E)
PCE ==> PolynomialConversion(C, E, esyms)

-- read precomputed GrÃ¶bner basis
)read ../test/etaRelations64.input )quiet
etaRelations64RE := [coerce(x) $ PCE for x in etaRelations64];

num0RE := num0 pretend RE

NF(x, gb) ==> primitivePart redPol(x, gb)$GroebnerInternalPackage(C, E, RE)

num0RE1 := NF(num0RE, etaRelations64RE);

rhx := [directProduct(members degree x)$DZ for x in monomials num0RE1];
reduce(minEntries, rhx, 0$DZ)$List(DZ)

num0RE1x := (num0RE1 exquo (coerce(E64^10)$PCE))::RE

num0RE2 := NF(num0RE1x, etaRelations64RE);

##########################################
--TODO: Consider GB wrt degrevlex(E1, E64, E2, E32, E4, E16,  E8)

[removeDuplicates sort [reduce(_+, members degree x) for x in monomials er] for er in etaRelations64RE]


-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------


-- +
-------------------------------------------------------------------
--test:Zudilin45
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 45 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 45). The variable `rgens` corresponds to the generators
-- of $R^\infty(45)$.

level := 45;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;
rgensExpected: List List Z := [_
    [0, -1, 0, 3, 1, -3], [0, -1, 0, 1, 5, -5], [1, -1, 1, 2, 1, -4],_
    [0, 1, 0, 1, 3, -5], [-1, 3, -1, 0, 5, -6], [0, 3, 0, 1, 1, -5],_
    [2, -1, 2, 1, 1, -5], [-1, 0, 5, 1, 0, -5], [5, -2, -1, 1, 2, -5],_
    [2, -2, -1, 2, 6, -7], [0, -1, 3, 3, 1, -6], [3, -2, 0, 3, 2, -6],_
    [-1, 1, 2, 2, 3, -7], [2, 0, -1, 2, 4, -7], [1, 0, -2, 1, 8, -8],_
    [1, 3, 1, 0, 1, -6], [-2, 4, 4, 0, 0, -6], [-1, 3, 2, 2, 1, -7],_
    [1, -1, 4, 2, 1, -7], [4, -2, 1, 2, 2, -7], [-2, 5, 1, 1, 3, -8],_
    [4, -3, -2, 3, 7, -9], [0, 1, 3, 1, 3, -8], [3, 0, 0, 1, 4, -8],_
    [3, -3, -3, 2, 11, -10], [-3, 8, 3, -1, 0, -7], [0, 7, 0, -1, 1, -7],_
    [1, -3, -2, 4, 11, -11], [-2, 7, 1, 1, 1, -8], [0, 3, 3, 1, 1, -8],_
    [3, 2, 0, 1, 2, -8], [0, -1, -3, 3, 13, -12], [-3, 9, 0, 0, 3, -9],_
    [-1, 5, 2, 0, 3, -9], [2, 4, -1, 0, 4, -9], [-4, 12, 2, -2, 0, -8],_
    [-1, 7, 2, 0, 1, -9], [2, -4, -4, 4, 16, -14], [-2, 9, 1, -1, 3, -10],_
    [1, -4, -5, 3, 20, -15], [-5, 16, 1, -3, 0, -9],_
    [-2, 11, 1, -1, 1, -10], [-3, 13, 0, -2, 3, -11]];
assertEquals(rgens, rgensExpected)

eqgens := [EQA1C r for r in rgens];
assertEquals([qetaGrade x for x in eqgens],_
    [4, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11,_
    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15,_
    16, 16, 16, 16, 17, 18])

msyms := indexedSymbols("M", #eqgens)
xeqgens: List X1 C := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X1 C := xeqgens.1
abex := samba(tex, xeqgens, 0, oneVerboseStep!(1,1,1,2))$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 3)
assertEquals(numOfGaps(abex), 3)

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_45

q := monomial(1,1)$A1(C)

-- Zudilin (Mail Silviu "Date: Thu, 6 Feb 2020 14:16:19 +0100")
-- f_45(\tau) = eta^(1,1,1,0,1,0) + eta^(0,1,0,1,1,1) + 2*eta^(0,1,0,0,3,0) -
--              4*eta^(0,1,0,0,1,2)*q^(7/2)*
--              geneta(45, [3,9,12,-18,-27,33,36,42])

f45silviu := 1*q+1*q^2-1*q^4-1*q^5-3*q^8-1*q^10+4*q^11-2*q^13-1*q^16-2*q^17 _
  +4*q^19+1*q^20+4*q^22+1*q^25-2*q^26+2*q^29+5*q^32-2*q^34-10*q^37 _
  +4*q^38+3*q^40-10*q^41+4*q^43-4*q^44-8*q^47-7*q^49+1*q^50+2*q^52 _
  +10*q^53-4*q^55+2*q^58+4*q^59-2*q^61+7*q^64+2*q^65+12*q^67+2*q^68 _
  +8*q^71+10*q^73-10*q^74-4*q^76+1*q^80-10*q^82-12*q^83+2*q^85+4*q^86 _
  -12*q^88+6*q^89-8*q^94-4*q^95+2*q^97-7*q^98

-- generalized eta-quotient
-- From: Cristian-Silviu Radu <sradu@risc.jku.at>
-- Date: Thu, 6 Feb 2020 14:16:19 +0100

a(n,k)==(1-q^(45*n+k))
xn(n) == reduce(_*, [a(n,k) for k in [3,9,12,33,36,42]])
xd(n) == reduce(_*, [a(n,k) for k in [18,27]])
s1 := reduce(_*, [xn(n)/xd(n) for n in 0..10])

geqprefactor := expansion((q24(7*12)$ETA(C)) * YEQ1C[0,1,0,0,1,2])
f45etapart := EQA1C[1,1,1,0,1,0] + EQA1C[0,1,0,1,1,1] + 2*EQA1C[0,1,0,0,3,0]
f45trunc := f45etapart - 4 * geqprefactor * s1

s2 := generalizedEulerProduct(45, [3,9,12,33,36,42])$QFunctions(C, A1 C)_
      /_
      generalizedEulerProduct(45, [18,27])$QFunctions(C, A1 C)

f45 := f45etapart - 4 * geqprefactor * s2

z := f45 - f45trunc
assertTrue(zero? z)

divs := DIVISORS level
idivs := [i for i in 1.. #divs-1]
rwgens := etaQuotientExponentVectors(level, idivs, -4)$QEQEV;

rcofactor := rwgens.1
assertEquals(rcofactor, [0, - 1, 0, 3, 3, - 9])
fcofactor := EQA1C rcofactor
fcofactors := [EQA1C r for r in rwgens];
assertEquals([qetaGrade x for x in fcofactors], _
  [14, 16, 18, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 24, 26])

f := f45 * fcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 5*xfr
pol := second(ixfr)::PolC + F  -- This corresponds to the mod func f.

-- pol corresponds to the modular function f_45 * fcofactor

assertEquals(pol, (-M1^2+3*M1)*M3+(M1^2-6*M1-5)*M2+4*M1^2-M1-5)

pol0 := M0*pol -- Corresponds to the original f45.
assertEquals(# monomials pol0, 8)

-- We convert the polynomial in the Mi into a Laurent polynomial in
-- the Ei variables.

esyms := indexedSymbols("E", divs)
dim: N := #esyms

rgens0 := members(- vector rcofactor)
vals := cons(monRZ rgens0, [monRZ x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

 -- The Laurent polynomial (in Ei variables) that belongs to f.
fpolRZ := EVALRZ(vars, vals, pol);

z := rzToA1C fpolRZ - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- Show nicely
-- find common denominator

minEntries(x: DZ, y: DZ): DZ == (_
    directProduct vector [min(x.i, y.i) for i in 1..#x]);

dzs := [degree mon for mon in monomials fpolRZ]
denRZ := (- reduce(minEntries, dzs, 0$DZ)$List(DZ))::RZ

rez denRZ
rez(fpolRZ * denRZ)

-- Now we do the same thing for the modular form f45 itself.

fpol0RZ := EVALRZ(vars, vals, pol0)
dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ
z0 := rzToA1C fpol0RZ - f45
assertEquals(order(z0, 301), 301)

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.

assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])
assertEquals(#monomials(rez fpol0RZ), 8)

-- Show nicely

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-------------------------------------------------------------------
-- # Problem: Zudilin has a relation with only 7 terms for f_45.
-------------------------------------------------------------------
-- Just multiplying a "smaller" cofactor does not work, because we would
-- not work in M^\infty(45).
-- Zudilin suggested the following cofactor eta-quotient, because
-- he had already found a 7-term relation for f_45, namely,
-- (mail wzudilin@gmail.com "Fri, 7 Feb 2020 11:40:38 +0100")

)if IGNORE
( 3*q^4 * eta(q^9)^4 * eta(q^15)^4
-15*q^8 * eta(q^3) * eta(q^9) * eta(q^15)^3 * eta(q^45)^3
-5*q^3 * eta(q^3) * eta(q^5)^3 * eta(q^9) * eta(q^15)^3
+4*q^3 * eta(q^3)^2 * eta(q^9)^4 * eta(q^15)^2
+q^7 * eta(q^3)^3 * eta(q^9) * eta(q^15) * eta(q^45)^3
+q^5 * eta(q) * eta(q^3)^3 * eta(q^5) * eta(q^15) * eta(q^45)^2
+q^3 * eta(q)^3 * eta(q^9) * eta(q^15)^4 )
/
( q^4 * eta(q^3)^2 * eta(q^45)^2 )
)endif

-- where eta(q) is obviously the EulerProduct.

-- We store the terms as a list of [coeff, etaexponents].

brunaultterms := [_
  [  3, 0,-2,0,4,4,-2],_
  [-15, 0,-1,0,1,3, 1],_
  [- 5, 0,-1,3,1,3,-2],_
  [  4, 0, 0,0,4,2,-2],_
  [  1, 0, 1,0,1,1, 1],_
  [  1, 3,-2,0,1,4,-2],_
  [  1, 1, 1,1,0,1, 0] _
 ]

# brunaultterms

f45brunault := rzToA1C polyRZ brunaultterms
z := f45brunault-f45;
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])

-------------------------------------------------------------------
-- Finding other symmetry group for f_45.
-------------------------------------------------------------------

spitzen := cuspsOfGamma0 level
o := reduce(_+, [width(level, denom cusp) for cusp in spitzen])
assertEquals(o, indexOfGamma0 level)
reps := rightCosetRepresentatives level;
assertEquals(# reps, o)

xiord := 24*level
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

)set stream calc 4

findSimilarExpansions(qseries: List L1 CX): List List Z == (_
    REC ==> Record(fo: Z, fi: Z, fc: L1 CX);_
    oics := [[order x, i, x]$REC for x in qseries for i in 1..#qseries];_
    l := oics;_
    result := empty()$List(List Z);_
    while not empty? l repeat (_
        a := first l;_
        l2 := rest l;_
        while not empty? l2 repeat (_
            b := first l2;_
            if a.fo = b.fo then (_
                ser := a.fc/b.fc;_
                cs := [coefficient(ser, i) for i in 1..20];_
                if removeDuplicates [zero? c for c in cs] = [true] then (_
                    print(hconcat [[a.fi, b.fi]::OF, [ser]::OF]);_
                    result := cons([a.fi, b.fi], result)));_
            l2 := rest l2);_
        l := rest l);_
    result);


creps := [TOMAT(cusp) for cusp in spitzen]
hmat := matrix [[1,1],[0,1]]
[WIDTH(level, denom cusp) for cusp in spitzen]
xreps := concat [(gamma:=TOMAT(cusp); [gamma*((hmat^i)::MZ) for i in 0..WIDTH(level, denom cusp)-1]) for cusp in spitzen];

-------------------------------------------------------------------
-- Consider f. We see no similar expansions.
-------------------------------------------------------------------

fser := rzToAnCX fpolRZ
fserreps  := [rzToL1CX(fpolRZ, gamma) for gamma in reps];
fserxreps := [rzToL1CX(fpolRZ, gamma) for gamma in xreps];

)if false
result := findSimilarExpansions(fserreps);
assertEquals(result, [])
)endif

)set stream calc 4
for i in 1..#xreps repeat (_
    print("-----------------"::Symbol);_
    print([[i]]);_
    print(xreps.i);_
    print(fserxreps.i))

-------------------------------------------------------------------
-- Find better cofactor by means of 4ti2.
-------------------------------------------------------------------

-- The grades of an eta quotient at cusps of the form a/c (gcd(a,c)=1)
-- agrees for all such a. We choose just a=1 (which is relevant for
-- the Ligozat matrix.

fsergrades := [qetaGrade(fser, asP position(1/c, spitzen)) for c in divs]
assertEquals(fsergrades, [-1, -1, -1, -3, -1, 13])

-- For the following we have to take the full Ligozat matrix.

ndivs := #divs
idivs := [i for i in 1..ndivs]

-- Double the full Ligozat matrix part, because we want a resulting
-- vector whose corresponding grades agree in sign with fsergrades,
-- but are in absolute value (in each component separately) at most as
-- big as the respective absolute value of fsergrades.

mat := matrixLigozatRStar(level, idivs)$QAuxMEQ
mat := vertConcat(mat(1..ndivs,1..ncols mat), mat)

-- The 24 comes from the fact that the result after applying the
-- Ligozat matrix gives 24 times the order (not the grade) of the
-- respective series expansion.

bval: VZ := new(nrows mat, 0);
rels: VZ := new(nrows mat, 0);
for g in fsergrades for i in 1..ndivs repeat (_
    bval.i := 24*g;_
    rels.i := - sign g;_
    rels(ndivs+i) := sign g)
z := zsolve(mat, rels, bval)$X4ti2
zzi := [members t for x in z.zinhom | (t:=x(1..ndivs); not zero? t)]

rcofactorx := first zzi
grdrcofactorx := qetaGrade(EQAnCX rcofactorx, #spitzen)
for r in zzi repeat (_
    if grdrcofactorx > qetaGrade(EQAnCX r, asP #spitzen) then (_
          rcofactorx := r;_
          grdrcofactorx := qetaGrade(EQAnCX r, asP #spitzen)))

rcofactorx
fserx := fser * EQAnCX rcofactorx
qetaGrades fserx

# spitzen
sx := series(fserx, #spitzen)::A1(CX)
s := map(retract, sx)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)
xs := toX1(C, s, 'S)
xsr := reduce(xs, abex)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := -2*second(reduce(xs, abex)$QXTOPRED1(C))::PolC + S
assertEquals(# monomials spol, 4)

varsx := cons('MC, vars)
valsx := cons(monRZ members(- vector rcofactorx), vals)

fpol := spol*MC
fpolRZ := EVALRZ(varsx, valsx, fpol)
rez fpolRZ
rzToA1C fpolRZ
assertTrue(zero?(f - rzToA1C fpolRZ))

fpol0 := M0 * fpol
fpol0RZ := EVALRZ(varsx, valsx, fpol0)
rez fpol0RZ
z0 := rzToA1C fpol0RZ - f45
assertEquals(order(z0, 301), 301)

dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := (- reduce(minEntries, dzs0, 0$DZ)$List(DZ))::RZ

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-- +
-------------------------------------------------------------------
-- Is every eta-quotient in the sum holonomic?
-------------------------------------------------------------------
-- -

vexponents := [vector members degree m for m in monomials fpol0RZ]
ords :=[(1/24*matrixLigozat(level)*v) for v in vexponents]
assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true, false], [true]])

-- No, it isn't.

vexponents := [vector rest x for x in brunaultterms]
ords :=[(1/24*matrixLigozat(level)*v) for v in vexponents]
assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true], [true,false]])

-- Hewever, it is also not the case for the representation of Brunault.

-- +
-------------------------------------------------------------------
-- Find a basis for all eta-quotients of weight 4 that are modular forms
-------------------------------------------------------------------
-- -

idivs := [i for i in 1..#divs]
zmodform := zsolve4ti2(level, idivs, concat([0 for i in idivs], 4))$QEQEV;
vdivs := vector(divs)$VZ -- part of the Ligozat matrix that gives the order
zmodformzi := [members x(1..ndivs) for x in zmodform.zinhom]
assertEquals(#zmodformzi, 40)

-- Sort the generating exponents according to the resulting series expansion

vmodformgens := [vector x for x in zmodformzi]
vmodformgenss := sort((x1,x2)+->dot(vdivs,x1)<dot(vdivs,x2), vmodformgens)
rmodformgens := [members x for x in vmodformgenss]
ords :=[(1/24*matrixLigozat(level)*vector(r)) for r in rmodformgens]

)set out algebra on
)set out linear off
matrix [qetaGrades YEQn x for x in rmodformgens]

-- +
-------------------------------------------------------------------
-- Check whether there is a Q-linear combinationn of holomorphic
-- eta-quotients of level 45 that is equal to f45.
-------------------------------------------------------------------
-- -

--$ sage: dimension_modular_forms(Gamma0(45),2)
--: 10

emodformgens := [EQA1C r for r in rmodformgens]
[order x for x in emodformgens]

-- The dimension of modular forms of weight 2 for Gamma_0(45) is 10.

dimM45 := 10
nmodformgens := # rmodformgens
cmodformgens := [[coefficient(x, i) for i in 0..dimM45] for x in emodformgens]
for x in cmodformgens for i in 1.. repeat print [i, x]
matmodforms := transpose matrix cmodformgens;
cf45 := [coefficient(f45, i) for i in 0..dimM45]
rels: VZ := new(nrows matmodforms, 0);
zmodforms := zsolve(matmodforms, rels, vector cf45)$X4ti2;
zmodformszi := zmodforms.zinhom
zmodformszf := zmodforms.zfree

-- Find the indicies where the entries are zero, i.e., those modular
-- form generators are irrelevant for the linear combination for f45.

nizi := [i for i in 1..#(zmodformszi.1) | not zero? zmodformszi.1.i]
zizi := [i for i in 1..#(zmodformszi.1) | zero? zmodformszi.1.i]

-- The shortened (relevant) vectors

nzf := [[x.i for i in nizi] for x in zmodformszf]
zzf := [[x.i for i in zizi] for x in zmodformszf]
for x in zzf repeat print [position(1, x), x]
for x in nzf for i in 1..#nzf repeat print [i, x]
nzi := [zmodformszi.1.i for i in nizi]
for x in nzf for i in 1..#nzf repeat (_
    l := members(vector x - vector nzi);_
    print [i, # remove(0, l), l])

for x in zmodformszf for i in 1..#zmodformszf repeat (_
    l := members(vector x - vector zmodformszi.1);_
    print [i, # remove(0, l), l])

assertEquals([[i,x] for i in 1..nmodformgens|(x:=zmodformszi.1.i;not zero? x)],_
    [[1, 3], [3, - 1], [5, - 2], [27, 2], [31, - 57], [32, 3], [33, - 39],_
     [34, 102], [39, 57], [40, 162]])

reduce(_+,[zmodformszi.1.i * emodformgens.i for i in 1..nmodformgens], 0$A1(C)) - f45

relvec := zmodformszi.1 - zmodformszf.30
assertEquals([[i, relvec.i] for i in 1..40 | not zero? relvec.i],_
    [[3, 1], [10, -1], [33, -1]])

h := reduce(_+,[relvec.i * emodformgens.i for i in 1..nmodformgens], 0$A1(C))
h45 := h - f45
removeDuplicates [qetaCoefficient(h45, -i) for i in -10..200]

u := rmodformgens;
h := (EQA1C u.3 - EQA1C u.10 - EQA1C u.33)
h := fcofactor * (EQA1C u.3 - EQA1C u.10 - EQA1C u.33)
assertTrue(zero?(h - f))

hn := (EQAnCX u.3 - EQAnCX u.10 - EQAnCX u.33)
hn - (fser/EQAnCX rcofactor)
hn * EQAnCX rcofactor - fser

-- Print nicely...

)set stream calc 20
EQA1C u.3
EQA1C u.10
EQA1C u.33

qetaGrades EQAnCX u.3
qetaGrades EQAnCX u.10
qetaGrades EQAnCX u.33

qetaGrades YEQn u.3
qetaGrades YEQn u.10
qetaGrades YEQn u.33

qsyms := indexedSymbols("Q", #rmodformgens)
xmfgens: List X1 C := [toX1(C, x, s) for x in emodformgens for s in qsyms];

xmf := xmfgens.3 - xmfgens.10 - xmfgens.33
mfpol := second(xmf)::PolC
valsmf := [monRZ x for x in rmodformgens]

fmfpolRZ := EVALRZ(qsyms, valsmf, mfpol)
z0 := rzToA1C fmfpolRZ - f45
assertEquals(order(z0, 301), 301)

rez fmfpolRZ

dzmf0 := [degree mon for mon in monomials fmfpolRZ]
denmf0RZ := (- reduce(minEntries, dzmf0, 0$DZ)$List(DZ))::RZ

assertEquals(#monomials(rez fmfpolRZ), 3)

num0 := rez (fmfpolRZ * denmf0RZ)
den0 := rez(denmf0RZ)

-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------


-- +
-------------------------------------------------------------------
--test:Zudilin21-42
-------------------------------------------------------------------
-- -

-- We have given f21 as an expression in level 63. So we first
-- compute the respective q-series and then multiply with
-- a cofactor of level 42 to get a modular function in level 42.

level := 63;
ef21 := E7 / (2*E1^2*E3*E9*E21) _
        *_
        (3*E1^2*E7^2*E9^4 - E3^5*E7*E9*E21 + 7*E1*E3^2*E9*E21^4_
         + 3*E1^3*E7*E9^3*E63 - 3*E1*E3^5*E21*E63 + 3*E1^4*E9^2*E63^2)
rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;
divs := DIVISORS level
esyms := indexedSymbols("E", divs)
dim: N := #esyms
num21 := toRZ numer ef21
den21 := 1 exquo toRZ denom ef21
f21polzudilinRZ := ((toRZ numer ef21) exquo (toRZ denom ef21))::RZ
f21 := rzToA1C f21polzudilinRZ

-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 21). The variable `rgens` corresponds to the generators
-- of $R^\infty(21)$.

level := 42;
divs := DIVISORS level
ndivs := #divs
esyms := indexedSymbols("E", divs)
dim: N := #esyms

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;
vgens := [vector x for x in rgens];
assertEquals(#rgens, 1517)

eqgens := [EQA1C r for r in rgens];
msyms := indexedSymbols("M", #eqgens);
xeqgens: List X1 C := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X1 C := xeqgens.1
abex := samba(tex, xeqgens, 5, oneVerboseStep!(1,1,0,2))$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 5)
assertEquals(numOfGaps(abex), 5)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- f_21

)set stream calc 4
idivs := [i for i in 1.. #divs-1]
wght := 2 -- weight of f21.
rhs: List Z := concat([0 for i in idivs], -2*wght)
z := zsolve4ti2(level, idivs, rhs);
zzi := sortByComponentGrade(level, [x(1..ndivs) for x in z.zinhom]);
zzh := sortByComponentGrade(level, [x(1..ndivs) for x in z.zhom]);
rwgens := zzi;
-- rwgens := etaQuotientExponentVectors(level, idivs, -4)$QEQEV;

)set output linear off
)set output alg on
spitzen := cuspsOfGamma0 level
xiord := 24*level
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

matrix [qetaGrades YEQn r for r in zzi]
matrix [qetaGrades YEQn r for r in zzh]

rcofactor := rwgens.1
--assertEquals(rcofactor, [-1, 0, 3, 0, -1, 4, 3, -12])
assertEquals(rcofactor, [1, - 2, - 3, 6, - 3, 6, 9, - 18])
fcofactor := EQA1C rcofactor
f := f21 * fcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 49*xfr
pol := -second(ixfr)::PolC + F  -- This corresponds to the mod func f.

assertEquals(# monomials pol, 17)



-- +
-------------------------------------------------------------------
-- Find a basis for all eta-quotients of weight 4 that are modular forms
-------------------------------------------------------------------
-- -

idivs := [i for i in 1..#divs]
rhs := concat([0 for i in idivs], 2*wght)
zmodform := zsolve4ti2(level, idivs, rhs)$QEQEV;
vdivs := vector(divs)$VZ -- part of the Ligozat matrix that gives the order
zmodformzi := [members x(1..#divs) for x in zmodform.zinhom];
assertEquals(#zmodformzi, 138)

-- Sort the generating exponents according to the resulting series expansion

vmodformgens := [vector x for x in zmodformzi];
vmodformgenss := sort((x1,x2)+->dot(vdivs,x1)<dot(vdivs,x2), vmodformgens);
rmodformgens := [members x for x in vmodformgenss]

mat := matrixLigozatRStar(level, idivs)$QAuxMEQ
rmat := mat(1..nrows(mat), 1..#divs)
rmat * vector rmodformgens.138

[order EQA1C r for r in rmodformgens]
)set out algebra on
)set out linear off
matrix [qetaGrades YEQn x for x in rmodformgens]

-- +
-------------------------------------------------------------------
-- Check whether there is a Q-linear combinationn of holomorphic
-- eta-quotients of level 42 that is equal to f21.
-------------------------------------------------------------------
-- -

--$ sage: dimension_modular_forms(Gamma0(42),2)
--: 12
CGRDS(gens, cond) ==> _
  matrix [cons(i, x) for r in gens for i in 1..#gens| (x := g YEQn r; cond)]
GRDS(gens) ==> CGRDS(gens, true)
emodformgens := [EQA1C r for r in rmodformgens];
[order x for x in emodformgens]

dimM42 := 12
ncoefs := 14
nmodformgens := # rmodformgens
cmodformgens := [[coefficient(x, i) for i in 0..ncoefs] for x in emodformgens];
assertEquals(rank matrix cmodformgens, dimM42)

matmodforms := transpose matrix cmodformgens;
cf21 := [coefficient(f21, i) for i in 0..ncoefs]
rels: VZ := new(nrows matmodforms, 0);
zmodforms := zsolve(matmodforms, rels, vector cf21)$X4ti2;
zmodformszi := zmodforms.zinhom
zmodformszf := zmodforms.zfree;
zzi := first zmodformszi
remove(0, zzi)
[[i, x] for i in 1..#zzi | (x := zzi.i; not zero? x)]
lz := [i for i in 1..#zzi | (x := zzi.i; zero? x)]
ln := [i for i in 1..#zzi | (x := zzi.i; not zero? x)]
l := concat(ln, lz);
c2modformgens := [cmodformgens.i for i in l];
mat2modforms := transpose matrix c2modformgens;
z2modforms := zsolve(mat2modforms, rels, vector cf21)$X4ti2;
z2modformszi := z2modforms.zinhom
z2modformszf := z2modforms.zfree;

emodformgens := [EQA1C r for r in rmodformgens]
[order x for x in emodformgens]
u:=emodformgens
h := -2*u.54 -3*u.58 +6*u.59 +2*u.79 +21*u.130
h42 := h - f21
removeDuplicates [qetaCoefficient(h42, -i) for i in -10..200]


sol := solve(mat2modforms, vector cf21);

s0 := (sol.particular)(1..13)
sols := cons(s0, [x(1..13) for x in sol.basis]);
solsZ := [(d:=lcm[denom x for x in members v]; (d*vector(v))::Vector(Z)) for v in sols];
matrix [cons(i-1, x) for i in 1..#solsZ |(x:=solsZ.i; true)]
matrix [cons(i-1, x) for i in 1..#solsZ |(x:=solsZ.i; x.1 + x.4 = 0)]

h := sol.particular + 4*sol.basis.89

[[i, x] for i in 1..#h | (x := h.i; not zero? x)]
ln2 := [l.i for i in 1..#h | (x := h.i; not zero? x)]
assertEquals(ln2, [1, 3, 4, 100])

hh := 1/36*u.1-2/9*u.3+7/36*u.4+4*u.100
hh42 := hh - f21
removeDuplicates [qetaCoefficient(hh42, -i) for i in -10..300]

-- Show nicely

qsyms := indexedSymbols("Q", #rmodformgens)
xmfgens: List X1 C := [toX1(C, x, s) for x in emodformgens for s in qsyms];

xmf := 1/36*xmfgens.1 - 2/9*xmfgens.3 + 7/36*xmfgens.4 + 4*xmfgens.100
mfpol := second(xmf)::PolC
valsmf := [monRZ x for x in rmodformgens]

fmfpolRZ := EVALRZ(qsyms, valsmf, mfpol)
z0 := rzToA1C fmfpolRZ - f21
assertEquals(order(z0, 301), 301)

rez fmfpolRZ

minEntries(x: DZ, y: DZ): DZ == (_
    directProduct vector [min(x.i, y.i) for i in 1..#x]);

dzmf0 := [degree mon for mon in monomials fmfpolRZ]
denmf0RZ := (- reduce(minEntries, dzmf0, 0$DZ)$List(DZ))::RZ

assertEquals(#monomials(rez fmfpolRZ), 4)

num0 := rez (fmfpolRZ * denmf0RZ)
den0 := rez(denmf0RZ)

-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
