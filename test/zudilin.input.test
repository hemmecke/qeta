-- Via jupytext this file can be shown as a jupyter notebook.
-- For that one would have to move or link it to a file with
-- extension ".input".

)clear complete
assertEquals(x,y)==>(x=y)@Boolean
assertTrue x ==> x

)cd /home/hemmecke/g/qeta/tmp

)r projectlibs )quiet
)r etamacros.input )quiet

)set mess type on
)set output linear on
)set output algebra off

)set mess time on


-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q
L ==> F1 C
X ==> X1 C

-- The following function simply maps the integer coefficients of the
-- series into the localized coefficient domain or into the rational
-- number domain Q.

abmap(A, B, x) ==> _
  map((c: A): B +-> c::B, x)$Finite0SeriesFunctions2(A, B, 'q, 'q, 0, 0)
zcmap(x) ==> abmap(Z, C, x)
cqmap(x) ==> abmap(C, Q, x)
zqmap(x) ==> abmap(Z, Q, x)

PolC ==> Pol C; LC ==> F1 C
PolZ ==> Pol Z; LZ ==> F1 Z

numOfGaps(ab) == (_
  t := multiplier ab; _
  n := qetaGrade(t)::P; _
  grades := [qetaGrade(first basis(ab, i))::P for i in 1..n-1]; _
  numberOfGaps(n, grades)$QAuxiliaryModularEtaQuotientPackage)

QEQEV ==> QEtaQuotientExponentVectors4ti2

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

-- # Relations in terms of the $M_i$'s

-- +
-------------------------------------------------------------------
--test:Zudilin128
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 128). The variable `rgens` corresponds to the generators
-- of $R^\infty(128)$.
level := 128;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;

rgensExpected: List List Z := [_
    [0, 0, 0, 0, - 1, 2, 1, - 2], [0, 0, 0, 0, 0, - 2, 6, - 4],_
    [0, 0, 0, - 2, 5, - 2, 1, - 2], [0, 0, 0, 2, - 1, 0, 1, - 2],_
    [0, - 2, 5, - 2, 0, 0, 1, - 2], [0, 2, - 1, 0, 0, 0, 1, - 2],_
    [0, 0, 0, - 1, 2, - 1, 4, - 4], [0, 0, - 2, 5, - 2, - 1, 4, - 4],_
    [0, 0, 2, - 1, 0, - 1, 4, - 4], [- 2, 5, - 2, 0, 0, - 1, 4, - 4],_
    [2, - 1, 0, 0, 0, - 1, 4, - 4], [0, 0, - 2, 4, 0, 0, 2, - 4],_
    [0, 0, 2, - 2, 2, 0, 2, - 4], [- 2, 5, - 2, - 1, 2, 0, 2, - 4],_
    [2, - 1, 0, - 1, 2, 0, 2, - 4], [0, 0, 0, - 1, 0, 5, 0, - 4],_
    [0, 0, - 2, 5, - 4, 5, 0, - 4], [0, 0, 2, - 1, - 2, 5, 0, - 4],_
    [- 2, 5, - 2, 0, - 2, 5, 0, - 4], [2, - 1, 0, 0, - 2, 5, 0, - 4],_
    [0, 0, 0, 0, - 4, 10, - 2, - 4], [- 2, 5, - 4, 5, - 2, 0, 2, - 4],_
    [2, - 1, - 2, 5, - 2, 0, 2, - 4], [0, 0, - 4, 10, - 4, 0, 2, - 4],_
    [- 2, 5, 0, - 1, 0, 0, 2, - 4], [2, - 1, 2, - 1, 0, 0, 2, - 4],_
    [- 4, 10, - 4, 0, 0, 0, 2, - 4], [4, - 2, 0, 0, 0, 0, 2, - 4]];
assertEquals(rgens, rgensExpected)

divs := divisors(level)$IntegerNumberTheoryFunctions;
etaquotgensZ: List EtaQuotient(Z, LZ) := [etaQuotient(divs, r) for r in rgens];
for x in etaquotgensZ repeat assertTrue(zero? prefactor x)

eqgensZ: List LZ := [retract x for x in etaquotgensZ];
eqgens: List L := [zcmap x for x in eqgensZ];
assertEquals([qetaGrade x for x in eqgens],_
  [6, 8, 8, 8, 8, 8, 11, 12, 12, 12, 12, 15, 15, 15, 15, 15, _
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])

msyms := indexedSymbols("M", #eqgens)

xeqgens: List X := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X := xeqgens.1
abex := samba(tex, xeqgens)$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 9)
assertEquals(numOfGaps(abex), 9)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabi–Yau manifolds"
-- f_128

q := monomial(1,1)$F1(C)
f128 := q - 2*q^3 + 6*q^5 - 20*q^7 - 23*q^9 - 14*q^11 + 54*q^13 - 12*q^15 - _
  66*q^17 - 162*q^19 + 40*q^21 - 172*q^23 - 89*q^25 + 100*q^27 - 2*q^29 + _
  128*q^31 + 28*q^33 - 120*q^35 + 158*q^37 - 108*q^39 + 202*q^41 + _
  298*q^43 - 138*q^45 + 408*q^47 + 57*q^49 + 132*q^51 - 690*q^53 - 84*q^55 _
  + 324*q^57 + 322*q^59 - 298*q^61 + 460*q^63 + 324*q^65 - 202*q^67 + _
  344*q^69 + 700*q^71 - 418*q^73 + 178*q^75 + 280*q^77 - 744*q^79 + _
  421*q^81 + 678*q^83 - 396*q^85 + 4*q^87 - 82*q^89 - 1080*q^91 - 256*q^93 _
  - 972*q^95 - 1122*q^97 + 322*q^99 + 1390*q^101 - 788*q^103 + 240*q^105 - _
  1614*q^107 + 2014*q^109 - 316*q^111 - 542*q^113 - 1032*q^115 - _
  1242*q^117 + 1320*q^119 - 1135*q^121 - 404*q^123 - 1284*q^125 - _
  1712*q^127 - 596*q^129 + 2118*q^131 + 3240*q^133 + 600*q^135 - 486*q^137 _
  - 1286*q^139 - 816*q^141 - 756*q^143 - 12*q^145 - 114*q^147 - 2666*q^149 _
  - 172*q^151 + 1518*q^153 + 768*q^155 + 838*q^157 + 1380*q^159 + _
  3440*q^161 - 1346*q^163 + 168*q^165 + 1052*q^167 + 719*q^169 + _
  3726*q^171 + 38*q^173 + 1780*q^175 - 644*q^177 + 2790*q^179 - 3418*q^181 _
  + 596*q^183 + 948*q^185 + 924*q^187 - 2000*q^189 + 1968*q^191 - _
  1058*q^193 - 648*q^195 + 726*q^197 - 4116*q^199 + 404*q^201 + 40*q^203 + _
  1212*q^205 + 3956*q^207 + 2268*q^209 - 1482*q^211 - 1400*q^213 + _
  1788*q^215 - 2560*q^217 + 836*q^219 - 3564*q^221 + 896*q^223 + _
  2047*q^225 - 3410*q^227 + 4502*q^229 - 560*q^231 + 2302*q^233 + _
  2448*q^235 + 1488*q^237 - 4024*q^239 - 3586*q^241 - 3542*q^243 + _
  342*q^245 - 8748*q^247 - 1356*q^249 + 1250*q^251 + 2408*q^253 + _
  792*q^255 - 6638*q^257 - 3160*q^259 + 46*q^261 + 1724*q^263 - 4140*q^265 _
  + 164*q^267 + 4814*q^269 + 1640*q^271 + 2160*q^273 + 1246*q^275 + _
  3982*q^277 - 2944*q^279 + 4126*q^281 - 3446*q^283 + 1944*q^285 - _
  4040*q^287 - 557*q^289 + 2244*q^291 - 1514*q^293 + 1932*q^295 - _
  1400*q^297 - 9288*q^299

rwgens := etaQuotientExponentVectors(level, [1,2,3,4,5,6,7], -8)$QEQEV;

rcofactor := first rwgens
assertEquals(rcofactor, [0, 0, 0, 0, -1, 2, 9, -18])
eqcofactor := retract etaQuotient(divs, rcofactor)$EtaQuotient(C, L)
eqcofactors := [retract etaQuotient(divs, r)$EtaQuotient(C, L) for r in rwgens];
assertEquals([qetaGrade x for x in eqcofactors],_
  [70, 72, 72, 72, 72, 72, 75, 76, 76, 76, 76, 79, 79, 79, 79, 79, _
  80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80])


f := f128 * eqcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 1024*xfr
pol := second(ixfr)::PolC + F  -- This corresponds to the mod func f.

assertEquals(pol,_
  ((-2*M1^8-24*M1^7+8*M1^6-56*M1^5+336*M1^4+368*M1^3+256*M1^2)*M6+2*M1^9_
  -56*M1^8+12*M1^7-128*M1^6+400*M1^5+704*M1^4-224*M1^3-1024*M1^2-1024*M1)*M7_
  +(M1^9-20*M1^8+48*M1^7-136*M1^6+96*M1^5+288*M1^4+160*M1^3+64*M1^2-64*M1)*M16)

pol0 := M0*pol -- Corresponds to the original f128.
assertEquals(# monomials pol0, 25)


h(l) == E1^l.1*E2^l.2*E4^l.3*E8^l.4*E16^l.5*E32^l.6*E64^l.7*E128^l.8

rgens0 := members(- vector rcofactor)
vals := cons(h(rgens0), [h x for x in rgens])
vars := cons(M0, msyms)

FPZ ==> Fraction PolZ
PE==>PolynomialEvaluation(Z, FPZ)

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.
epol := (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol);
epoln := numer epol;
epold := denom epol;

esyms := indexedSymbols("E", divs)
dim: N := #esyms
DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

E ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, E)

e(l) ==> retract etaQuotient(divs, l)$ETA(C)

rpoln := toRZ epoln
rpold := degree toRZ epold
irpold := (-rpold)::RZ
rpol := rpoln * irpold
ms := [leadingCoefficient x * e members degree x for x in monomials rpol];
z := reduce(_+, ms) - f
-- The function z is a modular function, so we only need to check the
-- negative exponents.
assertTrue(zero? z)
-- But we kill all the given coefficients for f128.
assertEquals(order(z::L, 300), 231)

-- Show nicely
num := rez rpoln
den := rez(rpold :: RZ)




-- Now we do the same thing for the modular form f128 itself.
epol0 := (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol0);
epol0n := numer epol0;
epol0d := denom epol0;

rpol0n := toRZ epol0n
rpol0d := degree toRZ epol0d
irpol0d := (-rpol0d)::RZ
rpol0 := rpol0n * irpol0d
ms0 := [leadingCoefficient x * e members degree x for x in monomials rpol0];
z0 := reduce(_+, ms0) - f128

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.
assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])
assertEquals(#monomials(rez rpol0n), 25)

-- Show nicely
num0 := rez rpol0n
den0 := rez(rpol0d :: RZ)

-------------------------------------------------------------------
-- Mail Zudillin 17-Feb-2020:
equ(l) ==> etaQuotient(divs, l)$ETA(C)

brunaultterms := [_
  [   1, 2, 1,3, 3,-1,0,0,0],_
  [   2, 0, 2,3, 2, 1,0,0,0],_
  [   8, 0, 0,2, 2, 2,2,0,0],_
  [ -24, 0, 0,2, 0, 2,4,0,0],_
  [ -16, 0, 2,1, 2,-1,0,4,0],_
  [ -64, 0, 0,0, 1, 2,3,2,0],_
  [  32, 0, 0,0,-1, 2,5,2,0],_
  [ -32, 0, 0,4, 1,-1,1,1,2],_
  [ -64, 0, 0,0, 1, 3,1,1,2],_
  [-256, 0, 0,0,-1, 3,3,1,2],_
  [ 128, 0, 0,2, 0,-1,2,3,2],_
  [-256, 0, 0,4,-1, 0,1,0,4],_
  [-128, 0, 0,0,-1, 4,1,0,4],_
  [-512, 0, 0,2, 0, 0,0,2,4]_
 ]

f128brunault := reduce(_+, [first(x)*retract(equ rest x) for x in brunaultterms])
z := f128brunault - f128
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])




-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------




-- +
-------------------------------------------------------------------
--test:Zudilin45
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 128 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 45). The variable `rgens` corresponds to the generators
-- of $R^\infty(45)$.

level := 45;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;

divs := divisors(level)$IntegerNumberTheoryFunctions;
etaquotgensZ: List EtaQuotient(Z, LZ) := [etaQuotient(divs, r) for r in rgens];
for x in etaquotgensZ repeat assertTrue(zero? prefactor x)

eqgensZ: List LZ := [retract x for x in etaquotgensZ];

eqgens: List L := [zcmap x for x in eqgensZ];
assertEquals([qetaGrade x for x in eqgens],_
    [4, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11,_
    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15,_
    16, 16, 16, 16, 17, 18])

msyms := indexedSymbols("M", #eqgens)
xeqgens: List X := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X := xeqgens.1
abex := samba(tex, xeqgens)$QXTOPSAMBA1(C)

assertEquals(genusOfGamma0(level), 3)
assertEquals(numOfGaps(abex), 3)

-- Due to another critical element selection strategy, the resulting
-- polynomial is a bit different.

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabi–Yau manifolds"
-- f_45

q := monomial(1,1)$F1(C)

-- Zudilin (Mail Silviu "Date: Thu, 6 Feb 2020 14:16:19 +0100")
-- f_45(\tau) = eta^(1,1,1,0,1,0) + eta^(0,1,0,1,1,1) + 2*eta^(0,1,0,0,3,0) -
--              4*eta^(0,1,0,0,1,2)*q^(7/2)*
--              geneta(45, [3,9,12,-18,-27,33,36,42])

f45silviu := 1*q+1*q^2-1*q^4-1*q^5-3*q^8-1*q^10+4*q^11-2*q^13-1*q^16-2*q^17 _
  +4*q^19+1*q^20+4*q^22+1*q^25-2*q^26+2*q^29+5*q^32-2*q^34-10*q^37 _
  +4*q^38+3*q^40-10*q^41+4*q^43-4*q^44-8*q^47-7*q^49+1*q^50+2*q^52 _
  +10*q^53-4*q^55+2*q^58+4*q^59-2*q^61+7*q^64+2*q^65+12*q^67+2*q^68 _
  +8*q^71+10*q^73-10*q^74-4*q^76+1*q^80-10*q^82-12*q^83+2*q^85+4*q^86 _
  -12*q^88+6*q^89-8*q^94-4*q^95+2*q^97-7*q^98

-- generalized eta-quotient
a(n,k)==(1-q^(45*n+k))
xn(n) == reduce(_*, [a(n,k) for k in [3,9,12,33,36,42]])
xd(n) == reduce(_*, [a(n,k) for k in [18,27]])
s := reduce(_*, [xn(n)/xd(n) for n in 0..10])
equ(l) ==> etaQuotient(divs, l)$ETA(C)
equs(l) ==> series equ l
l := [0,1,0,0,1,2]
f45trunc := equs[1,1,1,0,1,0] + equs[0,1,0,1,1,1] + 2*equs[0,1,0,0,3,0] _
  - 4*q^(((7*12+prefactor equ l) exquo 24)::Z)*equs(l)*s

QF ==> QFunctions(C, F1 C)
p(i) ==> qPochhammer(1, i, 45)$QF
ns := reduce(_*, [p k for k in [3,9,12,33,36,42]])
ds := reduce(_*, [p k for k in [18,27]])
s := ns/ds

f45 := equs[1,1,1,0,1,0] + equs[0,1,0,1,1,1] + 2*equs[0,1,0,0,3,0] _
  - 4*q^(((7*12+prefactor equ l) exquo 24)::Z)*equs(l)*s

z := f45 - f45trunc

idivs := [i for i in 1.. #divs-1]
rwgens := etaQuotientExponentVectors(level, idivs,-4)$QEQEV;

rcofactor := rwgens.1
assertEquals(rcofactor, [0, -2, 0, 6, 4, -12])
eqcofactor := retract etaQuotient(divs, rcofactor)$EtaQuotient(C, L)
eqcofactors := [retract etaQuotient(divs, r)$EtaQuotient(C, L) for r in rwgens];
assertEquals([qetaGrade x for x in eqcofactors], _
  [18, 20, 20, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 24, 24, 24, _
  25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, _
  28, 28, 28, 28, 28, 29, 30, 30, 30, 30, 31, 32])

f := f45 * eqcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
ixfr := 5 * xfr
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..200], [0])

FPZ ==> Fraction PolZ
PE==>PolynomialEvaluation(Z, FPZ)

pol := ((second(ixfr)::PolC + F)::PolZ)
-- pol corresponds to the modular function f_45 * eqcofactor
assertEquals(pol, (-M1^3+3*M1^2)*M3+(M1^3-6*M1^2-5*M1)*M2+4*M1^3-M1^2-5*M1)

pol0 := M0*pol
# monomials pol0
vars := sort(variables pol0)
assertEquals(vars, [M0, M1, M2, M3])

h(l) == E1^l.1*E3^l.2*E5^l.3*E9^l.4*E15^l.5*E45^l.6

rgens0 := members(- vector rcofactor)
vals := cons(h(rgens0), [h x for x in rgens])
vars := cons(M0, msyms)

-- The following give f_45 in terms of eta-quotients
efun := (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol)
assertEquals(efun, _
  (-E1*E15^4*E45*E5*E9^11+E15^8*E9^10+4*E15^3*E3*E45^5*E9^9 _
   +3*E1*E15^3*E3*E45^4*E5*E9^8-6*E15^7*E3*E45^3*E9^7 _
   -E15^2*E3^2*E45^8*E9^6-5*E15^6*E3^2*E45^6*E9^4-5*E15*E3^3*E45^11*E9^3)_
   /_
   (E3^4*E45^14))

-------------------------------------------------------------------
-- # Problem: Zudilin has a relation with only 7 terms for f_45.
-------------------------------------------------------------------
-- Just multiplying a "smaller" cofactor does not work, because we would
-- not work in M^\infty(45).
-- Zudilin suggested the following cofactor eta-quotient, because
-- he had already found a 7-term relation for f_45, namely,
-- (mail wzudilin@gmail.com "Fri, 7 Feb 2020 11:40:38 +0100")

)if IGNORE
( 3*q^4 * eta(q^9)^4 * eta(q^15)^4
-15*q^8 * eta(q^3) * eta(q^9) * eta(q^15)^3 * eta(q^45)^3
-5*q^3 * eta(q^3) * eta(q^5)^3 * eta(q^9) * eta(q^15)^3
+4*q^3 * eta(q^3)^2 * eta(q^9)^4 * eta(q^15)^2
+q^7 * eta(q^3)^3 * eta(q^9) * eta(q^15) * eta(q^45)^3
+q^5 * eta(q) * eta(q^3)^3 * eta(q^5) * eta(q^15) * eta(q^45)^2
+q^3 * eta(q)^3 * eta(q^9) * eta(q^15)^4 )
/
( q^4 * eta(q^3)^2 * eta(q^45)^2 )
)endif

-- where eta(q) is obviously the EulerProduct.

-- We store the terms as a list of [coeff, etaexponents].

zudilinterms := [_
  [  3, 0,-2,0,4,4,-2],_
  [-15, 0,-1,0,1,3, 1],_
  [- 5, 0,-1,3,1,3,-2],_
  [  4, 0, 0,0,4,2,-2],_
  [  1, 0, 1,0,1,1, 1],_
  [  1, 3,-2,0,1,4,-2],_
  [  1, 1, 1,1,0,1, 0] _
 ]

f45zudilin := reduce(_+, [first(x)*retract(equ rest x) for x in zudilinterms])
f45diff := f45zudilin-f45;
coeffsf45 :=  [qetaCoefficient(f45diff, -i) for i in 0..300];
assertEquals(removeDuplicates coeffsf45, [0])


rzudilin := rest(zudilinterms.1)
-- It corresponds to the denominator (exponent 2) and the monomial
-- eta(q^9)^4*eta(q^15).

-- In the following we aim at finding the above relation by means of
-- powersamba.

equn(r) ==> etaQuotient(level, r, 1, [0], 1, 0, cusps)$YMSETAQ
expand e ==> expansions(expandAtAllCusps(e)$MSETAQ(C, CX))::Fn(CX);

-------------------------------------------------------------------
-- We use powersamba to overcome the above problem
-------------------------------------------------------------------

-- We represent f45 by an expression from pol where the Mi are replaced
-- by the respective (power) eta-quotient expressions.

-- First let's compute a powersamba basis.

QEQMEVS ==> QEtaQuotientMonoidExponentVectorsStar
eqmevx ==> etaQuotientMonoidExponentVectorsX$QEQMEVS

)set stream calc 2
)set stream showall off
nn := level
--rs := eqmevx level
rs := etaQuotientMonoidExponentVectors(level, [2,3,4,5])$QEQEV;

--cusps := cuspsOfGamma0 level
--cusps := [1,1/5, 1/9, 1/45]
cusps := [1, 1/45]

qsyms := indexedSymbols("Q", #rs)
ygens := [equn rsi for rsi in rs];
xiord := max [minimalRootOfUnity y for y in ygens]
if xiord < 3 then (CX := Q; xi := -(1$CX)) else _
  (CX ==> UnityRootExtension(C, xiord); xi := generator()$CX)
egens := [expand y for y in ygens];
[qetaGrades x for x in egens]


assertEquals([qetaGrades x for x in egens], [_
  [1, 3], [4, 2], [2, 4], [4, 4], [5, 1], [6, -2], [6, 2], [0, 6],_
  [7, -1], [8, -8], [8, 0], [-4, 8], [-8, 8], [9, -3], [10, -4], _
  [10, -2], [11, -7], [12, -6], [12, -4], [14, -8], [16, -12]])

xgens := [toXn(CX, x, s) for x in egens for s in qsyms];

)read /home/hemmecke/g/qeta/input/tracing.input
)read /home/hemmecke/g/qeta/input/tracingpower.input

--ab := samba(xgens, onetnStep!)$QXSAMBAn(CX);
ab := samba(xgens)$QXSAMBAn(CX);

xlm := entries multipliers ab
xlb := concat concat [entries x for x in members basisElements ab]
xl := concat(xlm, xlb)
--ab2 := samba(xl, onetnStep!)$QXSAMBAn(CX);
ab2 := samba(xl)$QXSAMBAn(CX);

mults := multipliers ab;
idx := indexPermutation ab
ms := [mults idx i for i in 1..#idx]
qs := [qetaGrades x for x in ms]



-------------------------------------------------------------------
-- Reduction
-------------------------------------------------------------------

-------------------------------------------------------------------

-- In pol, We have to replace the Mi by eta-quotient corresponding to
-- rgens(i).

valsn := [toXn(CX, expand equn r, msym) for r in rgens for msym in msyms];
PEX==>PolynomialEvaluation(Z, Xn CX)

1$Xn(CX)
3 * 1$Xn(CX)
id(c: Z): Xn(CX) == c*1$Xn(CX)
id(5)
xmfn := (eval(id, msyms, valsn)$PEX)(pol);
qetaGrades xmfn
assertEquals(qetaGrades xmfn, [-1, 17])
-- xmfn corresponds to the same modular function as xf, but with expansion
-- at the cusps given by the variable "cusps".

[[order series(x,i::P) for i in 1..#cusps] for x in egens]
mf := (first(xmfn)::Fn(CX))
[order series(mf,i::P) for i in 1..#cusps]
xfn := toXn(CX, mf, 'F)
xfr := reduce(xfn, ab)$QXREDn(CX)
xfr2 := reduce(xfn, ab2)$QXREDn(CX);

assertTrue(zero? xfr)
assertTrue(zero? xfr2)

assertEquals(removeDuplicates [order(series(first(xfr)::Fn(CX), i), 9) for i in 1..#cusps], [9])

-- Find an eta-quotient that reduces the pole order at infinity at the cost
-- of increasing the pole order at 0.
-- We have already such eta-quotients given by rs (or egens).
-- Multiplying xfn by xgens.1

z := zsolve4ti2(level, [2,3,4,5,6], [0,0,0,0,24*17], 0)
zi := [x(1..#divs) for x in z.zinhom]
zsyms := indexedSymbols("Z", #zi)
xzi := [toXn(CX, expand equn x, s) for x in zi for s in zsyms];
xzisorted := sort((a1:Xn(CX),a2:Xn(CX)):Boolean +-> qetaGrades a1 < qetaGrades a2, xzi)

xfn1 := xfn*first(xzisorted)
xfr1 := reduce(xfn1, ab)$QXREDn(CX)
assertEquals(removeDuplicates [order(series(first(xfr1)::Fn(CX), i), 9) for i in 1..#cusps], [9])

zero? xfr1

qpol := 183708000*(-(second(xfr1))::Pol(CX) + F*Z13)
sort variables qpol
#monomials qpol

zh := [x(1..#divs) for x in z.zhom];
hsyms := indexedSymbols("H", #zh)
xzh := [toXn(CX, expand equn x, s) for x in zh for s in hsyms];
xzhsorted := sort((a1:Xn(CX),a2:Xn(CX)):Boolean +-> qetaGrades a1 < qetaGrades a2, xzh)
[qetaGrades x for x in xzhsorted]

abh := samba(xzhsorted)$QXSAMBAn(CX);
xfhr1 := reduce(xfn1, abh)$QXREDn(CX)
assertTrue(zero? xfhr1)

-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
