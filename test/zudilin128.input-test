-- -*- coding: utf-8 -*-
-- Via jupytext this file can be shown as a jupyter notebook.

)read /home/hemmecke/g/qeta/input/jfricas-test-support.input

-- # Init

-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q
VZ ==> Vector Z
MZ ==> Matrix Z
NEGATE x ==> members(- vector x) -- negate all entries in a list
)set mess type off
)set mess time off
)read convenience.input )quiet
smallerCusp(x: Cusp, y: Cusp): Boolean ==
   infinity? x => false
   infinity? y => true
   denom x < denom y => true
   denom x > denom y => false
   numer x < numer y

--)set mess type on
--)set mess time on

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

-- # Zudilin: $f_{128}$ modular form of weight 4 for $\Gamma_0(128)$

-- +
-------------------------------------------------------------------
--test:Zudilin128
-------------------------------------------------------------------
-- -

-- ## Modular form of Zudilin
--
-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabi–Yau manifolds"
--
-- Below are the first few terms of $f_{128}$, which is a
-- modular form for $\Gamma_0(128)$ of weight 4.
--
-- It was not known whether this form can be expressed as
-- a sum of eta-quotients.
--
-- For our computations Zudilin provided the first 300 coefficients.

q := monomial(1,1)$A1(C)
f128 := q - 2*q^3 + 6*q^5 - 20*q^7 - 23*q^9 - 14*q^11 + 54*q^13 - 12*q^15 - _
  66*q^17 - 162*q^19 + 40*q^21 - 172*q^23 - 89*q^25 + 100*q^27 - 2*q^29 + _
  128*q^31 + 28*q^33 - 120*q^35 + 158*q^37 - 108*q^39 + 202*q^41 + _
  298*q^43 - 138*q^45 + 408*q^47 + 57*q^49 + 132*q^51 - 690*q^53 - 84*q^55 _
  + 324*q^57 + 322*q^59 - 298*q^61 + 460*q^63 + 324*q^65 - 202*q^67 + _
  344*q^69 + 700*q^71 - 418*q^73 + 178*q^75 + 280*q^77 - 744*q^79 + _
  421*q^81 + 678*q^83 - 396*q^85 + 4*q^87 - 82*q^89 - 1080*q^91 - 256*q^93 _
  - 972*q^95 - 1122*q^97 + 322*q^99 + 1390*q^101 - 788*q^103 + 240*q^105 - _
  1614*q^107 + 2014*q^109 - 316*q^111 - 542*q^113 - 1032*q^115 - _
  1242*q^117 + 1320*q^119 - 1135*q^121 - 404*q^123 - 1284*q^125 - _
  1712*q^127 - 596*q^129 + 2118*q^131 + 3240*q^133 + 600*q^135 - 486*q^137 _
  - 1286*q^139 - 816*q^141 - 756*q^143 - 12*q^145 - 114*q^147 - 2666*q^149 _
  - 172*q^151 + 1518*q^153 + 768*q^155 + 838*q^157 + 1380*q^159 + _
  3440*q^161 - 1346*q^163 + 168*q^165 + 1052*q^167 + 719*q^169 + _
  3726*q^171 + 38*q^173 + 1780*q^175 - 644*q^177 + 2790*q^179 - 3418*q^181 _
  + 596*q^183 + 948*q^185 + 924*q^187 - 2000*q^189 + 1968*q^191 - _
  1058*q^193 - 648*q^195 + 726*q^197 - 4116*q^199 + 404*q^201 + 40*q^203 + _
  1212*q^205 + 3956*q^207 + 2268*q^209 - 1482*q^211 - 1400*q^213 + _
  1788*q^215 - 2560*q^217 + 836*q^219 - 3564*q^221 + 896*q^223 + _
  2047*q^225 - 3410*q^227 + 4502*q^229 - 560*q^231 + 2302*q^233 + _
  2448*q^235 + 1488*q^237 - 4024*q^239 - 3586*q^241 - 3542*q^243 + _
  342*q^245 - 8748*q^247 - 1356*q^249 + 1250*q^251 + 2408*q^253 + _
  792*q^255 - 6638*q^257 - 3160*q^259 + 46*q^261 + 1724*q^263 - 4140*q^265 _
  + 164*q^267 + 4814*q^269 + 1640*q^271 + 2160*q^273 + 1246*q^275 + _
  3982*q^277 - 2944*q^279 + 4126*q^281 - 3446*q^283 + 1944*q^285 - _
  4040*q^287 - 557*q^289 + 2244*q^291 - 1514*q^293 + 1932*q^295 - _
  1400*q^297 - 9288*q^299

-- ## Relations in terms of the $M_i$'s

-- The generators of the eta-quotients of level 128 are given by
-- these exponents for the eta-functions (with arguments being the
-- divisors of 128). The variable `rgens` corresponds to the generators
-- of $R^\infty(128)$.

-- ### Find monoid basis for all eta-quotients modular for $\Gamma_0(128)$

level := 128;
rgens := etaQuotientMonoidExponentVectors(level)$QEQEV
rgensExpected: List List Z := [_
    [0, 0, 0, 0, - 1, 2, 1, - 2], [0, 0, 0, 0, 0, - 2, 6, - 4],_
    [0, 0, 0, - 2, 5, - 2, 1, - 2], [0, 0, 0, 2, - 1, 0, 1, - 2],_
    [0, - 2, 5, - 2, 0, 0, 1, - 2], [0, 2, - 1, 0, 0, 0, 1, - 2],_
    [0, 0, 0, - 1, 2, - 1, 4, - 4], [0, 0, - 2, 5, - 2, - 1, 4, - 4],_
    [0, 0, 2, - 1, 0, - 1, 4, - 4], [- 2, 5, - 2, 0, 0, - 1, 4, - 4],_
    [2, - 1, 0, 0, 0, - 1, 4, - 4], [0, 0, - 2, 4, 0, 0, 2, - 4],_
    [0, 0, 2, - 2, 2, 0, 2, - 4], [- 2, 5, - 2, - 1, 2, 0, 2, - 4],_
    [2, - 1, 0, - 1, 2, 0, 2, - 4], [0, 0, 0, - 1, 0, 5, 0, - 4],_
    [0, 0, - 2, 5, - 4, 5, 0, - 4], [0, 0, 2, - 1, - 2, 5, 0, - 4],_
    [- 2, 5, - 2, 0, - 2, 5, 0, - 4], [2, - 1, 0, 0, - 2, 5, 0, - 4],_
    [0, 0, 0, 0, - 4, 10, - 2, - 4], [- 2, 5, - 4, 5, - 2, 0, 2, - 4],_
    [2, - 1, - 2, 5, - 2, 0, 2, - 4], [0, 0, - 4, 10, - 4, 0, 2, - 4],_
    [- 2, 5, 0, - 1, 0, 0, 2, - 4], [2, - 1, 2, - 1, 0, 0, 2, - 4],_
    [- 4, 10, - 4, 0, 0, 0, 2, - 4], [4, - 2, 0, 0, 0, 0, 2, - 4]];
assertEquals(rgens, rgensExpected)

egens := [EQA1C r for r in rgens];
assertEquals([qetaGrade x for x in egens],_
  [6, 8, 8, 8, 8, 8, 11, 12, 12, 12, 12, 15, 15, 15, 15, 15, _
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])

-- ### Compute algebra basis

msyms := indexedSymbols("M", #egens)
xgens: List X1 C := [toX1(C, x, s) for x in egens for s in msyms];

-- We take a minimal (in terms of the pole-order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_{28}]$.

genus(level)$GAMMA0

tx: X1 C := xgens.1
abx := samba(tx, xgens, 9)$QXTOPSAMBA1(C)

assertEquals(genus(level)$GAMMA0, 9)
assertEquals(numberOfGaps(abx), 9)

-- Since the genus is equal to the number of gaps, we know by the
-- Weierstrass Gap Theorem that for the above algebra basis it holds
-- $$
-- M^\infty(128) = \langle 1, b_1, b_2, b_3, b_4, b_5 \rangle_{\mathbb{C}[t]}
-- $$
-- where $t=M_1$,
-- $b_1=M_6 M_7$, $b_2=M_6$, $b_3=M_{16}$, $b_4=M_{27}$, $b_5=M_7$.

-- ### Find cofactor for $f_{128}$

-- We try to compute an eta-quotient cofactor of weight -4
-- such that the product with $f_{128}$ will be
-- a modular function in $M^\infty(128)$.

divs := DIVISORS level;
idivs := [i for i in 1.. #divs-1];
wght := 4
rwgens := etaQuotientExponentVectors(level, idivs, -2*wght)$QEQEV

rfcofactor := rwgens.1;
assertEquals(rfcofactor,[0, 0, 0, 0, 0, 0, 8, - 16])
fcofactor := EQA1C rfcofactor

fcofactors := [EQA1C r for r in rwgens];
assertEquals([qetaGrade x for x in fcofactors], [64])

-- ### Express $f$ in terms of algebra basis

-- In the following, we will deal with the modular function
-- $f \in M^\infty(128)$.

f := f128 * fcofactor;
xf := toX1(C, f, 'F)
xfr := reduce(xf, abx)$QXTOPRED1(C)
assertTrue(zero? xfr)

assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

coeff := coefficient(second(xfr)::Pol(C), 'F, 1)
ixfr := 1/coeff * xfr;
fmpol := second(-ixfr)::Pol(C) + 'F  -- This corresponds to the mod func f.

assertEquals(fmpol, (_
    (-2*M1^7-24*M1^6+8*M1^5-56*M1^4+336*M1^3+368*M1^2+256*M1)*M6+2*M1^8_
     -56*M1^7+12*M1^6-128*M1^5+400*M1^4+704*M1^3-224*M1^2-1024*M1-1024)*M7_
    +(M1^8-20*M1^7+48*M1^6-136*M1^5+96*M1^4+288*M1^3+160*M1^2+64*M1-64)*M16)

-- ### Express in quotients of eta-functions

f128mpol := M0*fmpol -- Corresponds to the original f128.
assertEquals(# monomials f128mpol, 25)

-- We convert the polynomial in the Mi into a Laurent polynomial in
-- the Ei variables.

esyms := indexedSymbols("E", divs)
dim: N := #esyms   -- needed for RZ

m0symsRZ := cons(monRZ NEGATE rfcofactor, [monRZ x for x in rgens]);
m0syms := cons('M0, msyms);

-- The following gives $f_{128}$ in terms of eta-quotients

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

-- The Laurent polynomial (in Ei variables) that belongs to f.

fpolRZ := EVALRZ(m0syms, m0symsRZ, fmpol);
z := rzToA1C fpolRZ - f

-- The function z is a modular function, so we only need to check the
-- coefficients of the negative exponents.

assertTrue(zero? z)

-- But we kill all the given coefficients for $f_{128}$.

assertEquals(order(z, 300), 237)

-- Show nicely.
-- Find common denominator

minEntries(x: DZ, y: DZ): DZ == (_
    directProduct vector [min(x.i, y.i) for i in 1..#x]);

fmonsDZ := [degree mon for mon in monomials fpolRZ];

fdenDZ := - reduce(minEntries, fmonsDZ, 0$DZ)$List(DZ);
assertEquals(fdenDZ::VZ, vector [0,0,1,1,8,1,0,20])

fdenRZ := monomial(1, fdenDZ)$RZ;
rez(fpolRZ * fdenRZ)
rez fdenRZ

-- Now we do the same thing for the modular form $f_{128}$ itself.

f128polRZ := EVALRZ(m0syms, m0symsRZ, f128mpol);
f128monsDZ := [degree mon for mon in monomials f128polRZ];
f128denRZ := monomial(1, - reduce(minEntries, f128monsDZ, 0$DZ)$List(DZ))$RZ;
z0 := rzToA1C f128polRZ - f128
assertEquals(order(z0, 301), 301)

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.

assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])

-- We have found a representation of $f_{128}$ as a sum
-- of $25$ eta-quotients.

assertEquals(#monomials(rez f128polRZ), 25)

-- Show nicely

num0 := rez (f128polRZ * f128denRZ)
den0 := rez(f128denRZ)

-- ## Mail from Zudillin 17-Feb-2020:

brunaultterms := [_
  [   1, 2, 1,3, 3,-1,0,0,0],_
  [   2, 0, 2,3, 2, 1,0,0,0],_
  [   8, 0, 0,2, 2, 2,2,0,0],_
  [ -24, 0, 0,2, 0, 2,4,0,0],_
  [ -16, 0, 2,1, 2,-1,0,4,0],_
  [ -64, 0, 0,0, 1, 2,3,2,0],_
  [  32, 0, 0,0,-1, 2,5,2,0],_
  [ -32, 0, 0,4, 1,-1,1,1,2],_
  [ -64, 0, 0,0, 1, 3,1,1,2],_
  [-256, 0, 0,0,-1, 3,3,1,2],_
  [ 128, 0, 0,2, 0,-1,2,3,2],_
  [-256, 0, 0,4,-1, 0,1,0,4],_
  [-128, 0, 0,0,-1, 4,1,0,4],_
  [-512, 0, 0,2, 0, 0,0,2,4]_
 ];

# brunaultterms

f128brunault := rzToA1C polyRZ brunaultterms
z := f128brunault - f128
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])

-- ## Finding other symmetry group for $f_{128}$

-- In my relation for $f_{128}$, $\eta(\tau)$ does not occur.
-- That suggests that $f_{128}$ is not only a modular form for
-- $\Gamma_0(128)$, but for the supergroup $\Gamma_0(64)$.

f128monsDZ

assertEquals([x.1 for x in f128monsDZ], [0 for i in 1..25])

spitzen := sort(smallerCusp, cusps(level)$GAMMA0)
oo ==> infinity()$Cusp
c(n: Z, q: Q): Cusp ==
  q = 1/n => oo
  one? q => cusp(0, 1)$Cusp
  cusp(numer q, denom q)$Cusp
ex := [1,1/2,1/4,3/4,1/8,3/8,5/8,7/8,1/16,3/16,5/16,7/16,1/32,3/32,1/64,1/128]
assertEquals(spitzen, [c(level,x) for x in ex])

o := reduce(_+, [WIDTH0(level, cusp) for cusp in spitzen])
assertEquals(o, index(level)$GAMMA0)

-- The index of $\Gamma_0(128)$ in $\mathrm{SL}_2(Z)$ is equal
-- to the number of coset rright representatives,

reps := rightCosetRepresentatives(level)$GAMMA0;
assertEquals(# reps, o)

-- ## Experiment with other cofactor

-- Since we know a representation of $f$ as a sum of eta-quotients,
-- we can apply the transformation formulas for eta-quotiens and
-- thus easily compute the expansion of $f$ at all cusps of
-- $\Gamma_0(128)$.
--
-- The expansion potentially involves roots of unity.
-- In our case a 3072-th root of unity (encoded by $\xi$) is enough.

xiord := 24*level
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

)set stream calc 2

-- Here we see the expansion of $f \in M^\infty(128)$ at all cusps.

fA128 := rzToAnCX fpolRZ

-- Adjust $f$ to other cofactor so that the product is a modular function
-- with poles at posssibly any cusp (**not** only at infinity).

divs := DIVISORS level;
idivs := empty()$List(Z);
z := zsolve4ti2(level, idivs, concat([0 for i in idivs], -2*wght))$QEQEV;
rgcofactor := members((z.zinhom.1)(1..#divs));
assertEquals(rgcofactor, [0,-16,8,0,0,0,0,0])

z

gpolRZ := f128polRZ * monRZ(rgcofactor);
gA128 := rzToAnCX gpolRZ

-- **Note:**
-- $g$ has series expansion of the form `q*series(q^2)` at every cusp.

assertEquals(qetaGrades gA128, [31,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1])

-- # Find cofactor to bring $f_{128}$ into $M^\infty(64)$

-- Try to find another cofactor `rhcofactor` such that the respective
-- series `hA128` is, in fact a modular function for $\Gamma_0(64)$. So
-- let's multiply with another nice eta-quotient that brings it to
-- $M^\infty(64)$.

idivs := [1,2,3,4,5,6];

-- Note that we look for an approprivate eta-quotient that does not
-- involve $\eta(128\tau)$, i.e., the first argument is 64.

z := zsolve4ti2(64, idivs, concat([0 for i in idivs], [-2*wght,0,12]))$QEQEV;
z.zinhom

-- The above command solved the following integer problem.

(matrixLigozatModularGamma0(64, idivs)$QETAAUX)::OF * 'z = _
  (transpose matrix [concat([0 for i in idivs], [-2*wght,0,12,0])])::OF

-- We consider the resulting vectors as eta-quotient exponent vectors
-- where the entry for $\eta_{128}$ is equal to zero.

liftTo128(vs: List Vector Z): List List Z == (_
    n := # DIVISORS 128;_
    [(v := copy x(1..n); v.n := 0; v) for x in vs]);

-- We lift the inhomogeneous as well as the homogeneous
-- solution vectors.

zzi := liftTo128 z.zinhom;
assertEquals(zzi,[_
  [0, 0, 0, 2, -2, 12, -20, 0], [0, 0, 0, 0, 4, 8, -20, 0],_
  [0, -2, 5, 0, -1, 10, -20, 0], [0, 2, -1, 2, -1, 10, -20, 0]])
assertEquals([qetaGrade EQA1C r for r in zzi], [38, 40, 40, 40])

zzh := liftTo128 z.zhom;
assertEquals(zzh, [_
  [0, 2, -1, 0, -1, 4, -4, 0], [0, -2, 5, -4, 5, 0, -4, 0],_
  [0, 0, 0, -4, 10, -2, -4, 0], [0, -4, 10, -4, 0, 2, -4, 0],_
  [0, 0, 0, 0, -2, 6, -4, 0], [0, -2, 5, -2, -1, 4, -4, 0],_
  [2, -1, 0, 0, 0, 1, -2, 0], [-2, 5, -2, 0, 0, 1, -2, 0],_
  [0, 0, 2, -1, 0, 1, -2, 0], [0, 2, -1, -2, 5, 0, -4, 0],_
  [0, 0, -2, 5, -2, 1, -2, 0], [0, 0, 0, -1, 2, 1, -2, 0]])

-- The order of the expansion at the cusps $\frac{1}{64}$ and $\frac{1}{128}$.

[qetaGrades(EQAnCX r)(15..16) for r in zzh]

zzf := liftTo128 z.zfree
assertEquals(zzf, [])

-- We adjust the first inhomogeneous solution with a
-- homogeneous solution in order to get a new cofactor.

rhcofactor := liftTo128([z.zinhom.1 - z.zhom.12]).1
assertEquals(rhcofactor, [0, 0, 0, 3, - 4, 11, - 18, 0])

hpolRZ := f128polRZ * monRZ(rhcofactor)
#monomials hpolRZ
assertEquals(level, 128)
hA128 := rzToAnCX hpolRZ

-- According to the orders of the expansions at all cusps,
-- `hA128` corresponds to a modular function in $M(128)$ that
-- only has poles at the cusps $1/64$ and $1/128$.

assertEquals(qetaGrades hA128, _
  [-2, -2, -2, -2, -2, -2, -2, -2, 0, 0, 0, 0, -2, -2, 34, 34])

-- `hA128` has expansions at the cusps of 128 that have the following form.

for cusp in spitzen for i in 1..#spitzen repeat _
    print([cusp, WIDTH0(128, cusp)/WIDTH0(64, cusp), series(hA128, i)]);

-- That is, if the quotient of the widths is 2, then the series is a
-- series in $q^2$.
-- In particular the series expansions for the cusp $1/64$ agrees with
-- the series expansion of the cusp $1/128$ ($=\infty$).

[spitzen.15, spitzen.16]
z := series(hA128, 15) - series(hA128, 16)
assertEquals(order(z, 100), 100)

-- # Reduction of expansion of $h$ in $M(64)$

-- ## Reduction of $h$ by algebra basis of $M^\infty(64)$

-- Let us consider the expansion of `h := series(hA128, 16)`, i.e.,
-- the expansion of the modular function at $\infty$, and try to
-- reduce it by the algebra basis of eta-quotients in $M^\infty(64)$.

hx := series(hA128, 16);
h := abfmap(CX, C, retract, hx)::A1(C)

-- Now we want to compute in $M^\infty(64)$, i.e. modular function for
-- $\Gamma_0(64)$.

-- Note that in constrast to the series $f$ (with pole order 65),
-- we now have to deal only with a series of pole order 34.
-- Therefore, we can expect that the redcution by the algebra
-- basis involves fewer reduction steps.

-- ### Find monoid basis for all eta-quotients modular for $\Gamma_0(64)$

level := 64;
rgens64 := etaQuotientMonoidExponentVectors(level)$QEQEV;
assertEquals(rgens64, [_
  [0, 0, 0, -1, 2, 1, -2], [0, 0, 0, 0, -2, 6, -4],_
  [0, 0, -2, 5, -2, 1, -2], [0, 0, 2, -1, 0, 1, -2],_
  [-2, 5, -2, 0, 0, 1, -2], [2, -1, 0, 0, 0, 1, -2],_
  [0, -2, 5, -2, -1, 4, -4], [0, 2, -1, 0, -1, 4, -4],_
  [0, -2, 5, -4, 5, 0, -4], [0, 2, -1, -2, 5, 0, -4],_
  [0, 0, 0, -4, 10, -2, -4], [0, -4, 10, -4, 0, 2, -4]])

egens64 := [EQA1C r for r in rgens64]
[qetaGrade x for x in egens64]

-- ### Compute algebra basis

usyms64 := indexedSymbols("U", #rgens64)
xgens64 := [toX1(C, x, sy) for x in egens64 for sy in usyms64]

tx64 := first xgens64
abx64 := samba(tx64, xgens64)$QXTOPSAMBA1(C)

-- We have found an algebra basis for $M^\infty(64)$.

assertEquals(numberOfGaps(abx64), 3)
assertEquals(genus(64)$GAMMA0, 3)

-- ### Reduce $h$ by algebra basis

-- The $h$ that we constructed was $f_{128}$ multiplied by a
-- certain eta-quotient cofactor
-- (given by the exponent vector `rhcofactor`)
-- to bring it into $M^\infty(64)$.
--
-- Clearly, we should be able to reduce that series to zero
-- modulo the algebra basis that we have just computed.

xh := toX1(C, h, 'H)
xhr := reduce(xh, abx64)$QXTOPRED1(C)
assertTrue(zero? xhr)
cxhr := [qetaCoefficient(first(xhr)::A1(C), -i) for i in -5..100];
assertEquals(removeDuplicates cxhr, [0])

haupol := 8192 * second(xhr)::PolC + 'H
assertEquals(# monomials haupol, 23)

assertEquals(haupol,_
  (U1^10-20*U1^8-24*U1^6-128*U1^4-512*U1^2+2048)*U5_
 +(-2*U1^8-36*U1^6+208*U1^4-224*U1^2+1024)*U11_
 -2*U1^11+4*U1^10+40*U1^9+56*U1^8+48*U1^7+368*U1^6+256*U1^5-1024*U1^4_
   +1024*U1^3+2048*U1^2-4096*U1-8192)

-- We have found a relation for $f_{128}$ with only
-- 23 eta-quotients from $M^\infty(64)$ (in contrast to
-- the 25 eta-quotients for $f$).
--
-- We have still not beaten the result of Brunault.

-- The following is the exponent vector that was multiplied
-- to $f_{128}$ to bring it into $M^\infty(64)$.

rhcofactor

-- ### Representation

-- We must append a zero to the rgens64 vectors, because we do evaluation
-- into a domain that contains an entry for E128.

rgens64x := [concat(x, 0) for x in rgens64];
u0syms64 := cons('U0, usyms64)
u0syms64RZ := cons(monRZ NEGATE rhcofactor, [monRZ x for x in rgens64x]);

hapolRZ := EVALRZ(u0syms64, u0syms64RZ, haupol);
rez hapolRZ

assertTrue(zero?(h - rzToA1C hapolRZ))

-- Here comes the representation for $f_{128}$ as a sum
-- of eta-quotients.

ha128upol := U0 * haupol;
ha128polRZ := EVALRZ(u0syms64, u0syms64RZ, ha128upol);
rez ha128polRZ

-- ### Safety check against original terms of $f_{128}$

-- Indeed, if we replace the $E_i$ by the respective
-- eta-function we get he following.

z0 := rzToA1C ha128polRZ - f128
assertEquals(order(z0, 301), 301)

-- We computed a common denominator.

ha128monsDZ := [degree mon for mon in monomials ha128polRZ];
ha128denRZ := monomial(1, - reduce(minEntries, ha128monsDZ, 0$DZ)$List(DZ))$RZ

num0 := rez (ha128polRZ * ha128denRZ)
den0 := rez(ha128denRZ)

-- ## Partial manual reduction of $h$ by eta-quotients from $M^\infty(64)$

-- Up to now we have represented $f_{128}$ or rather
-- $h$ by eta-quotients with the following exponents.
--
-- Note that $\eta(128\tau)$ is not involved, therefore it is an
-- element of $M(64)$, in fact, even in $M^\infty(64)$.

hapolRZ

-- We introduce now `haA64` as the expansions of an element of
-- $M^\infty(64)$ given by `hapolRZ`.

level := 64; spitzen := sort(smallerCusp, cusps(level)$GAMMA0);
egens64n := [EQAnCX r for r in rgens64];
xgens64n := [toXn(CX, x, sy) for x in egens64n for sy in usyms64];
u := egens64n;
assertEquals(level, 64)
haA64 := rzToAnCX hapolRZ;
qetaGrades(haA64)

-- ### "Reduction" by inspection

-- Let us look at the pole orders of $h_a$ and all the
-- generators of the monoid of eta-quotient of $M^\infty(64)$.

l := [qetaGrades x for x in u];
hal := cons(qetaGrades haA64, l);
matrix hal

-- Obviously, our choice for the cofactor was not optimal.
-- It is now quite easy to bring the pole order down to 26
-- without doing any reduction of the series.

k0A64 := haA64/(u.4*u.3);
qetaGrades(k0A64)

-- But we can do a little better.
-- Unfortunately, we introduce poles at other cusps.

qetaGrades(u.4*u.3*u.1^2)
kA64 := haA64/(u.4*u.3*u.1^2);
qetaGrades(kA64)
spitzen

-- We have poles at $\frac{1}{16}$, $\frac{3}{16}$, and $\infty$.

-- Let us keep track of the cofactor to $f_{128}$ so that
-- $k\in M(64)$ (with poles at any cusp).

v := vgens64x := [vector r for r in rgens64x];
rkcofactor := members(vector rhcofactor - v.4 - v.3 - 2*v.1);
assertEquals(rkcofactor, [0,0,0,1,-6,7,-10,0])

-- Let us take a closer look at the expansion at the
-- cusps that correspond to poles.

-- +
ixs := [9,10,12];
LCi(x, idxs) ==> [leadingCoefficient(series(x, i)) for i in idxs]
LMi(x, idxs) ==> [leadingMonomial(series(x, i)) for i in idxs]
LC(x) ==> LCi(x, ixs)
LM(x) ==> LMi(x, ixs)

lmu := [LM x for x in u];
for x in lmu for i in 1.. repeat print([i, x])
-- -

LM kA64

-- Fortunately, we can find an eta-quotient, that equals
-- the leading monomials of the 3 series that correspond
-- to poles.

mon1 := u.7*u.12^3/(u.3*u.1^2);
umon1 := U7* U12^3 * V3* V1^2;
qetaGrades mon1
LM mon1

-- Subtraction then brings down to the sum of
-- poles over all cusps by 2.
-- However, we now have poles at other cusps.

k1A64 := kA64 - mon1;
qetaGrades(k1A64)
ixs := [4,5,6,7,12]
LM k1A64

-- However, we are lucky again, since we can find another
-- eta-quotient that simultaneously has the same leading
-- monomials for all 5 cusps with poles.
--
-- This subtraction brings down the sum of poles over all
-- cusps by 6.

mon2 := -16*u.8^3*u.2/u.3;
umon2 := -16*U8^3* U2* V3;
qetaGrades(mon2)
LM mon2
k2A64 := k1A64 - mon2;
qetaGrades k2A64
)set stream calc 2
series(k2A64,12)

mon3 := -172*u.2^4;
umon3 := -172*U2^4;
qetaGrades(mon3)
k3A64 := k2A64 - mon3;
qetaGrades k3A64
series(k3A64,12)

-- Now we reduce the remaining series by the algebra basis.

k3 := series(k3A64,12)::A1(C)
xk3 := toX1(C, k3, 'K3)
xk3r := reduce(xk3, abx64)$QXTOPRED1(C)
assertTrue(zero? xk3r)
cxk3r := [qetaCoefficient(first(xk3r)::A1(C), -i) for i in -5..100];
assertEquals(removeDuplicates cxk3r, [0])

k3upol := -1472*second(reduce(xk3, abx64)$QXTOPRED1(C))::PolC + 'K3
assertEquals(# monomials k3upol, 9)

vsyms64 := indexedSymbols("V", #rgens64);
vsyms64RZ := [monRZ NEGATE x for x in rgens64x];
EV64RZ x ==> EVALRZ(concat[u0syms64,   vsyms64],_
                    concat(u0syms64RZ, vsyms64RZ), x)

-- ### Yields representation for $f_{128}$ with only 12 summands

-- Adding the monomials that we subtracted earlier, gives
-- a representation for $k$ (and therefore also for $f_{128}$
-- with only 12 terms.

kpolRZ := EV64RZ(k3upol + umon1 + umon2 + umon3)
# monomials kpolRZ

z0 := rzToA1C kpolRZ - series(kA64,12)
assertEquals(order(z0, 301), 301)
rez kpolRZ
# monomials kpolRZ

z0 := rzToAnCX kpolRZ - kA64
zero? z0

-- We have found a sum of 9+3=12 eta-quotients for $f_{128}$.

-- ## Manual reduction of `kA64` by eta-quotients from $M^\infty(64)$

-- We can do even better, if we do not reduce by the
-- algebra basis, but rather select appropriate
-- eta-quotients for the reduction ourselves.
--
-- Up to $k_3$ we do the same as in the previous section.

abx64

mon4 := -112*u.2^2*u.8;
umon4 := -112*U2^2*U8;
qetaGrades(mon4)
k4A64 := k3A64 - mon4;
qetaGrades k4A64
series(k4A64,12)

mon5 := -592*u.2^3;
umon5 := -592*U2^3;
series(mon5,12)
qetaGrades(mon5)
k5A64 := k4A64 - mon5;
qetaGrades k5A64
series(k5A64,12)

mon6 := -544*u.2*u.7;
umon6 := -544*U2*U7;
qetaGrades(mon6)
k6A64 := k5A64 - mon6;
qetaGrades k6A64
[coefficient(series(k6A64,12), i) for i in -8..8]

mon7 := 320*u.2^2;
umon7 := 320*U2^2;
qetaGrades(mon7)
k7A64 := k6A64 - mon7;
qetaGrades k7A64
[coefficient(series(k7A64,12), i) for i in -6..6]
LM k7A64

mon8 := -128*u.7;
umon8 := -128*U7;
qetaGrades(mon8)
k8A64 := k7A64 - mon8;
qetaGrades k8A64
[coefficient(series(k8A64,12), i) for i in -4..6]
LM k8A64

mon9 := -448*u.2;
umon9 := -448*U2;
qetaGrades(mon9)
k9A64 := k8A64 - mon9;
qetaGrades k9A64
[coefficient(series(k9A64,12), i) for i in -4..30]
k9A64

-- In a more compact form here is what we have just
-- computed.

-- +
z := kA64 _
     - u.7*u.12^3/(u.3*u.1^2)_
     + 16*u.8^3*u.2/u.3_
     + 172*u.2^4_
     + 112*u.2^2*u.8_
     + 592*u.2^3_
     + 544*u.2*u.7_
     - 320*u.2^2_
     + 128*u.7_
     + 448*u.2_
     + 64 * 1$An(CX)

zero?(z)
qetaGrades(z)
-- -

-- Clearly, this is a sum for $f_{128}$ consisting of
-- only 10 eta-quotients.
--
-- The variable `kA64` was given by the polynomial `kpolRZ`.
--
-- The `u.i` were given by the `rgens64` variable, i.e.,
-- the exponents for the generators of the monoid of
-- eta-quotients. For technical reasons we must append a 0 to
-- these vectors.
-- These are the vectors given by `rgens64x`.
--
-- Thus, we find a new polynomial with 10 instead of 12 terms.

kaupol := umon1 + umon2 + umon3 + umon4 + umon5_
        + umon6 + umon7 + umon8 + umon9 - 64
kapolRZ := EV64RZ kaupol
# monomials kapolRZ

kaA64 := rzToAnCX kapolRZ
qetaGrades(kaA64)

z0 := kaA64 - kA64
assertTrue(zero? z0)
[order(series(z0,i),100) for i in 1..12]

ka128polRZ := kapolRZ * monRZ(NEGATE rkcofactor)
assertEquals(# monomials ka128polRZ, 10)
rez ka128polRZ

z0 := f128 - rzToA1C ka128polRZ
cs := [coefficient(z0, i) for i in 1..300];
assertEquals(removeDuplicates cs, [0])

-- Check that `kaA64` (or rather the expansion of
-- the modular function corresponding to
-- `kapolRZ` at every cusp of $\Gamma_0(128)$)
-- agrees with `fA128` (after multiplication
-- with the respective eta-quotient).

level:=128; spitzen:=sort(smallerCusp, cusps(level)$GAMMA0);
rkfadjust := members(vector rfcofactor - vector rkcofactor);
assertEquals(rkfadjust, [0,0,0,-1,6,-7,18,-16])
z0 := fA128 - rzToAnCX(kapolRZ * monRZ rkfadjust);
ords := [order(series(z0, i), 50) for i in 1 .. maxIndex()$An(CX)];
assertEquals(removeDuplicates ords, [50])

-- ## Reduction with other algebra basis

-- Interestingly, the algebra basis is so simple that we can try
-- another $t$. This time with pole order 4 instead of 3.
-- Choosing also the input elements carefully, leads to a
-- algebra basis (in fact an integral basis for $M^\infty(64)$)
-- that look like Laurent-series-in-$q^2$, or
-- $q$-times-Laurent-series-in-$q^2$.

)set stream calc 10
xgens64

abxx64 := samba(xgens64.2, [xgens64.1, xgens64.7])$QXTOPSAMBA1(C)
numberOfGaps(abxx64) = genus(64)$GAMMA0

-- So we only need to do the first two reductions
-- manually and can then employ the algebra basis
-- reduction to do the rest.

kb2 := series(k2A64,12)::A1(C);
xkb2 := toX1(C, kb2, 'KB2)

-- Reduction of the series `xkb2` then ends in zero
-- as expected.

xkb2r := reduce(xkb2, abxx64)$QXTOPRED1(C);
assertTrue(zero? xkb2r)
cxkb2r := [qetaCoefficient(first(xkb2r)::A1(C), -i) for i in -5..100];
assertEquals(removeDuplicates cxkb2r, [0])

-- It also yields a polynomial for the representation of
-- $f_{128}$ that also has only 10 terms.

second(xkb2r)::Pol(C)
kbupol := (64 * second(xkb2r)::Pol(C)) + 'KB2::Pol(C) + umon1 + umon2
assertEquals(kbupol,_
             (U12^3*U7*V1^2-16*U2*U8^3)*V3_
            +(-112*U2^2-544*U2-128)*U7_
            -172*U2^4-144*U2^3+320*U2^2-448*U2-64)
assertEquals(# monomials kbupol, 10)
kbpolRZ := EV64RZ kbupol;
rez kbpolRZ

-- It differs only by a zero expression, i.e.,
-- a relation among eta-quotients.

level:=128; spitzen:=sort(smallerCusp, cusps(level)$GAMMA0);
rzToAnCX(kapolRZ - kbpolRZ)
rez(1/112*(kapolRZ - kbpolRZ))

level:=64; spitzen:=sort(smallerCusp, cusps(level)$GAMMA0);
kbA64 := rzToAnCX kbpolRZ;
kaA64-kbA64

-- # Try to reduce in $M^\infty(64)$

-- By working in $M(64)$,
-- we have derived a sum of 10 eta-quotients of
-- a modular (for $\Gamma_0(64)$) function
-- `kaA64` corresponding to $f_{128}$.
--
-- Note that `kaA64 * u.1^2` was still in
-- $M^\infty(64)$.
--
-- The reduction involved a subtraction by `mon1`
-- and `mon2` that are not in $M^\infty(64)$.

qetaGrades(kA64*u.1^2)

[qetaGrades(mon1), umon1]
[qetaGrades(mon2), umon2]

-- By multiplication of the whole relation by `U1^2*U3`
-- (note that `Vi` corresponds to the inverse of `Ui`),
-- we can give a relation that lives completely in
-- $M^\infty(64)$.

)set mess typ on
ru := rule
        U1*V1==1
        U3*V3==1

EXZ ==> Expression Z
kcupol := eval((U1^2*U3*kaupol)::EXZ, [V1::EXZ=(1/U1)::EXZ, V3::EXZ=(1/U3)::EXZ])::Pol(Z);
monomials kcupol

v := [vector r for r in rgens64x];
ricofactor := members(vector rkcofactor + 2*v.1 + v.3)

)set stream calc 2
ipolRZ := ka128polRZ * monRZ(ricofactor);
iA64 := rzToAnCX ipolRZ;
assertEquals(qetaGrades iA64,  [0,0,0,0,-1,-1,-1,-1,0,0,-2,30])

z0 := iA64_
      -                             u.7       * u.12^3_
      + 16  * u.1^2 * u.2 * u.8^3_
      + 172 * u.1^2 * u.2^4 * u.3_
      + 112 * u.1^2 * u.2^2 * u.3       * u.8_
      + 592 * u.1^2 * u.2^3 * u.3_
      + 544 * u.1^2 * u.2   * u.3 * u.7_
      - 320 * u.1^2 * u.2^2 * u.3_
      + 128 * u.1^2 * u.3         * u.7_
      + 448 * u.1^2 * u.2   * u.3_
      + 64  * u.1^2         * u.3
assertTrue(zero?(z0))

-- +
)set stream calc 15
SER x ==> series(x,12)
SER iA64
z := SER(iA64_
        -                             u.7       * u.12^3_
        + 16  * u.1^2 * u.2 * u.8^3_
        + 172 * u.1^2 * u.2^4 * u.3_
        + 112 * u.1^2 * u.2^2 * u.3       * u.8_
        + 592 * u.1^2 * u.2^3 * u.3_
        + 544 * u.1^2 * u.2   * u.3 * u.7_
        - 320 * u.1^2 * u.2^2 * u.3_
        + 128 * u.1^2 * u.3         * u.7_
        + 448 * u.1^2 * u.2   * u.3_
        + 64  * u.1^2         * u.3_
  )

assertEquals(removeDuplicates [coefficient(z,i) for i in -10..300], [0])
assertTrue(zero?(z::A1(C)))

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
-- -

-- # === THIS IS THE END ===

-- # Express $1/\eta(64\tau)$ as sum of eta-quotients

level := 64; spitzen := cusps(level)$GAMMA0;
QEtaIdeal ==> QEtaIdealHemmeckeCached
elig64 := etaLaurentIdealGenerators(level)$QEtaIdeal(C)

e64:=E64::Pol(C);
y64:=Y64::Pol(C);
z64:=Z64::Pol(C);
elig64e := eval(elig64,e64=z64);
elig64y := eval(elig64e,y64=e64);
elig64z := eval(elig64y,z64=y64);

)set me time on

er64z := etaRelations(level, elig64z)$QEtaIdeal(C);

#er64z







-- # Try to solve holomorphic matrix

level:=64; spitzen:=cusps(level)$GAMMA0;
divs := DIVISORS level
idivs := [i for i in 1..#divs]
wght

zmodform := zsolve4ti2(level, idivs, concat([0 for i in idivs], 2*wght))$QEQEV;

vdivs := vector(divs)$VZ -- part of the Ligozat matrix that gives the order
zmodformzi := [members x(1..ndivs) for x in zmodform.zinhom]
assertEquals(#zmodformzi, 40)
wght







-- # Experiment with $M(32)$

-- Looking more closely at the expression `kapolRZ`,
-- we realize that it does no involve $\eta(\tau)$.
-- This suggests that there might be a relation for $f_{128}$
-- involving only
-- $\eta(\delta\tau)$ for $\delta\in\{1,2,4,8,16,32\}$.

--setFormats!([Format1D,FormatMathJax])$JFriCASSupport
setFormats!([FormatMathJax])$JFriCASSupport

level:=32; spitzen:=cusps(level)$GAMMA0;
rgens32 := etaQuotientMonoidExponentVectors(level)$QEQEV;
egens32 := [EQA1C r for r in rgens32];
rsyms32 := indexedSymbols("R", #egens32)

xgens32: List X1 C := [toX1(C, x, sy) for x in egens32 for sy in rsyms32]
gen := genus(level)$GAMMA0
tx32: X1 C := xgens32.1
abex2 := samba(tx32, xgens32, gen)$QXTOPSAMBA1(C)

kahalfpolRZ := reduce(_+, [leadingCoefficient x * monRZ concat(rest members degree x,0) for x in monomials kapolRZ]);

level:=32; spitzen:=cusps(level)$GAMMA0;
egens32n := [EQAnCX r for r in rgens32];
xgens32n := [toXn(CX, x, sy) for x in egens32n for sy in rsyms32];
u := egens32n;

)set stream calc 2

kahalfA32 := rzToAnCX kahalfpolRZ;
qetaGrades(kahalfA32)
cusps(level)$GAMMA0

kahalfA32

l := [qetaGrades x for x in u];
kahalfl := cons(qetaGrades kahalfA32, l);
matrix kahalfl

z := kahalfA32 * u.4 / u.1;
z := u.5*u.6*u.8/u.2
qetaGrades z
LM z

LM kahalfA32

ixs := [5,6,7,8]
lmu := [LM x for x in u];
for x in lmu for i in 1.. repeat print([i, x])

z1 := EV64RZ(umon1)
z1 := reduce(_+, [leadingCoefficient x * monRZ concat(rest members degree x,0) for x in monomials z1])
z2 := rzToAnCX z1
LM z2
LM kahalfA32

--







for cusp in spitzen for i in 1..#spitzen repeat _
    print([cusp, WIDTH0(64, cusp)/WIDTH0(32, cusp), series(kaA64, i)]);

for cusp in spitzen for i in 1..#spitzen repeat _
    print([cusp, WIDTH0(64, cusp)/WIDTH0(32, cusp), series(kbA64, i)]);

-- That is, if the quotient of the widths is 2, then the series is a
-- series in $q^2$.
-- In particular the series expansions for the cusp $1/64$ agrees with
-- the series expansion of the cusp $1/128$ ($=\infty$).







-- # Experiment: $M^\infty(32)$

level:=128; spitzen:=cusps(level)$GAMMA0;
rfkadjust := members(vector rkcofactor - vector rfcofactor);
assertEquals(rfkadjust, [0,0,0,1,-6,7,-18,16])
fkmonRZ := monRZ rfkadjust;
z1 := rzToAnCX(fpolRZ * fkmonRZ);
z2 := rzToAnCX kapolRZ;
z := z1 - z2
ords := [order(series(z, i), 100) for i in 1 .. maxIndex()$An(CX)];
assertEquals(removeDuplicates ords, [100])

level := 2;
rgens2 := etaQuotientMonoidExponentVectors(level)$QEQEV;
egens2 := [EQA1C r for r in rgens2];
msyms2 := indexedSymbols("M", #egens2)

xgens2: List X1 C := [toX1(C, x, s) for x in egens2 for s in msyms];
gen := genus(level)$GAMMA0
tex2: X1 C := xgens2.1
abex2 := samba(tex2, xgens2, gen)$QXTOPSAMBA1(C)

divs := DIVISORS level
idivs := [i for i in 1.. #divs-1];
wght := 4
rwgens2 := etaQuotientExponentVectors(level, idivs, -2*wght)$QEQEV;
rcofactorx2 := rwgens2.1

matLR := matrixLigozatModularGamma0(128,[1,2,3,4,5,6,7])$QEtaAuxiliaryPackage;
rcofactorx := concat(rcofactorx2, [0 for i in 1..8-#divs])
radjustx := members(vector rcofactorx - vector rcofactor3)

level:=128; spitzen:=cusps(level)$GAMMA0;
modularGamma0?(level, radjustx)
monadjustx := monRZ radjustx

)set stream calc 1
fadjustx := rzToA1C monadjustx

qetaGrades(fadjustx)

fcofactor := EQA1C rcofactor
f := f128 * fcofactor;

xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertTrue(zero? xfr)

level
kpolRZ













z := zsolve4ti2(32, [1,2,3,4,5], [0,0,0,0,0, -2*wght,0,12])$QEQEV

z := zsolve4ti2(16, [1,2,3,4], [0,0,0,0, -2*wght,0,12])$QEQEV

z := zsolve4ti2(2, [1], [0,-2*wght])$QEQEV



matLR := matrixLigozatModularGamma0(128,[1,2,3,4,5,6,7])$QEtaAuxiliaryPackage;
r2 := members(matLR * vector [8,-16,0,0,0,0,0,0,0,0,0])

[positiveRemainder(x,24) for x in r2]



-- # TODO: Is every eta-quotient in the sum holomorphic?

level := 128; spitzen := cusps(level)$GAMMA0

)set mess typ on
monsRZ := [EV64RZ x for x in _
   [umon1, umon2, umon3, umon4, umon5,_
    umon6, umon7, umon8, umon9]]
vexponents := [vector members degree m for m in monsRZ]

ords := [(1/24*matrixLigozat(level)*v) for v in vexponents]

monsA128 := [rzToAnCX x for x in monsRZ];
[qetaGrades x for x in monsA128]



)set stream calc 3
monsRZ.1,monsRZ.2
z := rzToAnCX(monsRZ.1+monsRZ.2);
qetaGrades z

assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true, false], [true]])

divs
idivs := [1,2,3,4,5,6];
z := zsolve4ti2(64, idivs, concat([0 for i in idivs], [-2*wght,0,12]))$QEQEV;
z.zinhom

-- # Original derivation from Feb-2020

-- ## (128) Manual reduction of `fser3` by means of elemens created by `rgens64x`

-- We want to consider these exponent vectors for $M^\infty(128)$,
-- so we append a 0 for the exponent of $\eta(128\tau)$.

)set stream calc 3
level := 128; spitzen := cusps(level)$GAMMA0;
rgens64x := [concat(x,0) for x in rgens64]
assertEquals(sort rgens64x, sort zzh)

-- Let us look at the degrees of the expansion of the
-- generators of the eta-quotients for $\Gamma_0(64)$.

egens64x := [EQAnCX r for r in rgens64x];
xgens64x := [toXn(CX, x, s) for x in egens64x for s in usyms64];
u := egens64x;
l := [qetaGrades x for x in u];
l3 := cons(qetaGrades hser, l);
matrix l3
--for x in u for i in 1.. repeat print [i, qetaGrades x]
qetaGrades hser

-- It is now quite easy to bring the pole order down to 26.

ser0 := hser/(u.4*u.3);
qetaGrades(ser0)

-- But we can do a little better.
-- Unfortunately, we introduce poles at other cusps.

qetaGrades(u.4*u.3*u.1^2)
ser0 := hser/(u.4*u.3*u.1^2);
qetaGrades(ser0)

-- Let us take a closer look at the expansion at the
-- cusps that correspond to poles.

-- +
ixs := [9,10,11,12,16];
LCi(x, idxs) ==> [leadingCoefficient(series(x, i)) for i in idxs]
LMi(x, idxs) ==> [leadingMonomial(series(x, i)) for i in idxs]
LC(x) ==> LCi(x, ixs)
LM(x) ==> LMi(x, ixs)

lmu := [LM x for x in u];
for x in lmu for i in 1.. repeat print([i, x])
-- -

LM ser0

qetaGrades(ser0)
qetaGrades(u.4*u.7*u.12^3/(u.4*u.3*u.1^2))

ser1 := ser0 - u.4*u.7*u.12^3/(u.4*u.3*u.1^2);
qetaGrades(ser1)
ser1

s := 16*u.8^3*u.2/u.3;
qetaGrades(s)

ser2 := ser1 - s;
qetaGrades(ser2)

-- for M(64) -- copied from above with hser
ser := hser/(u.4*u.3*u.1^2)_
        - u.7*u.12^3/(u.3*u.1^2)_
        + 16*u.8^3*u.2/u.3_
        + 172*u.2^4_
        + 112*u.2^2*u.8_
        + 592*u.2^3_
        + 544*u.2*u.7_
        - 320*u.2^2_
        + 128*u.7_
        + 448*u.2
        + 64 * 1$An(CX)


qetaGrades(hser)
qetaGrades(ser)

assertEquals(maxIndex()$An(CX), 16)
sx := series(ser, maxIndex()$An(CX))::A1(CX)

-- That gives in total that $f_{128}$ can be expressed by a sum
-- of 12 eta-quotients.

-- +
-------------------------------------------------------------------
-- -

-- Is every eta-quotient in the sum holonomic?

-- +
-------------------------------------------------------------------
-- -

vexponents := [vector members degree m for m in monomials fpol0RZ]
ords :=[(1/24*matrixLigozat(level)*v) for v in vexponents]
assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true, false], [true]])

-- No, it isn't.

-- +
-------------------------------------------------------------------
-- -

-- Find a basis for all eta-quotients of weight 4 that are modular forms

-- +
-------------------------------------------------------------------
-- -

level := 64
divs := DIVISORS level
idivs := [i for i in 1..#divs]

spitzen := cusps(level)$GAMMA0
rhs := concat([0 for i in idivs], 2*wght)

zmodform := zsolve4ti2(level, idivs, rhs)$QEQEV; -- takes about 3min40sec
vdivs := vector(divs)$VZ -- part of the Ligozat matrix that gives the order

zmodformzi := [members x(1..#divs) for x in zmodform.zinhom];
assertEquals(#zmodformzi, 8757)

-- Sort the generating exponents according to the resulting series expansion

vmodformgens := [vector x for x in zmodformzi];
vmodformgenss := sort((x1,x2)+->dot(vdivs,x1)<dot(vdivs,x2), vmodformgens);
rmodformgens := [members x for x in vmodformgenss];

mat := matrixLigozatModularGamma0(level, idivs)$QETAAUX
rmat := mat(1..nrows(mat), 1..#divs)
rmat * vector rmodformgens.1


[order EQA1C r for r in rmodformgens]
(matrix [qetaGrades YEQn x for x in rmodformgens])(1..20, 1..#spitzen)

emodformgens := [EQA1C r for r in rmodformgens];
[order x for x in emodformgens]

-- +
-------------------------------------------------------------------
-- -

-- Check whether there is a Q-linear combinationn of holomorphic
-- eta-quotients of level 42 that is equal to f21.

-- +
-------------------------------------------------------------------
-- -

-- $ sage: dimension_modular_forms(Gamma0(64),2)
-- : 30

dimM := 30
ncoefs := 32
nmodformgens := # rmodformgens

cmodformgens := [[coefficient(x, i) for i in 0..ncoefs] for x in emodformgens];
assertEquals(rank matrix cmodformgens, dimM)

matmodforms := transpose matrix cmodformgens;
cf128 := [coefficient(f128, i) for i in 0..ncoefs]

rels: VZ := new(nrows matmodforms, 0);
zmodforms := zsolve(matmodforms, rels, vector cf128)$X4ti2;
zmodformszi := zmodforms.zinhom;
assertTrue(empty? zmodformszi)

zmodformszf := zmodforms.zfree;

sol := solve(matmodforms, vector cf128);
assertTrue(sol.particular case "failed")

-- Unfortunately no solution. :-(





-- +
-------------------------------------------------------------------
-- It follows the commands that were tried to figure out the above relation.
-------------------------------------------------------------------

)if false
ser1 := fser3
ser2 := fser3 - u.4*u.7*u.12^3
ser3 := ser2/(u.4*u.1^2)
ser := ser3

sx := series(ser, 16)
s := abfmap(CX, C. retract, sx)::A1(C)
xs := toX1(C, s, 'S3)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 4096*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S3
assertEquals(# monomials spol, 13)

ixs := [5,6,7,8,16]
lmu := [LM x for x in u];
for x in lmu for i in 1.. repeat print([i, x])

ser4 := (ser3 + 16*u.8^3*u.2)/u.3
sx := series(ser, 16)
s := abfmap(CX, C, retract, sx)::A1(C)
xs := toX1(C, s, 'S4)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 1280*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S4
assertEquals(# monomials spol, 11)

ser5 := ser4 + 172*u.12^2
sx := series(ser5, 16)
s := abfmap(CX, C, retract, sx)::A1(C)
xs := toX1(C, s, 'S5)
xsr := reduce(xs, abx64)$QXTOPRED1(C)
assertTrue(zero? xsr)
spol := 12288*second(reduce(xs, abx64)$QXTOPRED1(C))::PolC + S5
assertEquals(# monomials spol, 9)
)endif



-- +
-------------------------------------------------------------------
-- Groebner basis reduction
-------------------------------------------------------------------


-- +
assertTrue(false) -- stop here

-- Now we want to reduce this relation with respect to a Gröbner basis
-- of the eta relations of level 64.

-- etaRelations64 := etaRelations(64)$QEtaIdealHemmeckeCached(C, A1(C))

E ==> Monomials(dim, N, DN, esyms) -- show DirectProduct as monomials.
RE ==> PolynomialRing(C, E)
PCE ==> PolynomialConversion(C, E, esyms)

-- read precomputed Gröbner basis
)read ../test/etaRelations64.input )quiet
etaRelations64RE := [coerce(x) $ PCE for x in etaRelations64];

num0RE := num0 pretend RE

NF(x, gb) ==> primitivePart redPol(x, gb)$GroebnerInternalPackage(C, E, RE)

num0RE1 := NF(num0RE, etaRelations64RE);

rhx := [directProduct(members degree x)$DZ for x in monomials num0RE1];
reduce(minEntries, rhx, 0$DZ)$List(DZ)

num0RE1x := (num0RE1 exquo (coerce(E64^10)$PCE))::RE

num0RE2 := NF(num0RE1x, etaRelations64RE);

##########################################
--TODO: Consider GB wrt degrevlex(E1, E64, E2, E32, E4, E16,  E8)

[removeDuplicates sort [reduce(_+, members degree x) for x in monomials er] for er in etaRelations64RE]
