-- This is a testfile for src/qetafun.spad.
-- It is also connected to \cite{Hemmecke:DancingSambaRamanujan:2018}
-- formula (7).
-- To (7) corresponds an expression in eta functions. Here we compute
-- the expansion thereof not only at the cusp infinity (which is given by (7)),
-- but also at the other cusps of \Gamma_0(22).
-- The computation of such an expansion is given by F_{r,s,m,t} as given in
-- src/qetafun.spad.

)cd /home/hemmecke/g/qeta/tmp
)r qetalibs
)r etamacros

B ==> Boolean
S ==> Symbol;
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1

EZ ==> Expression Z;
expr x ==> x :: S :: EZ;

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [qcoerce(d)@P for d in divisors(m)$INTF]

C ==> Q

PZ ==> SparseUnivariatePolynomial Z;
PQ ==> SparseUnivariatePolynomial Q;
PL ==> PolynomialCategoryLifting(N, SingletonAsOrderedSet, Z, PZ, PQ);
CX ==> SimpleAlgebraicExtension(Q, PQ, pq);
LX ==> UnivariateLaurentSeries(CX, xsym, 0);
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage;
YEDG ==> SymbolicEtaDeltaGamma;
YEQG ==> SymbolicEtaQuotientGamma;
ETAQG ==> EtaQuotientGamma(C, mx, CX, xi, LX);
MEQ ==> ModularEtaQuotient(Q, mx, CX, xi, LX);
MEQX ==> ModularEtaQuotientExpansions(CX, LX, nn);
-------------------------------------------------------------------
MSEQC ==> ModularSiftedEtaQuotientCondition
YSEDLG ==> SymbolicSiftedEtaDeltaLambdaGamma
YSEQLG ==> SymbolicSiftedEtaQuotientLambdaGamma
SEQLG ==> SiftedEtaQuotientLambdaGamma(C, mx, CX, xi, LX)
SEQG ==> SiftedEtaQuotientGamma(C, mx, CX, xi, LX)
-------------------------------------------------------------------
WIDTH(nn, c) == qcoerce(width(nn, c))@P


xsym: Symbol := "x"::Symbol;

-- p(11n+6)
nn: P := 22; r: List Z := [10, 2, 11, -22]
--nn: P := 22; r: List Z := [-10,10,-9,10]
mm: P := 11; s: List Z := [-1, 0]
mmdivs: List P := DIVISORS mm
m: P := 11; t: N := 6;

if not modularInputConditions(nn,mm,s,m,t)$MSEQC then error "mod input cond"

cusps := cuspsOfGamma0 nn
gammas := [cuspToMatrix(nn, cusp)$QAuxMEQ for cusp in cusps]
--assert(cusps = [gamma(1,1)/gamma(2,1) for gamma in gammas])

widths := [WIDTH(nn, gamma(2,1)) for gamma in gammas] -- not used below

-- Determine the what biggest root of unity we need for the coefficient domain.
yel := [[etaQuotient(m, mmdivs, s, m, t, lambda::N, gamma)$YSEQLG _
         for lambda in 0..m-1] for gamma in gammas];
mx: P := lcm [lcm [minRootOfUnity y for y in ye] for ye in yel]

-- Create the actual coefficient domain (working for each cusp).
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage;
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL;
xi := generator()$CX

-- Compute sigmaInfinity = \hat{s} for the incoming eta-quotient that
-- represents the series that we want to express in other eta quotients.
shat: Z := 0 -- sigmaInfty
for delta in mmdivs for sdelta in s repeat shat := shat + delta * sdelta

-- What's the orbit for (m,t)-sifted sequences given by the s-eta-quotient.
orb: List N := orbit(shat, m, t)

-- Compute the expansion of the (m,t)-sifted s-eta-quotient that has been
-- multiplied by an r-eta-quotient that makes the product into a modular
-- function for Gamma0(nn).
[[gamma(1,1)/gamma(2,1), _
  modularEtaQuotient(nn, r, mm, s, m, t, gamma, WIDTH(nn, gamma(2,1)))$SEQG] _
    for gamma in gammas]

-- Turn the separate expansions at the cusps into a vector (MEQX).
--TODO: Look for a better CX. During the computation we might get
-- mx as a multiple of m whereas we actually only need a mx/m-th root of unity.
eqx: XHashTable(Q, LX) := table()
for cusp in cusps repeat (_
  w: P := WIDTH(nn, denom cusp);_
  gamma: SL2Z := cuspToMatrix(nn, cusp)$QAuxMEQ;_
  seqg: SEQG := modularEtaQuotient(nn, r, mm, s, m, t, gamma, w)$SEQG;_
  eqx.cusp := expansion seqg);
meqx: MEQX := eqx :: MEQX

--TODO: Find a "better" r-vector that makes
-- sum(g for cusp in cusps | (g := qetaGrade(F,cusp))>0) is minimal.
)fin

-- v = p + x1*v1 + x2*v2 + x3*v3

res := etaCoFactor(m, mm, nn, t, s)
res.particular + 10 * res.basis.1 - 5* (res.basis.2 -res.basis.3)

pp := (res.particular).(1..4)
vv := pp - vector r
mat := transpose matrix [x(1..4) for x in res.basis]
VZ ==> Vector Z

diophantineSystem(mat, vv)$SmithNormalForm(Z, VZ, VZ, MZ)

------------

nndivs := DIVISORS nn
gamma := gammas.2
w := width(nn, gamma(2,1))
eq1 := etaQuotientOrbitProduct(mm, mmdivs, s, m, t, gamma, w)$SEQG
eq2 := coEtaQuotient(nn, nndivs, r, gamma, w)$SEQG
expansion eq1 * expansion eq2

-- Consider the order of the the cofactor (without the (c\tau+d) factor)
-- at each cusp in terms of q^(1/w) where w=width(nn,gamma(2,1)).
yeq := [etaQuotient(nn, nndivs, r, gamma)$YEQG for gamma in gammas]
vr := vector r
yeq1 := [xExponent(y)$YEQG for y in yeq]

-------------------------------------------------------------------

yeqlg := [[(etaQuotient(mm, mmdivs, s, m, t, lambda, gamma)$YSEQLG) for lambda in 0..10] for gamma in gammas]
yeqlg1 := [[width(nn, (gamma$YSEQLG)(y)(2,1)) * qExponent(y)$YSEQLG for y in yeql] for yeql in yeqlg]


mats := [matrix [[1, lambda],[0,m]] * gamma for lambda in 0..10]
smats := [splitMatrix(mat, 1) for mat in mats]
