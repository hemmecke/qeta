-- This is a testfile for src/qetafun.spad.
-- It is also connected to \cite{Hemmecke:DancingSambaRamanujan:2018}
-- formula (7).
-- To (7) corresponds an expression in eta functions. Here we compute
-- the expansion thereof not only at the cusp infinity (which is given by (7)),
-- but also at the other cusps of \Gamma_0(22).
-- The computation of such an expansion is given by F_{r,s,m,t} as given in
-- src/qetafun.spad.

)cd /home/hemmecke/g/qeta/tmp
)r qetalibs
)r etamacros

B ==> Boolean
S ==> Symbol;
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1

EZ ==> Expression Z;
expr x ==> x :: S :: EZ;

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [qcoerce(d)@P for d in divisors(m)$INTF]

C ==> Q

PZ ==> SparseUnivariatePolynomial Z;
PQ ==> SparseUnivariatePolynomial Q;
PL ==> PolynomialCategoryLifting(N, SingletonAsOrderedSet, Z, PZ, PQ);
CX ==> SimpleAlgebraicExtension(Q, PQ, pq);
LX ==> UnivariateLaurentSeries(CX, xsym, 0);
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage;
YEDG ==> SymbolicEtaDeltaGamma;
YEQG ==> SymbolicEtaQuotientGamma;
ETAQG ==> EtaQuotientGamma(C, mx, CX, xi, LX);
METAQ ==> ModularEtaQuotient(Q, mx, CX, xi, LX);
METAQX ==> ModularEtaQuotientExpansions(CX, LX, level);
-------------------------------------------------------------------
YSEDLG ==> SymbolicSiftedEtaDeltaLambdaGamma
YSEQLG ==> SymbolicSiftedEtaQuotientLambdaGamma
SEQLG ==> SiftedEtaQuotientLambdaGamma(C, mx, CX, xi, LX)
SEQG ==> SiftedEtaQuotientGamma(C, mx, CX, xi, LX)
-------------------------------------------------------------------
WIDTH(nn, c) == qcoerce(width(nn, c))@P


xsym: Symbol := "x"::Symbol;

-- p(11n+6)
nn: P := 22; r: List Z := [10, 2, 11, -22]
mm: P := 11; s: List Z := [-1, 0]
mmdivs: List P := DIVISORS mm
m: P := 11; t: N := 6;


cusps := cuspsOfGamma0 nn
gammas := [cuspToMatrix(nn,x)$QAuxMEQ for x in cusps]
--assert(cusps = [gamma(1,1)/gamma(2,1) for gamma in gammas])

widths := [width(nn, gamma(2,1)) for gamma in gammas] -- not used below

-- Determine the what biggest root of unity we need for the coefficient domain.
yel := [[etaQuotient(m, mmdivs, s, m, t, lambda::N, gamma)$YSEQLG _
         for lambda in 0..m-1] for gamma in gammas];
mx: P := lcm [lcm [minRootOfUnity y for y in ye] for ye in yel]

-- Create the actual coefficient domain (working for each cusp).
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage;
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL;
xi := generator()$CX

-- Compute sigmaInfinity = \hat{s} for the incoming eta-quotient that
-- represents the series that we want to express in other eta quotients.
shat: Z := 0 -- sigmaInfty
for delta in mmdivs for sdelta in s repeat shat := shat + delta * sdelta

-- What's the orbit for (m,t)-sifted sequences given by the s-eta-quotient.
orb: List N := orbit(shat, m, t)

-- Compute the expansion of the (m,t)-sifted s-eta-quotient that has been
-- multiplied by an r-eta-quotient that makes the product into a modular
-- function for Gamma0(nn).
[[gamma(1,1)/gamma(2,1), _
  modularEtaQuotient(nn, r, mm, s, m, t, gamma, WIDTH(nn, gamma(2,1)))$SEQG] _
    for gamma in gammas]

--TODO: Find a "better" r-vector that makes
-- sum(g for cusp in cusps | (g := qetaGrade(F,cusp))>0) is minimal.
