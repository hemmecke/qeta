-- -*- coding: utf-8 -*-
-- Via jupytext this file can be shown as a jupyter notebook.

)read /home/hemmecke/g/qeta/input/jfricas-test-support.input

-- # Init

-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q
VZ ==> Vector Z
MZ ==> Matrix Z
)set mess type off
)set mess time off
)read /home/hemmecke/g/qeta/input/convenience.input )quiet
--)set mess type on
--)set mess time on

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -


-- +
-------------------------------------------------------------------
--test:Zudilin45
-------------------------------------------------------------------
-- -


-- The generators of the $\eta$-quotients of level 45 are given by
-- these exponents for the $\eta$ functions (with arguments being the
-- divisors of 45). The variable `rgens` corresponds to the generators
-- of $R^\infty(45)$.

level := 45;

rgens := etaQuotientMonoidExponentVectors(level)$QEQEV;
rgensExpected: List List Z := [_
    [0, -1, 0, 3, 1, -3], [0, -1, 0, 1, 5, -5], [1, -1, 1, 2, 1, -4],_
    [0, 1, 0, 1, 3, -5], [-1, 3, -1, 0, 5, -6], [0, 3, 0, 1, 1, -5],_
    [2, -1, 2, 1, 1, -5], [-1, 0, 5, 1, 0, -5], [5, -2, -1, 1, 2, -5],_
    [2, -2, -1, 2, 6, -7], [0, -1, 3, 3, 1, -6], [3, -2, 0, 3, 2, -6],_
    [-1, 1, 2, 2, 3, -7], [2, 0, -1, 2, 4, -7], [1, 0, -2, 1, 8, -8],_
    [1, 3, 1, 0, 1, -6], [-2, 4, 4, 0, 0, -6], [-1, 3, 2, 2, 1, -7],_
    [1, -1, 4, 2, 1, -7], [4, -2, 1, 2, 2, -7], [-2, 5, 1, 1, 3, -8],_
    [4, -3, -2, 3, 7, -9], [0, 1, 3, 1, 3, -8], [3, 0, 0, 1, 4, -8],_
    [3, -3, -3, 2, 11, -10], [-3, 8, 3, -1, 0, -7], [0, 7, 0, -1, 1, -7],_
    [1, -3, -2, 4, 11, -11], [-2, 7, 1, 1, 1, -8], [0, 3, 3, 1, 1, -8],_
    [3, 2, 0, 1, 2, -8], [0, -1, -3, 3, 13, -12], [-3, 9, 0, 0, 3, -9],_
    [-1, 5, 2, 0, 3, -9], [2, 4, -1, 0, 4, -9], [-4, 12, 2, -2, 0, -8],_
    [-1, 7, 2, 0, 1, -9], [2, -4, -4, 4, 16, -14], [-2, 9, 1, -1, 3, -10],_
    [1, -4, -5, 3, 20, -15], [-5, 16, 1, -3, 0, -9],_
    [-2, 11, 1, -1, 1, -10], [-3, 13, 0, -2, 3, -11]];
assertEquals(rgens, rgensExpected)

eqgens := [EQA1C r for r in rgens];
assertEquals([qetaGrade x for x in eqgens],_
    [4, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11,_
    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15,_
    16, 16, 16, 16, 17, 18])

msyms := indexedSymbols("M", #eqgens)
xeqgens: List X1 C := [toX1(C, x, s) for x in eqgens for s in msyms];

-- We take a minimal (in terms the order in q) element from the
-- generators and make it special. Then we compute an algebra basis
-- for $C[M_1,\ldots,M_28]$.

tex: X1 C := xeqgens.1
abex := samba(tex, xeqgens, 0, oneVerboseStep!(1,1,1,2))$QXTOPSAMBA1(C)

assertEquals(genus(level)$GAMMA0, 3)
assertEquals(numberOfGaps(abex), 3)

bas := sort(smallerGrade?, basis abex);
t := multiplier abex
grdt := qetaGrade t
assertEquals(# bas, grdt-1)

-- From a paper of Zudilin below the table called
-- "Hypergeometric motives for rigid Calabiâ€“Yau manifolds"
-- $f_{45}$

q := monomial(1,1)$A1(C)

-- Zudilin (Mail Silviu "Date: Thu, 6 Feb 2020 14:16:19 +0100")
--
-- $f_{45}(\tau) = eta^(1,1,1,0,1,0) + eta^(0,1,0,1,1,1) + 2*eta^(0,1,0,0,3,0) -
--              4*eta^(0,1,0,0,1,2)*q^(7/2)*
--              geneta(45, [3,9,12,-18,-27,33,36,42])$

f45silviu := 1*q+1*q^2-1*q^4-1*q^5-3*q^8-1*q^10+4*q^11-2*q^13-1*q^16-2*q^17 _
  +4*q^19+1*q^20+4*q^22+1*q^25-2*q^26+2*q^29+5*q^32-2*q^34-10*q^37 _
  +4*q^38+3*q^40-10*q^41+4*q^43-4*q^44-8*q^47-7*q^49+1*q^50+2*q^52 _
  +10*q^53-4*q^55+2*q^58+4*q^59-2*q^61+7*q^64+2*q^65+12*q^67+2*q^68 _
  +8*q^71+10*q^73-10*q^74-4*q^76+1*q^80-10*q^82-12*q^83+2*q^85+4*q^86 _
  -12*q^88+6*q^89-8*q^94-4*q^95+2*q^97-7*q^98

-- generalized eta-quotient
-- From: Cristian-Silviu Radu <sradu@risc.jku.at>
-- Date: Thu, 6 Feb 2020 14:16:19 +0100

a(n,k)==(1-q^(45*n+k))
xn(n) == reduce(_*, [a(n,k) for k in [3,9,12,33,36,42]])
xd(n) == reduce(_*, [a(n,k) for k in [18,27]])
s1 := reduce(_*, [xn(n)/xd(n) for n in 0..10])

geqprefactor := expansion((q24(7*12)$ETA(C)) * YEQ1C[0,1,0,0,1,2])
f45etapart := EQA1C[1,1,1,0,1,0] + EQA1C[0,1,0,1,1,1] + 2*EQA1C[0,1,0,0,3,0]
f45trunc := f45etapart - 4 * geqprefactor * s1

s2 := generalizedEulerProduct(45, [3,9,12,33,36,42])$QFunctions(C, A1 C)_
      /_
      generalizedEulerProduct(45, [18,27])$QFunctions(C, A1 C)

f45 := f45etapart - 4 * geqprefactor * s2

z := f45 - f45trunc
assertTrue(zero? z)

divs := DIVISORS level
idivs := [i for i in 1.. #divs-1]
rwgens := etaQuotientExponentVectors(level, idivs, -4)$QEQEV;

rcofactor := rwgens.1
assertEquals(rcofactor, [0, - 1, 0, 3, 3, - 9])

fcofactor := EQA1C rcofactor
fcofactors := [EQA1C r for r in rwgens];
assertEquals([qetaGrade x for x in fcofactors], _
  [14, 16, 18, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 24, 26])

f := f45 * fcofactor
xf := toX1(C, f, 'F)
xfr := reduce(xf, abex)$QXTOPRED1(C)
assertEquals(removeDuplicates [qetaCoefficient(xfr,-i) for i in 0..230], [0])

ixfr := 5*xfr
pol := second(ixfr)::PolC + F  -- This corresponds to the mod func f.

-- pol corresponds to the modular function f_45 * fcofactor

assertEquals(pol, (-M1^2+3*M1)*M3+(M1^2-6*M1-5)*M2+4*M1^2-M1-5)

pol0 := M0*pol -- Corresponds to the original f45.
assertEquals(# monomials pol0, 8)

-- We convert the polynomial in the Mi into a Laurent polynomial in
-- the Ei variables.

esyms := indexedSymbols("E", divs)
dim: N := #esyms

rgens0 := members(- vector rcofactor)
vals := cons(monRZ rgens0, [monRZ x for x in rgens])
vars := cons(M0, msyms)

-- The following gives f_45 in terms of eta-quotients

-- Let's first check whether the expansion for the modular function f is
-- correctly expressed in eta-quotients.

-- The Laurent polynomial (in Ei variables) that belongs to $f$.

fpolRZ := EVALRZ(vars, vals, pol);

z := rzToA1C fpolRZ - f

-- The function z is a modular function, so we only need to check the
-- negative exponents.

assertTrue(zero? z)

-- Show nicely
-- find common denominator

minEntries(x: DZ, y: DZ): DZ == (_
    directProduct vector [min(x.i, y.i) for i in 1..#x]);

dzs := [degree mon for mon in monomials fpolRZ]
denRZ := monomial(1, - reduce(minEntries, dzs, 0$DZ)$List(DZ))$RZ

rez denRZ
rez(fpolRZ * denRZ)

-- Now we do the same thing for the modular form f45 itself.

fpol0RZ := EVALRZ(vars, vals, pol0)
dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := monomial(1, - reduce(minEntries, dzs0, 0$DZ)$List(DZ))$RZ
z0 := rzToA1C fpol0RZ - f45
assertEquals(order(z0, 301), 301)

-- We must check 300 coeffients (see the given f128 in order to see
-- that our computation expands to the same coefficients.

assertEquals(removeDuplicates [qetaCoefficient(z0, -i) for i in 0..300], [0])
assertEquals(#monomials(rez fpol0RZ), 8)

-- Show nicely

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-- -----------------------------------------------------------------
-- # Problem: Zudilin has a relation with only 7 terms for f_45.
-- -----------------------------------------------------------------
-- Just multiplying a "smaller" cofactor does not work, because we would
-- not work in M^\infty(45).
-- Zudilin suggested the following cofactor eta-quotient, because
-- he had already found a 7-term relation for f_45, namely,
-- (mail wzudilin@gmail.com "Fri, 7 Feb 2020 11:40:38 +0100")

)if IGNORE
( 3*q^4 * eta(q^9)^4 * eta(q^15)^4
-15*q^8 * eta(q^3) * eta(q^9) * eta(q^15)^3 * eta(q^45)^3
-5*q^3 * eta(q^3) * eta(q^5)^3 * eta(q^9) * eta(q^15)^3
+4*q^3 * eta(q^3)^2 * eta(q^9)^4 * eta(q^15)^2
+q^7 * eta(q^3)^3 * eta(q^9) * eta(q^15) * eta(q^45)^3
+q^5 * eta(q) * eta(q^3)^3 * eta(q^5) * eta(q^15) * eta(q^45)^2
+q^3 * eta(q)^3 * eta(q^9) * eta(q^15)^4 )
/
( q^4 * eta(q^3)^2 * eta(q^45)^2 )
)endif

-- where eta(q) is obviously the EulerProduct.

-- We store the terms as a list of [coeff, etaexponents].

brunaultterms := [_
  [  3, 0,-2,0,4,4,-2],_
  [-15, 0,-1,0,1,3, 1],_
  [- 5, 0,-1,3,1,3,-2],_
  [  4, 0, 0,0,4,2,-2],_
  [  1, 0, 1,0,1,1, 1],_
  [  1, 3,-2,0,1,4,-2],_
  [  1, 1, 1,1,0,1, 0] _
 ]

# brunaultterms

f45brunault := rzToA1C polyRZ brunaultterms
z := f45brunault-f45;
assertEquals(removeDuplicates [qetaCoefficient(z, -i) for i in 0..300], [0])

-- -----------------------------------------------------------------
-- Finding other symmetry group for f_45.
-- -----------------------------------------------------------------

spitzen := cusps(level)$GAMMA0
o := reduce(_+, [WIDTH0(level, denom cusp) for cusp in spitzen])
assertEquals(o, index(level)$GAMMA0)

reps := rightCosetRepresentatives level;
assertEquals(# reps, o)

xiord := 24*level
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

)set stream calc 4

findSimilarExpansions(qseries: List L1 CX): List List Z == (_
    REC ==> Record(fo: Z, fi: Z, fc: L1 CX);_
    oics := [[order x, i, x]$REC for x in qseries for i in 1..#qseries];_
    l := oics;_
    result := empty()$List(List Z);_
    while not empty? l repeat (_
        a := first l;_
        l2 := rest l;_
        while not empty? l2 repeat (_
            b := first l2;_
            if a.fo = b.fo then (_
                ser := a.fc/b.fc;_
                cs := [coefficient(ser, i) for i in 1..20];_
                if removeDuplicates [zero? c for c in cs] = [true] then (_
                    print(hconcat [[a.fi, b.fi]::OF, [ser]::OF]);_
                    result := cons([a.fi, b.fi], result)));_
            l2 := rest l2);_
        l := rest l);_
    result);


creps := [TOMAT0(cusp) for cusp in spitzen]
hmat := matrix [[1,1],[0,1]]
[WIDTH0(level, denom cusp) for cusp in spitzen]
xreps := concat [(gamma:=TOMAT0(cusp); [gamma*((hmat^i)::MZ) for i in 0..WIDTH0(level, denom cusp)-1]) for cusp in spitzen];

-- -----------------------------------------------------------------
-- Consider f. We see no similar expansions.
-- -----------------------------------------------------------------

fser := rzToAnCX fpolRZ
fserreps  := [rzToL1CX(fpolRZ, gamma) for gamma in reps];
fserxreps := [rzToL1CX(fpolRZ, gamma) for gamma in xreps];

)if false
result := findSimilarExpansions(fserreps);
assertEquals(result, [])
)endif

)set stream calc 4
for i in 1..#xreps repeat (_
    print("-----------------"::Symbol);_
    print([[i]]);_
    print(xreps.i);_
    print(fserxreps.i))

-- -----------------------------------------------------------------
-- Find better cofactor by means of 4ti2.
-- -----------------------------------------------------------------

-- The grades of an eta quotient at cusps of the form a/c (gcd(a,c)=1)
-- agrees for all such a. We choose just a=1 (which is relevant for
-- the Ligozat matrix.

fsergrades := [qetaGrade(fser, asP position(1/c, spitzen)) for c in divs]
assertEquals(fsergrades, [-1, -1, -1, -3, -1, 13])

-- For the following we have to take the full Ligozat matrix.

ndivs := #divs
idivs := [i for i in 1..ndivs]

-- Double the full Ligozat matrix part, because we want a resulting
-- vector whose corresponding grades agree in sign with fsergrades,
-- but are in absolute value (in each component separately) at most as
-- big as the respective absolute value of fsergrades.

mat := matrixLigozatRStar(level, idivs)$QETAAUX
mat := vertConcat(mat(1..ndivs,1..ncols mat), mat)

-- The 24 comes from the fact that the result after applying the
-- Ligozat matrix gives 24 times the order (not the grade) of the
-- respective series expansion.

bval: VZ := new(nrows mat, 0);
rels: VZ := new(nrows mat, 0);
for g in fsergrades for i in 1..ndivs repeat (_
    bval.i := 24*g;_
    rels.i := - sign g;_
    rels(ndivs+i) := sign g)
z := zsolve(mat, rels, bval)$X4ti2
zzi := [members t for x in z.zinhom | (t:=x(1..ndivs); not zero? t)]

rcofactorx := first zzi
grdrcofactorx := qetaGrade(EQAnCX rcofactorx, #spitzen)
for r in zzi repeat (_
    if grdrcofactorx > qetaGrade(EQAnCX r, asP #spitzen) then (_
          rcofactorx := r;_
          grdrcofactorx := qetaGrade(EQAnCX r, asP #spitzen)))

rcofactorx
fserx := fser * EQAnCX rcofactorx
qetaGrades fserx

# spitzen
sx := series(fserx, #spitzen) -- L1(CX)
s := abfmap(CX, C, retract, sx)::A1(C)
xs := toX1(C, s, 'S)

xsr := reduce(xs, abex)$QXTOPRED1(C)
assertTrue(zero? xsr)

spol := -2*second(reduce(xs, abex)$QXTOPRED1(C))::PolC + S
assertEquals(# monomials spol, 4)

varsx := cons('MC, vars)
valsx := cons(monRZ members(- vector rcofactorx), vals)

fpol := spol*MC
fpolRZ := EVALRZ(varsx, valsx, fpol)
rez fpolRZ

rzToA1C fpolRZ
assertTrue(zero?(f - rzToA1C fpolRZ))

fpol0 := M0 * fpol
fpol0RZ := EVALRZ(varsx, valsx, fpol0)
rez fpol0RZ
z0 := rzToA1C fpol0RZ - f45
assertEquals(order(z0, 301), 301)

dzs0 := [degree mon for mon in monomials fpol0RZ]
den0RZ := monomial(1, - reduce(minEntries, dzs0, 0$DZ)$List(DZ))$RZ

num0 := rez (fpol0RZ * den0RZ)
den0 := rez(den0RZ)

-- +
-------------------------------------------------------------------
-- Is every eta-quotient in the sum holomorphic
-------------------------------------------------------------------
-- -

vexponents := [vector members degree m for m in monomials fpol0RZ]
ords :=[(1/24*matrixLigozat(level)*v) for v in vexponents]
assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true, false], [true]])

-- No, it isn't.

vexponents := [vector rest x for x in brunaultterms]
ords :=[(1/24*matrixLigozat(level)*v) for v in vexponents]
assertEquals(removeDuplicates [removeDuplicates [x>=0 for x in members o] for o in ords], [[true], [true,false]])

-- However, it is also not the case for the representation of Brunault.

-- +
-------------------------------------------------------------------
-- Find a basis for all eta-quotients of weight 4 that are modular forms
-------------------------------------------------------------------
-- -

idivs := [i for i in 1..#divs]
zmodform := zsolve4ti2(level, idivs, concat([0 for i in idivs], 4))$QEQEV;
vdivs := vector(divs)$VZ -- part of the Ligozat matrix that gives the order
zmodformzi := [members x(1..ndivs) for x in zmodform.zinhom]
assertEquals(#zmodformzi, 40)

-- Sort the generating exponents according to the resulting series expansion

vmodformgens := [vector x for x in zmodformzi]
vmodformgenss := sort((x1,x2)+->dot(vdivs,x1)<dot(vdivs,x2), vmodformgens)
rmodformgens := [members x for x in vmodformgenss]
ords :=[(1/24*matrixLigozat(level)*vector(r)) for r in rmodformgens]

)set out algebra on
)set out linear off
matrix [qetaGrades YEQn x for x in rmodformgens]

-- +
-------------------------------------------------------------------
-- Check whether there is a Q-linear combinationn of holomorphic
-- eta-quotients of level 45 that is equal to f45.
-------------------------------------------------------------------
-- -

-- $ sage: dimension_modular_forms(Gamma0(45),2)
-- : 10

emodformgens := [EQA1C r for r in rmodformgens]
[order x for x in emodformgens]

-- The dimension of modular forms of weight 2 for Gamma_0(45) is 10.

dimM45 := 10
nmodformgens := # rmodformgens
cmodformgens := [[coefficient(x, i) for i in 0..dimM45] for x in emodformgens]
for x in cmodformgens for i in 1.. repeat print [i, x]
matmodforms := transpose matrix cmodformgens;
cf45 := [coefficient(f45, i) for i in 0..dimM45]
rels: VZ := new(nrows matmodforms, 0);
zmodforms := zsolve(matmodforms, rels, vector cf45)$X4ti2;
zmodformszi := zmodforms.zinhom
zmodformszf := zmodforms.zfree

-- Find the indicies where the entries are zero, i.e., those modular
-- form generators are irrelevant for the linear combination for f45.

nizi := [i for i in 1..#(zmodformszi.1) | not zero? zmodformszi.1.i]
zizi := [i for i in 1..#(zmodformszi.1) | zero? zmodformszi.1.i]

-- The shortened (relevant) vectors

nzf := [[x.i for i in nizi] for x in zmodformszf]
zzf := [[x.i for i in zizi] for x in zmodformszf]
for x in zzf repeat print [position(1, x), x]
for x in nzf for i in 1..#nzf repeat print [i, x]
nzi := [zmodformszi.1.i for i in nizi]
for x in nzf for i in 1..#nzf repeat (_
    l := members(vector x - vector nzi);_
    print [i, # remove(0, l), l])

for x in zmodformszf for i in 1..#zmodformszf repeat (_
    l := members(vector x - vector zmodformszi.1);_
    print [i, # remove(0, l), l])

assertEquals([[i,x] for i in 1..nmodformgens|(x:=zmodformszi.1.i;not zero? x)],_
    [[1, 3], [3, - 1], [5, - 2], [27, 2], [31, - 57], [32, 3], [33, - 39],_
     [34, 102], [39, 57], [40, 162]])

reduce(_+,[zmodformszi.1.i * emodformgens.i for i in 1..nmodformgens], 0$A1(C)) - f45

relvec := zmodformszi.1 - zmodformszf.30
assertEquals([[i, relvec.i] for i in 1..40 | not zero? relvec.i],_
    [[3, 1], [10, -1], [33, -1]])

h := reduce(_+,[relvec.i * emodformgens.i for i in 1..nmodformgens], 0$A1(C))
h45 := h - f45
removeDuplicates [qetaCoefficient(h45, -i) for i in -10..200]

u := rmodformgens;
h := (EQA1C u.3 - EQA1C u.10 - EQA1C u.33)
h := fcofactor * (EQA1C u.3 - EQA1C u.10 - EQA1C u.33)
assertTrue(zero?(h - f))

hn := (EQAnCX u.3 - EQAnCX u.10 - EQAnCX u.33)
hn - (fser/EQAnCX rcofactor)
hn * EQAnCX rcofactor - fser

-- Print nicely...

)set stream calc 20
EQA1C u.3
EQA1C u.10
EQA1C u.33

qetaGrades EQAnCX u.3
qetaGrades EQAnCX u.10
qetaGrades EQAnCX u.33

qetaGrades YEQn u.3
qetaGrades YEQn u.10
qetaGrades YEQn u.33

qsyms := indexedSymbols("Q", #rmodformgens)
xmfgens: List X1 C := [toX1(C, x, s) for x in emodformgens for s in qsyms];

xmf := xmfgens.3 - xmfgens.10 - xmfgens.33
mfpol := second(xmf)::PolC
valsmf := [monRZ x for x in rmodformgens]

fmfpolRZ := EVALRZ(qsyms, valsmf, mfpol)
z0 := rzToA1C fmfpolRZ - f45
assertEquals(order(z0, 301), 301)

rez fmfpolRZ

dzmf0 := [degree mon for mon in monomials fmfpolRZ]
denmf0RZ := monomial(1, - reduce(minEntries, dzmf0, 0$DZ)$List(DZ))$RZ

assertEquals(#monomials(rez fmfpolRZ), 3)

num0 := rez (fmfpolRZ * denmf0RZ)
den0 := rez(denmf0RZ)

-- -----------------------------------------------------------------
-- endtest
-- -----------------------------------------------------------------
