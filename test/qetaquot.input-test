-- -*- coding: utf-8 -*-
-- Via jupytext this file can be shown as a jupyter notebook.

)read /home/hemmecke/g/qeta/input/jfricas-test-support.input

-- This is a testfile for `src/qetaquot.spad`.
-- It is also connected to \cite{Hemmecke_DancingSambaRamanujan_2018}
-- formulas (4), (5), (9).
--
-- https://www.sciencedirect.com/science/article/abs/pii/S0747717117300147
-- and
-- https://risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
--
-- To each formula corresponds an expression in eta-functions.
-- Here we compute the expansion thereof not only at the cusp infinity
-- (which is given by (4), (5), (7)), but also at the other cusps of
-- $\Gamma_0(10)$, $\Gamma_0(14)$, $\Gamma_0(22)$.
-- The computation of such an expansion is given by $F_{r,s,m,t}$ (see
-- documentation in `src/qeta.tex`).

-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> Q
LX ==> L1 CX
)read convenience.input )quiet
)set mess type on
)set mess time on

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

)set output algebra on
)set output formatted off


-- +
-------------------------------------------------------------------
--test:Ramanujan5
-------------------------------------------------------------------
-- -

nn := 10 :: P;
rspec := eqSPEC [[1,-1]]
m := 5 :: P;
spitzen := CUSPS0 nn

orbs := [orb for tt in 0..m-1 | (orb := ORBIT(rspec,m,tt); one? # orb)]
t := (first first orbs)::Z
assertEquals(t, 4)

sspec := cofactI0(nn, rspec, m, t)
assertEquals(sspec, geqSPEC(10,[[1,6],[5,-5]]))

minroot := 120 :: P
yf := specYM0EQ(sspec, rspec, m, t);
xiord := minimalRootOfUnity(yf)::P
assertEquals(xiord, minroot)
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
mf := expandAnCX yf
-- compare result with formula (4) from
-- \cite{Hemmecke_DancingSambaRamanujan_2018}
-- Note that mf comes with the cofactor given by r. So we also must
-- multiply the right-hand side. That then equals to the constant 5.
minusfive := (-5)*1$An(CX)
assertTrue zero?(mf+minusfive)

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan7
-------------------------------------------------------------------
-- -

nn := 14 :: P;
rspec := eqSPEC [[1,-1]];
m := 7 :: P;
spitzen := CUSPS0 nn

orbs := [orb for tt in 0..m-1 | (orb := ORBIT(rspec,m,tt); one? # orb)]
t := (first first orbs) :: N
assertEquals(t, 5)

sspec := cofactI0(nn, rspec, m, t) --: List Z
assertEquals(sspec,  eqSPEC[[1,7], [2,1], [14,-7]])

minroot := 168 :: P

-- TODO:
-- c := etaCofactorSpace0(nn, mm, s, m, t)$QEtaCofactorSpace
-- vector r - (c.particular - 20*c.basis.3)(1..4) -- [0,0,1,0]
-- vector r = (c.particular + 2*c.basis.2 - 22*c.basis.3)(1..4) -- [8,0,-7,0]

yf := specYM0EQ(sspec, rspec, m, t);
xiord := minimalRootOfUnity yf
assertEquals(xiord, minroot)
CX := UnityRootExtension(C, xiord)
xi := generator()$CX

mf := expandAnCX yf;

-- compare result with formula (5) from
-- \cite{Hemmecke_DancingSambaRamanujan_2018}
-- Note that mf comes with the cofactor given by sspec. So we also must
-- multiply the right-hand side by that eta-quotient. It gives rise to
-- the (-7)*seven below for the second term on the rhs of (5).
-- The first term on the rhs of (5) turns into the eta-quotient given by
-- [[1,4],[7,-4]].

y1 := specYM0EQ(eqSPEC(nn,[3,1, 3,-7]),1$SPEC,1,0);
y2 := specYM0EQ(eqSPEC(nn,[-1,1,7,-7]),1$SPEC,1,0);

rhs := 7*expandAnCX(y1) + 49*expandAnCX(y2)
assertTrue(zero?(mf - rhs))

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan7_4-4
-------------------------------------------------------------------
-- -

-- Check that the sifted computation equals modular computation as prefactor.

nn := 14 :: P;
xiord := 168
CX := UnityRootExtension(C, xiord)
xi := generator()$CX

spitzen := CUSPS0 nn
y1 := specYM0EQ(eqSPEC(nn,[0,0, 0,0]),eqSPEC(7,[4,-4]),1,0)
y2 := specYM0EQ(eqSPEC(nn,[4,0,-4,0]),1$SPEC,1,0)
m1 := expandAnCX y1
m2 := expandAnCX y2
assertTrue(zero?(m1 - m2)) -- check different construction of m1 and m2.

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan11
-------------------------------------------------------------------
-- -

nn := 22 :: P;
--nn: P := 11; r: List Z := [0, 1]
--nn: P := 22; r: List Z := [-10,10,-9,10]
rspec := eqSPEC [[1, -1]]
m := 11 :: P;
spitzen := CUSPS0 nn

orbs := [orb for tt in 0..m-1 | (orb := ORBIT(rspec,m,tt); one? # orb)]
t := (first first orbs)::N
assertEquals(t, 6)

sspec := cofactI0(nn, rspec, m, t)
assertEquals(pureExponents sspec, [10, 2, 11, -22])

minroot := 264 :: P;
yf := specYM0EQ(sspec, rspec, m, t);
xiord:= minimalRootOfUnity(yf) :: P
assertEquals(xiord, minroot)
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
mf := expandAnCX yf


-- compare result with formula (9) from
-- \cite{Hemmecke_DancingSambaRamanujan_2018}

-- The $M_1, \ldots, M_7$ from \cite{Hemmecke_DancingSambaRamanujan_2018}.

nndivs := DIVISORS nn
mgens := [_
  [- 1,   1, 11, - 11],_
  [- 4,   8,  4,  - 8],_
  [  7, - 3,  3,  - 7],_
  [- 2,   6,  6, - 10],_
  [  0,   4,  8, - 12],_
  [  2,   2, 10, - 14],_
  [  4,   0, 12, - 16]]$List(List Z)
mspecs := [eqSPEC(nn, x) for x in mgens];

assertEquals(mSPECS0 nn, mspecs)

ygens := [specYM0EQ(mspec,1$SPEC,1,0) for mspec in mspecs];
M := [expandAnCX x for x in ygens];
F ==> mf
X n ==> n * 1$An(CX)

repr := 11*(_
  11*3068*M.7_
  + 11*(3*M.3 + X 4236)*M.6_
  + (285*M.3+X(11*5972))*M.5_
  + 1/8*(M.3^2+11*4497*M.3+X(11^2*3156))*M.1_
  + (1867*M.3+X(11*2476))*M.4_
  + (-1/8)*(M.3^3+1011*M.3^2+11*6588*M.3+X(11^2*10880)));

ZERO := F - repr;

assertTrue zero? ZERO

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
