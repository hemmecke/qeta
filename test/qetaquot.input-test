-- -*- coding: utf-8 -*-
-- Via jupytext this file can be shown as a jupyter notebook.

)read /home/hemmecke/g/qeta/input/jfricas-test-support.input

-- This is a testfile for `src/qetaquot.spad`.
-- It is also connected to \cite{Hemmecke_DancingSambaRamanujan_2018}
-- formulas (4), (5), (9).
--
-- https://www.sciencedirect.com/science/article/abs/pii/S0747717117300147
-- and
-- https://risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
--
-- To each formula corresponds an expression in eta-functions.
-- Here we compute the expansion thereof not only at the cusp infinity
-- (which is given by (4), (5), (7)), but also at the other cusps of
-- $\Gamma_0(10)$, $\Gamma_0(14)$, $\Gamma_0(22)$.
-- The computation of such an expansion is given by $F_{r,s,m,t}$ (see
-- documentation in `src/qeta.tex`).

-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------
-- -

C ==> QQ
QMOD ==> QMOD0
ORBIT ==> modularOrbit $ QMOD0
)read convenience.input )quiet
)set mess type on
)set mess time on

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

)set output algebra on
)set output formatted off


-- +
-------------------------------------------------------------------
--test:Ramanujan5
-------------------------------------------------------------------
-- -

nn := 10 :: PP;
idxs := etaFunctionIndices nn
rspec := eqSPEC [[1,-1]]
m := 5 :: PP;
spitzen := cuspsM0 nn

orbs := [orb for tt in 0..m-1 | (orb := ORBIT(rspec,m,tt); one? # orb)]
t := (first first orbs)::ZZ
assertEquals(t, 4)

sspec := cofactInfM0(nn, rspec, m, t, idxs)
assertEquals(sspec, eqSPEC(10,[[1,6],[5,-5]]))

minroot := 120 :: PP
yf := specYM0EQ(sspec, rspec, m, t);
xiord := minimalRootOfUnity(yf)::PP
assertEquals(xiord, minroot)
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
mf := expandM0AnCX yf
-- compare result with formula (4) from
-- \cite{Hemmecke_DancingSambaRamanujan_2018}
-- Note that mf comes with the cofactor given by r. So we also must
-- multiply the right-hand side. That then equals to the constant 5.
minusfive := (-5)*1$An(CX)
assertTrue zero?(mf+minusfive)

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan7
-------------------------------------------------------------------
-- -

nn := 14 :: PP;
idxs := etaFunctionIndices nn
rspec := eqSPEC [[1,-1]];
m := 7 :: PP;
spitzen := cuspsM0 nn

orbs := [orb for tt in 0..m-1 | (orb := ORBIT(rspec,m,tt); one? # orb)]
t := (first first orbs) :: NN
assertEquals(t, 5)

sspec := cofactInfM0(nn, rspec, m, t, idxs) --: List ZZ
assertEquals(sspec,  eqSPEC[[1,7], [2,1], [14,-7]])

minroot := 168 :: PP

-- TODO:
-- c := etaCofactorSpace0(nn, mm, s, m, t)$QEtaCofactorSpace
-- vector r - (c.particular - 20*c.basis.3)(1..4) -- [0,0,1,0]
-- vector r = (c.particular + 2*c.basis.2 - 22*c.basis.3)(1..4) -- [8,0,-7,0]

yf := specYM0EQ(sspec, rspec, m, t);
xiord := minimalRootOfUnity yf
assertEquals(xiord, minroot)
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

mf := expandM0AnCX yf;

-- compare result with formula (5) from
-- \cite{Hemmecke_DancingSambaRamanujan_2018}
-- Note that mf comes with the cofactor given by sspec. So we also must
-- multiply the right-hand side by that eta-quotient. It gives rise to
-- the (-7)*seven below for the second term on the rhs of (5).
-- The first term on the rhs of (5) turns into the eta-quotient given by
-- [[1,4],[7,-4]].

y1 := specYM0EQ(eqSPEC(nn,[3,1, 3,-7]),1$SPEC,1,0);
y2 := specYM0EQ(eqSPEC(nn,[-1,1,7,-7]),1$SPEC,1,0);

rhs := 7*expandM0AnCX(y1) + 49*expandM0AnCX(y2)
assertTrue(zero?(mf - rhs))

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan7_4-4
-------------------------------------------------------------------
-- -

-- Check that the sifted computation equals modular computation as prefactor.

nn := 14 :: PP;
idxs := etaFunctionIndices nn
xiord := 168
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

spitzen := cuspsM0 nn
y1 := specYM0EQ(eqSPEC(nn,[0,0, 0,0]),eqSPEC(7,[4,-4]),1,0);
y2 := specYM0EQ(eqSPEC(nn,[4,0,-4,0]),1$SPEC,1,0);
m1 := expandM0AnCX y1
m2 := expandM0AnCX y2
assertTrue(zero?(m1 - m2)) -- check different construction of m1 and m2.

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan11
-------------------------------------------------------------------
-- -

nn := 22 :: PP;
idxs := etaFunctionIndices nn
--nn: PP := 11; r: List ZZ := [0, 1]
--nn: PP := 22; r: List ZZ := [-10,10,-9,10]
rspec := eqSPEC [[1, -1]]
m := 11 :: PP;
spitzen := cuspsM0 nn

orbs := [orb for tt in 0..m-1 | (orb := ORBIT(rspec,m,tt); one? # orb)]
t := (first first orbs)::NN
assertEquals(t, 6)

sspec := cofactInfM0(nn, rspec, m, t, idxs)
assertEquals(pureExponents sspec, [10, 2, 11, -22])

minroot := 264 :: PP;
yf := specYM0EQ(sspec, rspec, m, t);
xiord:= minimalRootOfUnity(yf) :: PP
assertEquals(xiord, minroot)
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
mf := expandM0AnCX yf


-- compare result with formula (9) from
-- \cite{Hemmecke_DancingSambaRamanujan_2018}

-- The $M_1, \ldots, M_7$ from \cite{Hemmecke_DancingSambaRamanujan_2018}.

mgens := [_
  [- 1,   1, 11, - 11],_
  [- 4,   8,  4,  - 8],_
  [  7, - 3,  3,  - 7],_
  [- 2,   6,  6, - 10],_
  [  0,   4,  8, - 12],_
  [  2,   2, 10, - 14],_
  [  4,   0, 12, - 16]]$List(List ZZ)
mspecs := [eqSPEC(nn, x) for x in mgens];

assertEquals(sort [pureExponents x for x in mSPECSInfM0(nn,idxs)], sort mgens)

ygens := [specYM0EQ(mspec,1$SPEC,1,0) for mspec in mspecs];
M := [expandM0AnCX x for x in ygens];
F ==> mf
X n ==> n * 1$An(CX)

repr := 11*(_
  11*3068*M.7_
  + 11*(3*M.3 + X 4236)*M.6_
  + (285*M.3+X(11*5972))*M.5_
  + 1/8*(M.3^2+11*4497*M.3+X(11^2*3156))*M.1_
  + (1867*M.3+X(11*2476))*M.4_
  + (-1/8)*(M.3^3+1011*M.3^2+11*6588*M.3+X(11^2*10880)));

ZERO := F - repr;

assertTrue zero? ZERO

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- # Expansion of eta function as Puiseux series

-- ## Pure eta function

-- +
-------------------------------------------------------------------
--test:eta_delta-m-lambda-puiseux
-------------------------------------------------------------------
-- -

-- It corresponds to \eqref{eq:eta_delta-m-lambda^[R](gamma*tau)}.

-- Compute the expansion of eta((t+1)/2) under the transformation with
-- matrix[[1,0],[5,1]].

rspec := eqSPEC [[1,1]]; delta := 1 :: PP;
m := 2 :: PP; lambda := 1 :: NN;
gamma := matrix [[1,0],[5,1]]

-- We only have a puiseuxExpansion function for
-- SymbolicEtaQuotientLambdaGamma, so we do not compute an element of
-- SymbolicEtaGamma, but rather an element of
-- SymbolicEtaQuotientLambdaGamma.
-- Since there is only one part in

parts rspec

-- we can easily extract from

y := etaQuotient(rspec,m,lambda,gamma)$SymbolicEtaQuotientLambdaGamma;

-- the respective element of SymbolicEtaGamma.

yy := y[delta,-1] -- SymbolicEtaGamma

-- Their Puiseux expansion is therefore the same.

-- Before we can compute the expansion, we must determine in which
-- coefficient ring we can do it.

-- Since $\kappa_{\gamma_{\delta,m,\lambda}}$ from
-- \eqref{eq:eta_delta-m-lambda^[R](gamma*tau)} is an integer, we
-- determine by which $n$-th root of unity $\xi$ we must extend our
-- coefficient ring (rational numbers) so that all coefficients of the
-- expansion (without the $(c\tau+d)$ factor live in
-- $\mathbb{Q}[\xi]$.

assertEquals(gamma1 yy, matrix[[3,1],[5,2]])
kappa := (upsilonExponent(gamma1 yy)$QETAAUX)::QQ
assertEquals(kappa,22)
assertEquals(udelta yy, 2)
assertEquals(vdelta yy, 0)
rat := rationalPrefactor y
rr := rationalSquareRoot(rat)$QETAAUX

-- For second factor
-- $\left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^(1/2)$ in
-- \eqref{eq:eta_delta-m-lambda^[R](gamma*tau)} we need a 8-th root of unity.

minroot := minimalSquareRootOfUnity(rr.rootOf)$QETAAUX

ue := unityExponent y -- third factor
assertEquals(ue, 1/24*(vdelta yy + kappa))

xiord := lcm(minroot, denom ue)
assertEquals(xiord,24)

-- Now we can define the coefficient ring CX and the root xi and
-- compute the expansion.

EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi);
px := puiseuxExpansion(y,0) $ QESXM(C,CX,QMOD0)

-- Note that in our case, the 0 in the argument is actually
-- superfluous, but QEta has no implementation to expand `yy`.

-- Furthermore, the `QMOD0` parameter is actually not used, but QEta
-- did not bother to implement a domain that does not need that
-- parameter.

-- Let us continue with some checks.

qe := qExponent y -- 4th factor
cde := cdExponent y -- first factor

assertEquals(order px, qe)
assertEquals(cde, 1/2)

-- Compute the actual root
-- $\left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^(1/2)$ in
-- $\mathbb{Q}[\xi]$.

s2 := squareRoot(rr.rootOf)$GaussRoot(CX,xi,xiord)
assertEquals(s2^2, rr.rootOf)

c := s2*xi^(ue*xiord)

assertEquals(c,-xi^7+xi)
assertEquals(leadingCoefficient(px),c)
assertEquals(leadingCoefficient(reductum px),-c)
assertEquals(leadingCoefficient(reductum reductum px),-c)

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
