-- -*- coding: utf-8 -*-
-- Via jupytext this file can be shown as a jupyter notebook.

)read /home/hemmecke/g/qeta/input/jfricas-test-support.input

-- # Problem formulation


-- This worksheet contains some formulas and computations from
-- the following article.
--
--     @Article{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019,
--       author =       {Chen, William Y. C. and Du, Julia Q. D. and Zhao,
--                       Jack C. D.},
--       title =        {Finding Modular Functions for {R}amanujan-Type
--                       Identities},
--       journal =      {Annals of Combinatorics},
--       year =         2019,
--       volume =       23,
--       number =       3,
--       pages =        {613--657},
--       abstract =     {This paper is concerned with a class of partition
--                       functions $a(n)$ introduced by Radu and defined in
--                       terms of eta-quotients. By utilizing the
--                       transformation laws of Newman, Schoeneberg and
--                       Robins, and Radu’s algorithms, we present an
--                       algorithm to find Ramanujan-type identities for
--                       $a(mn+t)$. While this algorithm is not guaranteed to
--                       succeed, it applies to many cases. For example, we
--                       deduce a witness identity for $p(11n+6)$ with
--                       integer coefficients. Our algorithm also leads to
--                       Ramanujan-type identities for the overpartition
--                       functions $\overline{p}(5n+2)$ and
--                       $\overline{p}(5n+3)$ and Andrews–Paule’s broken
--                       2-diamond partition functions $\triangle_2(25n+14)$
--                       and $\triangle_2(25n+24)$. It can also be extended
--                       to derive Ramanujan-type identities on a more
--                       general class of partition functions. For example,
--                       it yields the Ramanujan-type identities on Andrews’
--                       singular overpartition functions
--                       $\overline{Q}_{3,1}(9n+3)$ and
--                       $\overline{Q}_{3,1}(9n+6)$ due to Shen, the
--                       2-dissection formulas of Ramanujan, and the
--                       8-dissection formulas due to Hirschhorn.},
--       issn =         {0219-3094},
--       doi =          {10.1007/s00026-019-00457-4},
--       url =          {https://doi.org/10.1007/s00026-019-00457-4}
--     }
--

-- # Init

-- +
-------------------------------------------------------------------
--setup
-------------------------------------------------------------------

-- +
)set mess type off
)set mess time off
C ==> Q

GEP ==> generalizedEtaPower $ EQI(C)
EQ ==> etaQuotient $ EQI(C)
EE ==> eulerExpansion $ EQI(C)
EX ==> expansion $ EQI(C)

QF ==> QFunctions(Q, L1 Q)
QFX ==> QFunctions(CX, L1 CX)
jf ==> jacobiFunction $ QF
ef ==> eulerFunction $ QF
gep ==> generalizedEulerProduct $ QF
one(n: Z): Q == 1

L ==> L1 C
TX ==> T1 CX
LX ==> L1 CX
PX ==> QEtaPuiseuxSeries CX

puiex ==> puiseuxExpansion $ QESX(C, CX)

oo ==> infinity()$Cusp

)read convenience.input )quiet
)set stream calc 2
-- -

ps := partitionSeries(1)$QFunctions(Q, L1(Q))

)set mess type on
)set mess time on

-- +
-------------------------------------------------------------------
--endsetup
-------------------------------------------------------------------
-- -

-- # $p(5n)$

-- See Formula (1.4) of
-- \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.
-- \begin{align}
-- \sum_{n=0}^\infty p(5n)
-- &=
-- \frac{(q^5;q^5)_\infty}{(q;q)_\infty^2 (q,q^4;q^5)_\infty^8}
-- -
-- 3 q \frac{(q^5;q^5)_\infty^6 (q,q^4;q^5)_\infty^2}{(q;q)_\infty^7}
-- \tag{1.4}
-- \end{align}

-- We can easily verify this identity up to order 100.

m := 5; t := 0;
rspec := geqSPEC [[1,-1]];
nn := minimalLevelCoEtaQuotientGamma1(rspec, m, t)$QEtaCofactorSpace

-- As can be seen that is done in level 5.

f := p5n0 := choose(m, t, ps);
rspec1 := geqSPEC [[1,-2],[5,1],[5,1,-8]];
rspec2 := geqSPEC [[1,-7],[5,6],[5,1,2]];
f1 := eulerExpansion specEQI(C) rspec1
f2 := eulerExpansion specEQI(C) rspec2
g := f1 - monomial(3, 1)$L1(C)*f2;
assertEquals(order(f - g,100), 100)

-- ## Find cofactor

-- Let us do a first step into the direction of finding
-- the above identity. In order to do this, we have to
-- multiply the left-hand side of (1.4) by a generalized
-- eta-quotient so that the product will be a modular
-- function for $\Gamma_1(5)$ with poles only at infinity.
--
-- This cofactor can be computed as follows.

idxs := [[1],[5],[5, 1]]
sspec := etaCofactorInfinity(nn,rspec,m,t,idxs)$QEtaModularGamma1

-- Interestingly, it is just the invers of the eta-quotient in
-- the second summand of the right-hand side. So we will show:
-- \begin{align}
-- \frac
-- {(q;q)_\infty^7}
-- {q (q^5;q^5)^6_\infty (q,q^4;q^5)_\infty^2}
-- \sum_{n=0}^\infty p(5n)
-- &=
-- \frac
-- {(q;q)_\infty^5}
-- {q (q^5;q^5)_\infty^5 (q,q^4;q^5)_\infty^{10}}
-- -
-- 3
-- \end{align}
-- or rather
-- \begin{align}
-- \frac
-- {\eta(\tau)^7}
-- {\eta(5 \tau)^6 \eta_{5,1}(\tau)^2}
-- \sum_{n=0}^\infty p(5n)
-- &=
-- \frac
-- {\eta(\tau)^5}
-- {\eta(5 \tau)^5 \eta_{5,1}(\tau)^{10}}
-- -
-- 3.
-- \end{align}

assertTrue(modularGamma1?(sspec,rspec,m,t))

-- Is the cofactor and the basis modular for $\Gamma_1(N)$.

yf := specYM1GEQ(sspec,rspec,m,t);
rspect := geqSPEC [[1,5], [5,-5], [5,1,-10]]
yt := specYM1GEQ(rspect);
xiord := minimalRootOfUnity(yf)::P
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi);
spitzen := cusps(yf)

af := expandAnCX yf; qetaGrades af
at := expandAnCX yt; qetaGrades at

-- We check the identity at all cusps of
-- $\Gamma_1(5)$.

assertTrue(zero?(af-at+3*1$An(CX)))

-- ## Find the relation

generalizedEtaFunctionIndices(nn)

)clear prop idxs
idxs: List List Z := [[1],[5],[5, 2]]
ggens := generalizedEtaQuotientMonoidExponentVectors(nn, idxs)
bspecs := generalizedEtaQuotientMonoidSpecifications(nn, idxs)


ygens := [specYM1GEQ x for x in bspecs];
egens := [expandAnCX x for x in ygens];
[qetaGrades x for x in egens]

msyms := indexedSymbols("M", #egens)
k := position(oo, spitzen)
xgens := [toX1(C, series(x,k), msym) for msym in msyms for x in egens];
[qetaGrade x for x in xgens]
xab := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

xf := toX1(C, series(af,k), 'F)
xr := reduce(xf,xab)$QXTOPRED1(C)
pol := second(xr)::Pol(C)
ilcpol := -inv(coefficient(pol,'F, 1))::C

mpol := coefficient(ilcpol*pol, 'F, 0)
assertEquals(mpol, M1-3)

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
-- +
-------------------------------------------------------------------
--test:p11n6
-------------------------------------------------------------------
-- -
-- # $p(11n+6)$

-- See \cite[Thm.~1.1]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.
-- Theorem 1.1 Equations (1.7)-(1.9)

m := 11; t := 6;
rspec := eqSPEC [[1,-1]]
nn := minimalLevelCoEtaQuotientGamma1(rspec, m, t)

p11n6 := choose(11,6,ps);
z01 := EE(EQ(11,[24,-23])*GEP(11,1,-28)*GEP(11,2,-16)*GEP(11,3,-12)*GEP(11,4,-4));
z02 := EE(EQ(11,[24,-23])*generalizedEtaQuotient(11,[1,2,3,4],[-28,-16,-12,-4])$EQI(C));
assertEquals(order(z01 - z02, 100), 100)

rspecz0 := geqSPEC [[1,24],[11,-23],[11,1,-28],[11,2,-16],[11,3,-12],[11,4,-4]];
z00 := EE specEQI(C) rspecz0;
assertEquals(order(z01-z00, 100), 100)
z0 := monomial(1,-20)$L1(C)* z00;

rspecz := geqSPEC [[1,1],[11,-1],[11,1,-3],[11,2,-2]];
z := EX specEQI(C) rspecz;
assertEquals(order(z - EX(EQ(11,[1,-1]) * generalizedEtaQuotient(11,[1,2],[-3,-2])$EQI(C)), 100), 100)

rspece := geqSPEC [[1,3],[11,-3],[11,1,-5],[11,2,-5],[11,3,-4],[11,4,-1]];
e := EX specEQI(C) rspece;
ex := EX(EQ(11,[3,-3]) * generalizedEtaQuotient(11,[1,2,3,4],[-5,-5,-4,-1])$EQI(C));
assertEquals(order(e - ex, 100), 100)

ts := [z^10, z^8*e, z^9, z^7*e, z^8, z^6*e, z^7, z^5*e, z^6, z^4*e,_
       z^5, z^3*e, z^4, z^2*e, z^3, z*e, z^2, z, 1$L];
cs := [1,11,30,-44,-90,44,72,-44,4,99,-12,-132,-41,88,68,-22,-39,7,1];
terms := [c*t for c in cs for t in ts];

zz := z0*p11n6 - 11*reduce(_+, terms, 0$L);
assertEquals(removeDuplicates[coefficient(zz,i) for i in -20..50],[0])
assertEquals(order(zz, 100), 100)

-- ## Check modularity for cofactor

sspec := rspecz0
assertTrue(modularGamma1?(sspec,rspec,m,t))

-- ## Check Puiseux = Laurent expansion

-- Check that Puiseux expansion and Laurent
-- expansion have the same order.

x := specYM1GEQ(sspec,rspec,m,t);
spitzen := cusps x
xiord := minimalRootOfUnity(x)::P
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)
)set stream calc 2
PGRD(nn,x,c) ==> - WIDTH1(nn, c)*order puiex(x(c))
pgrds := [PGRD(nn, x, cusp) for cusp in spitzen]
ax := expandAnCX x;
assertEquals(pgrds, qetaGrades ax)
yz0 := specYGEQ rspecz0;
yz := specYGEQ rspecz;
pgrds := [PGRD(nn, yz, cusp) for cusp in spitzen]
assertEquals(pgrds, qetaGrades yz)

ye := specYGEQ rspece;
pgrds := [PGRD(nn, ye, cusp) for cusp in spitzen]
assertEquals(pgrds, qetaGrades ye)

-- ## Check modularity of basis

assertTrue(modularGamma1? rspecz)
assertTrue(modularGamma1? rspece)

-- ## Find cofactor

-- If we exclued the index [11,5] from the indices, then we
-- find the same cofactor as in 
-- \cite[Thm.~1.1]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

idxs := [[1],[11],[11,1],[11,2],[11,3],[11,4]]
assertEquals(concat(idxs, [11,5]), generalizedEtaFunctionIndices nn)

rspecz0
sspec := etaCofactorInfinity(nn,rspec,m,t,idxs)$QEtaModularGamma1
assertEquals(rspecz0,sspec)
assertTrue(modularGamma1?(sspec,rspec,m,t))
yf := generalizedEtaQuotient(sspec,rspec,m,t);
xiord := minimalRootOfUnity(yf)::P
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi);
spitzen := cusps yf
af := expandAnCX yf; qetaGrades af

-- Obviously, our cofactor gives the same modular
-- function as the cofactor z0 from
-- \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

)set stream calc 1
assertTrue(zero?(af-ax))

-- ## Find the relation

ggens := generalizedEtaQuotientMonoidExponentVectors(nn);
gspecs := [geqSPEC(nn,toGeneralizedEtaQuotientSpecification(nn,x)) for x in ggens];
bspecs := generalizedEtaQuotientMonoidSpecifications nn;
assertEquals(gspecs, bspecs)

ygens := [specYM1GEQ x for x in bspecs];
egens := [expandAnCX x for x in ygens];
[qetaGrades x for x in egens]

msyms := indexedSymbols("M", #egens)
k := position(oo, spitzen)
xgens := [toX1(C, series(x,k), msym) for msym in msyms for x in egens];
[qetaGrade x for x in xgens]
xab := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

xf := toX1(C, series(af,k), 'F)
xr := reduce(xf, xab)$QXTOPRED1(C)
pol := second(xr)::Pol(C);
ilcpol := -inv(coefficient(pol,'F, 1))::C;

mpol := coefficient(ilcpol*pol, 'F, 0)
assertEquals(_
  mpol,_
  11*(M1^10 + 40*M1^9 + 11*M1^8*M5 + 225*M1^8 + 44*M1^7*M5_
      + 552*M1^7 + 44*M1^6*M5 + 718*M1^6-88*M1^5*M5_
      + 516*M1^5 - 231*M1^4*M5 + 169*M1^4 - 220*M1^3*M5_
      - 16*M1^3 - 110*M1^2*M5 - 24*M1^2 - 22*M1*M5_
      - 3*M1+1))

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
-- +
-------------------------------------------------------------------
--test:pp5n2
-------------------------------------------------------------------
-- -
-- # $\overline{p}(5n+2)$
--
-- \cite[p. 7]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
--
-- $$
-- \sum_{n=0}^\infty \overline{p}(n) q^n
-- =
-- \frac{(q^2;q^2)_\infty}{(q;q)_\infty^ 2}
-- $$

m := 5; t:= 2

rspec := eqSPEC [[1,-2],[2,1]]

nn := minimalLevelCoEtaQuotientGamma1(rspec,m,t)$QEtaCofactorSpace

generalizedEtaFunctionIndices nn
ecss := etaCofactorSpace1System(nn,rspec,m,t)$QEtaCofactorSpace
etaCofactorSpace1(nn,rspec,m,t)$QEtaCofactorSpace

mat := ecss.comatrix; v := ecss.rhs;

mat * vector [0,0,18,-17,0,0,0,0,0,-8,  10,6,13,4,0,9,4,13,9]

48*2





sspec := etaCofactorInfinity(nn,rspec,m,t)$QEtaModularGamma1

assertTrue(false)

assertTrue(modularGamma1?(sspec,rspec,m,t))
yf := generalizedEtaQuotient(sspec,rspec,m,t);
xiord := minimalRootOfUnity(yf)::P
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi);
spitzen := cusps yf
af := expandAnCX yf; qetaGrades af

bspecs := generalizedEtaQuotientMonoidSpecifications nn;

ygens := [specYM1GEQ x for x in bspecs];
egens := [expandAnCX x for x in ygens];
[qetaGrades x for x in egens]

msyms := indexedSymbols("M", #egens)
k := position(oo, spitzen)
xgens := [toX1(C, series(x,k), msym) for msym in msyms for x in egens];
[qetaGrade x for x in xgens]
xab := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

xf := toX1(C, series(af,k), 'F)
xr := reduce(xf, xab)$QXTOPRED1(C)
pol := second(xr)::Pol(C);
ilcpol := -inv(coefficient(pol,'F, 1))::C;

mpol := coefficient(ilcpol*pol, 'F, 0)
assertEquals(_
  mpol,_
  11*(M1^10 + 40*M1^9 + 11*M1^8*M5 + 225*M1^8 + 44*M1^7*M5_
      + 552*M1^7 + 44*M1^6*M5 + 718*M1^6-88*M1^5*M5_
      + 516*M1^5 - 231*M1^4*M5 + 169*M1^4 - 220*M1^3*M5_
      - 16*M1^3 - 110*M1^2*M5 - 24*M1^2 - 22*M1*M5_
      - 3*M1+1))



















pp := expansion etaQuotient([1,2],[-2,1])
pp5n2 := choose(5, 2, pp);
phi := GEQ[[10],[10,5,9],[10,4,-8]];
f := EE phi * pp5n2

-- We list here the generators of $GE^\infty(10)$ as written the top
-- of page 20 of \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
-- which is equation (3.2).

x := GEQ[[1],[5],[10,-2],[5,1,-2],[10,1,-1]];
x1 := GEQ[[1,-1],[2,2],[5],[10,-2],[5,1,2],[10,1,-4]];
x2 := GEQ[[1,-1],[2,-1],[5,3],[10,-1],[5,1,4],[10,1,-3]];
x3 := GEQ[[1],[2,-2],[5,-1],[10,2],[5,1,2],[10,1,-4]];
x4 := GEQ[[1,4],[2,-3],[10,-1],[5,1,2],[10,1,-4]];
xh := x^(-6) * x1^2 * x2^(-4) * x3^3 * x4^3;

-- Theorem 3.1 of \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

z := EX x;
h := EX xh;
zz := h*f - (4*z^3 + 4*z^2 - 32*z + 32);
assertEquals(removeDuplicates[coefficient(zz,i) for i in -20..50],[0])
assertEquals(order(zz, 100), 100)

y := GEQ[[1,11],[2,-7],[5,-19],[10,16],[5,1,12],[10,1,-14],[10,4,-8],[10,5,9]];
assertEquals(order(EX(xh*phi/y) - 1,100),100)

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------


-- +
-------------------------------------------------------------------
--test:overpartition
-------------------------------------------------------------------

-- # test:overpartition

-- See example after
-- \cite[Thm.~2.1]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
-- and
-- \cite[Thm.~3.1]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

mm := 2; m := 5; t := 2
rbar := [[1,-2],[2,1]]
nn := minimalLevelCoEtaQuotientGamma1(mm, rbar, m, t)
assertEquals(nn, 10)

sbar := [[5,18],[10,-17],[10,4,-8]]

-- +
rrec: GEQSPLIT := splitEtaQuotientSpecification(mm, rbar)$QETAAUX
r: LZ := rrec.pure
rtilde: LLZ := rrec.properGeneralized

srec: GEQSPLIT := splitEtaQuotientSpecification(nn, sbar)$QETAAUX
s: LZ := srec.pure
stilde: LLZ := srec.properGeneralized
-- -

x := generalizedEtaQuotient(nn,sbar,mm,rbar,m,t)$YM1GEQ;

cusps x
xiord := minimalRootOfUnity(x)::P
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

)set stream calc 2
QLX(x)

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:singularoverpartition-3-1
-------------------------------------------------------------------
-- -

-- # test:singularoverpartition-3-1

-- See \cite[Thm.~10.3]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

m := 9; t := 3
rspec := geqSPEC [[1,-1],[3,1],[3,1,-1],[6,2,1]]

nn := minimalLevelCoEtaQuotientGamma1(rspec,m,t)$QEtaCofactorSpace
sspec := etaCofactorInfinity(nn,rspec,m,t)$QEtaModularGamma1

sspec := geqSPEC [[1,14],[2,-5],[3,-6],[6,-3]]

rrec: GEQSPLIT := splitEtaQuotientSpecification(mm, rbar)$QETAAUX
r: LZ := rrec.pure
rtilde: LLZ := rrec.properGeneralized

srec: GEQSPLIT := splitEtaQuotientSpecification(nn, sbar)$QETAAUX
s: LZ := srec.pure
stilde: LLZ := srec.properGeneralized
sigma0(nn,s,stilde) + numer(nn/mm)*m*sigma0(mm,r,rtilde)
-- -
x := generalizedEtaQuotient(nn,sbar,mm,rbar,m,t)$SymbolicModularGamma1GeneralizedEtaQuotient;
cusps x
xiord := minimalRootOfUnity(x)::P
EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi)

)set stream calc 2

px := QPX(x(1/6))

rationalPower px

lx := qetaLaurentRep px

degree lx

)set stream calc 10
tx := qetaTaylorRep lx







h := QLX(x)

)set stream calc 10

h

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------

-- +
-------------------------------------------------------------------
--test:Ramanujan-2-disection
-------------------------------------------------------------------
-- -

-- # test:Ramanujan-2-disection

-- See \cite[Thm.~10.4]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

mm := 5; m := 2; t := 0
nn := 10
rbar := [[5,1,-1],[5,2,1]]
sbar := [[1,14],[2,-5],[3,-6],[6,-3]]

matrixEtaOrder(10)

matrix[[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [10, 5, 2, 1, 20, 20, 20, 20, 10, 10, 24, 0, 0, 0, 0, 0, 0, 0, 0], [10, 20, 50, 100, 12, -132, 276, 24, -156, -264, 0, 240, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0]]

ecs := etaCofactorSpace1(nn,mm,[],m,t);
bas := [x(1..10) for x in ecs.basis | not zero?(x(1..10))]
A := transpose matrix bas
b := [1,0,1,-2,-2,0,-1,0,0,0]

solve(A,b)
============================ CONTINUE HERE =============================

toEtaQuotientSpecification(nn,[])



rrec: GEQSPLIT := splitEtaQuotientSpecification(mm, rbar)$QETAAUX
r: LZ := rrec.pure
rtilde: LLZ := rrec.properGeneralized

sbar

srec: GEQSPLIT := splitEtaQuotientSpecification(nn, sbar)$QETAAUX
s: LZ := srec.pure
stilde: LLZ := srec.properGeneralized

sigma0(nn,s,stilde) + numer(nn/mm)*m*sigma0(mm,r,rtilde)

mm

x := generalizedEtaQuotient(nn,sbar,mm,rbar,m,t)$SymbolicModularGamma1GeneralizedEtaQuotient;
minimalRootOfUnity x
cusps x

y := x(1/3);
yb := basefactor y; yc := cofactor y;
minimalRootOfUnity yb, minimalRootOfUnity yc

yc.0

-- +
-------------------------------------------------------------------
--endtest
-------------------------------------------------------------------
-- -

)compile /home/hemmecke/g/qeta/src/qetacofactorspace
setFormat!(FormatMathJax)$JFriCASSupport

)compile /home/hemmecke/g/qeta/src/qetaquotsymb
setFormat!(FormatMathJax)$JFriCASSupport

n := lengthOfGeneralizedEtaQuotientSpecification nn
ecs := etaCofactorSpace1(nn,mm,rbar,m,t)
sbar := toEtaQuotientSpecification(nn, (ecs.particular)(1..n))

dim := #msyms
D ==> HomogeneousDirectProduct(dim, N)
E ==> Monomials(dim, N, D, msyms)
PC ==> PolynomialConversion(C, E, msyms)
coerce(1/11*mpol)$PC

-- # $\bar{p}(5n+2)$

-- # $\Delta_2(25n+14)$

-- # $\Delta_2(25n+24)$






