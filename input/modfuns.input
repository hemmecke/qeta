-- This functions defined in this file assume that the missing values
-- for the macros in etamacros.input and convenience.input have been set.
-- In particular C, xiord, and CX.

-- expansion of j(n*tau) at cusp gamma(1,1)/gamma(2,1).
kleinJ(n: P, gamma: SL2Z, w: P): L1 CX ==
  t := splitMatrix(gamma, n).triang
  j := kleinJInvariant()$QFunctions(CX, L1 CX)
  d := t(2,2)
  u: P := t(1,1)*w/d
  v: N := t(1,2)*xiord/d
  substitute(j, u, v)$EQG(C, CX)

-- expansion of j(n*tau) at all cusps of Gamma0(nn).
kleinJn(nn: P, n: N): An(CX) == (_
  h := table()$XHashTable(Q, L1 CX);_
  for cusp in cusps(nn)$GAMMA0 repeat (_
    w := WIDTH0(nn, denom cusp);_
    gamma := cuspToMatrix(nn, cusp)$GAMMA0;_
    h.cusp  := kleinJ(n, gamma, w));_
  h :: An(CX))








)if false
hj: XHashTable(Q, L1 CX) := table()
hj11: XHashTable(Q, L1 CX) := table()
for cusp in cusps(nn)$GAMMA0 repeat (_
  hj.cusp := kleinJ(1, cuspToMatrix(nn, cusp)$GAMMA0, WIDTH0(nn, denom cusp));_
  hj11.cusp := kleinJ(11, cuspToMatrix(nn, cusp)$GAMMA0, WIDTH0(nn, denom cusp)))

mj   := hj  ::Fn(CX); qetaGrades mj
mj11 := hj11::Fn(CX); qetaGrades mj11
)endif

)if false
expansionModular(xiord, CX, xi, y, w) ==
    e := expansion(puiseux(y, w)$EQG(C, CX))::A1(CX)
    abmap(CX, C, e)

expansionModularSiftedEtaQuotientGamma(nn, r, mm, s, m, t, gamma) ==
  w: P := WIDTH0(nn, gamma(2,1))
  y := etaQuotient(nn, r, mm, s, m, t, gamma)$YM0SEQG
  xiord: P := minimalRootOfUnity y
  if xiord > 2 then
    CX ==> UnityRootExtension(C, xiord)
    expansionModular(xiord, CX, generator()$CX, y, w)
  else
    CX ==> Q
    expansionModular(xiord, CX, -(-1)^xiord, y, w)
)endif


-- traceMap(nn, t, r) applies the trace function, see
-- \cite{Kohnen:WeierstrassPointsAtInfinity:2004}, to the modular
-- eta-quotient of M(nn*t) given by the exponent vector r.
-- The result is a modular function in M(nn).
-- Input condition: #r = #DIVISORS(nn*t), gcd(nn, t)=1.
traceMap(nn: P, t: P, r: List Z): A1 C ==
  #r ~= numberOfDivisors(nn*t)$INTF =>
    error "length of r must match number of divisors)"
  idgamma: SL2Z := matrix [[1,0],[0,1]]
  ye := etaQuotient(nn*t, r, idgamma)$YEQG
  e := laurent puiseux(ye, 1)$EtaQuotientGamma(C, 1, C, 1)
  alw: MZ := matrixAtkinLehner(nn*t, t)
  sm := splitMatrix(alw(1,1), alw(1,2), alw(2,1), alw(2,2))
  gamma := sm.red
  yeg := etaQuotient(nn*t, r, gamma)$YEQG
  -- Check that there is no need for an extension by a root of unity
  xiord := minimalRootOfUnity yeg;
  xiord > 2 =>
    print("minimalRootOfUnity yeg"::Symbol::OutputForm)
    print((minimalRootOfUnity yeg)::OutputForm)
    error "traceMap: need extension by root of unity"
  eg := laurent puiseux(yeg, t)$EtaQuotientGamma(C, 2, C, -1)
  -- finally apply Ut operator
  uteg := choose(t, 0, eg)
  -- and add things up
  (e + t*uteg)::A1(C)
