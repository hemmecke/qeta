-- This functions defined in this file assume that the missing values
-- for the macros in etamacros.input have been set.
-- In particular C, xiord, and CX, spitzen=CUSPS0(level).

-- The following function simply maps the integer coefficients of the
-- series into the localized coefficient domain or into the rational
-- number domain Q.

abfmap(A, B, f, x) ==> map(f, x)$QEtaLaurentSeriesFunctions2(A, B)
abffmap(A, B, f, x) ==> abfmap(A, B, f, x::L1(A))::A1(B)
abmap(A, B, x) ==> abffmap(A, B, (c: A): B +-> c::B, x)
zcmap(x) ==> abmap(Z, C, x)
cqmap(x) ==> abmap(C, Q, x)
zqmap(x) ==> abmap(Z, Q, x)


-------------------------------------------------------------------
-- macro that we use.
-- MOD:     actually a macro pointing to MOD1 or MOD2

-------------------------------------------------------------------
-- Implicit global variables:
-- nn:      We consider the modular groups Gamma_0(nn) or Gamma_1(nn).
-- spitzen: The cusps at which to expand.
-- xiord:   We compute with the xiord-th root of unity
-- xi:      A xiord-th root of unity in CX
-- CX:      An C-Algebra containing xi.
-- Call macro EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi).
-------------------------------------------------------------------
QESXM(C, CX, MOD) ==> QEtaSeriesExpansion(C, xiord, CX, xi, MOD)
QESXMOD(C, CX) ==> QESXM(C, CX, MOD)
An CX ==> ModularFunctionExpansionsAtCusps(CX, spitzen)

-------------------------------------------------------------------
-- Expansion of symbolic (generalized) eta-quotient into laurent series.
expandMAn(CX, MOD) y ==> (laurentExpansions(y, spitzen)$QESXM(C,CX,MOD))::An(CX)
expandMODAn CX ==> expandMAn(CX, MOD)
expandMODAnCX ==> expandMAn(CX, MOD)
expandM0An CX ==> expandMAn(CX, MOD0)
expandM1An CX ==> expandMAn(CX, MOD1)
expandM0AnCX ==> expandM0An CX
expandM1AnCX ==> expandM1An CX

-------------------------------------------------------------------
-- Creation of eta-quotient expansions at the cusps given by spitzen.
specYMODEQn spec ==> specYMODEQ(spec, spitzen)
specYM0EQn spec ==> specYM0EQ(spec, spitzen)
specYM1EQn spec ==> specYM1EQ(spec, spitzen)

-------------------------------------------------------------------
-- Expansion of a specification int (generalized) eta-quotient into
-- laurent series.
specMAn(CX,MOD)(spec) ==> expandMAn(CX, MOD)(specYMEQ(MOD)(spec, spitzen))
specM0An CX ==> specMAn(CX, MOD0)
specM1An CX ==> specMAn(CX, MOD1)

-------------------------------------------------------------------
CAn CX ==> QEtaAlgebraCachedPower(CX, An CX) -- domain in cached version
Xn CX ==> QEtaExtendedAlgebra(CX, CAn CX, CPol CX)
toXn(CX, a, b) ==> embed(a, b::CPol(CX))$Xn(CX)

-- Now powersamba in extended form, i.e., with attached part (all cahed powers)
QXABn C ==> XEtaAlgebraBasis(C, Xn C)
QXREDn C ==> XEtaReduction(C, Xn C, QXABn C)
QXCOMPn C ==> XEtaComputation(C, Xn C, QXABn C, QXREDn C)
QXSAMBAn C ==> XEtaSambaPackage(C, Xn C, QXABn C, QXCOMPn C)

-- polyToA1C: Polynomial(C) -> A1(C)
-- polyToA1C(E1^12*E2^6+E1^24)
-- Translation of Ei variables to eta(i*tau) expansion.
-- Error if result has fractional q powers.
-- For fractional results use polynomialToEta(poly)$EQI(C).
polyToA1C poly ==> expansion(polynomialToEta(poly) $ EQI(C))

-- Create a Laurent polynomial ring
-- Implicit variable:
-- dim: number of variables of polynomial ring
DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

EVALRZ(vars, vals, pol) ==> _
    (eval((c:C):RZ +-> c, vars, vals)$PolynomialEvaluation(C, RZ))(pol)
EZ ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, EZ)

-- monRZ(l: List Z): RZ == monomial(1, directProduct(l)$DZ)
specMonRZ spec ==> monomial(1, directProduct(allPureExponents spec)$DZ)$RZ
monRZ(l) ==> monomial(1, directProduct(l)$DZ)$RZ

-- A "term" here is a coefficient (Integer) cons'd to a list of
-- exponents for every divisor of nn. See brunaultterms.

-- termRZ(term: List Z): RZ == monomial(first term, directProduct(rest term)$DZ)
termRZ(term) ==> monomial(first term, directProduct(rest term)$DZ)$RZ

-- polyRZ(terms: List List Z): RZ == reduce(_+, [termRZ x for x in terms], 0$RZ)
polyRZ(terms) ==> reduce(_+, [termRZ x for x in terms], 0$RZ)

algSUM(f, x) ==> reduce(_+, [f(mon) for mon in monomials x])

-- We assum that mon is such that degree(mon): DZ.
monToA1(C)(mon) ==> _
  leadingCoefficient(mon)*specMA1(C,MOD)(eqSPEC(nn, members degree mon))
monToAn(CX)(mon) ==> _
  leadingCoefficient(mon)*specMAn(CX,MOD)(eqSPEC(nn, members degree mon))

-- rzToA1CX: RZ -> A1 C
rzToA1(C)(x) ==> algSUM(monToA1(C), x)

-- rzToAnCX: RZ -> An CX
rzToAn(CX)(x) ==> algSUM(monToAn(CX), x)
