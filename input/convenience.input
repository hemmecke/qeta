-- This functions defined in this file assume that the missing values
-- for the macros in etamacros.input have been set.
-- In particular C, xiord, and CX, spitzen=CUSPS0(level).

-- The following function simply maps the integer coefficients of the
-- series into the localized coefficient domain or into the rational
-- number domain Q.

abfmap(A, B, f, x) ==> map(f, x)$QEtaLaurentSeriesFunctions2(A, B)
abffmap(A, B, f, x) ==> abfmap(A, B, f, x::L1(A))::A1(B)
abmap(A, B, x) ==> abffmap(A, B, (c: A): B +-> c::B, x)
zcmap(x) ==> abmap(Z, C, x)
cqmap(x) ==> abmap(C, Q, x)
zqmap(x) ==> abmap(Z, Q, x)


-------------------------------------------------------------------
-- Implicit global variables:
-- C: The coefficient ring where we consider the q-expansions.
specEQIC ==> specEQI C
specM0A1C ==> specM0A1 C -- was EQA1C

-------------------------------------------------------------------
-- Implicit global variables:
-- level:   We consider the modular group Gamma_0(level).
-- spitzen: The cusps at which to expand.
-- xiord:   We compute with the xiord-th root of unity
-- xi:      A xiord-th root of unity in CX
-- CX:      An C-Algebra containing xi.
-- Call macro EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi).
-------------------------------------------------------------------
QESX(C, CX) ==> QEtaSeriesExpansion(C, xiord, CX, xi)
An CX ==> ModularFunctionExpansionsAtCusps(CX, spitzen)

-------------------------------------------------------------------
-- Expansion of symbolic (generalized) eta-quotient into laurent series.
expandAnCX y ==> (laurentExpansions(y, spitzen)$QESX(C,CX))::An(CX)

-------------------------------------------------------------------
-- Creation of eta-quotient expansions at the cusps given by spitzen.
specYM0EQn spec ==> specYM0EQ(spec, spitzen)
specYM1GEQn spec ==> specYM1GEQ(spec, spitzen)

-------------------------------------------------------------------
-- Expansion of a specification int (generalized) eta-quotient into
-- laurent series.
specM0AnCX spec ==> expandAnCX specYM0EQn spec
specM1AnCX spec ==> expandAnCX specYM1GEQn spec

-------------------------------------------------------------------
CAn CX ==> QEtaAlgebraCachedPower(CX, An CX) -- domain in cached version
Xn CX ==> QEtaExtendedAlgebra(CX, CAn CX, CPol CX)
toXn(CX, a, b) ==> embed(a, b::CPol(CX))$Xn(CX)

-- Now powersamba in extended form, i.e., with attached part (all cahed powers)
QXABn C ==> XEtaAlgebraBasis(C, Xn C)
QXREDn C ==> XEtaReduction(C, Xn C, QXABn C)
QXCOMPn C ==> XEtaComputation(C, Xn C, QXABn C, QXREDn C)
QXSAMBAn C ==> XEtaSambaPackage(C, Xn C, QXABn C, QXCOMPn C)

-- polyToA1C: Polynomial(C) -> A1(C)
-- polyToA1C(E1^12*E2^6+E1^24)
-- Translation of Ei variables to eta(i*tau) expansion.
-- Error if result has fractional q powers.
-- For fractional results use polynomialToEta(poly)$EQI(C).
polyToA1C poly ==> expansion(polynomialToEta(poly) $ EQI(C))

-- Create a Laurent polynomial ring
-- Implicit variable:
-- dim: number of variables of polynomial ring
DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

EVALRZ(vars, vals, pol) ==> _
    (eval((c:C):RZ +-> c, vars, vals)$PolynomialEvaluation(C, RZ))(pol)
EZ ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, EZ)

-- monRZ(l: List Z): RZ == monomial(1, directProduct(l)$DZ)
specMonRZ spec ==> monomial(1, directProduct(allPureExponents spec)$DZ)$RZ
monRZ(l) ==> monomial(1, directProduct(l)$DZ)$RZ

-- A "term" here is a coefficient (Integer) cons'd to a list of
-- exponents for every divisor of level. See brunaultterms.

-- termRZ(term: List Z): RZ == monomial(first term, directProduct(rest term)$DZ)
termRZ(term) ==> monomial(first term, directProduct(rest term)$DZ)$RZ

-- polyRZ(terms: List List Z): RZ == reduce(_+, [termRZ x for x in terms], 0$RZ)
polyRZ(terms) ==> reduce(_+, [termRZ x for x in terms], 0$RZ)

algSUM(f, x) ==> reduce(_+, [f(mon) for mon in monomials x])

-- We assum that mon is such that degree(mon): DZ.
monToA1C(mon) ==> _
  leadingCoefficient(mon)*specM0A1C(eqSPEC(level, members degree mon))
monToAnCX(mon) ==> _
  leadingCoefficient(mon)*specM0AnCX(eqSPEC(level, members degree mon))

-- rzToA1CX: RZ -> A1 C
rzToA1C(x) ==> algSUM(monToA1C, x)

-- rzToAnCX: RZ -> An CX
rzToAnCX(x) ==> algSUM(monToAnCX, x)
