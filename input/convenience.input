-- This functions defined in this file assume that the missing values
-- for the macros in etamacros.input have been set.
-- In particular C, xiord, and CX, spitzen=cusps(level)$GAMMA0.

QEQEV ==> QEtaQuotientExponentVectors4ti2

-- The following function simply maps the integer coefficients of the
-- series into the localized coefficient domain or into the rational
-- number domain Q.

abfmap(A, B, f, x) ==> map(f, x)$QEtaLaurentSeriesFunctions2(A, B)
abffmap(A, B, f, x) ==> abfmap(A, B, f, x::L1(A))::A1(B)
abmap(A, B, x) ==> abffmap(A, B, (c: A): B +-> c::B, x)
zcmap(x) ==> abmap(Z, C, x)
cqmap(x) ==> abmap(C, Q, x)
zqmap(x) ==> abmap(Z, Q, x)

-- Implicit global variables:
-- C: The coefficient ring where we consider the q-expansions.
-- level: We consider the modular group Gamma_0(level).
YEQ1C(r) ==> etaQuotient(level, r)$EQI(C)
EQA1C(r) ==> expansion(YEQ1C r)::A1(C) -- expansion at infinity

-- Implicit global variables:
-- level:   We consider the modular group Gamma_0(level).
-- spitzen: The cusps at which to expand.
-- xiord:   We compute with the xiord-th root of unity
-- xi:      A xiord-th root of unity in CX
-- CX:      An C-Algebra containing xi.
-- Call macro EXTENDEDCOEFFICIENTRING(C, xiord, CX, xi).
YEQn(r) ==> etaQuotient(level, r, spitzen)$YEQ
EXPAND x ==> expansions(x::M0EQ(C, CX))::An(CX);
EQAnCX(r) ==> EXPAND YEQn r -- expansion at all cusps for moduler eta-quotients

YEQG1(l, g) ==> etaQuotient(level, l, g)$YEQG
EQGL1CX(l, g) ==> expansion(YEQG1(l, g)::EQG(C, CX))$EQG(C,CX)

-- polyToA1C: Polynomial(C) -> A1(C)
-- polyToA1C(E1^12*E2^6+E1^24)
-- Translation of Ei variables to eta(i*tau) expansion.
-- Error if result has fractional q powers.
-- For fractional results use polynomialToEta(poly)$EQI(C).
polyToA1C poly ==> expansion(polynomialToEta(poly) $ EQI(C))

PolC ==> Pol C
PolZ ==> Pol Z
FPZ ==> Fraction PolZ
PE ==> PolynomialEvaluation(Z, FPZ)
EVALFPZ(vars, vals, pol) ==> (eval((c:Z):FPZ +-> c, vars, vals)$PE)(pol)

asP x ==> x pretend P
asLP x ==> x pretend List(P)

-- Create a Laurent polynomial ring
-- Implicit variable:
-- dim: number of variables of polynomial ring
DN ==> HomogeneousDirectProduct(dim, N);
DZ ==> HomogeneousDirectProduct(dim, Z);
RZ ==> PolynomialRing(C, DZ)
toRZ x ==> (coerce(x)$PolynomialConversion(C, DN, esyms)) pretend RZ

PERZ ==> PolynomialEvaluation(C, RZ)
EVALRZ(vars, vals, pol) ==> (eval((c:C):RZ +-> c, vars, vals)$PERZ)(pol)
EZ ==> Monomials(dim, Z, DZ, esyms) -- show DirectProduct as monomials.
rez x ==> x pretend  PolynomialRing(C, EZ)

-- monRZ(l: List Z): RZ == monomial(1, directProduct(l)$DZ)
monRZ(l) ==> monomial(1, directProduct(l)$DZ)$RZ

-- A "term" here is a coefficient (Integer) cons'd to a list of
-- exponents for every divisor of level. See brunaultterms.

-- termRZ(term: List Z): RZ == monomial(first term, directProduct(rest term)$DZ)
termRZ(term) ==> monomial(first term, directProduct(rest term)$DZ)$RZ

-- polyRZ(terms: List List Z): RZ == reduce(_+, [termRZ x for x in terms], 0$RZ)
polyRZ(terms) ==> reduce(_+, [termRZ x for x in terms], 0$RZ)

ALGSUM(f, x) ==> reduce(_+, [f(mon) for mon in monomials x])

-- We assum that mon is such that degree(mon): DZ.
monToA1C(mon) ==> leadingCoefficient(mon)*EQA1C(members degree mon)
monToL1CX(mon, g) ==> leadingCoefficient(mon)*EQGL1CX(members degree mon, g)
monToAnCX(mon) ==> leadingCoefficient(mon)*EQAnCX(members degree mon)

-- rzToA1CX: RZ -> A1 C
rzToA1C(x) ==> ALGSUM(monToA1C, x)

-- rzToL1CX: (RZ, SL2Z) -> L1 CX
rzToL1CX(x, gamma) ==> ALGSUM(m +-> monToL1CX(m, gamma), x)

-- rzToAnCX: RZ -> An CX
rzToAnCX(x) ==> ALGSUM(monToAnCX, x)

TOMAT0(cusp) ==> cuspToMatrix(level, cusp)$GAMMA0
IMAT(mat) ==> inverse(mat)::MZ
