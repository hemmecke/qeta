-------------------------------------------------------------------
-- General macros for the compuation with eta quotions in the QEta package
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> display(([x::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 77)
vPrint(x,y)==>display(hconcat([x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF))::LinearOutputFormat,77)

-------------------------------------------------------------------
N ==> NonNegativeInteger
P ==> PositiveInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1

LSym ==> List Symbol

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [qcoerce(d)@P for d in divisors(m)$INTF]

-------------------------------------------------------------------
-- The following macros are parametrized by the coefficient domain C.
-------------------------------------------------------------------
-- related to Gröbner basis computation
-- The domain D (DirectProduct) has to be set to specify the term order.
-- The list of variables have to be given through `syms`.
Pol C  ==> Polynomial C
LPol C  ==> List Pol C

QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage;
WIDTH(nn, c) == qcoerce(width(nn, c)$QAuxMEQ)@P

-------------------------------------------------------------------
-- The type of laurent series that we use for expansion.
-- Should be possible to replace this with SparseUnivariateLaurentSeries.
-- However, our series are dense anyway.
-------------------------------------------------------------------
-- related to computation with eta quotients having poles only at infinity
LS C  ==> UnivariateLaurentSeries(C , 'q, 0);
F1 C ==> Finite0Series(C, 'q, 0) -- actual computation domain
ETA C  ==> EtaQuotient(C, F1 C)
toeta ==> toEta $ ETA(C)
CF1 C ==> QEtaAlgebraCachedPower(C, F1 C) -- computation domain (cached)
CPol C ==> QEtaAlgebraCachedPower(C, Pol C) -- computation pols in (cached)
X1 C ==> QEtaExtendedAlgebra(C, CF1 C, CPol C)
toX1(C, a, b) ==> embed(a::CF1(C), b::CPol(C))$X1(C)

-- We always use CachedPower versions
QAB1 C ==> QEtaAlgebraBasis(C, CF1 C)
QRED C ==> QEtaReduction(C, CF1 C, QAB1 C)
QCOMP C ==> QEtaComputation(C, CF1 C, QAB1 C, QRED C)
QSAMBA1 C ==> QEtaSambaPackage(C, CF1 C, QAB1 C, QCOMP C)

-- Now samba in extended form, i.e., with attached part (all cahed powers)
QXAB1 C ==> QEtaAlgebraBasis(C, X1 C)
QXRED C ==> QEtaReduction(C, X1 C, QXAB1 C)
QXCOMP C ==> QEtaComputation(C, X1 C, QXAB1 C, QXRED C)
QXSAMBA1 C ==> QEtaSambaPackage(C, X1 C, QXAB1 C, QXCOMP C)

-- The following macros yield samba with a zero-reduction test
-- before the reduction with attached part is repeated.
QFXRED C ==> QEtaExtendedReduction(C, CF1 C, X1 C, QXAB1 C)
QFXCOMP C ==> QEtaComputation(C, X1 C, QXAB1 C, QFXRED C)
QFXSAMBA1 C ==> QEtaSambaPackage(C, X1 C, QXAB1 C, QFXCOMP C)
-------------------------------------------------------------------
-- related to computation with eta quotients having poles at any cusp
-- Must set:
-- xiord: order of the root of unity
xisym: Symbol := "ξ"::Symbol;
UPxi C ==> UnivariatePolynomial(xisym, C);
SUPZ2SUP(C, x) ==> map(coerce, x)$SparseUnivariatePolynomialFunctions2(Z, C)
SUP2UP(C, x) ==> unmakeSUP(SUPZ2SUP(C, x))$UPxi(C)

-- minimal polynomial for n-th root of unity
MINROOTPOL(C, n) ==> SUP2UP(C, cyclotomic(n)$CyclotomicPolynomialPackage);
-- If xiord = 1 or 2 then set xi==>1 or xi==>-1 respectively and,
-- furthermore, CX ==> C.
-- Extension of C with n-th root of unity
UnityRootExtension(C, n) ==> _
    SimpleAlgebraicExtension(C, UPxi C, MINROOTPOL(C, n));

-------------------------------------------------------------------
-- TODO: The following macros must be made more parametrized.
-- Problem is that we need C, xiord, and xi.
LX ==> LS CX
YMSETAQ ==> SymbolicModularSiftedEtaQuotient;
YMSETAQG ==> SymbolicModularSiftedEtaQuotientGamma;
ETAQG ==> EtaQuotientGamma(C, xiord, CX, xi, LX);
METAQ ==> ModularEtaQuotient(C, xiord, CX, xi, LX)
SETAQG ==> SiftedEtaQuotientGamma(C, xiord, CX, xi, LX);
MSETAQ ==> ModularSiftedEtaQuotient(C, xiord, CX, xi, LX);
MODFUNX ==> ModularFunctionExpansions(CX, LX, nn);
Fn ==> MODFUNX
CFn ==> QEtaAlgebraCachedPower(CX, Fn) -- computation domain in cached version
PolCX ==> Polynomial CX
CPolCX ==> QEtaAlgebraCachedPower(CX, PolCX) -- computation with cached pols
Xn ==> QEtaExtendedAlgebra(CX, CFn, CPolCX);
toXn(a, b) ==> embed(a, b::CPolCX)$Xn
QABPn ==> XEtaSambaPackage(CX, Xn, XEtaComputation(CX, Xn))

-------------------------------------------------------------------
-- Auxiliary functions
-------------------------------------------------------------------
sigmaInfinity(divs: List P, s: List Z): Z == (_
  #divs ~= #s => error "sigmaInfinity: Lists have different lengths.";_
  shat: Z := 0;_
  for delta in divs for sdelta in s repeat shat := shat + delta * sdelta;_
  shat)
-------------------------------------------------------------------
smallerGrade?(x, y) == qetaGrade x < qetaGrade y
-------------------------------------------------------------------
