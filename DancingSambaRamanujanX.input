)set message type off
)set message time off
)r qetalibs )quiet
)r etamacros )quiet
)set stream calculate 2

OF==>OutputForm
dbgPrint(a, b) ==> MyPrint([a::Symbol::OF,b::OF]$List(OF)::OF)
MyPrint(x)==> print(x)

QMEVS==>QEtaQuotientMonoidExponentVectorsStar
eqmevs==>etaQuotientMonoidExponentVectors$QMEVS
eqmevx==>etaQuotientMonoidExponentVectorsX$QMEVS
lc ==> leadingCoefficient

S ==> Symbol
EZ ==> Expression Z
expr x ==> x :: S :: EZ
PL ==> PolynomialCategoryLifting(N, SingletonAsOrderedSet, C, PZ, PQ)
LX ==> UnivariateLaurentSeries(CX, xsym, 0)
EQX ==> EtaQuotientX(Q, mx, CX, xi, LX)
EQXA ==> EtaQuotientExpansionAlgebra(CX, LX, level)

PZ ==> SparseUnivariatePolynomial Z
PQ ==> SparseUnivariatePolynomial Q
Rec ==> Record(root: P, elem: PZ)

unityroots(m: P): List P == (_
  divs: List P := [qcoerce(delta)@P for delta in divisors m];_
  rs := eqmevx m;_
  l: List P := empty(); _
  for r in rs repeat (_
    e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
    l := cons(rootOfUnity e, l) _
  );_
  l_
)

)set message type on
)set message time on

-------------------------------------------------------------------
-------------------------------------------------------------------
-- Find idea how to modify the SAMBA algorithm.
-------------------------------------------------------------------
-------------------------------------------------------------------

-- compute the basis of eta quotients in terms of expansions
level := m := 22
mx: P := lcm unityroots(m)
if mx > 2 then (_
    pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage;_
    pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL;_
    CX := SimpleAlgebraicExtension(Q, PQ, pq);_
    xi := generator()$CX_
) else (_
    CX := Q;_
    xi := -1_
)
xsym: Symbol := "x"::Symbol
divs: List P := [qcoerce(d)@P for d in divisors m]
rs := eqmevx m
lse := [etaQuotient(m, divs, r)$ SymbolicEtaQuotient for r in rs];
le := [etaQuotient(e)$EQX for e in lse];
-- [etaQuotient(divs, r)$ETA for r in rs]
eas := [etaQuotient(r, expansions e)$EQXA for e in le for r in rs]
grds := [qetaGrades  ea for ea in eas]

-- set up structures for computation of algebraBasis

cusps: List Q := cuspsOfGamma0(level)
ncusps: P := qcoerce(#cusps)@P

F ==> EQXA
Y ==> XEtaComputation(CX, ncusps, F)
y := algebraBasisComputation(eas)$XEtaAlgebraBasis(CX, F, Y)
--[qetaGrades x for x in multipliers y]
--[qetaGrades x for x in basisElements y]

rgens := xetaQuotientMonoidExponentVectors level
Mlse := [etaQuotient(m, divs, r)$ SymbolicEtaQuotient for r in rgens];
Mle := [etaQuotient(e)$EQX for e in Mlse];
-- [etaQuotient(divs, r)$ETA for r in rs]
M := [etaQuotient(r, expansions e)$EQXA for e in Mle for r in rgens]
grds := [qetaGrades  ea for ea in M]


paper := 11^2*3068*M.7+ 11^2*(3*M.1+4236*1$F)*M.6 +11*(285*M.1+11*5972*1$F)*M.5+11/8*((M.1)^2+11*4497*M.1+11^2*3156*1$F)*M.4+11*(1867*M.1+11*2476*1$F)*M.3+(-11/8)*((M.1)^3+1011*(M.1)^2+11*6588*M.1+11^2*10880*1$F)

H ==> XHashTable(Z, List F)
V ==> Vector H
MUL ==> XHashTable(P, F)
FF ==> Record(f1: F, f2: F)
Products ==> XHashTable(Z, List FF)
Rec ==> Record(mul: MUL, be: V, ce: List F,_
                   havepairs?: Boolean, pairs: Products)
rec x ==> x pretend Rec
rec(y).be
rec(y).mul

[qetaGrades x for x in multipliers y]
[qetaGrades x for x in basisElements y]

rpaper := reduce(paper, rec(y).mul, rec(y).be)$XEtaReduction(CX, ncusps, F)
zero? rpaper
