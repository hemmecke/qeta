)r qetalibs
)r etamacros

OF==>OutputForm
dbgPrint(a, b) ==> MyPrint([a::Symbol::OF,b::OF]$List(OF)::OF)
MyPrint(x)==> print(x)

QMEVS==>QEtaQuotientMonoidExponentVectorsStar
eqmevs==>etaQuotientMonoidExponentVectors$QMEVS
eqmevx==>etaQuotientMonoidExponentVectorsX$QMEVS

S ==> Symbol
E ==> Expression Z
expr x ==> x :: S :: E
SymEtaMat ==> Record(symetaquo: SymbolicEtaQuotient, data: Matrix E)

rsr ==> rationalSquareRoot$QAuxiliaryModularEtaQuotientPackage
isr ==> squareRoot$QAuxiliaryModularEtaQuotientPackage
PZ ==> SparseUnivariatePolynomial Z
Rec ==> Record(root: P, elem: PZ)


symEtaMat(m: P, r: List Z): SymEtaMat == (_
  divs: List P := [qcoerce(d)@P for d in divisors m];_
  n: N := # divs; _
  cusps := cuspsOfGamma0 m;_
  nrows: N := 4 + n; _
  ncols: N := 2 + # cusps; _
  mat: Matrix E := new(nrows, ncols, 0); _
  mat(1, 1) := expr "cusps"; _
  mat(2, 1) := expr "order"; _
  mat(3, 1) := expr "roots"; _
  mat(4, 1) := expr "sqrtR"; _
  for i in 1..n for delta in divs repeat mat(i+4, 1) := delta :: E; _
  e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
  o := order e;_
  u := unityPower e;_
  f := rationalPrefactor e;_
  maxu := 1;_
  maxs := 1;_
  for j in 3..ncols for cusp in cusps repeat (_
    mat(1, j) := cusp; _
    mat(2, j) := o.cusp; _
    mat(3, j) := u.cusp; maxu := lcm(maxu, denom(u.cusp)); _
    mat(4, j) := sqrt(f.cusp); _
    for i in 1..n for delta in divs repeat (_
      mat(i+4, j) := xvdelta(e, cusp, delta) _
    );_
    rr: Record(rat: Q, rootOf: P) := rsr(f.cusp); _
    z: P := rr.rootOf; _
    maxs := lcm(maxs, minSquareRootOfUnity z) _
  );_
  mat(1, 2) := if maxu < maxs then -1 else 0; _
  mat(2, 2) := rootOfUnity e; _
  mat(3, 2) := maxu; _
  mat(4, 2) := maxs; _
  [e, mat] _
)

-------------------------------------------------------------------

demo(m) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmev m;_
  for r in rs repeat he.r := dem(m, r);_
  he_
)

demos(m) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmevs m;_
  dbgPrint("EQMEVS", rs);_
  for r in rs repeat he.r := dem(m, r);_
  he_
)

demox(m: P): XHashTable(List Z, SymbolicEtaQuotient) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmevx m;_
  dbgPrint("EQMEVX", rs);_
  for r in rs repeat (_
    emat := symEtaMat(m, r);_
    he.r := emat.symetaquo;_
    dbgPrint("============================================= r", r);_
    MyPrint((emat.data)::OF)_
  );_
  he_
)

-------------------------------------------------------------------

roottest(m: P): Set Z== (_
  he: XHashTable(List Z, Z) := empty();_
  rs := eqmevx m;_
  dbgPrint("EQMEVX", rs);_
  for r in rs repeat (_
    emat := symEtaMat(m, r);_
    dbgPrint("============================================= r", r);_
    mat: Matrix E := emat.data; _
    mat := mat(1..4, 1..2);_
    he.r := mat(1, 2)::Z;_
    MyPrint((mat)::OF)_
  );_
  set parts he_
)

unityroots(m: P): List P == (_
  divs: List P := [qcoerce(delta)@P for delta in divisors m];_
  rs := eqmevx m;_
  l: List P := empty(); _
  for r in rs repeat (_
    e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
    l := cons(rootOfUnity e, l) _
  );_
  l_
)


squaretest(y: P): P == (_
  b:= minSquareRootOfUnity y;_
  pz := cyclotomic(b)$CyclotomicPolynomialPackage;_
  CX ==> SimpleAlgebraicExtension(Z, PZ, pZ);_
  g := generator()$CX;_
  s := squareRoot(y)$GaussRoot(CX, g, b);_
  retract(s*s)@Z_
 )

m := 25
mx: P := lcm unityroots(m)
PQ ==> SparseUnivariatePolynomial Q
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage
PL ==> PolynomialCategoryLifting(N,SingletonAsOrderedSet, C, PZ, PQ)
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL
CX := SimpleAlgebraicExtension(Q, PQ, pq)
xsym: Symbol := "x"::Symbol
LX := UnivariateLaurentSeries(CX, xsym, 0)
xi := generator()$CX
EQX := EtaQuotientX(Q, mx, CX, xi, LX)
divs: List P := [qcoerce(d)@P for d in divisors m]
rs := eqmevx m
lse: List SymbolicEtaQuotient := [etaQuotient(m, divs, r) for r in rs];
le: List EQX := [etaQuotient(e)$EQX for e in lse];
[etaQuotient(divs, r)$ETA for r in rs]

cs: List Q := cusps(lse.1)
r: List P := [qcoerce(t)@P for t in members(vector rs.1 + vector rs.2)]
sesum := etaQuotient(m, divs, r);
esum := etaQuotient(sesum)$EQX;
lesum := le.1 * le.2
cmp(x: EQX, y: EQX, n: P, cusp: Q): Boolean == (_
  ex:=expansion(x, cusp); _
  ey:=expansion(y, cusp); _
  ox: Z := order(ex);_
  oy: Z := order(ey);_
  ox ~= oy => false;_
  for k in ox..ox+n repeat if ex.k ~= ey.k then return false;_
  return true_
)
[cmp(esum, lesum, 20, cusp) for cusp in cs]
