)r qetalibs
)r etamacros
)set stream calculate 2

OF==>OutputForm
dbgPrint(a, b) ==> MyPrint([a::Symbol::OF,b::OF]$List(OF)::OF)
MyPrint(x)==> print(x)

QMEVS==>QEtaQuotientMonoidExponentVectorsStar
eqmevs==>etaQuotientMonoidExponentVectors$QMEVS
eqmevx==>etaQuotientMonoidExponentVectorsX$QMEVS
lc ==> leadingCoefficient

S ==> Symbol
EZ ==> Expression Z
expr x ==> x :: S :: EZ
SymEtaMat ==> Record(symetaquo: SymbolicEtaQuotient, data: Matrix EZ)
PL ==> PolynomialCategoryLifting(N, SingletonAsOrderedSet, C, PZ, PQ)
LX ==> UnivariateLaurentSeries(CX, xsym, 0)
EQX ==> EtaQuotientX(Q, mx, CX, xi, LX)
EQXA ==> EtaQuotientExpansionAlgebra(CX, LX, level)


rsr ==> rationalSquareRoot$QAuxiliaryModularEtaQuotientPackage
isr ==> squareRoot$QAuxiliaryModularEtaQuotientPackage
PZ ==> SparseUnivariatePolynomial Z
PQ ==> SparseUnivariatePolynomial Q
Rec ==> Record(root: P, elem: PZ)


symEtaMat(m: P, r: List Z): SymEtaMat == (_
  divs: List P := [qcoerce(d)@P for d in divisors m];_
  n: N := # divs; _
  cusps := cuspsOfGamma0 m;_
  nrows: N := 4 + n; _
  ncols: N := 2 + # cusps; _
  mat: Matrix EZ := new(nrows, ncols, 0); _
  mat(1, 1) := expr "cusps"; _
  mat(2, 1) := expr "order"; _
  mat(3, 1) := expr "roots"; _
  mat(4, 1) := expr "sqrtR"; _
  for i in 1..n for delta in divs repeat mat(i+4, 1) := delta :: EZ; _
  e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
  o := order e;_
  u := unityPower e;_
  f := rationalPrefactor e;_
  maxu := 1;_
  maxs := 1;_
  for j in 3..ncols for cusp in cusps repeat (_
    mat(1, j) := cusp; _
    mat(2, j) := o.cusp; _
    mat(3, j) := u.cusp; maxu := lcm(maxu, denom(u.cusp)); _
    mat(4, j) := sqrt(f.cusp); _
    for i in 1..n for delta in divs repeat (_
      mat(i+4, j) := xvdelta(e, cusp, delta) _
    );_
    rr: Record(rat: Q, rootOf: P) := rsr(f.cusp); _
    z: P := rr.rootOf; _
    maxs := lcm(maxs, minSquareRootOfUnity z) _
  );_
  mat(1, 2) := if maxu < maxs then -1 else 0; _
  mat(2, 2) := rootOfUnity e; _
  mat(3, 2) := maxu; _
  mat(4, 2) := maxs; _
  [e, mat] _
)

-------------------------------------------------------------------

demo(m) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmev m;_
  for r in rs repeat he.r := dem(m, r);_
  he_
)

demos(m) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmevs m;_
  dbgPrint("EQMEVS", rs);_
  for r in rs repeat he.r := dem(m, r);_
  he_
)

demox(m: P): XHashTable(List Z, SymbolicEtaQuotient) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmevx m;_
  dbgPrint("EQMEVX", rs);_
  for r in rs repeat (_
    emat := symEtaMat(m, r);_
    he.r := emat.symetaquo;_
    dbgPrint("============================================= r", r);_
    MyPrint((emat.data)::OF)_
  );_
  he_
)

-------------------------------------------------------------------

roottest(m: P): Set Z== (_
  he: XHashTable(List Z, Z) := empty();_
  rs := eqmevx m;_
  dbgPrint("EQMEVX", rs);_
  for r in rs repeat (_
    emat := symEtaMat(m, r);_
    dbgPrint("============================================= r", r);_
    mat: Matrix EZ := emat.data; _
    mat := mat(1..4, 1..2);_
    he.r := mat(1, 2)::Z;_
    MyPrint((mat)::OF)_
  );_
  set parts he_
)

unityroots(m: P): List P == (_
  divs: List P := [qcoerce(delta)@P for delta in divisors m];_
  rs := eqmevx m;_
  l: List P := empty(); _
  for r in rs repeat (_
    e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
    l := cons(rootOfUnity e, l) _
  );_
  l_
)

squaretest(y: P): P == (_
  b:= minSquareRootOfUnity y;_
  pz := cyclotomic(b)$CyclotomicPolynomialPackage;_
  g := generator()$CX;_
  s := squareRoot(y)$GaussRoot(CX, g, b);_
  retract(s*s)@Z_
 )


-------------------------------------------------------------------
-------------------------------------------------------------------
-- Find idea how to modify the SAMBA algorithm.
-------------------------------------------------------------------
-------------------------------------------------------------------

--- level 4 -------------------------------------------------------
-- compute the basis of eta quotients in terms of expansions
level := m := 60
mx: P := lcm unityroots(m)
if mx > 2 then (_
    pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage;_
    pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL;_
    CX := SimpleAlgebraicExtension(Q, PQ, pq);_
    xi := generator()$CX_
) else (_
    CX := Q;_
    xi := -1_
)
xsym: Symbol := "x"::Symbol
divs: List P := [qcoerce(d)@P for d in divisors m]
rs := eqmevx m
lse := [etaQuotient(m, divs, r)$ SymbolicEtaQuotient for r in rs];
le := [etaQuotient(e)$EQX for e in lse];
-- [etaQuotient(divs, r)$ETA for r in rs]
eas := [etaQuotient(r, expansions e)$EQXA for e in le for r in rs]
grds := [qetaGrades  ea for ea in eas]

-- set up structures for computation of algebraBasis

cusps: List Q := cuspsOfGamma0(level)
ncusps: P := qcoerce(#cusps)@P

F ==> EQXA
Y ==> XEtaComputation(CX, ncusps, F)
y := algebraBasisComputation(eas)$XEtaAlgebraBasis(CX, F, Y)
[qetaGrades x for x in multipliers y]
[qetaGrades x for x in basisElements y]
)fin









-- Try to run some samba-like procedure
t1 := eas.1; t2:=eas.3; t3:=eas.2;
c := [eas.4];
p := empty()$List EQXA
s := empty()$List EQXA
bas := [1$EQXA]
u := first c, c := rest c
[[orders x for x in p], [orders u], [orders x for x in bas]]
v := u + (-16)*t1 + (-1)*bas.1 --- 1 + [- 16, 24, - 8] - 16 [- 8, 0, 8]

p := concat [[b1*b2 for b2 in rest bas] for b1 in rest bas]
[[orders x for x in p], [orders u], [orders x for x in bas]]

[orders(t) for t in [t1,t2,t3]]
p := [t1*t2, t1*t3, t2*t3]
u := first p, p := rest p
v := 16*u + t2 + (-1) * bas.1 -- - 1 + 16 [8, - 24, 16] + [16, - 24, 8]
[[orders x for x in p], [orders u], [orders x for x in bas]]

u := first p, p := rest p
v := u + (-1) * bas.1 -- 0
[[orders x for x in p], [orders u], [orders x for x in bas]]

u := first p, p := rest p
v := u + 16*t2 + (-1)*t3 --  - [8, 0, - 8] + [24, - 24, 0] + 16 [16, - 24, 8]
[[orders x for x in p], [orders u], [orders x for x in bas]]
)endif
--- end level 4 ---------------------------------------------------


)fin


--- level 25 -------------------------------------------------------
--)if LEVEL25
-- compute the basis of eta quotients in terms of expansions
level := m := 25
mx: P := lcm unityroots(m)
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL
xsym: Symbol := "x"::Symbol
xi := generator()$CX
divs: List P := [qcoerce(d)@P for d in divisors m]
rs := eqmevx m
lse := [etaQuotient(m, divs, r)$ SymbolicEtaQuotient for r in rs];
le := [etaQuotient(e)$EQX for e in lse];
-- [etaQuotient(divs, r)$ETA for r in rs]
eas := [etaQuotient(r, expansions e)$EQXA for e in le for r in rs]
grds := [qetaGrades ea for ea in eas]
cusps := cuspsOfGamma0(m)

products(l: List EQXA): List EQXA == (_
  empty? l => [1];_
  u := first l; ll := rest l;_
  empty? ll => [u*u];_
  l1 := [u*v for v in l];_
  l2 := products rest l;_
  concat!(l1, l2)_
)

)fin

-- Try to run some samba-like procedure
t := [eas.1, eas.3, eas.2];
c := [eas.4];
p := empty()$List EQXA
s := empty()$List EQXA
bas := [1$EQXA]
u := first c, c := rest c
[[orders u], [orders x for x in t], [orders x for x in p], [orders x for x in bas]]
v := u + (-25)*t.1 + (-1)*t.3
t := concat(t, v);

p := products t;
[[orders u, orders v], [orders x for x in t], [orders x for x in p], [orders x for x in bas]]

u := first p; p := rest p;
v := u + (-1)*t.1^2

u := first p; p := rest p;
v := u + (-leadingCoefficient(u,2)/leadingCoefficient(t.2,2))*t.2

[[orders u, orders v], [orders x for x in t], [orders x for x in p], [orders x for x in bas]]

t := concat(t, v)

-- reduce an element from the t basis
u := t.2
v := u + (-1)*lc(u,3)/lc(t.5,3)*t.5
t := concat(t, v);

[[orders u, orders v], [orders x for x in t], [orders x for x in p], [orders x for x in bas]]

p := rest p;

u := t.1
v := u + (-1)*lc(u,1)/lc(t.4,1)^2*t.4^2
v := v + (-1)*lc(v,1)/lc(t.4,1)*t.4
v := v + (-1)*lc(v,6)/lc(t.3,6)*t.3
v := v + 1/25*bas.1 -- zero

[[orders u, orders v], [orders x for x in t], [orders x for x in p], [orders x for x in bas]]

--)endif
--- end level 25 ---------------------------------------------------
