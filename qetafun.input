)r qetalibs
)r etamacros

OF==>OutputForm
dbgPrint(a, b) ==> MyPrint([a::Symbol::OF,b::OF]$List(OF)::OF)
MyPrint(x)==> print(x)

QMEVS==>QEtaQuotientMonoidExponentVectorsStar
eqmevs==>etaQuotientMonoidExponentVectors$QMEVS
eqmevx==>etaQuotientMonoidExponentVectorsX$QMEVS

S ==> Symbol
EZ ==> Expression Z
expr x ==> x :: S :: EZ
SymEtaMat ==> Record(symetaquo: SymbolicEtaQuotient, data: Matrix EZ)
PL ==> PolynomialCategoryLifting(N, SingletonAsOrderedSet, C, PZ, PQ)
CX ==> SimpleAlgebraicExtension(Q, PQ, pq)
LX ==> UnivariateLaurentSeries(CX, xsym, 0)
EQX ==> EtaQuotientX(Q, mx, CX, xi, LX)
EQXA ==> EtaQuotientExpansionAlgebra(CX, LX, level)


rsr ==> rationalSquareRoot$QAuxiliaryModularEtaQuotientPackage
isr ==> squareRoot$QAuxiliaryModularEtaQuotientPackage
PZ ==> SparseUnivariatePolynomial Z
PQ ==> SparseUnivariatePolynomial Q
Rec ==> Record(root: P, elem: PZ)


symEtaMat(m: P, r: List Z): SymEtaMat == (_
  divs: List P := [qcoerce(d)@P for d in divisors m];_
  n: N := # divs; _
  cusps := cuspsOfGamma0 m;_
  nrows: N := 4 + n; _
  ncols: N := 2 + # cusps; _
  mat: Matrix EZ := new(nrows, ncols, 0); _
  mat(1, 1) := expr "cusps"; _
  mat(2, 1) := expr "order"; _
  mat(3, 1) := expr "roots"; _
  mat(4, 1) := expr "sqrtR"; _
  for i in 1..n for delta in divs repeat mat(i+4, 1) := delta :: EZ; _
  e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
  o := order e;_
  u := unityPower e;_
  f := rationalPrefactor e;_
  maxu := 1;_
  maxs := 1;_
  for j in 3..ncols for cusp in cusps repeat (_
    mat(1, j) := cusp; _
    mat(2, j) := o.cusp; _
    mat(3, j) := u.cusp; maxu := lcm(maxu, denom(u.cusp)); _
    mat(4, j) := sqrt(f.cusp); _
    for i in 1..n for delta in divs repeat (_
      mat(i+4, j) := xvdelta(e, cusp, delta) _
    );_
    rr: Record(rat: Q, rootOf: P) := rsr(f.cusp); _
    z: P := rr.rootOf; _
    maxs := lcm(maxs, minSquareRootOfUnity z) _
  );_
  mat(1, 2) := if maxu < maxs then -1 else 0; _
  mat(2, 2) := rootOfUnity e; _
  mat(3, 2) := maxu; _
  mat(4, 2) := maxs; _
  [e, mat] _
)

-------------------------------------------------------------------

demo(m) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmev m;_
  for r in rs repeat he.r := dem(m, r);_
  he_
)

demos(m) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmevs m;_
  dbgPrint("EQMEVS", rs);_
  for r in rs repeat he.r := dem(m, r);_
  he_
)

demox(m: P): XHashTable(List Z, SymbolicEtaQuotient) == (_
  he: XHashTable(List Z, SymbolicEtaQuotient) := empty();_
  rs := eqmevx m;_
  dbgPrint("EQMEVX", rs);_
  for r in rs repeat (_
    emat := symEtaMat(m, r);_
    he.r := emat.symetaquo;_
    dbgPrint("============================================= r", r);_
    MyPrint((emat.data)::OF)_
  );_
  he_
)

-------------------------------------------------------------------

roottest(m: P): Set Z== (_
  he: XHashTable(List Z, Z) := empty();_
  rs := eqmevx m;_
  dbgPrint("EQMEVX", rs);_
  for r in rs repeat (_
    emat := symEtaMat(m, r);_
    dbgPrint("============================================= r", r);_
    mat: Matrix EZ := emat.data; _
    mat := mat(1..4, 1..2);_
    he.r := mat(1, 2)::Z;_
    MyPrint((mat)::OF)_
  );_
  set parts he_
)

unityroots(m: P): List P == (_
  divs: List P := [qcoerce(delta)@P for delta in divisors m];_
  rs := eqmevx m;_
  l: List P := empty(); _
  for r in rs repeat (_
    e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
    l := cons(rootOfUnity e, l) _
  );_
  l_
)

squaretest(y: P): P == (_
  b:= minSquareRootOfUnity y;_
  pz := cyclotomic(b)$CyclotomicPolynomialPackage;_
  g := generator()$CX;_
  s := squareRoot(y)$GaussRoot(CX, g, b);_
  retract(s*s)@Z_
 )






-------------------------------------------------------------------
-------------------------------------------------------------------
-- Find idea how to modify the SAMBA algorithm.
-------------------------------------------------------------------
-------------------------------------------------------------------

--- level 4 -------------------------------------------------------
)if LEVEL4
-- compute the basis of eta quotients in terms of expansions
level := m := 4
mx: P := lcm unityroots(m)
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL
xsym: Symbol := "x"::Symbol
xi := generator()$CX
divs: List P := [qcoerce(d)@P for d in divisors m]
rs := eqmevx m
lse := [etaQuotient(m, divs, r)$ SymbolicEtaQuotient for r in rs];
le := [etaQuotient(e)$EQX for e in lse];
-- [etaQuotient(divs, r)$ETA for r in rs]
eas := [etaQuotient(r, expansions e)$EQXA for e in le for r in rs]
ords := [orders ea for ea in eas]

-- Try to run some samba-like procedure
t1 := eas.1; t2:=eas.3; t3:=eas.2;
c := [eas.4];
p := empty()$List EQXA
s := empty()$List EQXA
bas := [1$EQXA]
u := first c, c := rest c
[[orders x for x in p], [orders u], [orders x for x in bas]]
v := u + (-16)*t1 + (-1)*bas.1 --- 1 + [- 16, 24, - 8] - 16 [- 8, 0, 8]

p := concat [[b1*b2 for b2 in rest bas] for b1 in rest bas]
[[orders x for x in p], [orders u], [orders x for x in bas]]

[orders(t) for t in [t1,t2,t3]]
p := [t1*t2, t1*t3, t2*t3]
u := first p, p := rest p
v := 16*u + t2 + (-1) * bas.1 -- - 1 + 16 [8, - 24, 16] + [16, - 24, 8]
[[orders x for x in p], [orders u], [orders x for x in bas]]

u := first p, p := rest p
v := u + (-1) * bas.1 -- 0
[[orders x for x in p], [orders u], [orders x for x in bas]]

u := first p, p := rest p
v := u + 16*t2 + (-1)*t3 --  - [8, 0, - 8] + [24, - 24, 0] + 16 [16, - 24, 8]
[[orders x for x in p], [orders u], [orders x for x in bas]]
)endif
--- end level 4 ---------------------------------------------------



--- level 6 -------------------------------------------------------
--)if LEVEL6
-- compute the basis of eta quotients in terms of expansions
level := m := 6
mx: P := lcm unityroots(m)
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL
xsym: Symbol := "x"::Symbol
xi := generator()$CX
divs: List P := [qcoerce(d)@P for d in divisors m]
rs := eqmevx m
lse := [etaQuotient(m, divs, r)$ SymbolicEtaQuotient for r in rs];
le := [etaQuotient(e)$EQX for e in lse];
-- [etaQuotient(divs, r)$ETA for r in rs]
eas := [etaQuotient(r, expansions e)$EQXA for e in le for r in rs]
ords := [orders ea for ea in eas]
)fin

-- Try to run some samba-like procedure
t := [eas.1, eas.3, eas.2, eas.4];
c := [eas.5, eas.6];
p := empty()$List EQXA
s := empty()$List EQXA
bas := [1$EQXA]
u := first c, c := rest c
[[orders x for x in p], [orders u], [orders x for x in bas]]
v := u + (-9)*t.2 + 8*bas.1 -- 8 + [9, - 9, - 3, 3] - 9 [1, - 5, 5, - 1]

u := first c, c := rest c
v := u + (-9)*t.1 + (-1)*bas.1 -- - 1 + [- 9, 9, 3, - 3] - 9 [- 5, 1, - 1, 5]
orders v

p := concat [[t1*t2 for t2 in t] for t1 in t]; #p
[[orders x for x in p], [orders u], [orders x for x in bas]]
p := rest p;

u := first c, c := rest c
v := u + (-9)*t.1 + (-1)* bas.1 -- - 1 + [- 9, 9, 3, - 3] - 9 [- 5, 1, - 1, 5]

--)endif
--- end level 6 ---------------------------------------------------
