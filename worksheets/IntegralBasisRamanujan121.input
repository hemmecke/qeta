-- # Compute integral basis for $M^\infty(121)$

-- Compute integral basis for N=121 by adding to the generators of the
-- eta quotients of level 121 having only poles at infinity the
-- p(11n+6) generating series and a series coming from the trace of a
-- modular eta quotient for N=242 of order -15.

-- ## Init

)clear completely
)set output linear on
)set output algebra off
)cd /home/hemmecke/g/qeta/tmp
)set mess type off

)r projectlibs )quiet
)r etamacros.input )quiet
C ==> Q;
CF ==> CF1 C
X ==> X1 C

)r ../input/tracemacros )quiet

nn: P := 121; -- level
nndivs := DIVISORS nn;

xiord: P := 2;
xi := -1;
CX := Q;
)r ../input/convenience )quiet

-- We do expansion at the cusp $\infty$ which corresponds to $1/N$ or to `1/nn` in terms of our session variables.

)set mess time on
)set mess type on
)set output linear off
)set output algebra on
)set stream calculate 2

QEQMEV ==> QEtaQuotientMonoidExponentVectors4ti2
eqmev ==> etaQuotientMonoidExponentVectors $ QEQMEV
rgens := eqmev nn;
eqgens := [retract(etaQuotient(nndivs, r)$ETA C) for r in rgens]

-- ## `xab`=samba($t, \{u\}$) --- Samba with T and U

-- The generators of the $\eta$-quotients of level 121 are given by these exponents for the $\eta$ functions (with arguments being the divisors of 121).
-- The variable `rgens` corresponds to the generators of $R^\infty(121)$.

xgens := [toX1(C, eqgens.1, 'T), toX1(C, eqgens.2, 'U)]

-- We take a minimal (in terms the order in q) element from the generators and make it special.b
-- Then we compute an algebra basis for $C[T,U]$.

xt: X := xgens.1; xu := xgens.2;

xab := samba(xt, xgens, 0, onet1Step!)$QXSAMBA1(C)
# basis xab, [qetaGrade x for x in basis xab]

genus := genusOfGamma0 121

-- Let's set new variables for each series in the basis.

bsyms := indexedSymbols("B", # basis xab);
xabbasis := [toX1(C, first x, s) for x in basis xab for s in bsyms];
nog := numOfGaps(xab)
xabb := samba(xt, xabbasis, nog)$QXSAMBA1(C);

-- With this number of gaps (96), we have not yet reached the
-- genus of the modular curve. Thus we must find another modular
-- function.

-- # Series H: N=242, r=[6, - 3, - 1, 1, 5, - 8]

-- We can generate a new modular function by applying the trace to
-- a modular function from $M^\infty(242)$.

-- ## Atkin-Lehner involution $W_2^{242}$

-- The trace
-- $\mathrm{tr}_{121}^{242}: M^\infty(242) \to M^\infty(121)$
-- is given through the Atkin-Lehner involution.
-- See, for example, \cite{Kohnen:WeierstrassPointsAtInfinity:2004}.
--
-- In our case we have
-- $$f|\mathrm{tr}_{121}^{242} = f + 2 f|W_2^{242}|U_2$$
-- where
-- $$
-- W_2^{242}=
-- \begin{pmatrix}
-- 2 & -1\\
-- 242 & -120
-- \end{pmatrix}
-- $$
-- is given below and $U_2$ is the operator described
-- in `qetafun.spad`.
--
-- We can split $W_2^{242}$ into an element of $SL_2(\mathbb{Z})$
-- and a triangular matrix.

alw := matrix [[2, -1], [242, -120]]
sm := splitMatrix(alw(1,1), alw(1,2), alw(2,1), alw(2,2))
gamma := sm.red;

-- The second matrix just corresponds to going from $\tau$ to $2\tau$.
-- In other words,
-- $$
-- (f|\mathrm{tr}_{121}^{242})(\tau)
-- = f(\tau) + 2 (f_{\gamma,2}|U_2)(\tau)
-- $$
-- where $f_{\gamma,2}(\tau) := (f|\gamma)(2\tau)$.

w := WIDTH(242, gamma(2,1))

-- The width of the Atkin-Lehner involution $W_2^{242}$ is 2,
-- so the resulting series will be in $q^{1/w}$ which together with
-- the above $\tau\mapsto 2\tau$ neutalizes and we can simply read
-- the resulting series as a series in $q$.

-- ## Series coming from $N=242$

-- Since we can only compute with series coming from eta quotients, we
-- temporarily switch to level 242 and take the trace of a series from
-- there.

divs242 := DIVISORS 242;
rgens242 := etaQuotientMonoidExponentVectors(242)$QEQMEV;
egens242 := [(retract etaQuotient(divs242, r)$ETA(Z))::F1(C) for r in rgens242];
[qetaGrade(x) for x in egens242];

-- For all the series we compute that we need at most a second root of unity, i.e. we continue our computation in $C=\mathbb{Q}$.

[minimalRootOfUnity etaQuotient(242, divs242, r, gamma) for r in rgens242]

CX := Q;
xiord := 2;
xi := -1; -- a second root of unity

-- We have tried to compute the algebra basis for N=121 with
-- the addition of one of the series coming from the N=242
-- generators and found that the eta quotient corresponding to
-- the third vector, namely $(6, -3, -1, 1, 5, -8)$ works best
-- in the sense that it yields a basis with number of gaps equal
-- to 6 whereas for other indices we get bases with a higher
-- number of gaps.
--
-- $1 = (-1, 2, 0, 0, 1, -2) \to 8$,
-- $2 = (0, 0, 7, -3, 3, -7) \to 31$,
-- $3 = (6, -3, -1, 1, 5, -8) \to 6$,
-- $4 = (0, 0, -4, 8, 4, -8) \to 31$,
-- $5 = (7, -3, -1, 1, 4, -8) \to 6$.

-- Thus, we have chosen the third vector which gives a
-- series of order -55.

r242   := rgens242.3
eqt242 := egens242.3

-- Below we use the functions from `qetafun.spad`.

-- Since internally the computation of `eqt242` is done by a different function, we first check that we optain the same result when the transformation is the identity matrix.

idgamma: SL2Z := matrix [[1,0],[0,1]];
yeq242: YETAQG := etaQuotient(242, divs242, r242, idgamma);
modular? yeq242

eq242 := (expansion(etaQuotient(yeq242)$ETAQG))::F1(C)

zero?(eqt242-eq242)

yeq242g: YETAQG := etaQuotient(242, divs242, r242, gamma);
eq242g := (expansion(etaQuotient(yeq242g)$ETAQG))::F1(C)

-- Now we apply the $U_2$ operator.

ordu2eq242g := (order(eq242g)/2)::Z -- series starts at this order
u2eq242g := choose((n: Z): Z +-> 2*n, eq242g, ordu2eq242g)

-- Similar computation with other (sifted) domain.
-- This is another check that we have no bug in the
-- implementation.

yseq242g: YSETAQG := etaQuotient(242, divs242, r242, 1, 0, gamma);
seq242g := puiseux(yseq242g, w)$SETAQG

-- Due to implementation as Laurent series, the above series is computed with $q$ standing for $q^{24}$. The result, however, says (den=24) that we should consider it as a series in $q=(q^{24})^{1/24}$.

-- We additionally apply the $U_2$ operator (factor 2 below).

eseq242g := expansion(seq242g)
ordseq242g := (order eseq242g / 24 / 2)::Z
u2seq242g := choose((n: Z): Z +-> 2*24*n, eseq242g, ordseq242g)::F1(C)

[coefficient(u2eq242g - u2seq242g, i) for i in 0..100]

-- u2eq242g represents $f|W_2^{242}|U_2$.

-- Now we compute $f + 2 f|W_2^{242}|U_2$.

cftraceeq242 := (eq242 + 2*u2eq242g)::CF

xh: X := toX1(C, cftraceeq242, 'H);

-- ## Using $\gamma_1$ and $\gamma_2$

-- By multiplying out the Atkin-Lehner involution, we get
-- $$
-- f|\mathrm{tr}_{121}^{242} = f + f|\gamma_1 + f|\gamma_2
-- $$
-- where
-- $$
-- \gamma_1 = 
-- \begin{pmatrix}
-- 1 & -1\\
-- 121 & -120
-- \end{pmatrix}
-- \qquad
-- \gamma_2 = 
-- \begin{pmatrix}
-- 1 & 0\\
-- 121 & 1
-- \end{pmatrix}
-- $$
-- are both elements of $SL_2(\mathbb{Z})$.

gamma1 := matrix [[1, -1], [121,-120]]; splitMatrix(gamma1, 1)
gamma2 := matrix [[1,  0], [121,   1]]; splitMatrix(gamma2, 1)

-- By using $\gamma_1$ and $\gamma_2$ we get:

yeq242g1: YETAQG := etaQuotient(242, divs242, r242, gamma1);
eq242g1 := (expansion(etaQuotient(yeq242g1)$ETAQG))::F1(C)
yeq242g2: YETAQG := etaQuotient(242, divs242, r242, gamma2);
eq242g2 := (expansion(etaQuotient(yeq242g2)$ETAQG))::F1(C)
eq242g1+eq242g2

eq242 := (expansion(etaQuotient(yeq242)$ETAQG))::F1(C)

xhh := toX1(C, eq242 + eq242g1 + eq242g2, 'HH)

-- GO ON HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

yseq242g: YSETAQG := etaQuotient(242, divs242, r242, 2, 0, gamma);
seq242g := puiseux(yseq242g, 2)$SETAQG
eseq242g := expansion(seq242g)
ordseq242g := (order eseq242g / 24)::Z
u2seq242g := choose((n: Z): Z +-> 24*n, seq242g, ordseq242g)::F1(C)

ordseq242g := (order eseq242g / 24 / 2)::Z











-- ## `cfhab`=samba($t, \{u, h\}$)

-- Now we can add this element to the algebra basis computed earlier
-- and hope that we end with a algebra basis for all modular functions
-- of level 121, i.e., $M^\infty(121)$.

cft := first xt
xtracebas := [xt, xu, xh]
cftracebas := [first x for x in xtracebas];


genus

cfhab := samba(cft, cftracebas, genus, cfonet1Step!)$QSAMBA1(C);


cfhab

nog := numOfGaps(cfhab)

-- ## xhab=samba($t, \{u,h\}$)

xtracebas := [xt, xu, xh]


xhab := samba(xt, xtracebas, genus, onet1Step!)$QXSAMBA1(C);


# basis xhab
grades := [qcoerce(qetaGrade x)@P for x in basis xhab]
numOfGaps(xhab)

-- ## Denominator polynomial for $h$ with respect to `xab`

-- We try to find a polynomial $d(t)$ such that .. see below.

e1:=29; e2:=129
rs := [reduce(xt^e1*xh, xab)$QXRED(C)];
for i in e1+1..e2 repeat (_
  print(i);_
  rs := cons(reduce(xt*first(rs), xab)$QXRED(C), rs))
rs := reverse! rs;
[qetaGrade x for x in rs]
[variables(second(x)::Pol(C)) for x in rs]
[coefficient(second(x)::Pol C, H, 1) for x in rs]

l := [[qetaCoefficient(first x, i) for i in 0..191] for x in rs];

-- Extract the 192 coefficients corresponding to the orders $-191, \ldots, 0$ and compute the kernel of the corresponding matrix.

mat := transpose matrix l;
[nrows mat, ncols mat]
ns := nullSpace mat;
#ns

-- Extract the coefficients from the vector in the nullspace.

cs := members first ns;

-- Check that the resulting vector indeed yields a relation.

lincomp := [c*rr for c in cs for rr in rs];
lc := reduce(_+, lincomp);
zero? lc
qetaCoefficient(lc, 0)

-- Indeed, we have just shown a relation for
-- $t^{39}h-h_{39}, \ldots, t^{129}h-h_{129}$.
--
-- In the second component of this "zero" is it's relation in terms of $H$, $T$, and $U$.
-- The "denominator polynomial" is given by the coefficient of $H$.

d := (second lc)::Pol C;
variables d
[degree(d, x) for x in variables d]

-- ### Computation of the corresponding polynomials $d_0,..,d_4$

-- In order to find the respective cofactors to the $c_1$
-- from above, we must do the whole computation with
-- different attached values, namely $T$, and $U$
-- for the elements in basis `xab`.

c1:=coefficient(p,H,1);
c0:=coefficient(p,H,0);

variables c0
vars := reverse! rest variables c0
c0s := [coefficient(c0, x, 1) for x in vars];
degree(c1, T), [degree(x, T) for x in c0s]
gcd cons(c1,c0s)

-- Apart from the $t^{39}$ factor, we get other factors.

fl := factorList factor c1;
[x.exponent for x in fl]
flfactors := [x.factor for x in fl]

-- ## Try to reduce the order -15 element that comes from level 242

r242_1 := rgens242.1

eqt242_1 := (retract etaQuotient(divs242, r242_1)$ETA(Z))::F1(C)

yeq242_1g: YETAQG := etaQuotient(242, divs242, r242_1, gamma);
eq242_1g := (expansion(etaQuotient(yeq242_1g)$ETAQG))::F1(C);

ordh2eq242_1g := (order(eq242_1g)/2)::Z
h2eq242_1g := choose((n: Z): Z +-> 2*n, eq242_1g, ordh2eq242_1g)

cftraceeq242_1 := (eqt242_1 + 2*h2eq242_1g)::CF

xh_1 := toX1(C, cftraceeq242_1, 'H1)
xr_1 := reduce(xh_1, xhab)$QXRED(C);
zero? xr_1
[coefficient(first(xr_1)::F1(C), i) for i in -30..30]

-- Note that the `zero?` function only tests negative coefficients. That is not sufficient here, otherwise we could "prove" that some function is a modular function for $\Gamma_0(121)$ when it is actually not.

xh_h := toX1(C, eqt242_1, 'HH)
xr_h := reduce(xh_h, xhab)$QXRED(C);
zero? xr_h
[coefficient(first(xr_h)::F1(C), i) for i in -30..3]

-- However, we see it more easily by reducing the product with
-- $t$ by the algebra basis.

xr_th := reduce(xt*xh_h, xhab)$QXRED(C);
first xr_th
zero? xr_th

-- # Series F: $p(11n+6)$ generating series

-- Now we consider an additional series. Here we take the series corresponding to the $p(11n+6)$ problem.

mm: P := 11; s: List Z := [-1, 0]; m: P := 11;
mmdivs: List P := DIVISORS mm
shat: Z := sigmaInfinity(mmdivs, s)
orbs := [orb for tt in 0..m-1 | (orb := orbit(shat,m,tt); one? # orb)]
t: N := first first orbs
r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)$QEtaModularFunctionTools

-- Let's compute the expansion of
-- $$
-- F(\tau) = q^{\frac{13}{24}}
--           \frac{\eta(\tau)^{11} \eta(11\tau)}{\eta(121\tau)^{11}}
--           \sum_{k=0}^{\infty}p(11k+6)q^k.
-- $$

)set output linear on
)set output algebra off

ff := zcmap modularSiftedPartitionSeries(121, m, t);
xf := toX1(C, ff, F)

-- The generating series does not reduce to zero modulo the
-- algebra basis `xab`, but it does modulo the basis `xuab`.

m,t
xr := reduce(xf, xab)$QXRED(C);
zero? xr

xr

xfr := reduce(xf, xhab)$QXRED(C);
zero? xfr

-- Note the the relation looks pretty ugly. Coefficients are too big.

-- ## Compute denominator polynomial for integral basis

-- We only need the coefficients of the pricipal part of
-- $t^{37} f-h_{37}, \ldots, t^{102}f-h_{102}$
-- where $h_i \in \langle 1, b_1, b_2, b_3, b_4 \rangle_{C[t]}$
-- in order to find a relation among these $q$-series.
--
-- Note that $t$ corresponds to our variable `xt` and $b_1,\ldots,b_4$ to our basis `abex`.
--
-- Then $t^i f - h_i$ corresponds to `reduce(xt^i xf, xt, xabb)`.
--
-- Note that the result $r$ contains in its second component its representation in terms of the given $F$, and the $B_i$.

e1:=37; e2:=102
rs := [reduce(xt^e1*xf, xabb)$QXRED(C)];
for i in e1+1..e2 repeat (_
  print(i);_
  rs := cons(reduce(xtt*first(rs), xabb)$QXRED(C), rs))
rs := reverse! rs;
[qetaGrade x for x in rs]

[coefficient(second(x)::Pol C, F, 1) for x in rs]

-- Extract the 192 coefficients corresponding to the orders $-191, \ldots, 0$ and compute the kernel of the corresponding matrix.

l := [[qetaCoefficient(first x, i) for i in 0..191] for x in rs];
mat := transpose matrix l;
ns := nullSpace mat;
#ns

-- Extract the coefficients from the vector in the nullspace.

cs := members first ns;

-- Check that the resulting vector indeed yields a relation.

lincomp := [c*rr for c in cs for rr in rs];
lc := reduce(_+, lincomp);
zero? lc

qetaCoefficient(lc, 0)

-- Indeed, we have just shown a relation for
-- $t^{37} f-h_{37}, \ldots, t^{102}f-h_{102}$.
--
-- In the second component of this "zero" is it's relation in terms of $F$, $B_1$, $B_2$, $B_3$, and $B_4$.
-- The "denominator polynomial" is given by the coefficient of $F$.

pf := (second lc)::Pol C;
variables pf
[degree(pf, x) for x in variables pf]

-- ### Computation of the corresponding polynomials $d_0,..,d_4$

-- In order to find the respective cofactors to the `c1` from above, we must do the whole computation with different attached values, namely T, and B1, B2, B3, B4, for the elements in basis `ab`.

c1f:=coefficient(pf,F,1);
c0f:=coefficient(pf,F,0);

variables c0f
vars := reverse! rest variables c0f
c0fs := [coefficient(c0f, x, 1) for x in vars];
degree(c1f, T), [degree(x, T) for x in c0fs]
gcd cons(c1f,c0fs)

-- Apart from the $t^{37}$ factor, we get other factors.

flf := factorList factor c1f;

[x.exponent for x in flf]
flffactors := [x.factor for x in flf]

-- There is one factor that is not already a factor of `c1f`.

[x for x in flfactors | not member?(x, flffactors)]

)set mess type on
)set output linear off
)set output algebra on

den := lcm [denom leadingCoefficient x for x in monomials c1f];
gcd(den, 121)

d := (-den * c1f/T^37)::Pol(Z); degree(d)

c00f := ((den*coefficient(c0f, vars, [0 for i in vars]))/T^37)::Pol(Z);

dis := cons(c00f, [(den*(x/T^37))::Pol(Z) for x in c0fs]);

[[unit factor(di), degree(di,T)] for di in dis]



-- ## Express $p(T)F$ in terms of $T$, $B_1, \ldots, B_4$

xd := eval(d, (c:Z):X +-> c*1$X, ['T], [xt])$PolynomialEvaluation(Z, X);
first xd
xdf := xd*xf;
xdf2 := second(xdf)::Pol(Q);
dfint := coefficient(xdf2, F, 1)::Pol(Z);
zero?(dfint-p)

xdfredb := reduce(xdf, xabb)$QXRED(C);
zero? xdfredb

xdfredb2 := second(xpfredb)::Pol(Q);
d0frat := coefficient(xdfredb2, F, 0)::Pol(Q); -- the representation
d1frat := coefficient(xdfredb2, F, 1)::Pol(Q); -- the poly d
dend1f := (denom d1frat)::Z;
p1fint :=(dend1f * d1frat)::Pol(Z);
zero?(d1fint - d)

factorList factor dend1f

dend0f := (denom d0frat)::Z;
d0fint :=(dend0f * d0frat)::Pol(Z);

factorList factor dend0f

-- Now compute the respective $d_0, \ldots, d_4$ as integer polynomials.

xabbas := basis xabb

11 * xabbas.3 - (xgens.2-xt^10)

vars

d00f := ((dend1f*coefficient(d0frat, vars, [0 for i in vars])))::Pol(Z);
d0fs := [(dend1f*coefficient(d0frat, x, 1))::Pol(Z) for x in vars];
ds := cons(d00f, d0fs);

[[unit factor x, degree x] for x in ds]

-- Unfortunately, because of the relation for `xabbas.2` above these factors of 11 are not enough.

[factorList factor x for x in ds]

-- ## Express $d(T)F$ in terms of $T$ and $U$

xdfred := reduce(xdf, xab)$QXRED(C);
zero? xdfred

-- Because of the factor 11 in `xgens.2 - xgens.1^10`, we need here a prefactor of 11^3 to make the result an integer polynomial.
--
-- That makes it clear that without the localization trick, we have no relation that demonstrates that $p(11n+6)$ is divisible by 11.

xdfred2 := second(xdfred)::Pol(Q);
xd0frat := coefficient(xdfred2, F, 0)::Pol(Q); -- the representation
xd0fint :=(11^3*dend1f * xd0frat)::Pol(Z);

[(c := coefficient(xd0fint, 'U, i); [#factorList factor c, degree(c,T)]) for i in 0..4]
qetaGrade(xu)

invxp := 1/(first(xd)::F1(Q));
ft := first(xt)::F1(Q);
fs := first(xu)::F1(Q);
invxd*fs^0*ft^65
invxd*fs^1*ft^55
invxd*fs^2*ft^45
invxd*fs^3*ft^35
invxd*fs^4*ft^25


xpfrep := eval(xd0fint, (c:Z):X +-> c*1$X, ['T, 'U], xgens)$PolynomialEvaluation(Z, X);

xf5 := xf^5-161051*xu^5*xt^4

xj0

xjp := reduce(xj2*xp, xab)$QXRED(C)

zero? xjp

xpfrepfred := reduce(xj0, xab)$QXRED(C);

xpfrepred

zero? xpfrepfred

q := (monomial(1,1)$F1(Q))^(-1);
xq: X := embed(q, 'Q::Pol(Q))
reduce(xq^0*xpfrep, xab)$QXRED(C)

xpf2red := reduce(xt^66*xf, xab)$QXRED(C);
zero? xpf2red

xf

-- ## Polynomial for $F^2$

e1:=37; e2:=102
rs2 := [reduce(xt^e1*xf^2, xabb)$QXRED(C)];
for i in e1+1..e2 repeat (_
  print(i);_
  rs2 := cons(reduce(xtt*first(rs2), xabb)$QXRED(C), rs2))
rs2 := reverse! rs2;
[qetaGrade x for x in rs2]

[coefficient(second(x)::Pol C, F, 2) for x in rs2]

l := [[qetaCoefficient(first x, i) for i in 0..191] for x in rs2];
mat2 := transpose matrix l;
ns2 := nullSpace mat2;
#ns2

cs2 := members first ns2;

)set mess time on

lincomp := [c*rr for c in cs2 for rr in rs2];
lc2 := reduce(_+, lincomp);
zero? lc2

pf2 := (second lc2)::Pol C;
variables pf2
[degree(pf2, x) for x in variables pf2]

c21f:=coefficient(pf2,F,2);
c20f:=coefficient(pf2,F,0);

variables c20f
vars := reverse! rest variables c20f
c20fs := [coefficient(c20f, x, 1) for x in vars];
degree(c21f, T), [degree(x, T) for x in c20fs]
gcd cons(c21f,c20fs)

flf2 := factorList factor c21f;

[x.exponent for x in flf2]
flf2factors := [x.factor for x in flf2]

[x-y for x in flffactors for y in flf2factors]

(factorList factor c20fs.1).2

(factorList factor c0fs.1).2









-- # cffab=samba($t$, $\{u, f\}$)

cft := first xt;
xfgens := [xt, xu, xf]
cffgens := [first x for x in xfgens];

-- We know already that the number of gaps will be 31.

cffab := samba(cft, cffgens, 31, cfonet1Step!)$QSAMBA1(C);
grades := [qcoerce(qetaGrade x)@P for x in basis cffab]
nog := numOfGaps(cffab)

xfab := samba(xt, xfgens, 31, onet1Step!)$QXSAMBA1(C);

-- # Add F-expansion at 1 instead of $\infty$

QEQMEVS ==> QEtaQuotientMonoidExponentVectorsStar
eqmevx ==> etaQuotientMonoidExponentVectorsX$QEQMEVS
eqmev ==> etaQuotientMonoidExponentVectors$QEQMEV

-- With the cofactor eta quotient corresponding to $r=(11,1,-11)$, we get a modular function for the generating function of $p(11n+6)$ that only has a pole at infinity (corresponding to the cusp $\frac{1}{121}$).

nn, r, mm, s, m, t

fGrades := qetaGrades(nn, r, mm, s, m, t);
[fGrades.cusp for cusp in cuspsOfGamma0(nn)]

-- A basis for the monoid of all modular eta quotients is given by the following exponent vectors, which in turn correspond to expansions with the following grades. (Note that our concept of grade corresponds to the negated order of the series.)

rs1 := eqmevx nn
rGrades :=[qetaGrades(nn, r1, mm, [0,0], 1, 0) for r1 in rs1];
[[h.cusp for cusp in cuspsOfGamma0(nn)] for h in rGrades]

-- Thus by multiplying $f$ with 11 times the eta quotient corresponding to $(-1,0,1)$, we get a modular function that only has a pole of order 55 at the cusp 1.

r1 := members(vector r + 11 * vector rs1.1)
f1Grades := qetaGrades(nn, r1, mm, s, m, t);
[f1Grades.cusp for cusp in cuspsOfGamma0(nn)]

-- Let's compute the expansion of $F_1(\gamma_1\tau)$ for the modular function
--
-- $$
-- F_1(\tau) = q^{\frac{13}{24}}
--             \eta(11\tau)^{11}
--             \sum_{k=0}^{\infty}p(11k+6)q^k
-- $$
-- where
-- $$
-- \gamma_1 = \begin{pmatrix} 1 & -1 \\ 1 & 0 \end{pmatrix}
-- $$
-- corresponds to the cusp at 1.

)if false
yf1 := etaQuotient(nn, r1, mm, s, m, t)$YMSETAQ;
xiord: P := minimalRootOfUnity yf1
CX := UnityRootExtension(C, xiord);
xi := generator()$CX;
af: MSETAQ :=  expandAtAllCusps yf1;
qetaGrades(expansions(af)::MODFUNX)
xaf := (expansions(af).1)::F1(CX)
map(retract, xaf)$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)
)endif

)set stream calc 2
CX := Q

)r ../input/convenience

expansionAtCusp(nn, r, mm, s, m, t, cusp) == _
    expansionModularSiftedEtaQuotientGamma(nn, r, mm, s, m, t, cuspToMatrix(nn, cusp)$QAuxMEQ)


xf1 := toX1(C, expansionAtCusp(nn, r1, mm, s, m, t, 1), 'F1)

xt

xf1bas := [xt, xgens.2, xf1]

xf1ab := samba(xtt, xf1bas, genus, onet1Step!)$QXSAMBA1(C);

# basis xf1ab

[first x for x in basis xf1ab]

grades1 := [qcoerce(qetaGrade x)@P for x in basis xf1ab]

nog := numberOfGaps(qetaGrade xt, grades1)

xff1bas := [xtt, xgens.2, xf1, xf]

xff1ab := samba(xtt, xf1bas, genus, onet1Step!)$QXSAMBA1(C);

gradesff1 := [qcoerce(qetaGrade x)@P for x in basis xff1ab]

nog := numberOfGaps(qetaGrade xt, gradesff1)

-- +
rs1 := eqmev nn

rs2 := [members(- vector x) for x in rs1]
-- -
-- # Add Klein's $j$-invariant


-- First expand $j(\tau)$ and $j(11\tau)$ at every cusp of $\Gamma_0(121)$.

rgens := etaQuotientMonoidExponentVectors(nn)$QEtaQuotientMonoidExponentVectors4ti2
ys := [etaQuotient(nn, r, 1, [0], 1, 0) for r in rgens];
xiord := max [minimalRootOfUnity x for x in ys]

CX := UnityRootExtension(C, xiord);
xi := generator()$CX;

fs := [expandAtAllCusps(x)$MSETAQ for x in ys];
ms := [expansions(x)::MODFUNX for x in fs];
[qetaGrades x for x in ms]

)r ../input/convenience

mj0 := kleinJn(nn, 11^0); qetaGrades mj0
mj1 := kleinJn(nn, 11^1); qetaGrades mj1
mj2 := kleinJn(nn, 11^2); qetaGrades mj2

mmj0 := mj0*ms.1^25*ms.2;   qetaGrades mmj0
mmj1 := mj1*ms.1^3 *ms.2^3; qetaGrades mmj1
mmj2 := mj2*ms.1   *ms.2;   qetaGrades mmj2

toF1C x ==> map(retract, series(x, 12)::F1(CX))$Finite0SeriesFunctions2(CX, C, 'q, 'q, 0, 0)

xj0 := toX1(C, toF1C mmj0,T^25*U*J0)
xj1 := toX1(C, toF1C mmj1, T^3*U^3*J1)
xj2 := toX1(C, toF1C mmj2, T*U*J2)

-- ## Compute samba with $j_0$, $j_1$, and `xgens`

-- Unfortunately the following basis computation only leads to number of gaps = 31.
--
-- We do not compute with the extended basis, since then the computation takes quite some time (1440 seconds) to reduce the representation part.
--
-- Since we already know that the computation will end with a basis having gap number 31, we can abort the computation when we have reached a basis with gap number 31.

gens := concat([xj0, xj1], xgens)

cfjab := samba(first xt, [first x for x in gens], 31, cfonet1Step!)$QSAMBA1(C)

grades := [qcoerce(qetaGrade x)@P for x in basis cfjab]
numOfGaps(cfjab)

-- ## Compute samba with $j_0$, $j_2$, and `xgens`

-- Computing with $j(121\tau)$ instead of $j(11\tau)$ leads to an integral basis with gap number 6.

gens := concat([xj0, xj2], xgens)

-- With aborting the computation when we have reached gap number = genus, it takes about 400 seconds to compute this basis.

xjab := samba(xt, gens, genus, onet1Step!)$QXSAMBA1(C);

grades := [qcoerce(qetaGrade x)@P for x in basis xjab]
numOfGaps(xjab)

xjabbas := basis xjab;
b1 := xjabbas.4;
b2 := xjabbas.3;
b3 := xjabbas.2;
b4 := xjabbas.1;
bpols := [second(x)::Pol(Q) for x in [b1, b2, b3, b4]];
varlists := [variables x for x in bpols]

[[d for x in monomials bpols.i|(d := degree(x,T); d)] for i in 1..4]

[d for x in monomials bpols.4|(d := degree(x,[T, U, J0, J2]); d.2=0)]

[d for x in monomials bpols.4|(d := degree(x,[T, U, J0, J2]); d.4>0)]


gens









-- # nthRoot and functional inverse

)clear completely
)cd /home/hemmecke/g/qeta/tmp
)set mess type off
)r projectlibs )quiet
)r etamacros.input )quiet
)set output linear off
)set output algebra on
)set stream calculate 20
)set mess time on
C ==> Q
CF ==> CF1 C
X ==> X1 C
xiord := 5;
CX := UnityRootExtension(C, xiord)
xi := generator()$CX
)r ../input/convenience
)r ../input/tracemacros
)set mess type on

nn: P := 22; -- level
nndivs := DIVISORS nn;
rgens := etaQuotientMonoidExponentVectors(nn)$QEQMEV
eqgens := [retract(etaQuotient(nndivs, r)$ETA(Z)) for r in rgens];
t := (eqgens.1)::F1(C)

p := nthRoot(t, 5)
px := map(coerce, p)$Finite0SeriesFunctions2(C, CX, 'q, 'q, 0, 0)
ix := 1/px
qx: F1(CX) := monomial(1,1)

h := qx*px
g := laurent(0, lagrange(taylorRep h))$F1(CX)

qs := [g(xi^i * ix) for i in 0..5];
qs.1

reduce(_+, qs,0)













-- # Investigate another $f_2$ whose generating series corresponds to $c(11n+1)$

-- The first $f$ had used the parameter $s=(-1,0)$.

s

-- Now we use a function corresponding to the vector $s_2 =(-2,0)$.
-- As can be seen below, that function already lives in the module generated by $F$ and the original generators $M_1$ and $M_2$.

s2 := [-2,0]
shat2: Z := sigmaInfinity(mmdivs, s2)
orbs2 := [orb for tt in 0..m-1 | (orb := orbit(shat2,m,tt); one? # orb)]
t2: N := first first orbs2
r2: List Z := etaCoFactorInfinity(nn, mm, s2, m, t2)$QEtaModularFunctionTools

ps2: LZ := ps^2
r112: LZ := choose((n: Z): Z +-> m*n+t2, ps2, 0)
ecfz2 := etaQuotient(nndivs, r2)$EtaQuotient(Z, LZ)

expectedGrade := qetaGrades(nn, r2, mm, s2, m, t2).(1/nn)
qfactor2 := ((qetaGrade series ecfz2)-expectedGrade)*24 - prefactor ecfz2

pf2Z := retract(q24(qfactor2)$EtaQuotient(Z, LZ) * ecfz2);
fe2z := r112 * pf2Z;
fe2 := zcmap fe2z;
f2x: X := xembed(fe2, F)

r2x: X := reduce(f2x, tx, abfx);
zero? r2x

-- # Yet another try with $f_{11}$ corresponding to $p(121n+116)$

mm: P := 121; s: List Z := [-1, 0, 0]; m: P := 121;
mmdivs: List P := DIVISORS mm
shat: Z := sigmaInfinity(mmdivs, s)
orbs := [orb for tt in 0..m-1 | (orb := orbit(shat,m,tt); one? # orb)]
t: N := first first orbs
r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)$QEtaModularFunctionTools


ff2 := zcmap modularSiftedPartitionSeries(121, m, t);
xf2 := toX1(C, ff2, F2)

-- We reduce first by `xab` and only then by `xfab`.

cfbas := [first x for x in basis xab]
cfab := samba(first xt, cfbas, 96, cfonet1Step!)$QSAMBA1(C);

red121 := reduce(first xf2, cfab)$QRED(C);
zero? red121

qetaGrade red121

red121f := reduce(red121, cffab)$QRED(C);
zero? red121f

red121f

[factor numer qetaCoefficient(xf2, i) for i in 598..604]

factor 83416057119615

1










-- # Algebraic Curve setup

h := etaQuotientIdealGenerators(nn, rgens)$QEtaIdeal(C, L0);
variables h
#h
gb := groebner(h);

dis := eval(discriminant(first gb, M2), M1=T);

disfl := factorList factor dis;
#disfl

[x.exponent for x in disfl]
[degree(x.factor, T) for x in disfl]
disflfactors := [x.factor for x in disfl]

(flfactors = [disflfactors.i for i in [1,2,3,4,7,8]])@Boolean

-- Additional factors in the discriminant.

disflfactors.5,disflfactors.6





-- ## Try with built-in AlgebraicFunctionField

U ==> UnivariatePolynomial('M1, Q)
UU ==> UnivariatePolynomial('M2, Fraction U)
modulus: UU := gb.1::UU;
AFF ==> AlgebraicFunctionField(Q, U, UU, modulus)

basis()$AFF

1--genus()$AFF

1--integralBasis()$AFF

-- Maybe our denominator comes from the fact that our basis is not given in terms of
-- $[1, M_2, M_2^2, M_2^3, M_2^4]$ but in the following representation.

[second x for x in abex]

[reduce((xeqgens.2)^i, tex, [tex]) for i in 1..4]



reduce((xeqgens.2)^2, tex, [tex])

((196-1) + (147-2) + (98-3) + (49-4))/5

xfr
