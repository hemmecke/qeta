)r qetalibs
)r etamacros
)set stream calculate 10

QMEVS==>QEtaQuotientMonoidExponentVectorsStar;
eqmevx==>etaQuotientMonoidExponentVectorsX$QMEVS;

S ==> Symbol;
EZ ==> Expression Z;
expr x ==> x :: S :: EZ;
SymEtaMat ==> Record(symetaquo: SymbolicEtaQuotient, data: Matrix EZ);
PL ==> PolynomialCategoryLifting(N, SingletonAsOrderedSet, C, PZ, PQ);
CX ==> SimpleAlgebraicExtension(Q, PQ, pq);
LX ==> UnivariateLaurentSeries(CX, xsym, 0);
EQX ==> EtaQuotientX(Q, mx, CX, xi, LX);
EQXA ==> EtaQuotientExpansionAlgebra(CX, LX, level);

PZ ==> SparseUnivariatePolynomial Z;
PQ ==> SparseUnivariatePolynomial Q;
Rec ==> Record(root: P, elem: PZ);

unityroots(m: P): List P == (_
  divs: List P := [qcoerce(delta)@P for delta in divisors m];_
  rs := eqmevx m;_
  l: List P := empty(); _
  for r in rs repeat (_
    e := etaQuotient(m, divs, r)$SymbolicEtaQuotient;_
    l := cons(rootOfUnity e, l) _
  );_
  l_
);

level := m := 22;
mx: P := lcm unityroots(m);
pz: PZ := cyclotomic(mx)$CyclotomicPolynomialPackage;
pq: PQ := map(n+->monomial(1$Q,1$N)$PQ, c+->c::Q::PQ, pz)$PL;
xsym: Symbol := "x"::Symbol;
xi := generator()$CX;
divs: List P := [qcoerce(d)@P for d in divisors m];
rs := eqmevx m;
lse := [etaQuotient(m, divs, r)$SymbolicEtaQuotient for r in rs]
le := [etaQuotient(e)$EQX for e in lse];
eas := [etaQuotient(r, expansions e)$EQXA for e in le for r in rs];
ords := [orders ea for ea in eas]

vPrint("OUTPUT STARTS HERE", level)
vPrint("level", level)
vPrint("divisors", divs)
vPrint("exponent vectors", rs)
vPrint("maximal root of unity", mx)
vPrint("Expansion at cusps", cuspsOfGamma0 m)

eas
