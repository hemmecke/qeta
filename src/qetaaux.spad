-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Auxiliary functions}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The packages \code{QEtaAuxiliaryPackage} contains helper functions.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

First of all for debugging.
)endif
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
%$
These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- will be a square matrix
MQ ==> Matrix Q -- matrixEtaOrder
SL2Z ==> MZ -- represents SL_2(Z)
EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)
Rec ==> Record(red: SL2Z, triang: MZ)
Pol ==> SparseUnivariatePolynomial Z
LZ ==> List Z
LLZ ==> List LZ

INTF ==> IntegerNumberTheoryFunctions

asN x ==> x pretend N
asP x ==> x pretend P

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaAuxiliaryPackage: Check modularity of
  eta-quotients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we mainly deal with the sets $R^*(N)$ and $R^\infty(N)$ from
\cite{HemmeckeRadu_EtaRelations_2019}.

The function \code{matrixLigozat} computes the respective matrix $A_N$
whereas \code{modularGamma0} checks which of the conditions for an $r$
vector to correspond to a modular eta-quotient is violated.


)endif

)abbrev package QETAAUX QEtaAuxiliaryPackage
++ QEtaAuxiliaryPackage helps to do computations with
++ eta-quotients that are modular functions.
QEtaAuxiliaryPackage: with
    matrixAtkinLehner: (P, P) -> MZ
      ++ matrixAtkinLehner(m, t) with t a Hall divisor
      ++ (https://en.wikipedia.org/wiki/Hall_subgroup) of m returns
      ++ the 2x2 matrix with entries [[t, -a], [m, t*b]] such that
      ++ n=m/t and t*b + n*a = 1, see
      ++ \cite{Kohnen_WeierstrassPointsAtInfinity_2004}.
    modularGamma0: (P, List Z) -> Z
      ++ modularGamma0(nn, r) returns 0 if all conditions are
      ++ fulfilled. Otherwise it returns a positive number in the
      ++ range 1 to 4 that corresponds to the condition that is not
      ++ met. This corresponds to the conditions given for
      ++ R(N,i,j,k,l) on page 226 of \cite{Radu_RamanujanKolberg_2015}
      ++ and to the conditions \eqref{eq:sum=0},
      ++ \eqref{eq:sigmainfinity}, \eqref{eq:sigma0}, and
      ++ \eqref{eq:productsquare} in qeta.tex.
      ++ It is equivalent to check whether there is an extension v of r
      ++ such that matrixModular(nn)*v is 0.
    modularGamma0?: (P, List Z) -> Boolean
      ++ modularGamma0(nn, r) returns true iff the eta-quotient
      ++ corresponding to r is a modular function for Gamma_0(nn). It
      ++ is equivalent to zero?(modularGamma0(nn, r)).
    jacobiLowerStar: (Z, Z) -> Z
      ++ See, for example, Definition 2.26 in the PhD thesis of Silviu Radu.
      ++ http://www3.risc.jku.at/publications/download/risc_5453/main.pdf
    jacobiUpperStar: (Z, Z) -> Z
      ++ See, for example, Definition 2.26 in the PhD thesis of Silviu Radu.
      ++ http://www3.risc.jku.at/publications/download/risc_5453/main.pdf
    upsilonExponent: (Z, Z, Z, Z) -> Z
      ++ upsilonExponent(a,b,c,d) returns z \in {0..23} such that
      ++ exp(\pi*i*z/12) is a multiplier in the transformation of an
      ++ eta-function by the matrix [[a,b],[c,d]] from SL_2(Z).
      ++ A definition can be found in \cite[Lemma~2.27]{Radu_PhD_2010}.
    upsilonExponent: MZ -> Z
      ++ upsilonExponent(m) for a matrix m from SL_2(Z) returns
      ++ upsilonExponent(m(1,1), m(1,2), m(2,1), m(2,2)).
    numberOfGaps: (P, List P) -> N
      ++ numberOfGaps(n, l) computes
      ++ reduce(+, [floor(x/n) for x in l], 0).
    splitMatrix: (SL2Z, Z, P, N) -> Rec
      ++ splitMatrix(mat, delta, m, lambda) computes
      ++ splitMatrix(a, b, c, d) where the arguments are the matrix
      ++ entries of matrix [[delta, delta*lambda], [0, m]]*mat.
      ++ Input condition: determinant(mat)>0.
    splitMatrix: (SL2Z, Z) -> Rec
      ++ splitMatrix(mat, delta) computes splitMatrix(mat, delta, 1, 0).
      ++ Input condition: determinant(mat)>0.
    splitMatrix: (Z, Z, Z, Z) -> Rec
      ++ splitMatrix(a, b, c, d) returns a record rec that contains
      ++ two matrices rec.red=m1 and rec.triang=m2 such that mat=m1*m2
      ++ according to \cide[Lemma~4.8]{Radu_PhD_2010}, but in a variation
      ++ as described in qeta.tex, i.e., such that 0<=m2(1,2)<det(mat)/g
      ++ where g = gcd(a, c) and mat=[[a,b],[c,d]].
      ++ Input condition: a*d-b*c>0.
    rationalSquareRoot: Q -> Record(rat: Q, rootOf: P)
      ++ if z = rationalSquareRoot(x) then x = (z.rat)^2 * z.root
    minimalSquareRootOfUnity: P -> P
      ++ minimalSquareRootOfUnity(p) returns an integer n such that
      ++ in Z(x) (where x is a primitive n-th root of unity) there
      ++ exists an element y such that y^2=p.
      ++ p must be a radical integer, i.e., should not contain the
      ++ square of a prime.
    fractionalPart: Q -> Q
      ++ fractionalPart(x) returns x - floor(x)::Fraction(Integer).
    fractionalBernoulli1: Q -> Q
      ++ fractionalBernoulli1(x) computes t - 1/2 where t is the
      ++ fractional part of x, i.e., t = x - floor(x)
    fractionalBernoulli2: Q -> Q
      ++ fractionalBernoulli2(x) computes t^2 - t + 1/6 where t is the
      ++ fractional part of x, i.e., t = x - floor(x)
    sawTooth: Q -> Q
      ++ sawTooth(x) is 0 if x is an integer and
      ++ fractionalBernoulli1(x) otherwise.
    dedekindSum: (Z, Z) -> Q
       ++ dedekindSum(p,q) returns for two relatively prime integers
       ++ p and q the Dedekind sum as defined by
       ++ dedekindSum(p,q)=sum(sawTooth(1/q)*sawTooth(p*i/q), i=1..q-1).
    generalizedDedekindSum: (P, Z, Z, Z, Z) -> Q
       ++ generalizedDedekindSum(nn,g,h,p,q) returns the generalized
       ++ Dedekind sum as defined in
       ++ \cite[p~673]{Yang:GeneralizedDedekindEtaFunctions} by
       ++ generalizedDedekindSum(nn,g,h,p,q) =
       ++ sum(sawTooth((g+i*nn)/(q*nn))*sawTooth((g'+p*i*nn)/(q*nn)),i=1..q-1).
       ++ Condition: one? gcd(p,q).
    kappaSchoeneberg: (P, Z, Z, Z, Z, Z, Z) -> Q
      ++ kappaSchoeneberg(nn, g, h, a, b, c, d) returns a value x such
      ++ that \eta_{g,h}(mat*tau) = exp(2*%pi*%i*x) *
      ++ \eta_{g',h'}(tau) as given at the top of page 673 of
      ++ \cite{Yang_GeneralizedDedekindEtaFunctions_2004} where
      ++ mat=matrix[[a,b],[c,d]].
      ++ See also \eqref{eq:kappa_g-h-N-gamma-Schoeneberg}.
    kappaSchoeneberg: (P, Z, Z, MZ) -> Q
      ++ kappaSchoeneberg(nn, g, h, mat) returns a value x such
      ++ that \eta_{g,h}(mat*tau) = exp(2*%pi*%i*x) *
      ++ \eta_{g',h'}(tau) as given at the top of page 673 of
      ++ \cite{Yang_GeneralizedDedekindEtaFunctions_2004}.
      ++ See also \eqref{eq:kappa_g-h-N-gamma-Schoeneberg}.
    kappaYang: (P, Z, Z, Z, Z, Z, Z) -> Q
      ++ kappaYang(nn, g, h, a, b, c, d) returns a value x such that
      ++ E_{g,h}(mat*tau) = exp(2*%pi*%i*x) * E_{g',h'}(tau) as given
      ++ in \cite[Theorem~1]{Yang_GeneralizedDedekindEtaFunctions_2004}
      ++ where mat = matrix [[a,b],[c,d]].
      ++ Condition: not zero? c.
    kappaYang: (P, Z, Z, MZ) -> Q
      ++ kappaYang(nn, g, h, mat) returns a value x such that
      ++ E_{g,h}(mat*tau) = exp(2*%pi*%i*x) * E_{g',h'}(tau) as given
      ++ in \cite[Theorem~1]{Yang_GeneralizedDedekindEtaFunctions_2004}.
      ++ Condition: not zero? mat(2,1).
    minimizeVector: (Vector Z, List Vector Z) -> Vector Z
      ++ minizeVector(v, basis) computes
      ++ vps := concat [w for b in bas | (w:=v+b; dot(w,w)<dot(v,v)]
      ++ vms := concat [w for b in bas | (w:=v-b; dot(w,w)<dot(v,v)]
      ++ From these vectors it takes the one with minimal length as
      ++ the new v and iterates as long as concat(vps, vms) is not empty.
      ++ This minimal vector is eventually returned.
    primePower: (P, P) -> N
      ++ primePower(d, p) returns e such that gcd(d/p^e, p)=1, i.e., the
      ++ highest power e such that p^e is a factor of d.

  == add
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FL ==> List Record(flag: fUnion, factor: Z, exponent: N)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Related to Eta-Quotients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

    primePower(d: P, p: P): N ==
        e: N := 0;
        x: Z := d
        while not one? gcd(x, p) repeat (x := (x exquo p)::Z; e:=e+1)
        return e

    matrixAtkinLehner(m: P, t: P): MZ ==
        -- t is a Hall divisor of m.
        -- https://en.wikipedia.org/wiki/Hall_subgroup
        --assert((m exquo t) case Z)
        n: Z := (m exquo t)::Z -- input condition is that t divides m
        --assert(one? gcd(n, t))
        exgcd: EXGCD := extendedEuclidean(n, t)
        matrix [[t, -exgcd.coef1], [m, t*exgcd.coef2]]

    -- These are the conditions (1) to (4) of
    -- \cite{HemmeckeRadu_EtaRelations_2019} that have to be fulfilled
    -- by a vector r to lie in R^*(N).
    modularGamma0(m: P, r: List Z): Z ==
        divs: List Z := divisors(m)$INTF
        rdivs: List Z := reverse divs
        s: Z := 0
        a: Z := 0
        b: Z := 0
        c: Factored Z := 1
        for ri in r for d in divs for rd in rdivs repeat
            s := s + ri
            a := a + ri * d  -- sigma_\infty
            b := b + ri * rd -- sigma_0
            c := c * factor(d)^asN(abs ri)
        -- Check conditions 1, 2, 3, 4.
        not zero? s => 1
        not zero? positiveRemainder(a, 24) => 2
        not zero? positiveRemainder(b, 24) => 3
        for fe in factors c repeat if odd?(fe.exponent) then return 4
        return 0

    modularGamma0?(nn: P, r: List Z): Boolean ==
        zero? modularGamma0(nn, r)

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Related to Transformations of Eta-Quotients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

    jacobiLowerStar(c: Z, d: Z): Z == -- result either 1 or -1
        --assert(one? gcd(c,d))
        --aaawer(odd? d)
        -- See \cite[Def.~2.26]{Radu_PhD_2010}.
        -- \left(\frac{c}{d}\right)_* =
        -- \begin{cases}
        -- \left(\frac{c}{\lvert d \rvert}\right) (-1)^{m_c m_d},
        --   & \text{if $c\ne0$},\\
        -- \sign{d}, & \text{otherwise}
        -- \end{cases}
        -- where $m x=\frac{\sign{x}-1}{2}$.
        zero? c => sign(d) -- note that d ~= 0 in this case
        j: Z := jacobi(c, abs(d))$INTF
        if c>0 or d>0 then j else -j -- c=0 or d=0 does not happen

    jacobiUpperStar(c: Z, d: Z): Z == -- result either 1 or -1
        --assert(one? gcd(c,d))
        --assert(odd? d)
        -- See \cite[Def.~2.26]{Radu_PhD_2010}.
        -- \left(\frac{c}{d}\right)^* =
        -- \begin{cases}
        -- \left(\frac{c}{\lvert d \rvert}\right), & \text{if $c\ne0$},\\
        -- 1, & \text{otherwise}
        -- \end{cases}
        zero? c => 1
        jacobi(c, abs(d))$INTF

    upsilonExponent(a: Z, b: Z, c: Z, d: Z): Z ==
        u: Z := c*(a+d)-b*d*(c^2-1)-3*c
        v: Z := 3*(d-1)*(c-1)
        r(x) ==> positiveRemainder(x, 24)
        -- Note that we exp(2*\pi*i*n/24)=exp(\pi*i)=-1 for n=12.
        odd? c => if jacobiUpperStar(d, c) > 0 then r(u) else r(u+12)
        if jacobiLowerStar(c, d) > 0 then r(u-v) else r(u-v+12)

    upsilonExponent(mat: MZ): Z ==
        upsilonExponent(mat(1,1), mat(1,2), mat(2,1), mat(2,2))

    numberOfGaps(n: P, list: List P): N ==
        asN reduce(_+, [floor(x /$Q n) for x in list]$List(Z), 0)

    -- Split matrix as in Lemma~\ref{thm:matrix-splitting} with
    -- z = delta*lambda.
    splitMatrix(mat: SL2Z, delta: Z, m: P, lambda: N): Rec ==
        z: Z := delta*lambda
        w11: Z := delta*mat(1,1) + mat(2,1)*z
        w12: Z := delta*mat(1,2) + mat(2,2)*z
        w21: Z := mat(2,1)*m
        w22: Z := mat(2,2)*m
        splitMatrix(w11, w12, w21, w22)

    -- Split matrix as in Lemma~\ref{thm:matrix-splitting} with
    -- z = 0 and m = 1.
    splitMatrix(mat: SL2Z, delta: Z): Rec ==
        splitMatrix(mat(1,1) * delta, mat(1,2) * delta, mat(2,1), mat(2,2))
        -- Same as splitMatrix(mat, delta, 1, 0).

    -- Split matrix according to Section~\ref{sec:eta-transformation} in
    -- qeta.tex.
    splitMatrix(a: Z, b: Z, c: Z, d: Z): Rec ==
        exgcd: EXGCD := extendedEuclidean(a, c)
        g: Z := exgcd.generator
        d0: Z :=  exgcd.coef1 -- initial value for d1
        b0: Z := -exgcd.coef2 -- initial value for b1
        a1: Z := (a exquo g) :: Z
        c1: Z := (c exquo g) :: Z
        a2: Z := g
        d2: Z := a1*d-b*c1
        -- Now try to find s such that 0 <= b*d1 - d*b1 - s*d2 < d2.
        b2init: Z := b*d0 - d*b0
        b2: Z := positiveRemainder(b2init, d2)
        s: Z := ((b2init - b2) exquo d2) :: Z
        b1: Z := b0 + s * a1
        d1: Z := d0 + s * c1
        m1: MZ := matrix([[a1, b1], [c1, d1]]$LLZ)
        m2: MZ := matrix([[g, b2], [0, d2]]$LLZ)
        [m1, m2]$Rec

)if LiterateDoc
%$

We use \cite[Lemma~2.45]{Radu_PhD_2010} to compute the cusps of
$\Gamma_0(N)$ as the set of all $\frac{a}{c}$ such that $c|N$ and
$a\in X_c$.

)endif

    -- local
    squarePart(fl: FL): Z ==
        -- if fl = factorList factor x and z=squarePart(fl) then
        -- z^2*r=expand(fl) for some squarefree r.
        z: Z := 1
        for x in fl repeat
            e: P := asP shift(x.exponent, -1)
            z := (x.factor)^e * z
        return z

    rationalSquareRoot(x: Q): Record(rat: Q, rootOf: P) ==
        import from FL
        fden: Factored Z := factor denom x
        fnum: Factored Z := factor numer x
        fl: FL := factorList fden
        for x in fl | odd?(x.exponent) repeat
            fnum := x.factor * fnum
            fden := x.factor * fden
        fl := factorList fnum
        r: Z := 1
        for x in fl | odd? (x.exponent) repeat r := x.factor * r
        return [squarePart(fl)/squarePart(factorList fden), asP r]

    -- local
    -- TODO: unused
    square(x: Record(root: P, elem: Pol)): Vector Z ==
        pol: Pol := cyclotomic(x.root)$CyclotomicPolynomialPackage
        C ==> SimpleAlgebraicExtension(Z, Pol, pol)
        z: C := convert(x.elem)@C
        convert(z*z)@Vector(Z)

    minimalSquareRootOfUnity(x: P): P ==
        -- x is a radical integer (squarefree)
        -- See \cite[Section~IV.3]{Lang_AlgebraicNumberTheory_1986}.
        x = 2 => 8
        positiveRemainder(x, 4)=1 => x
        4*x

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Related to Generalized Eta-Quotients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

    fractionalPart(x: Q): Q == -- local function
        d: Z := denom x
        positiveRemainder(numer x, d)/d

    fractionalBernoulli1(x: Q): Q == fractionalPart x - 1/2
    fractionalBernoulli2(x: Q): Q ==
        t: Q := fractionalPart x
        t^2 - t + 1/6

    sawTooth(x: Q): Q ==
        one? denom x => 0
        fractionalBernoulli1 x
    dedekindSum(p: Z, q: Z): Q ==
        not one? gcd(p, q) => error "dedekindSum: input not coprime"
        ds: Q := 0
        for i in 1..abs(q)-1 repeat
            ds := ds + sawTooth(i/q)*sawTooth(p*i/q)
        return ds
    generalizedDedekindSum(nn: P, g: Z, h: Z, a: Z, c: Z): Q ==
        not one? gcd(a, c) => error "generalizedDedekindSum: input not coprime"
        gds: Q := 0
        gg: Z := a*g + c*h
        for i in 0..abs(c)-1 repeat
            cn := c * nn
            s1: Q := sawTooth((g+i*nn)/cn)
            s2: Q := sawTooth((gg+a*i*nn)/cn)
            gds := gds + s1*s2
        return gds

    kappaSchoeneberg(nn: P, g: Z, h: Z, a: Z, b: Z, c: Z, d: Z): Q ==
        zero? c => fractionalPart(b/(2*d)*fractionalBernoulli2(g/nn))
        gprime: Z := a*g + c*h
        x := a/(2*c)*fractionalBernoulli2(g/nn) _
             + d/(2*c)*fractionalBernoulli2(gprime/nn)
        gds := generalizedDedekindSum(nn, g, h, a, c)
        c < 0 => fractionalPart(x + gds)
        fractionalPart(x - gds)

    kappaYang(nn: P, g: Z, h: Z, a: Z, b: Z, c: Z, d: Z): Q ==
        r: Q := 1/2* ((g^2*a*b + 2*g*h*b*c + h^2*c*d)/nn^2 _
           - (g*b + h*(d-1))/nn) -- corresponds to delta/2 in Yang's paper
        u: Z := c*(a+d-3)+b*d*(1-c^2)
        odd? c => fractionalPart(u/12 + r)
        even? d => error "kappaYang: d is even"
        v: Z := a*c*(1-d^2)+d*(b-c+3)
        minusI: Q := -1/4
        fractionalPart(minusI + v/12 + r)

    kappaSchoeneberg(nn: P, g: Z, h: Z, mat: MZ): Q ==
        kappaSchoeneberg(nn, g, h, mat(1,1), mat(1,2), mat(2,1), mat(2,2))

    kappaYang(nn: P, g: Z, h: Z, mat: MZ): Q ==
        kappaYang(nn, g, h, mat(1,1), mat(1,2), mat(2,1), mat(2,2))


    -- By adding interger multiples of elements of b we try to make
    -- the length of a vector v as small as possible in a cheap way.
    -- The emphasis here is on "cheap". It is actually an auxiliary
    -- function. It is not completely necessary to find the optimally
    -- minimal vector, since there is a second optimization step in
    -- the place where we are going to use it to compute the cofactor
    -- specification.
    minimizeVector(v: Vector Z, basis: List Vector Z): Vector Z ==
        empty? basis => v
        w := v; lw := lv := dot(v, v)
        repeat
            for b in basis repeat -- search for a minimal w
                t := v+b; lt := dot(t, t); if lt < lw then (w := t; lw := lt)
                t := v-b; lt := dot(t, t); if lt < lw then (w := t; lw := lt)
            lw = lv => break -- no change happened
            -- otherwise lw < lv
            v := w; lv := lw -- take this minimal w as the new v
        w













)if LiterateDoc
%$
\bibliography{qeta}
\end{document}
)endif
