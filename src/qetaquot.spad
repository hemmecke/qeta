-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (sifted and generalized) Dedekind Eta Functions into
  $q$-series at various cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of sifted and
  generalized Dedekind eta-quotients that have been turned into a
  modular function by multiplication with a cofactor. Expansions into
  $q$-series of objects are considered at any cusp of $\Gamma_0(N)$ or
  $\Gamma_1(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
GAMMA0 ==> CongruenceSubgroupGamma0
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]
lcmP(a, b) ==> asP lcm(a::Integer, b::Integer)





)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic} and implemented in \PathName{qetaquotsymb.spad}.

Another naming convention is that domains that involve the string
\code{Sifted} correspond to an application of the
$U_m$ operator, \ie, instead of looking on a series
$\sum_{n=0}^\infty{a(n)}
q^n$, we deal with a ``sifted'' series of the form
$\sum_{n=0}^\infty{a(mn+t) q^n}$.

Eta-quotients are considered as modular functions for $\Gamma_0(N)$,
whereas generalized eta-quotients are considered as modular functions
for $\Gamma_1(N)$.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D EtaQuotientGamma}
\label{sec:EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{EtaQuotientGamma} represents the Puiseux series
expansion of various eta-quotients.
)endif

-------------------------------------------------------------------
)abbrev domain EQG EtaQuotientGamma
++ EtaQuotientGamma It holds data to compute an eta
++ quotient expansion of $g_{r,m,t,\lambda}(\gamma \tau)$,
++ $g_{r,m,t}(\gamma \tau)$, $F_{s,r,m,t}(\gamma \tau)$.
++ See \eqref{eq:g_r-m-t-lambda(gamma*tau)}.}
++ This Domain behaves partly like univariate Puiseux series.
EtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseux: (SymbolicEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $g_{r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    ym0seqgpuiseux: (SymbolicModularGamma0SiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    rationalPowerDenominator: % -> P
      ++ If k=order(x) and f=qetaTaylorRep(x) then,
      ++ rationalPowerDenominator(x) returns w such that
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    qetaTaylorRep: % -> TX
      ++ qetaTaylorRep(x) returns the Taylor series representation f of x
      ++ without the prefactor corresponding to $(c \tau + d)$
      ++ If w=rationalPowerDenominator(x) and k=order(x) then
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    order: % -> Q
      ++ If w=rationalPowerDenominator(x) and f=qetaTaylorRep(x) then
      ++ order(x) returns k such that x(q)=z^(k)*f(z) with z=q^(1/w).
      ++ order(x) returns the order o
    laurent: % -> LX
      ++ If order(x) is an integer, then laurent(x) returns the
      ++ Laurent series f of x without the prefactor corresponding to
      ++ $(c \tau + d)$ such that x(q) = f(z) for z=q^(1/w) where
      ++ w=rationalPowerDenominator(x). It is an error if order(x) is
      ++ not an integer.

    --TODO: The following function should live somewhere else.
    substitute: (LX, P, N) -> LX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

  Implementation ==> add
    -- If x: % and s = rep(x).ser, d = rep(x).den, then x represents
    -- the series s(q^(1/d)).
    Rep ==> Record(den: P, ord: Q, ser: TX)
    xx ==> rep x

    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol

    -- Cache for frequently used objects
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

-------------------------------------------------------------------
-- local functions
-------------------------------------------------------------------
    xiPower(v: N): (Z -> CX) == (e: Z): CX +->
         -- Take care of the fact that xi^mx = 1.
        e := positiveRemainder(v*e, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: P, v: N): LX ==
        multiplyExponents(multiplyCoefficients(xiPower v, s), u)

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        zero? rd => 1$LX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    rationalPowerDenominator(x: %): P == xx.den
    order(x: %): Q == xx.ord
    qetaTaylorRep(x: %): TX == xx.ser
    laurent(x: %): LX ==
        ord: Q := order x
        not one? denom ord =>
            error "EQG: Laurent series with fractional exponent"
        laurent(numer ord, qetaTaylorRep x)$LX
    coerce(x: %): OutputForm == xx::OutputForm


)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,t,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-t-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    yeqlgpuiseux(y: SymbolicEtaQuotientLambdaGamma, w: P): % ==
        -- w=width
        mm: P := level y
        divs: LP := divisors y
        m: P := multiplier y
        d: P := m*w
        s: LX := 1
        for delta in divs for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicEtaGamma := y.delta
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "EtaQuotientGamma: denominator does not vanish"
            v: Q := mx * vdelta etadelta
            not one? denom v or v<0 =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("vdelta", [vdelta etadelta, u]$List(Q))
                error "EtaQuotientGamma: denominator does not vanish"
            s := s * eulerFunctionPower(asP numer u, asN numer v, rd)
        q: Q := mx * unityExponent y
        not one? denom q =>
            dbgPrint("mx * unityExponent y", q)
            error "EtaQuotientGamma: denominator for xi does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor y -- leading coefficient
        p: Q := d * qExponent y
        not one? denom p =>
            error "EtaQuotientGamma: denominator for q does not vanish"
        tx: TX := cx * qetaTaylorRep s
        per [d, p, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{EtaQuotientGamma}
represents the series expansion of
\begin{gather*}
  g_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicEtaQuotientGamma, w: P): % ==
        m: P := multiplier y
        x: % := yeqlgpuiseux(y.0, w)
        one? m => x
        lx: LX := laurent x
        m1: P := asP(m::Z - 1)
        for lambda in 1..m1 repeat lx := lx + laurent yeqlgpuiseux(y.lambda, w)
        -- A sifted version of an eta-quotient is a non-zero function.
        -- Thus, we can safely remove initial zeroes.
        --TODO: WARNING: The above is not true.
        -- Try findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)
        lx: LX := removeZeroes(lx)$LX
        -- And, it is safe to ask for the order of the series expansion.
        ord: Z := order lx
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        tx: TX := qetaTaylorRep lx
        stx: Stream CX := coefficients tx
        for i in 1..m1 repeat
            stx := rest stx
            if not zero? first stx then
                dbgPrint("YEQG c", first stx)
                dbgPrint("Laurent expansion", lx)
                error "EtaQuotientGamma: m-lambda sum"
        tx := (1/m)$Q::C::CX * multisect(m, 0, tx)
        per [w, ord/m, tx]

    yeqogpuiseux(y: SymbolicEtaQuotientOrbitProductGamma, w: P): % ==
        orb := orbit y
        t: N := first orb;
        px: % := puiseux(y.t, w)
        d: P := rationalPowerDenominator px
        tx: TX := qetaTaylorRep px
        ord: Q := order px
        for k in rest orb repeat
            px: % := puiseux(y.k, w)
            tx := tx * qetaTaylorRep px
            ord := ord + order px
        not one? denom ord =>
            error "EtaQuotientGamma: orbit product: denominator for q does not vanish"
        per [d, ord, tx]

    ym0seqgpuiseux(y: SymbolicModularGamma0SiftedEtaQuotientGamma, w: P): % ==
        yc: SymbolicEtaQuotientGamma := coFactor y
        yo: SymbolicEtaQuotientOrbitProductGamma := orbitProduct y
        pc: % := puiseux(yc, 24*w)
        po: % := yeqogpuiseux(yo, 24*w)
        d: P := rationalPowerDenominator pc
        -- Sanity check.
        d ~= 24 * w =>
            error "EtaQuotientGamma: Puiseux expansion in wrong variable"
        rationalPowerDenominator pc ~= rationalPowerDenominator po =>
            error "EtaQuotientGamma: expansion in different variables"
        tx: TX := multisect(24, 0, qetaTaylorRep pc * qetaTaylorRep po)
        ord: Q := order pc + order po
        ord := ord * (1$Z/24)-- It's a modular function.
        not one? denom ord =>
            error "EtaQuotientGamma: modular: denominator for q does not vanish"
        per [w, ord, tx]









)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularGamma0EtaQuotient}
\label{sec:ModularGamma0EtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R^*(N)$, and \code{e = etaQuotient(N, r)}, then
$e$ represents the information given in
\eqref{eq:modular-g_r(gamma*tau)}
for each cusp $\frac{a}{c}$ of $\Gamma_0(N)$.


)endif
)abbrev domain M0EQ ModularGamma0EtaQuotient
++ ModularGamma0EtaQuotient(C, mx, CX, xi, LX) represents the set
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
ModularGamma0EtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  YEQ ==> SymbolicEtaQuotient
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: YEQ -> %
      ++ coerce(y) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(level y).
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ level(x) returns m such that x corresponds to a modular
      ++ function for Gamma_0(m).
    symbolicEtaQuotient: % -> YEQ
      ++ symbolicEtaQuotient(x) returns the meta data corresponding to x.
      ++ If x=etaQuotient(y) then symbolicEtaQuotient(x)=y.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $g_r(tau)$ at all cusps of Gamma_0(level x) corresponding to
      ++ cusps(symbolicEtaQuotient x).
  Implementation ==> add
    Rep ==> Record(meta: YEQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: YEQ): % ==
        import from EtaQuotientGamma(C, mx, CX, xi)
        nn: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(nn, exponents y)$QETAAUX then
            dbgPrint("M0EQ coerce: not a modular function", exponents y)
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurent puiseux(y.cusp, w)
        per [y, hser]
    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        (etaQuotient(mm, r, cusps)$YEQ)::%
    etaQuotient(mm: P, r: LZ): % == (etaQuotient(mm, r)$YEQ)::%
    level(x: %): P == level(xx.meta)
    symbolicEtaQuotient(x: %): YEQ == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        symbolicEtaQuotient x = symbolicEtaQuotient y


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularGamma0SiftedEtaQuotient}
\label{sec:ModularGamma0SiftedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{ModularGamma0SiftedEtaQuotient} represents the Puiseux
series expansion of various eta-quotients.

)endif

-------------------------------------------------------------------
)abbrev domain M0SEQ ModularGamma0SiftedEtaQuotient
++ ModularGamma0SiftedEtaQuotient is a generalization of
++ ModularGamma0EtaQuotient. It holds the expansions
++ of F_{s,r,m,t}(\tau) at all cusps of $\Gamma_0(N)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)}.
++ The domain serves as the representation of the underlying q-series.
ModularGamma0SiftedEtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  Exports ==> SetCategory with
    coerce: SymbolicModularGamma0SiftedEtaQuotient -> %
      ++ coerce(y) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at all cusps of $\Gamma_0(N)$ where
      ++ N=level(y).
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    metadata: % -> SymbolicModularGamma0SiftedEtaQuotient
      ++ metadata(x) returns y such that coerce(y) = x.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $F_{s,r,m,t}(tau)$ at all cusps of Gamma_0(N).

  Implementation ==> add
    YM0SEQ ==> SymbolicModularGamma0SiftedEtaQuotient
    Rep ==> Record(meta: YM0SEQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: SymbolicModularGamma0SiftedEtaQuotient): % ==
        import from EtaQuotientGamma(C, mx, CX, xi)
        nn: P := level y
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurent ym0seqgpuiseux(y.cusp, w)
        per [y, hser]
    level(x: %): P == level(xx.meta)
    metadata(x: %): SymbolicModularGamma0SiftedEtaQuotient == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.meta)
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        metadata x = metadata y




)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
