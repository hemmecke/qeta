-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (sifted) Dedekind Eta Functions into $q$-series at
  various cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of sifted Dedekind eta
  quotients that have been turned into a modular function by
  multiplication with a cofactor. Expansions into $q$-series of
  objects are considered at any cusp of $\Gamma_0(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
GAMMA0 ==> CongruenceSubgroupGamma0
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]
lcmP(a, b) ==> asP lcm(a::Integer, b::Integer)

)if LiterateDoc
%$
In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic}.

Another naming convention is that domains that involve the string
\code{Sifted} correspond to an application of the
$U_m$ operator, \ie, instead of looking on a series
$\sum_{n=0}^\infty{a(n)}
q^n$, we deal with a ``sifted'' series of the form
$\sum_{n=0}^\infty{a(mn+t) q^n}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symbolic domains}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The domains below collect all the (meta) data that is needed to
compute the actual Puiseux series expansion of the object in question,
but do not itself hold the series expansion.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicEtaDeltaGamma}
\label{sec:SymbolicEtaDeltaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$,
$\divides{\delta}{N}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SymbolicEtaDelta}
represent the tuple
\begin{gather*}
  \left(\frac{h_{\delta}}{\delta}, e_\delta, u_\delta, v_\delta, \kappa_\delta\right)
\end{gather*}
from \eqref{eq:eta_delta(gamma*tau)-expansion}.

)endif

)abbrev domain YEDG SymbolicEtaDeltaGamma
++ SymbolicEtaDeltaGamma collects data for the expansion of
++ eta_delta(\gamma \tau).
++ See \eqref{eq:eta_delta(gamma*tau)}.
SymbolicEtaDeltaGamma: SetCategory with
    eta: (P, P, SL2Z) -> % -- gamma=[[a,b],[c,d]], m=level, delta, r_delta
      ++ eta(m, delta, gamma) represents the expansion of
      ++ \eta_\delta(\gamma \tau) in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c) for some cusp a/c of Gamma0(m).
    level: % -> P
      ++ level(x) returns the level corresponding to x.
    delta: % -> P
      ++ delta(x) returns the delta that was used at creation time of x.
    gamma: % -> SL2Z
      ++ gamma(x) returns the gamma as given at creation time of x.
    rationalPrefactor: % -> Q -- (h_delta/delta)
      ++ See \ref{thm:c*tau+d}.
    upsilonExponent: % -> Z -- kappa_delta
      ++ See \eqref{eta_delta(gamma*tau)}.
    edelta: % -> P            -- width*udelta
      ++ See \eqref{eq:uv_delta}
    udelta: % -> Q            -- gcd(delta,c)^2/delta
      ++ See \eqref{eq:uv_delta}
    vdelta: % -> Q            -- b2/d2
      ++ See \eqref{eq:uv_delta}.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,    -- level \Gamma_0(lev)
              fdelta: P,    -- the divisor used at creation
              fgamma: SL2Z, -- the gamma used at creation
              frat: Q,      -- h_delta/delta
              fkappa: Z,    -- upsilonExponent(a1,b2,c1,d1)
              fedelta: P,   -- edelta = width*hdelta^2/delta \eqref{eq:q_delta}}
              fudelta: Q,   -- edelta = hdelta^2/delta \eqref{eq:q_delta}}
              fvdelta: Q    -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
             )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, gamma: SL2Z): % ==
        c: Z := gamma(2, 1)
        --assert(c>0)
        hdelta: Z := gcd(c, delta)
        rat: Q := hdelta/delta
        rec: Rec := splitMatrix(gamma, delta)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        a2: Z := gamma2(1, 1); wgamma: Z := WIDTH0(mm, c)
        udelta: Q := gcd(c,delta)^2 / delta
        edelta: P := asP numer(wgamma*udelta)
        if not one?(denom(wgamma*udelta)) then
            error "edelta is not integer"
        --assert(edelta = ((a2*wgamma exquo d2) :: Z))
        if udelta ~= a2/d2 then
            error "edelta does not match"
        vdelta: Q := b2/d2
        kappa: Z := upsilonExponent(gamma1)$QETAAUX
        per [mm, delta, gamma, rat, kappa, edelta, udelta, vdelta]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z == xx.fkappa
    edelta(x: %): P == xx.fedelta
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        gamma x = gamma y




)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicEtaQuotientGamma}
\label{sec:SymbolicEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SymbolicEtaQuotientGamma}
represent the tuple
\begin{gather}
  \left(
  N
  ,
  r
  ,
  \gamma
  ,
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}
  ,
  \divisorsum{N} \frac{r_\delta e_\delta}{24}
  \right)
\end{gather}
and thus corresponds to the data from \eqref{eq:g_r(gamma*tau)}.

)endif
-------------------------------------------------------------------
)abbrev domain YEQG SymbolicEtaQuotientGamma
++ SymbolicEtaQuotientGamma holds data to compute an eta quotient expansion
++ of g_r(\gamma \tau).
++ See \eqref{eq:g_r(gamma*tau)}.
SymbolicEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, SL2Z) -> %
      ++ etaQuotient(mm, r, gamma) represents the expansion of
      ++ $g_r(\gamma \tau) =
      ++   \prod_{\delta in divisors(m)} \eta(\delta \gamma \tau)^{r_{\delta}}$
      ++ in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=matrix[[a,b],[c,d]]  represents the cusp a/c of Gamma0(mm).
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were
      ++ given at creation time of x.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r(gamma*tau)}.
    unityPower: % -> Q
      ++ unityPower(e) returns sum_{\delta} rdelta*(vdelta+kappa_delta)/24.
      ++ It corresponds to the third product of eq:g_r(gamma*tau).
    xExponent: % -> Q
      ++ xExponent(e) returns the order of the expansion
      ++ of e in x = \exp(2 \pi i \tau/w) where w is the width of the cusp
      ++ while neglecting the (c \tau+d) factor.
      ++ It corresponds to the exponent of the fourth product
      ++ of \eqref{eq:g_r(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns the order of the expansion
      ++ of e in q = \exp(2 \pi i \tau) while neglecting the (c \tau+d)
      ++ factor. It corresponds to the exponent of the fourth
      ++ product of \eqref{eq:g_r(gamma*tau)}.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(e) returns the smallest positive integer n such that
      ++ the expansion of the function g_r(\gamma \tau) corresponding to
      ++ e=etaQuotient(mm, r, gamma) (neglecting the (c\tau+d)^* factor)
      ++ lives in Q[w][[x]] where w is a n-th root of unity.
    elt: (%, P) -> SymbolicEtaDeltaGamma
      ++ elt(x, delta) returns the data corresponding to the respective
      ++ delta.
    modularGamma0?: % -> Boolean
      ++ modularGamma0?(x) returns true if the eta quotient is a modular
      ++ function for Gamma0(level x), i.e, it returns
      ++ modularGamma0?(level x, exponents x) from
      ++ QEtaAuxiliaryPackage.
 == add
    HT ==> XHashTable(P, SymbolicEtaDeltaGamma) -- mapping delta to \eta_\delta
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_\delta
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
              fxExponent: Q, -- \sum_delta rdelta*edelta/24
              fqExponent: Q, -- \sum_delta rdelta*udelta/24
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    -- divs must be ALL divisors of m sorted ascendingly
    etaquot(mm: P, r: LZ, gamma: SL2Z, eta: HT): % ==
        divs: LP := DIVISORS mm
        rat: Q := 1
        upower: Q := 0
        xexponent: Q := 0
        qexponent: Q := 0
        for delta in divs for rdelta in r | not zero? rdelta repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            rd := rdelta/24
            xexponent := xexponent + rd * edelta(e)
            qexponent := qexponent + rd * udelta(e)

            kappa: Q := (upsilonExponent e)::Q
            upower := upower + rd * (vdelta e + kappa)

        -- Now make the numerator small.
        upower := fractionalPart(upower)$QETAAUX

        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minimalSquareRootOfUnity(p)$QETAAUX)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [mm, divs, r, gamma, eta, rat, upower, xexponent, qexponent, minroot]

    etaQuotient(mm: P, r: LZ, gamma: SL2Z): % ==
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in DIVISORS mm repeat
            eta.delta := eta(mm, delta, gamma)$SymbolicEtaDeltaGamma
        etaquot(mm, r, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    elt(x: %, delta: P): SymbolicEtaDeltaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    xExponent(x: %): Q == xx.fxExponent
    qExponent(x: %): Q == xx.fqExponent
    minimalRootOfUnity(x: %): P == xx.fminroot
    modularGamma0?(x: %): Boolean ==
        modularGamma0?(level x, exponents x)$QETAAUX

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fgamma = yy.fgamma


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicEtaQuotient}
\label{sec:SymbolicEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
elements from the domain \code{SymbolicEtaQuotient}
is a container of data from  \code{SymbolicEtaQuotientGamma} for each
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, corresponding to a cusp of $\Gamma_0(N)$.

If \code{e = etaQuotient(nn, r)}, then
for each cusp in
\code{cusps(nn)$CongruenceSubgroupGamma0(nn)}
%$
we have \code{e.cusp} is the corresponding data from
\code{SymbolicEtaQuotientGamma}.

)endif
-------------------------------------------------------------------
)abbrev domain YEQ SymbolicEtaQuotient
++ SymbolicEtaQuotient holds data to compute an eta quotient expansions
++ of g_r(\tau) at all cusps of $\Gamma_0(N)$ or at the given cusps.
++ See \eqref{g_r(tau)}
SymbolicEtaQuotient: SetCategory with
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ If x=etaQuotient(mm, r) then level(x) returns the level of
      ++ the eta quotient, i.e., level(x)=mm.
    exponents: % -> LZ
      ++ If x=etaQuotient(m, r) then exponents(x) returns the list of
      ++ exponents, i.e., exponents(x)=r.
    cusps: % -> LQ
      ++ If x=etaQuotient(mm, r), then
      ++ cusps(x)=cusp(mm)$CongruenceSubgroupGamma0.
    minimalRootOfUnity: % -> P
      ++ If x=etaQuotient(mm, r), then minimalRootOfUnity(x) returns the
      ++ smallest positive integer n such that the expansion of the
      ++ function g_r(\tau) at any cusp of Gamma_0(mm)
      ++ (neglecting the (c\tau+d)^* factor lives in Q[w][[x]] where w
      ++ is an n-th root of unity.
    elt: (%, Q) -> SymbolicEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    qetaGrades: % -> List Q
      ++ qetaGrades(x) returns the (negated) exponents of a series
      ++ expansion of x at all the cusps in the canonical variables.
      ++ Internally, the matrix of Ligozat is employed.
 == add
    HT ==> XHashTable(Q, SymbolicEtaQuotientGamma)
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(level)
              fexponents: LZ,-- the r vector
              fcusps: LQ,
              feta: HT,      -- mapping delta to \eta_\delta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    qetaGrades(x: %): List Q == [-xExponent(x.cusp) for cusp in cusps x]

    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        divs: LP := DIVISORS mm
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(mm, cusp)$GAMMA0
            e: SymbolicEtaQuotientGamma := etaQuotient(mm, r, gamma)
            h.cusp := e
            minroot := lcmP(minroot, minimalRootOfUnity e)
        per [mm, r, cusps, h, minroot]

    etaQuotient(mm: P, r: LZ): % == etaQuotient(mm, r, cusps(mm)$GAMMA0)

    level(x: %): P == xx.flevel
    exponents(x: %): LZ == xx.fexponents
    cusps(x: %): LQ == xx.fcusps
    elt(x: %, cusp: Q): SymbolicEtaQuotientGamma == xx.feta.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents = yy.fexponents


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaDeltaLambdaGamma}
\label{sec:SymbolicSiftedEtaDeltaLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaDeltaLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  \delta,
  m,
  \lambda,
  \gamma,
  \frac{h_{\delta,m,\lambda}}{\delta}
  ,
  u_{\delta,m,\lambda},
  v_{\delta,m,\lambda},
  \kappa_{\delta,m,\lambda}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:eta_delta-m-lambda(gamma*tau)}, \ie, it computes the
building blocks for $\eta_{\delta,m,\lambda}(\gamma\tau)$.

)endif
-------------------------------------------------------------------
)abbrev domain YSEDLG SymbolicSiftedEtaDeltaLambdaGamma
++ SymbolicSiftedEtaDeltaLambdaGamma is a generalization of
++ SymbolicEtaDeltaGamma. It holds data to compute an eta
++ expansion of $\eta_{delta.m,\lambda}(\gamma \tau)$.
++ See \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
SymbolicSiftedEtaDeltaLambdaGamma: SetCategory with
    eta: (P, P, P, N, SL2Z) -> %
      ++ eta(mm, delta, m, lambda, gamma) represents the
      ++ expansion of $\eta_{\delta,m,\lambda}(\gamma \tau)$ in terms of
      ++ $q = \exp(2 \pi i \tau)$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    delta: % -> P
      ++ delta(x) returns the corresponding delta.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in eta(...,gamma).
    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r(gamma*tau)}
    upsilonExponent: % -> Z
      ++ Returns $\kappa_{\gamma_{\delta,m,\lambda}}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
    udelta: % -> Q
      ++ Returns $u_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
    vdelta: % -> Q
      ++ Returns $v_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,
              fdelta: P,
              fmultiplier: P,
              flambda: N,
              fgamma: SL2Z, -- gamma
              frat: Q,      -- square of rational prefactor
              fkappa: Z,    -- upsilonExponent(a1,b2,c1,d1)
              fudelta: Q,   -- udelta = hdelta^2/(delta*m)
                            -- \eqref{eq:uv_delta-m-lambda}}
              fvdelta: Q    -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        --assert(gamma(2, 1)>0)
        rec: Rec := splitMatrix(gamma, delta, m, lambda)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        a2: Z := gamma2(1, 1); b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        rat: Q := a2/delta -- = hdelta/delta
        udelta: Q := a2/d2 -- = hdelta^2/delta/m
        vdelta: Q := b2/d2
        kappa: Z := upsilonExponent(gamma1)$QETAAUX
        per [mm, delta, m, lambda, gamma, rat, kappa, udelta, vdelta]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z == xx.fkappa
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        multiplier x ~= multiplier y => false
        lambda x ~= lambda y => false
        gamma x = gamma y


)if LiterateDoc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaQuotientLambdaGamma}
\label{sec:SymbolicSiftedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $g_{r,m,t,\lambda}(\gamma\tau)$
as well as $g_{r,m,-,\lambda}(\gamma\tau)$.

For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaQuotientLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  r,
  m,
  t,
  \lambda,
  \gamma,
  y,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!r_\delta}
  ,
  -\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr) +
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} \frac{r_\delta u_{\delta,m,\lambda}}{24}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:g_r-m-t-lambda(gamma*tau)}, \ie, it computes the building
blocks for $g_{r,m,t,\lambda}(\gamma\tau)$.

The special entry $y=(y_\delta)_{\divides{\delta}{M}}$ is a container
of the \code{SymbolicSiftedEtaDeltaLambdaGamma} values for each
divisor $\delta$ of $M$.


For the special case $t=-1$, the part
$-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)$ is missing, i.e.,
we get
\begin{gather}
  \left(
  M,
  r,
  m,
  t,
  \lambda,
  \gamma,
  y,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} \frac{r_\delta u_{\delta,m,\lambda}}{24}
  \right).
\end{gather}

)endif
-------------------------------------------------------------------
)abbrev domain YSEQLG SymbolicSiftedEtaQuotientLambdaGamma
++ SymbolicSiftedEtaQuotientLambdaGamma is a generalization of
++ SymbolicEtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of g_{r,m,t,\lambda}(\gamma \tau) or
++ of g_{r,m,-,\lambda}(\gamma \tau).
++ See \eqref{eq:g_r-m-t-lambda(gamma*tau)} and
++ \eqref{eq:g_r-m---lambda(gamma*tau)}.
SymbolicSiftedEtaQuotientLambdaGamma: SetCategory with
    etaQuotient: (P, LZ, P, Z, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, lambda, gamma) represents the
      ++ expansion of $g_{r,m,t,\lambda}(\gamma \tau)$ in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(nn, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c of Gamma0(mm).
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were given
      ++ at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> Z
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    lambda: % -> N
      ++ lambda(x) returns lambda
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).

    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r-m-t-lambda(gamma*tau)}.
    unityPower: % -> Q
      ++ unityPower(e) returns $- lambda*(24*t+\sumdelta{r})/(24*m) +
      ++ sum_{\delta} rdelta*(vdelta+Kappa_delta)/24$. It corresponds to
      ++ the second factor of \eqref{eq:g_r-m-t-lambda(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns the order of the expansion
      ++ of e in q = \exp(2 \pi i \tau)  while neglecting the (c\tau+d) factor.
      ++ It corresponds to the exponent of the fourth product
      ++ of \eqref{eq:g_r-m-t-lambda(gamma*tau)}.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(e) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $g_{r,m,t,\lambda}(\gamma \tau)$ corresponding to
      ++ e=etaQuotient(mm, divs, r, m, t, lambda, gamma) (neglecting
      ++ the (c \tau+d)^* factor) lives in Q[w][[z]] where w is a n-th
      ++ root of unity and z a fractional q power.
    elt: (%, P) -> SymbolicSiftedEtaDeltaLambdaGamma
      ++ x.delta returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicSiftedEtaDeltaLambdaGamma)
      -- mapping delta to \eta_{\delta,m,\lambda}
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the s vector
              fmultiplier: P,-- the multiplier m
              foffset: Z,    -- the offset t \in 0..(m-1) or t=-1
              flambda: N,    -- lambda \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_{\delta,m,lambda}
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
                             -- - lambda*(24*t+\sumdelta{s})/(24*m)
              fqExponent: Q, -- \sum_delta rdelta*udelta/24
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaquot(mm: P, divs: LP, r: LZ,
            m: P, t: Z, lambda: N, gamma: SL2Z, eta: HT): % ==
        rat: Q := 1
        upower: Q := 0
        qexponent: Q := 0
        sigmaInfty: Z := 0
        for delta in divs for rdelta in r | not zero? rdelta repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            rd := rdelta/24
            qexponent := qexponent + rd * udelta(e)

            kappa: Q := (upsilonExponent e)::Q
            upower := upower + rd * (vdelta e + kappa)
            sigmaInfty := sigmaInfty + delta * rdelta

        -- Distinguish between g_{s,m,t,\lambda} and g_{s,m,-,\lamnbda}.
        if t>=0 then upower := upower - lambda/m * ((t::Q) + sigmaInfty/24)

        -- Now make the numerator small.
        upower := fractionalPart(upower)$QETAAUX

        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minimalSquareRootOfUnity(p)$QETAAUX)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [mm, divs, r, m, t, lambda, gamma, eta, rat, upower, qexponent, minroot]

    etaQuotient(mm: P, r: LZ, m: P, t: Z, lambda: N, gamma: SL2Z): % ==
        divs: LP := DIVISORS mm
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in divs repeat
            YSEDLG ==> SymbolicSiftedEtaDeltaLambdaGamma
            eta.delta := eta(mm, delta, m, lambda, gamma)$YSEDLG
        etaquot(mm, divs, r, m, t, lambda, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    elt(x: %, delta: P): SymbolicSiftedEtaDeltaLambdaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): Z == xx.foffset
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    qExponent(x: %): Q == xx.fqExponent
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaQuotientGamma}
\label{sec:SymbolicSiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $g_{r,m,t}(\gamma\tau)$ as well as
$g_{r,m}(\gamma\tau)$.

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{-1, 0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaQuotientGamma} represent the collection
\code{SymbolicSiftedEtaQuotientLambdaGamma} for each $\lambda \in
\Set{0,\ldots,m-1}$ and thus corresponds to the data from
\eqref{eq:g_r-m-t(gamma*tau)}, \ie, it computes the building
blocks for $g_{r,m,t}(\gamma\tau)$ and for $t=-1$ the building blocks
of $g_{r,m}=U_mg_r$.

)endif
-------------------------------------------------------------------
)abbrev domain YSEQG SymbolicSiftedEtaQuotientGamma
++ SymbolicSiftedEtaQuotientGamma is a generalization of
++ SymbolicEtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of $g_{r,m,t}(\gamma \tau)$ or $g_{r,m}(\gamma \tau)$.
++ See \eqref{eq:g_r-m-t(gamma*tau)} and \eqref{eq:g_r-m(gamma*tau)}.
SymbolicSiftedEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, Z, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the
      ++ expansion of $g_{r,m,t}(\gamma \tau)$ where $r$ is indexed
      ++ by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were
      ++ given at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> Z
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaQuotient(...,gamma).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.lambda) for lambda in 0..m-1].
    elt: (%, N) -> SymbolicSiftedEtaQuotientLambdaGamma
      ++ x.lambda returns the data corresponding to the respective
      ++ lambda.
 == add
    A ==> IndexedOneDimensionalArray(SymbolicSiftedEtaQuotientLambdaGamma, 0)
    Rep ==> Record(
              feta: A,    -- mapping lambda to \eta_{\delta,m,lambda}
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep

    etaQuotient(mm: P, r: LZ, m: P, t: Z, gamma: SL2Z): % ==
        e: SymbolicSiftedEtaQuotientLambdaGamma :=
            etaQuotient(mm, r, m, t, 0, gamma)
        minroot: P := minimalRootOfUnity e
        eta: A := new(m, e) -- fill with dummy values
        for lambda in 1..m-1 repeat -- can start with 1.
            e := etaQuotient(mm, r, m, t, lambda, gamma)
            minroot := lcmP(minroot, minimalRootOfUnity e)
            eta.lambda := e
        per [eta, minroot]

    elt(x: %, lambda: N): SymbolicSiftedEtaQuotientLambdaGamma ==
        rep(x).feta.lambda
    level(x: %): P == level(x.0)
    divisors(x: %): LP == divisors(x.0)
    exponents(x: %): LZ == exponents(x.0)
    multiplier(x: %): P == multiplier(x.0)
    offset(x: %): Z == offset(x.0)
    gamma(x: %): SL2Z == gamma(x.0)
    minimalRootOfUnity(x: %): P == rep(x).fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, x.0)
    ((x: %) = (y: %)): Boolean == x.0 = y.0


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaQuotientOrbitProductGamma}
\label{sec:SymbolicSiftedEtaQuotientOrbitProductGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaQuotientOrbitProductGamma} represent the
collection \code{SymbolicSiftedEtaQuotientGamma}
for each
$t' \in \modularOrbit{r, m, t}$ and thus corresponds to the data from
\eqref{eq:P_r-m-t(gamma*tau)}, \ie, it computes the building blocks
for $P_{r,m,t}(\gamma\tau)$.


)endif

-------------------------------------------------------------------
)abbrev domain YSEQOG SymbolicSiftedEtaQuotientOrbitProductGamma
++ SymbolicSiftedEtaQuotientOrbitProductGamma
++ holds data to compute an eta quotient
++ expansions of $P_{r, m, t}(\gamma \tau)$.
++ See \eqref{eq:P_r-m-t(gamma*tau)}.}
SymbolicSiftedEtaQuotientOrbitProductGamma: SetCategory with
    etaQuotient: (P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the expansion
      ++ of $P_{r, m, t}(\gamma \tau)$.
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).
    orbit: % -> List N
      ++ orbit(x) returns $\modularOrbit{r, m, t}$ where
      ++ r=exponents(x), m=multiplier(x), t=offset(x).
      ++ See definition of orbit in qetacofactorspace.spad
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in orbit(rhat,m,t)]
      ++ where $rhat = \sum_\delta \delta r_\delta$
    elt: (%, N) -> SymbolicSiftedEtaQuotientGamma
      ++ x.u returns the data corresponding to the respective
      ++ orbit element u.
 == add
    YSEQG ==> SymbolicSiftedEtaQuotientGamma
    HT ==> XHashTable(N, YSEQG)
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              forbit: List N,-- \modularOrbit(r, m, t}
              fdata: HT,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        divs: LP := DIVISORS mm
        rhat: Z := 0 -- sigmaInfty
        for delta in divs for rdelta in r repeat rhat := rhat + delta * rdelta
        orb: List N := orbit(rhat, m, t)$QEtaCoFactorSpace
        h: HT := empty()
        minroot: P := 1
        for tt in orb repeat
            e: YSEQG := etaQuotient(mm, r, m, tt, gamma)
            minroot := lcmP(minroot, minimalRootOfUnity e)
            h.tt := e
        per [mm, divs, r, m, t, gamma, orb, h, minroot]

    elt(x: %, tt: N): YSEQG == rep(x).fdata.tt
    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    gamma(x: %): SL2Z == xx.fgamma
    orbit(x: %): List N == xx.forbit
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.fgamma = yy.fgamma




)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicModularSiftedEtaQuotientGamma}
\label{sec:SymbolicModularSiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicModularSiftedEtaQuotientGamma} represent the product of
an
$\eta$-quotient cofactor to an element of
\code{SymbolicSiftedEtaQuotientOrbitProductGamma} in order to make the
product a modular function.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie, it
computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YMSEQG SymbolicModularSiftedEtaQuotientGamma
++ SymbolicModularSiftedEtaQuotientGamma
++ holds data to compute an eta quotient
++ expansions of $F_{s, r, m, t}(\gamma \tau)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)} in this file.
SymbolicModularSiftedEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, gamma) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    coFactor: % -> SymbolicSiftedEtaQuotientGamma
      ++ coFactor(x) returns the coFactor part to make $F_{s,r,m,t}$ a
      ++ modular function.
    orbitProduct: % -> SymbolicSiftedEtaQuotientOrbitProductGamma
      ++ orbitProduct(x) returns the orbit product part of $F_{s,r,m,t}$.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in orbit(rhat,m,t)].
 == add
    Rep ==> Record(
              fcoetaqg: SymbolicSiftedEtaQuotientGamma,
              fseqopg: SymbolicSiftedEtaQuotientOrbitProductGamma,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        not modularGamma0?(nn, s, mm, r, m, t)$QEtaCoFactorSpace =>
            error "modular conditions are not fulfilled"
        nndivs: LP := DIVISORS nn
        mmdivs: LP := DIVISORS mm
        coetaqg: SymbolicSiftedEtaQuotientGamma :=
            etaQuotient(nn, s, 1, 0, gamma)
        seqopg: SymbolicSiftedEtaQuotientOrbitProductGamma :=
            etaQuotient(mm, r, m, t, gamma)
        minR1: P := minimalRootOfUnity coetaqg
        minR2: P := minimalRootOfUnity seqopg
        per [coetaqg, seqopg, lcmP(minR1, minR2)]

    coFactor(x: %): SymbolicSiftedEtaQuotientGamma == xx.fcoetaqg
    orbitProduct(x: %): SymbolicSiftedEtaQuotientOrbitProductGamma == xx.fseqopg
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fcoetaqg)
        h := hashUpdate!(h, xx.fseqopg)
        h

    ((x: %) = (y: %)): Boolean ==
        (xx.fcoetaqg = yy.fcoetaqg) and (xx.fseqopg = yy.fseqopg)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicModularSiftedEtaQuotient}
\label{sec:SymbolicModularSiftedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$, elements from the domain
\code{SymbolicModularSiftedEtaQuotient} represent the collection of
element from \code{SymbolicSiftedEtaQuotienGamma} for all $\gamma \in
\SL2Z$ corresponding to a cusp of $\Gamma_0(N)$.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie,
it computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YMSEQ SymbolicModularSiftedEtaQuotient
++ SymbolicModularSiftedEtaQuotient holds data to compute an eta
++ quotient expansions of $F_{s, r, m, t}(\gamma \tau)$ at all cusps
++ of $Gamma_0(N)$. See \eqref{eq:F_s-r-m-t(gamma*tau)}.
SymbolicModularSiftedEtaQuotient: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, LQ) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, cusps) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$ for all gamma corresponding to
      ++ the given cusps.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    etaQuotient: (P, LZ, P, LZ, P, N) -> %
      ++ etaQuotient(nn, s, mm, r, m, t) represents the expansion of
      ++ $F_{r,s,m,t}(\gamma \tau)$ for all gamma corresponding to the
      ++ cusps of $\Gamma_0(nn)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    cusps: % -> LQ
      ++ cusps(x) either returns the value that was given to
      ++ etaQuotient at creation time or cusps(level
      ++ x)$CongruenceSubgroupGamma0 if the cusps where not given.
    elt: (%, Q) -> SymbolicModularSiftedEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in cusps x].
 == add
    YMSEQG ==> SymbolicModularSiftedEtaQuotientGamma
    HT ==> XHashTable(Q, YMSEQG)
    Rep ==> Record(
              flevel: P,  -- corresponds to Gamma_0(N)
              fcusps: LQ, -- cusps of Gamma_0(N)
              fmseq: HT,  -- mapping gamma to YMSEQG
              fminroot: P -- minimal root of unity needed for the coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, cusps: LQ): % ==
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(nn, cusp)$GAMMA0
            e: YMSEQG := etaQuotient(nn, s, mm, r, m, t, gamma)
            h.cusp := e
            minroot := lcmP(minroot, minimalRootOfUnity e)
        per [nn, cusps, h, minroot]

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): % ==
        etaQuotient(nn, s, mm, r, m, t, cusps(nn)$GAMMA0)

    level(x: %): P == xx.flevel
    elt(x: %, cusp: Q): YMSEQG == xx.fmseq.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot
    cusps(x: %): LQ == xx.fcusps

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.fmseq)
    ((x: %) = (y: %)): Boolean == xx.fmseq = yy.fmseq













)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domains involving Puiseux series}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following domains compute actual series from the data provided by
the ``symbolic'' domains from above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D EtaQuotientGamma}
\label{sec:EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, and \code{y = etaQuotient(N, r, gamma)} and
\code{e = etaQuotient(y)}, then $e$ represents the tuple
\begin{gather}
  \left(
  \underbrace{y}_{\texttt{symbolicEtaQuotient}}
  ,
  \underbrace{\divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  }_{\texttt{leadingCoefficient}}
  ,
  \underbrace{\divisorprod{N}\prod_{n=1}^{\infty}
    (1-\unityPower{n v_\delta} x^{n e_\delta})^{r_\delta}
  }_{\texttt{series}}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:modular-g_r(gamma*tau)} with
$x=\unityPower{\frac{\tau}{w_\gamma}}$ where $w_\gamma$ is given by
\eqref{eq:width0}.


)endif
-------------------------------------------------------------------
)abbrev domain EQG EtaQuotientGamma
++ EtaQuotientGamma(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotient expansions at gamma.
++ The eta quotient need not be a modular function, but the (c*tau+d)
++ factor is always ignored.
EtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: SymbolicEtaQuotientGamma -> %
      ++ coerce(s) represents the expansion of
      ++ g_r(\gamma \tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c),
      ++ r = exponents(s), and g_r is defined by
      ++ $g_r(\tau) =
      ++   \prod_{\delta in divisors(s)} \eta(\delta \gamma \tau)^{r_{\delta}}$.
    eulerFunctionPower: (P, N, Z) -> LX
      ++ eulerFunctionPower(u, v, p) computes eulerFunction(1)^p and
      ++ replaces q=monomial(1,1)$LC by monomial(xi^v, u)$LX
    symbolicEtaQuotient: % -> SymbolicEtaQuotientGamma
      ++ symbolicEtaQuotient(x) returns meta-data corresponding to x.
    eulerExpansion: % -> LX
      ++ eulerExpansion(e) returns the series expansion of e without
      ++ any prefactor.
      ++ The true series expansion (in terms of fractional x powers of e
      ++ is given by lc * x^p * s where
      ++ lc = leadingCoefficient e,
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c),
      ++ y = symbolicEtaQuotient e,
      ++ c = gamma(y)(2,1),
      ++ p = xExponent y,
      ++ s = eulerExpansion e.
    expansion: % -> LX
      ++ expansion(e) should only be called if modularGamma0?(e) holds,
      ++ otherwise it might return an error.
      ++ expansion(e) returns the series expansion of e in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c),
      ++ c = gamma(symbolicEtaQuotient e)(2,1).
    leadingCoefficient: % -> CX
      ++ leadingCoefficient(x) returns the coefficient corresponding
      ++ to the smallest q-power with non-zero coefficient.
    modularGamma0?: % -> Boolean
      ++ modularGamma0?(x) returns true if the eta quotient is a
      ++ modular function for Gamma0(nn) where
      ++ nn=level(symbolicEtaQuotient x).

    --TODO: The following function should live somewhere else.
    substitute: (LX, P, N) -> LX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

  Implementation ==> add
    Rep ==> Record(fsymetaquo: SymbolicEtaQuotientGamma, lc: CX, ser: LX)
    -- The true series expansion of e is given by c * x^p * s where
    -- c = leadingCoefficient e
    -- x = \exp(2 \pi i \tau/w) where w=width(m, c)
    -- p = xExponent symbolicEtaQuotient e
    -- s = eulerExpansion e
    xx ==> rep x
    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

    xiPower(v: N): (Z -> CX) == (e: Z): CX +->
         -- Take care of the fact that xi^mx = 1.
        e := positiveRemainder(v*e, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: P, v: N): LX ==
        multiplyExponents(multiplyCoefficients(xiPower v, s), u)

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        zero? rd => 1$LX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    coerce(e: SymbolicEtaQuotientGamma): % ==
        m: P := level e
        divs: LP := divisors e
        s: LX := 1
        for delta in divs for rd in exponents e | not zero? rd repeat
            etadelta: SymbolicEtaDeltaGamma := e.delta
            u: P := edelta(etadelta)
            v: N := asN numer(mx * vdelta(etadelta))
            s := s * eulerFunctionPower(u, v, rd)
        q: Q := mx * unityPower e
        if not one? denom q then
            error "EtaQuotientGamma: denominator does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor e -- leading coefficient
        per [e, cx, s]

    symbolicEtaQuotient(x: %): SymbolicEtaQuotientGamma == xx.fsymetaquo
    leadingCoefficient(x: %): CX == xx.lc
    eulerExpansion(x: %): LX == xx.ser
    expansion(x: %): LX ==
        lc: CX := leadingCoefficient x
        y: SymbolicEtaQuotientGamma := symbolicEtaQuotient x
        ord: Z :=
            not one? denom xExponent y =>
                error "expansion$EtaQuotientGamma: rational exponent"
            numer xExponent y -- order of series
        monomial(lc, ord)$LX * eulerExpansion x

    modularGamma0?(x: %): Boolean == modularGamma0? symbolicEtaQuotient x

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean == symbolicEtaQuotient x = symbolicEtaQuotient y

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D ModularEtaQuotient}
\label{sec:ModularEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R^*(N)$, and \code{e = etaQuotient(N, r)}, then
$e$ represents the information given in
\eqref{eq:modular-g_r(gamma*tau)}
for each cusp $\frac{a}{c}$ of $\Gamma_0(N)$.


)endif
)abbrev domain MEQ ModularEtaQuotient
++ ModularEtaQuotient(C, mx, CX, xi, LX) represents the set
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
ModularEtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  YEQ ==> SymbolicEtaQuotient
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: YEQ -> %
      ++ coerce(y) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(level y).
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ level(x) returns m such that x corresponds to a modular
      ++ function for Gamma_0(m).
    symbolicEtaQuotient: % -> YEQ
      ++ symbolicEtaQuotient(x) returns the meta data corresponding to x.
      ++ If x=etaQuotient(y) then symbolicEtaQuotient(x)=y.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $g_r(tau)$ at all cusps of Gamma_0(level x) corresponding to
      ++ cusps(symbolicEtaQuotient x).
  Implementation ==> add
    Rep ==> Record(meta: YEQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: YEQ): % ==
        m: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(m, exponents y)$QETAAUX then
            dbgPrint("MEQ coerce: not a modular function", exponents y)
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            ye: SymbolicEtaQuotientGamma := y.cusp
            e := ye :: EtaQuotientGamma(C, mx, CX, xi)
            hser.cusp := expansion e
        per [y, hser]
    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        (etaQuotient(mm, r, cusps)$YEQ)::%
    etaQuotient(mm: P, r: LZ): % == (etaQuotient(mm, r)$YEQ)::%
    level(x: %): P == level(xx.meta)
    symbolicEtaQuotient(x: %): YEQ == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        symbolicEtaQuotient x = symbolicEtaQuotient y


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SiftedEtaQuotientGamma}
\label{sec:SiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{SiftedEtaQuotientGamma} represents the Puiseux series
expansion of various eta quotients.
)endif

-------------------------------------------------------------------
)abbrev domain SEQG SiftedEtaQuotientGamma
++ SiftedEtaQuotientGamma is a generalization of
++ EtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of $g_{r,m,t,\lambda}(\gamma \tau)$,
++ $g_{r,m,t}(\gamma \tau)$, $F_{s,r,m,t}(\gamma \tau)$.
++ See \eqref{eq:g_r-m-t-lambda(gamma*tau)}.}
++ This Domain behaves partly like univariate Puiseux series.
SiftedEtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseux: (SymbolicSiftedEtaQuotientLambdaGamma, P) -> %
      ++ puiseux(y, w) represents the
      ++ q-expansion of g_{r,m,t,\lambda}(\gamma \tau) at \tau=i \infity.
    puiseux: (SymbolicSiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $g_{r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    puiseux: (SymbolicSiftedEtaQuotientOrbitProductGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $\prod_{t' \in \modularOrbit{r,m,t}} g_{r,m,t}(\gamma \tau)$
      ++ at $\tau=i \infity$.
    puiseux: (SymbolicModularSiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    rationalPowerDenominator: % -> P
      ++ If k=order(x) and f=qetaTaylorRep(x) then,
      ++ rationalPowerDenominator(x) returns w such that
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    qetaTaylorRep: % -> TX
      ++ qetaTaylorRep(x) returns the Taylor series representation f of x
      ++ without the prefactor corresponding to $(c \tau + d)$
      ++ If w=rationalPowerDenominator(x) and k=order(x) then
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    order: % -> Q
      ++ If w=rationalPowerDenominator(x) and f=qetaTaylorRep(x) then
      ++ order(x) returns k such that x(q)=z^(k)*f(z) with z=q^(1/w).
      ++ order(x) returns the order o
    laurent: % -> LX
      ++ If order(x) is an integer, then laurent(x) returns the
      ++ Laurent series f of x without the prefactor corresponding to
      ++ $(c \tau + d)$ such that x(q) = f(z) for z=q^(1/w) where
      ++ w=rationalPowerDenominator(x). It is an error if order(x) is
      ++ not an integer.
  Implementation ==> add
    -- If x: % and s = rep(x).ser, d = rep(x).den, then x represents
    -- the series s(q^(1/d)).
    Rep ==> Record(den: P, ord: Q, ser: TX)
    xx ==> rep x

    import from EtaQuotientGamma(C, mx, CX, xi)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    rationalPowerDenominator(x: %): P == xx.den
    order(x: %): Q == xx.ord
    qetaTaylorRep(x: %): TX == xx.ser
    laurent(x: %): LX ==
        ord: Q := order x
        not one? denom ord =>
            error "SEQG: Laurent series with fractional exponent"
        laurent(numer ord, qetaTaylorRep x)$LX
    coerce(x: %): OutputForm == xx::OutputForm

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,t,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-t-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicSiftedEtaQuotientLambdaGamma, w: P): % ==
        -- w=width
        mm: P := level y
        divs: LP := divisors y
        m: P := multiplier y
        d: P := 24*m*w
        s: LX := 1
        for delta in divs for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicSiftedEtaDeltaLambdaGamma := y.delta
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "SiftedEtaQuotientGamma: denominator does not vanish"
            v: N := asN numer(mx * vdelta(etadelta))
            s := s * eulerFunctionPower(asP numer u, v, rd)
        q: Q := mx * unityPower y
        not one? denom q =>
            dbgPrint("mx * unityPower y", q)
            error "SiftedEtaQuotientGamma: denominator for xi does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor y -- leading coefficient
        p: Q := d * qExponent y
        not one? denom p =>
            error "SiftedEtaQuotientGamma: denominator for q does not vanish"
        tx: TX := cx * qetaTaylorRep s
        per [d, p, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SiftedEtaQuotientGamma}
represents the series expansion of
\begin{gather*}
  g_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicSiftedEtaQuotientGamma, w: P): % ==
        m: P := multiplier y
        lx: LX := 0
        m1: P := asP(m::Z - 1)
        for lambda in 0..m1 repeat lx := lx + laurent puiseux(y.lambda, w)
        -- A sifted version of an eta-quotient is a non-zero function.
        -- Thus, we can safely remove initial zeroes.
        --TODO: WARNING: The above is not true.
        -- Try findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)
        lx: LX := removeZeroes(lx)$LX
        -- And, it is safe to ask for the order of the series expansion.
        ord: Z := order lx
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        tx: TX := qetaTaylorRep lx
        stx: Stream CX := coefficients tx
        for i in 1..m1 repeat
            stx := rest stx
            if not zero? first stx then
                dbgPrint("YSEQG c", first stx)
                dbgPrint("Laurent expansion", lx)
                error "SiftedEtaQuotientGamma: m-lambda sum"
        tx := (1/m)$Q::C::CX * multisect(m, 0, tx)
        per [24 * w, ord/m, tx]

    puiseux(y: SymbolicSiftedEtaQuotientOrbitProductGamma, w: P): % ==
        orb := orbit y
        t: N := first orb;
        px: % := puiseux(y.t, w)
        d: P := rationalPowerDenominator px
        tx: TX := qetaTaylorRep px
        ord: Q := order px
        for k in rest orb repeat
            px: % := puiseux(y.k, w)
            tx := tx * qetaTaylorRep px
            ord := ord + order px
        not one? denom ord =>
            error "SiftedEtaQuotientGamma: orbit product: denominator for q does not vanish"
        per [d, ord, tx]

    puiseux(y: SymbolicModularSiftedEtaQuotientGamma, w: P): % ==
        yc: SymbolicSiftedEtaQuotientGamma := coFactor y
        yo: SymbolicSiftedEtaQuotientOrbitProductGamma := orbitProduct y
        pc: % := puiseux(yc, w)
        po: % := puiseux(yo, w)
        d: P := rationalPowerDenominator pc
        -- Sanity check.
        d ~= 24 * w =>
            error "SiftedEtaQuotientGamma: Puiseux expansion in wrong variable"
        rationalPowerDenominator pc ~= rationalPowerDenominator po =>
            error "SiftedEtaQuotientGamma: expansion in different variables"
        tx: TX := multisect(24, 0, qetaTaylorRep pc * qetaTaylorRep po)
        ord: Q := order pc + order po
        ord := ord * (1$Z/24)-- It's a modular function.
        not one? denom ord =>
            error "SiftedEtaQuotientGamma: modular: denominator for q does not vanish"
        per [w, ord, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D ModularSiftedEtaQuotient}
\label{sec:ModularSiftedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{ModularSiftedEtaQuotient} represents the Puiseux
series expansion of various eta quotients.

)endif

-------------------------------------------------------------------
)abbrev domain MSEQ ModularSiftedEtaQuotient
++ ModularSiftedEtaQuotient is a generalization of
++ ModularEtaQuotient. It holds the expansions
++ of F_{s,r,m,t}(\tau) at all cusps of $\Gamma_0(N)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)}.
++ The domain serves as the representation of the underlying q-series.
ModularSiftedEtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  Exports ==> SetCategory with
    coerce: SymbolicModularSiftedEtaQuotient -> %
      ++ coerce(y) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at all cusps of $\Gamma_0(N)$ where
      ++ N=level(y).
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    metadata: % -> SymbolicModularSiftedEtaQuotient
      ++ metadata(x) returns y such that coerce(y) = x.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $F_{s,r,m,t}(tau)$ at all cusps of Gamma_0(N).

  Implementation ==> add
    YMSEQ ==> SymbolicModularSiftedEtaQuotient
    Rep ==> Record(meta: YMSEQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: SymbolicModularSiftedEtaQuotient): % ==
        PX ==> SiftedEtaQuotientGamma(C, mx, CX, xi)
        import from PX
        nn: P := level y
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurent puiseux(y.cusp, w)
        per [y, hser]
    level(x: %): P == level(xx.meta)
    metadata(x: %): SymbolicModularSiftedEtaQuotient == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.meta)
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        metadata x = metadata y

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0}
\label{sec:QEtaModularGamma0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta quotient
in order to make it a modular function for
$\Gamma_0(N)$ having a pole only at infinity or to make the (positive)
orders at all cusps (\code{qetaGrades}) small in total sum.

)endif

)abbrev package QETAMG0 QEtaModularGamma0
QEtaModularGamma0: Exports == Implementation where
  Exports ==> with
    qetaGrades: SymbolicModularSiftedEtaQuotient -> XHashTable(Q, Z)
      ++ qetaGrades(y) returns the qetaGrades of the modular
      ++ function corresponding to y.
    qetaGrades: (P, LZ, P, LZ, P, N) -> XHashTable(Q, Z)
      ++ qetaGrades(nn, s, mm, r, m, t) returns
      ++ qetaGrades(y) where
      ++ y=etaQuotient(nn, s, mm, r, m, t)$SymbolicModularSiftedEtaQuotient.
    etaCoFactorInfinity: (P, P, LZ, P, N) -> LZ
      ++ etaCoFactorInfinity(nn,mm,r,m,t) returns a list s such that
      ++ modularGamma0?(nn,s,mm,r,m,t)$QEtaCoFactorSpace and
      ++ etaQuotient(nn,s,mm,r,m,t)$SymbolicModularSiftedEtaQuotient
      ++ corresponds to a modular function with poles only at infinity
      ++ and with smallest pole order.

    -- temporarily exported
    minimizeVector: (VZ, List VZ) -> VZ

  Implementation ==> add
    LVZ ==> List VZ
    ZRESULT ==> Record(zinhom: LVZ, zhom: LVZ, zfree: LVZ) -- zsolve$X4ti2
    ECFS ==>  Record(particular: Union(VZ, "failed"), basis: List VZ)
    C ==> Q
    lift2C x ==> map(coerce, x)$SparseUnivariatePolynomialFunctions2(Z, C)
    SUPC ==> SparseUnivariatePolynomial C
    CX ==> SimpleAlgebraicExtension(C, SUPC, supc)
    TX ==> QEtaTaylorSeries CX
    LX ==> QEtaLaurentSeries CX
    YMSEQ ==> SymbolicModularSiftedEtaQuotient
    MSEQ ==> ModularSiftedEtaQuotient(C, mx, CX, xi)
    a ==> aLigozat $ QETAAUX

    -- order of eta^r at cusp a/c.
    grade(nn: P, divs: LP, c: Z, r: LZ): Z ==
        l: LZ := [rdelta * a(nn, c, delta) for delta in divs for rdelta in r]
        -(reduce(_+, l, 0) exquo 24)::Z

    -- orders at cusps of Gamma0(nn) different from infinity
    grades(nn: P, divs: LP, cusps: LQ, r: LZ): LZ ==
        [grade(nn, divs, denom cusp, r) for cusp in cusps]

    qetaGrades(y: YMSEQ): XHashTable(Q, Z) ==
        mx: P := minimalRootOfUnity y
        supc: SUPC := lift2C(cyclotomic(mx)$CyclotomicPolynomialPackage);
        xi := generator()$CX;
        xsym: Symbol := "x"::Symbol;
        msetaq := y::MSEQ
        e: XHashTable(Q, LX) := expansions(msetaq)
        ht: XHashTable(Q, Z) := empty()
        for cusp in keys e repeat ht.cusp := -order(e.cusp)
        ht

    qetaGrades(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): XHashTable(Q, Z) ==
        y: YMSEQ := etaQuotient(nn, s, mm, r, m, t);
        qetaGrades y


    -- local function
    -- By adding interger multiples of elements of b we try to
    -- make the length of sinitial as small as possible in a cheap way.
    -- It is not completely necessary to find the minimal vector, since
    -- there is a second optimization step in minimalGrades that makes
    -- the order at the cusps relatively small.
    -- We try to achieve small length by a simple algorithm.
    --
    -- Let b be a vector of bas. Compute v1:=v+b, v2:=v-b. If v1 is
    -- strictly shorter than v, then set v to v1 and iterate. Similar
    -- if v2 is strictly shorter. If neither v1 nor v2 are not
    -- strictly shorter than v continue with the next vector from bas.
    minimizeVector(v: VZ, basis: LVZ): VZ ==
        empty? basis => v
        reduced?: Boolean := true -- to start the loop
        lv := dot(v, v)
        while reduced? repeat
            bas := basis
            reduced? := false
            while not empty? bas and not reduced? repeat
                b := first bas
                bas := rest bas
                u := v + b
                while (lu := dot(u, u)) < lv repeat
                    lv := lu
                    v := u
                    u := v + b
                    reduced? := true
                reduced? => break
                u := v - b
                while (lu := dot(u, u)) < lv repeat
                    lv := lu
                    v := u
                    u := v - b
                    reduced? := true
        v


    -- local function
    -- It might happen that the particular solution of etaCoFactorSpace
    -- has entries that are very big. That would lead to a very heavy
    -- computation when we determine the grades of the respective
    -- eta-quotient at all cusps. We therefore try to "reduce" the vector
    -- by elements of the basis such that the length of the vector becomes
    -- small.
    -- Here we do it by applying the LLL algorithm and trying to reconstruct
    -- a relavtively small vector s such that s = r + dot(c, bas) for some
    -- integer vector c.
    minimizeVectorLLL(rinitial: VZ, b: LVZ): VZ ==
        -- The rinitial vector might have very big numbers in it. We
        -- make them smaller by applying LLL to the system.
        -- Note that the elements of b correspond to exponent vectors that
        -- yield eta-quotients that are modular functions.
        mat: MZ := matrix cons(members rinitial, [members v for v in b])
        el: Record(lll: MZ, trf: MZ) := extendedLLL(mat)$LLLReduction
        -- Now look for 1 or -1 in the first entry of the transformation
        -- matrix.
        tmat: MZ := el.trf
        z: Z := 0
        i: N := 1
        n: N := nrows(tmat)
        while i <= n and not one? abs(z := tmat(i, 1)) repeat i := i+1
        one? abs z => z*row(tmat, i)*mat

        -- Here we were unlucky. No 1 or -1 in the first component found.
        -- Thus we try to construct a 1 by successive gcd computation.
        i := 1
        while i <= n and zero?(z := tmat(i, 1)) repeat i := i + 1
        i > n => rinitial
        -- We know that there is no 1 or -1 in the first position, so
        -- abs(tmat(i, 1)) is not equal to one. If i=n then we have no
        -- chance to change that into a 1.
        i = n => rinitial

        v: VZ := row(tmat, i)
        i := i + 1
        CCG ==> Record(coef1: Z, coef2: Z, generator: Z)
        while i <= n and not one? z repeat
            ccg: CCG := extendedEuclidean(z, tmat(i, 1))
            v := ccg(coef1) * v + ccg(coef2) * row(tmat, i)
            z := ccg.generator
            i := i + 1
        one? z => v*mat
        rinitial


    -- local function
    -- What actually counts is that the grade of eta-quotient corresponding
    -- to sinitial is small.
    -- The initial minimizeVector is only here, because the computation of
    -- qetaGrades involves the actual computation of the Laurent series
    -- expansion of the respective eta-quotient at all cusps. So we
    -- shouldn't have too high exponents.
    minimizeGrades(nn: P, mm: P, r: LZ, m: P, t: N, rinitial: VZ, b: LVZ): LZ ==
        sinitial := minimizeVector(rinitial, b)
        -- Compute the poleorders/grades (at all cusps) for the
        -- particular solution rinitial.
        g: XHashTable(Q, Z) := qetaGrades(nn, members sinitial, mm, r, m, t);
        -- Exclude order at the cusp infinity.
        cusps: LQ := [cusp for cusp in cusps(nn)$GAMMA0 | cusp~=1/nn]
        rhs: LZ := [g.cusp for cusp in cusps]

        -- For the vectors in the basis, we don't need to compute the
        -- series explicitly, since these vectors correspond to
        -- modular eta quotients and thus we can use the matrix of
        -- Ligozat to compute the order vectors.
        nndivs: List P := DIVISORS nn
        bas: List LZ := [grades(nn, nndivs, cusps, members r) for r in b]
        mat: MZ := transpose matrix bas
        rels: VZ := vector [1 for x in 1..#cusps]
        zresult: ZRESULT := zsolve(mat, rels, vector rhs)$X4ti2
        adjustment := members first zresult.zinhom
        members(sinitial - reduce(_+, [x*bb for x in adjustment for bb in b]))

    etaCoFactorInfinity(nn: P, mm: P, r: LZ, m: P, t: N): LZ ==
        ecfs: ECFS := etaCoFactorSpace(nn, mm, r, m, t)$QEtaCoFactorSpace
        n: Z := numberOfDivisors(nn)$IntegerNumberTheoryFunctions
        sinitial: VZ := ((ecfs.particular)::VZ)(1..n)
        b: LVZ := [x(1..n) for x in ecfs.basis]
        members minimizeGrades(nn, mm, r, m, t, sinitial, b)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0Infinity}
\label{sec:QEtaModularGamma0Infinity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta quotient
in order to make it a modular function having a pole only at infinity
or to make the (positive) orders at all cusps (\code{qetaGrades})
small in total sum.

)endif

)abbrev package QETAMG0I QEtaModularGamma0Infinity
QEtaModularGamma0Infinity(C: IntegralDomain): Exports == Implementation where
  T1 C  ==> QEtaTaylorSeries C
  L1 C  ==> QEtaLaurentSeries C
  A1 C ==> Finite0Series C
  EQI C  ==> EtaQuotientInfinity C
  Exports ==> with
    modularSiftedEtaQuotientInfinity: (P, LZ, P, LZ, P, N) -> A1 C
      ++ modularSiftedEtaQuotientInfinity(nn, s, mm, r, m, t) returns
      ++ the series expansion of
      ++ etaQuotient(nn,s,mm,r,m,t)$SymbolicModularSiftedEtaQuotient
      ++ at the cusp infinity.
    modularSiftedEtaQuotientInfinity: (P, P, LZ, P, N) -> A1 C
      ++ modularSiftedEtaQuotientInfinity(nn, mm, r, m, t) returns
      ++ modularSiftedEtaQuotientInfinity(nn, s, mm, r, m, t) for s
      ++ equal to etaCoFactorInfinity(nn, mm, r, m, t).
  Implementation ==> add
    -- generating series for a(m*n+t) with cofactor eta quotient and
    -- the fractional q power where \sum_{k=0}^\infty a(k)q^k is
    -- defined by an eta-quotient with exponent vector r.

    modularSiftedEtaQuotientInfinity(nn:P, s:LZ, mm:P, r:LZ, m:P, t:N): A1 C ==
        -- First compute the expansion of the orbit product.
        eulerquo: T1 C := qetaTaylorRep(eulerExpansion(mm, r)$EQI(C))

        orb: List N := orbit(mm, r, m, t)$QEtaCoFactorSpace
        tt := first orb
        p: T1 C := multisect(m-tt, tt, eulerquo)
        -- Now multiply the series selecting sum_{n=0}^\infty a(m*n+k)q^n.
        for k in rest orb repeat p := p * multisect(m-k, k, eulerquo)

        -- The expansion of the coFactor is here.
        -- We take care of the right q-order through alphaInfinity.
        cofact: T1 C := qetaTaylorRep(eulerExpansion(nn, s)$EQI(C))

        -- We multiply both things together to get (nearly) a modular
        -- function.
        tf: T1 C := cofact * p

        -- We have to multiply by some q-power to get the expansion of
        -- a modular function f.
        alpha: Z := alphaInfinity(nn, s, mm, r, m, t)$QEtaCoFactorSpace
        laurent(alpha, tf)$A1(C)

    modularSiftedEtaQuotientInfinity(nn: P, mm: P, r: LZ, m: P, t: N): A1 C ==
        orb: List N := orbit(mm, r, m, t)$QEtaCoFactorSpace
        tracePrint("orbit", sort orb)
        s: List Z := etaCoFactorInfinity(nn, mm, r, m, t)$QEtaModularGamma0
        tracePrint("cofactor", s)
        modularSiftedEtaQuotientInfinity(nn, s, mm, r, m, t)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularFunctionExpansionsAtCusps}
\label{sec:ModularFunctionExpansionsAtCusps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $s\in R(N)$, and \code{e = etaQuotient(N, s)}, \code{v
  = coerce(expansions e)} then $v$ represents the vector of Laurent
expansions of an eta quotient (corresponding to $s$) at the cusps of
$\Gamma_0(N)$ given in the argument of the constructor.
It is assumed that the corresponding modular function has only poles
at these cusps.
%
These vectors form an algebra that similar to
\code{Finite0Series} have a finite zero test. A vector $v$ is zero, if
\code{qetaGrade(v, k)} is smaller than 0 for all indices $k$ from 1 to
$n$ where $n$ is the number of cusps of the given cusps.

)endif

)abbrev domain MODFUNC ModularFunctionExpansionsAtCusps
++ ModularFunctionExpansionsAtCusps(C, L, cusps) represents the
++ algebra of eta quotients that are modular functions for a certain
++ Gamma_0(m) and have only poles at the given cusps.
ModularFunctionExpansionsAtCusps(C, cusps): Exports == Implementation
 where
  C: IntegralDomain
  L ==> QEtaLaurentSeries C
  cusps: LQ
  Exports ==> XEtaGradedAlgebra C with
    coerce: XHashTable(Q, L) -> %
      ++ If t is a hashtable containing (for each cusp of Gamma_0(m)
      ++ the series expansions at the cusps, then etaQuotient(t) creates
      ++ a data structure that can be used for computations.
    series: (%, P) -> L
      ++ series(x, n) returns the series corresponding to the n-th index.
      ++ Indices can run from 1 to maxIndex().
  Implementation ==> add
    ncusps: P := asP(#cusps)
    Rep ==> DirectProduct(ncusps, L)
    xx ==> rep x
    yy ==> rep y

    coerce(t: XHashTable(Q, L)): % ==
        -- sanity check
        # (cs := keys t) ~= ncusps or sort cs ~= sort cusps =>
            error "keys do not agree with cusps of this domain"
        per directProduct vector [t.c for c in cusps]

    coerce(x: %): OutputForm == xx::OutputForm
    0: % == per(0$Rep)
    1: % == per(1$Rep)
    zero?(x: %): Boolean ==
        for kn in 1..ncusps repeat
            k: P := asP kn
            qetaGrade(x, k, 0) > 0 => return false
            not zero? xx.k.0 => return false
        return true

    _-(x: %): % == per(- xx)
    ((x: %) + (y: %)): % == per(xx + yy)
    ((x: %) - (y: %)): % == per(xx - yy)
    ((x: %) * (y: %)): % == per(xx * yy)
    ((c: C) * (x: %)): % == per map((s: L): L +-> c * s, xx)
    ((x: %) ^ (n: N)): % == per map((s: L): L +-> s^n, xx)
    maxIndex(): P == ncusps
    qetaIndex(x: %): P ==
        --assert(not zero? x) -- therefore for one k qetaGrade(x,k)>=0
        maxGrade: Z := -1 -- dummy value
        idx: N := 0
        for kn in 1 .. ncusps repeat
            k: P := asP kn
            if (mx := qetaGrade(x, k)) > maxGrade then
                maxGrade := mx
                idx: P := k
        return idx
    qetaGrade(x: %, k: P): Z == - order(xx.k)
    qetaGrade(x: %, k: P, mn: Z): Z == - order(xx.k, -mn)
    qetaLeadingCoefficient(x: %, k: P): C == leadingCoefficient(xx.k)
    series(x: %, k: P): L == xx.k
    qetaGrades(x: %): LZ ==
        zero? x => [-1$Z for k in 1..ncusps]
        [qetaGrade(x, asP k) for k in 1..ncusps]
    if C has Field then
        ((x: %) / (y: %)): % ==
            v: Vector L := new(ncusps, 0) -- new vector
            for i in 1..ncusps repeat v.i := xx.i / yy.i
            per(directProduct(v)$Rep)



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularFunctionExpansions}
\label{sec:ModularFunctionExpansions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $s\in R(N)$, and \code{e = etaQuotient(N, s)}, \code{v
  = coerce(expansions e)} then $v$ represents the vector of Laurent
expansions of an eta quotient (corresponding to $s$) at each cusp of
$\Gamma_0(N)$. These vectors form an algebra that similar to
\code{Finite0Series} have a finite zero test. A vector $v$ is zero, if
\code{qetaGrade(v, k)} is smaller than 0 for all indices $k$ from 1 to
$n$ where $n$ is the number of cusps of $\Gamma_0(N)$.

)endif
)abbrev domain MODFUNX ModularFunctionExpansions
++ ModularFunctionExpansions(C, m) represents the algebra of
++ eta quotients that are modular functions for Gamma_0(m).
ModularFunctionExpansions(C, m): Exports == Implementation where
  C: IntegralDomain
  L ==> QEtaLaurentSeries C
  m: P -- level
  Exports ==> XEtaGradedAlgebra C with
    coerce: XHashTable(Q, L) -> %
      ++ If t is a hashtable containing (for each cusp of Gamma_0(m)
      ++ the series expansions at the cusps, then etaQuotient(t) creates
      ++ a data structure that can be used for computations.
    series: (%, P) -> L
      ++ series(x, n) returns the series corresponding to the n-th index.
      ++ Indices can run from 1 to maxIndex().
  cog0 ==> cusps(m)$GAMMA0
  Implementation ==> ModularFunctionExpansionsAtCusps(C, cog0)


)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
