-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
warnPrint(x,y) ==> tracePrint(x,y)
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (generalized) Dedekind Eta Functions into $q$-series
  at various cusps}

\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of (generalized)
  Dedekind eta-quotients that have been turned into a modular function
  by multiplication with a cofactor. Expansions into $q$-series of
  objects are considered at any cusp of $\Gamma_0(N)$ or
  $\Gamma_1(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$CongruenceSubgroupGamma0)
WIDTH1(nn, c) ==> asP(width(nn, c)$CongruenceSubgroupGamma1)





)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We do the compuation in an extension of the coefficient field by a
root of unity. We determine the order of the root of unity that is
needed to represent the coefficients of the expansion at any cusp via
\emph{symbolic} domains. These domains hold all relevant data to be
able to turn them into an actual series expansion.

All these domains are marked with the prefix \code{Symbolic} and
implemented in \PathName{qetaquotsymb.spad}.

In this file we assume that \code{mx} holds the order of the minimal
root of unity needed and that \code{xi} is such a primitive root of
unity and \code{CX} is $C[\xi]$.

Eta-quotients are considered as modular functions for $\Gamma_0(N)$,
whereas generalized eta-quotients are considered as modular functions
for $\Gamma_1(N)$.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaSeriesExpansion
  $p_{r,m,t}(\gamma\tau)$, $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:QEtaSeriesExpansion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The package \code{QEtaSeriesExpansion} turns an element of a
\emph{symbolic} domain into a Puiseux series or a Laurent series if
the respective width of the cusp is given.



)endif

-------------------------------------------------------------------
)abbrev package QESX QEtaSeriesExpansion
++ QEtaSeriesExpansion computes an eta quotient expansion of
++ $g_{r,m,\lambda}(\gamma \tau)$, $p_{r,m,t}(\gamma\tau)$,
++ $F_{s,r,m,t}(\gamma\tau)$. See \eqref{eq:g_r-m-lambda(gamma*tau)}
++ and \eqref{eq:F_s-r-m-t(gamma*tau)}.
QEtaSeriesExpansion(C, mx, CX, xi): Exports == Implementation where
  C: IntegralDomain -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX
  PX ==> QEtaPuiseuxSeries CX
  QLX ==> XHashTable(Cusp, LX)
  YM1GEQG ==> SymbolicModularGamma1GeneralizedEtaQuotientGamma
  YM1GEQ ==> SymbolicModularGamma1GeneralizedEtaQuotient

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseuxExpansion: (SymbolicEtaQuotientLambdaGamma, Q) -> PX
      ++ puiseuxExpansion(y, r) computes the Puiseux expansion of
      ++ $g_{r,m,\lambda(\gamma\tau)$ in terms of $q$ multiplied by
      ++ $\exp(2\pi i r)$. The $(c\tau+d)$ factor is missing.
      ++ See \eqref{eq:g_r-m-lambda(gamma*tau)}.
    puiseuxExpansion: SymbolicEtaQuotientGamma -> PX
      ++ puiseuxExpansion(y) computes the Puiseux expansion of the
      ++ q-expansion of $p_{r,m,t}(\gamma \tau)$, see
      ++ \eqref{eq:p_r-m-t(gamma*tau)}. The $(c\tau+d)$ factor is
      ++ missing.
    puiseuxExpansion: SymbolicEtaQuotientOrbitProductGamma -> PX
      ++ puiseuxExpansion(x) computes the PuiseuX expansion of
      ++ P_{r,m,t}(\gamma\tau), see \eqref{eq:P_r-m-t(gamma*tau)}.
      ++ The $(c\tau+d)$ factor is missing.
    puiseuxExpansion: SymbolicModularGamma0EtaQuotientGamma -> PX
      ++ puiseuxExpansion(y) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$, see
      ++ \eqref{eq:F_s-r-m-t(gamma*tau)}.

    laurent: (PX, P) -> LX
      ++ If p(q)=s(z) is a Puiseux series p expressed as a Laurent
      ++ series s in the variable z=q^r, then laurent(x, w) returns
      ++ the laurent series l such that l(x)=s(z)=p(q) where x=q^(1/w)
      ++ in case r*w is an integer. It might happen that r*w is not an
      ++ integer. That is even to be expected since non-modular
      ++ eta-quotients involve a factor in terms of q^(1/24). If
      ++ r=s/t, then we take only every t-th term and check that the
      ++ intermediate terms come indeed with a zero coefficient.

    laurentExpansion: SymbolicModularGamma0EtaQuotientGamma -> LX
      ++ laurentExpansion y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ given by y in the canonical
      ++ variables given by the width of the cusp wrt.
      ++ Gamma_0(level(y)).
    laurentExpansions: SymbolicModularGamma0EtaQuotient -> QLX
      ++ laurentExpansions y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ at all cusps given by y in the
      ++ canonical variables given by the width of the cusp wrt.
      ++ Gamma_0(level y).

    --TODO: The following function should live somewhere else.
    substitute: (LX, Q, N) -> PX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

--    puiseuxExpansion: (SymbolicProperGeneralizedEtaQuotientLambdaGamma, Q) -> PX
    if CX has Field then
      puiseuxExpansion: (SymbolicGeneralizedEtaQuotientLambdaGamma, Q) -> PX
        ++ puiseuxExpansion(y, r) return the Puiseux expansion of
        ++ $g_{\bar{r},m,\lambda(\gamma\tau)$ in terms of $q$
        ++ multiplied by $\exp(2\pi i r)$. The $(c\tau+d)$ factor is
        ++ missing. See \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
      puiseuxExpansion: SymbolicGeneralizedEtaQuotientGamma -> PX
        ++ puiseuxExpansion(y) return the Puiseux expansion of
        ++ $p_{\bar{r},m,\lambda(\gamma\tau)$ in terms of $q$. The
        ++ $(c\tau+d)$ factor is missing. See
        ++ \eqref{eq:p_rbar-m-lambda(gamma*tau)}. The $(c\tau+d)$
        ++ factor is missing.
      puiseuxExpansion: YM1GEQG -> PX
        ++ puiseuxExpansion(y) represents the q-expansion of
        ++ $F_{\bar{s},\bar{r},m,t}(\gamma \tau)$, see
        ++ \eqref{eq:F_sbar-rbar-m-t(tau)}.
      laurentExpansion: YM1GEQG -> LX
        ++ laurentExpansion y represents the q-expansion of
        ++ $F_{\bar{s},\bar{r},m,t}(\gamma\tau)$ given by y in the
        ++ canonical variables given by the width of the cusp wrt.
        ++ Gamma_1(level(y)). See \eqref{eq:F_sbar-rbar-m-t(tau)}.
      laurentExpansions: YM1GEQ -> QLX
        ++ laurentExpansions y represents the q-expansion of
        ++ $F_{\bar{s},\bar{r},m,t}(\gamma\tau)$ at all cusps given by
        ++ y in the canonical variables given by the width of the cusp
        ++ wrt. Gamma_1(level y).

  Implementation ==> PX add
    Rep ==> PX
    xx ==> rep x

    -- Cache for frequently used objects
    xic: CachedPower CX := xi :: CachedPower(CX)

-------------------------------------------------------------------
-- local functions
-------------------------------------------------------------------
    xipow(n: Z): CX ==
         -- Take care of the fact that xi^mx = 1.
        e: Z := positiveRemainder(n, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    xiPower(v: Z): (Z -> CX) == (e: Z): CX +-> xipow(v*e)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: Q, v: N): PX ==
        puiseux(u, multiplyCoefficients(xiPower v, s))

    eulerFunctionPower(u: Q, v: N, rd: Z): PX ==
        zero? rd => 1$PX
        efp: LX := eulerFunctionPower(1, rd)$CachedQPochhammerPower(CX, LX)
        substitute(efp, u, v)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        sqrt: CX := squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)
        C has Algebra Q  => sqrt * ((rr.rat)::C::CX)
        CX has Algebra Q => sqrt * ((rr.rat)::CX)
        -- Otherwise we can only continue if we have no denominators.
        one? denom(rr.rat) => numer(rr.rat)::CX * sqrt
        error "cannot take root in coefficient ring"

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    laurent(x: PX, w: P): LX ==
        x := multiplyExponents(x, w)
        r: Q := rationalPower x
        -- Here we assume that the Puiseux series x is indeed a
        -- Laurent series in q^(1/w).
        d: P := denom(r)::P
        n: P := numer(r)::P
        lx: LX := qetaLaurentRep x
        -- if possible, get rid of some initial zeros up to degree 0
        lx := removeZeroes(-degree lx, lx)
        one? d => -- lucky case, no multisect needed
            one? n => return lx -- avoid needless "multiplyExponents"
            return multiplyExponents(lx, n)
        lx := choose(d, 0, lx)$LX
        one? n => return lx
        return multiplyExponents(lx, n)


)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- local
    -- The q-Pochhammer part (last product) of \eqref{g_r-m-lambda(gamma*tau)}.
    qPochhammerPure(y: SymbolicEtaQuotientLambdaGamma): PX ==
        px: PX := 1
        for delta in divisors y for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicEtaGamma := y.delta
            u: Q := udelta etadelta
            v: Q := mx * vdelta etadelta
            not one? denom v or v<0 =>
                errorPrint("delta", delta)
                errorPrint("vdelta", [vdelta etadelta, u]$List(Q))
                error "QEtaSeriesExpansion: denominator does not vanish"
            px := px * eulerFunctionPower(u, asN numer v, rd)
        return px

    -- $g_{r,m,\lambda}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicEtaQuotientLambdaGamma, ue: Q): PX ==
        uexp: Q := mx * (lambda(y)*ue + unityExponent y)
        not one? denom uexp =>
            errorPrint("mx * unityExponent y", uexp)
            error "QEtaSeriesExpansion: denominator for xi does not vanish"
        -- leading coefficient
        cx: CX := xipow numer uexp * squareRoot rationalPrefactor y
        monomial(cx, qExponent y) * qPochhammerPure y


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function computes
\begin{gather*}
  p_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- $p_{r,m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicEtaQuotientGamma): PX ==
        ue: Q := unityExponent y
        px: PX := puiseuxExpansion(y.0, ue) -- $g_{r,m,\lambda}$ for lambda=0
        m: P := multiplier y
        one? m => px
        m1: P := asP(m::Z - 1)
        for lambda in 1..m1 repeat px := px + puiseuxExpansion(y.lambda, ue)
        -- Summation possibly produces zero leading coefficients.
        -- We try to remove at most 100 leading coefficients.
        --TODO: Make 100 dependent on some parameters.
        -- "lx: LX := removeZeroes(lx)$LX" would be nice the following
        -- gives the zero series and thus wouldn't terminate.
        -- "findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)"
        C has Algebra Q => ((1/m)$Q)::C::CX * px
        CX has Algebra Q => ((1/m)$Q)::CX * px
        error "cannot invert m in coefficient ring"

    -- $P_{r,m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicEtaQuotientOrbitProductGamma): PX ==
        orb: List N := orbit y
        t: N := first orb;
        px: PX := puiseuxExpansion(y.t) -- p_{r,m,t}
        for k in rest orb repeat px := px * puiseuxExpansion(y.k)
        px

    -- $f_{s,r,m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicModularGamma0EtaQuotientGamma): PX ==
        puiseuxExpansion cofactor y * puiseuxExpansion orbitProduct y

    -- $F_{s,r,m,t}(\gamma\tau)$
    laurentExpansion(y: SymbolicModularGamma0EtaQuotientGamma): LX ==
        cy: SymbolicEtaQuotientGamma := cofactor y
        nn: P := level cy
        g: SL2Z := gamma cy
        w: P := WIDTH0(nn, cusp(g(1,1),g(2,1)))
        laurent(puiseuxExpansion y, w)

    -- $g_r(\gamma\tau)$ for all cusps of $\Gamma_0(N)$
    -- $F_{s,r,m,t}(\gamma\tau)$ for all cusps of $\Gamma_0(N)$
    laurentExpansions(y: SymbolicModularGamma0EtaQuotient): QLX ==
        hser: QLX := empty()
        for cusp in cusps y repeat hser.cusp := laurentExpansion(y.cusp)
        hser



)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\bar{r} \in \bar{R}(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion of
$g_{\tilde{r},m,\lambda}(\gamma\tau)$, \ie, in terms of
$q^{1/w)}$, \ie, the series from
\eqref{eq:g_rtilde-m-lambda(gamma*tau)}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif



    if CX has Field then
      -- For all the function below we assume that CX is a field.

      -- local
      -- Note that according to
      -- \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)-0} and
      -- \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)} the respective
      -- $(1-\zeta_\delta^{-b'g})$ factor is taken care of in the
      -- jacobiFunction arguments if a'g is divisibly by \delta.
      -- So we only have the $exp(2\pi i \cdot 1/2*P_1(b'g/delta))$
      -- contribution, which we here encode.
      --assert(CX has Field)
      alphaSchoenebergContribution(_
        y: SymbolicProperGeneralizedEtaQuotientLambdaGamma): CX ==
          cx: CX := 1
          for l in exponents y repeat
              delta := asP l.1; g := asP l.2; rdg := l.3;
              ygeg := y(delta, g)
              g1 := gamma1 ygeg
              gd: Q := fractionalPart(g1(1,1)*g/delta)$QETAAUX -- note that h=0
              hd: Q := fractionalPart(g1(1,2)*g/delta)$QETAAUX
              if zero? numer gd and not zero? numer hd and not zero? rdg then
                  -- Note that xi is a mx-th root of unity so, we have
                  -- to multiply the (rational) exponent of xi by mx.
                  uexp: Q := (mx/2)*fractionalBernoulli1(hd)$QETAAUX
                  not one? denom uexp =>
                      errorPrint("mx * Bernoulli1", uexp)
                      error "QEtaSeriesExpansion: alphaSchoenebergContribution"
                  cx := cx * xipow(rdg * numer uexp)
          cx

      -- local
      -- Compute $\tilde{r}_\delta$ from $\tilde{r}$. See definition
      -- below \eqref{eq:p_rbar-m-lambda(gamma*tau)}, i.e.
      -- $\tilde{r}_\delta := \sum_{0 < g < \frac{\delta}{2}} r_{\delta,g}$.
      rtilde(delta: P, y: SymbolicProperGeneralizedEtaQuotientLambdaGamma): Z ==
          rd: Z := 0
          for l in exponents y | delta = asP l.1 repeat rd := rd + l.3;
          rd

      -- local
      -- The q-Pochhammer part (last product) of
      -- \eqref{eq:p_rbar-m-lambda(gamma*tau)}.
      -- It includes the pure and properGeneralized part, because we
      -- employ the jacobiProduct to compute it.
      --assert(CX has Field)
      qPochhammerGeneralized(_
        y: SymbolicGeneralizedEtaQuotientLambdaGamma): PX ==
          ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
          ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
              properGeneralizedEtaQuotient y

          -- We first compute the first q-Pochhammer product (with
          -- exponent $r_\delta - \tilde{r}_\delta$, see
          -- \eqref{eq:p_rbar-m-lambda(gamma*tau)}.
          -- Compare also with implementation of qPochhammerPure
          px: PX := 1
          divs: List P := divisors ypure
          r: LZ := concat(exponents ypure, [0 for i in divs]) -- fill r with 0's
          for delta in divs for rd in r _
                  | not zero?(expo := rd - rtilde(delta, ypg)) repeat
              etadelta: SymbolicEtaGamma := ypure.delta
              u: Q := udelta etadelta
              v: Q := mx * vdelta etadelta
              not one? denom v or v<0 =>
                  errorPrint("delta", delta)
                  errorPrint("vdelta", [vdelta etadelta, u]$List(Q))
                  error "QEtaSeriesExpansion: denominator does not vanish"
              px := px * eulerFunctionPower(u, asN numer v, expo)

          -- Now the jacobiFunction part.

          -- According to whether or not a'g/delta is an integer, we
          -- distinguish two cases.
          -- \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)-0} and
          -- \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}
          for l in exponents ypg repeat
              delta := asP l.1; g := asP l.2; rdg := l.3;
              ygeg: SymbolicGeneralizedEtaGamma := ypg(delta, g)
              g1 := gamma1 ygeg
              alphabeta := fractionalPart(g1(1,1)*g/delta)$QETAAUX
              alpha: Z := numer alphabeta
              beta: Z  := denom alphabeta
              -- exponent for mx-th root of unity
              h: Q := mx*g1(1,2)*g/delta -- is made smaller in xipow
              not one? denom h => -- mx should be such that h is integral
                  errorPrint("mx*h'/delta", h)
                  error "QEtaSeriesExpansion: denom for xi does not vanish"
              jac ==> jacobiFunction $ QFunctions(CX, LX)
              -- See \eqref{eq:mimimalRootOfUnity-g_rtilde-m-lambda}.
              nh: Z := numer h
              if zero? alpha then -- {eq:eta_delta-g-m-lambda^[R](gamma*tau)-0}
                  lx: LX := jac(xiPower(-nh), beta::P, 0)^rdg
              else
                  lx: LX := jac(xiPower nh, beta::P, alpha::N)^rdg
              u: Q := udelta(ygeg)
              v: Q := vdelta(ygeg)
              vbeta: Q := mx * v * (1/beta)
              not one? denom vbeta =>
                  errorPrint("vbeta", vbeta)
                  error "QEtaSeriesExpansion: denom for xi does not vanish"
              px := px * substitute(lx, (1/beta)*u, asP numer vbeta)
          return px










)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\bar{r} \in \bar{R}(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion of
$g_{\bar{r},m,\lambda}(\gamma\tau)$, \ie, in terms of
$q^{1/w)}$, \ie, the series from \eqref{eq:g_rbar-m-lambda(gamma*tau)}
without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

      -- $g_{\bar{r},m,\lambda}(\gamma\tau)$
      --assert(CX has Field)
      puiseuxExpansion(y: SymbolicGeneralizedEtaQuotientLambdaGamma,
                       ue: Q): PX ==
          -- Theoretically, the following would be sufficient.
          --
          --: ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
          --: ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
          --:     properGeneralizedEtaQuotient y
          --: puiseuxExpansion(ypure, ue) * puiseuxExpansion(ypg, 0)
          --
          -- However, in certain cases the expansion of the pure
          -- eta-quotient with the unityExponent ue for the
          -- generalized eta-quotient would lead to the necessity of
          -- not only a mx-th root of unity, but a bigger root of unity.
          -- This could be solved in different ways.
          --
          -- (a) Change the minimalRootOfUnity computation for
          --     SymbolicGeneralizedEtaQuotientGamma, in order to be
          --     able to use the above simple code.
          -- (b) Split ue in the respective ue for the pure
          --     eta-quotient and a rest (basically \sigma_\infty
          --     for the proper generalized part), adapt the code
          --     above accordingly, and also adapt the
          --     minimalRootOfUnity computation accordingly.
          -- (c) Implement according to what is under the sum sign in
          --     \eqref{eq:p_rbar-m-t(gamma*tau)}.
          --
          -- We decided for (c), because that avoids some
          -- multiplication with coefficients and monomials.

          uexp: Q := mx * (lambda(y)*ue + unityExponent y)
          not one? denom uexp =>
              errorPrint("mx * unityExponent y", uexp)
              error "QEtaSeriesExpansion: denominator for xi does not vanish"

          -- leading coefficient
          ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
          cx: CX := xipow numer uexp * squareRoot rationalPrefactor ypure

          -- Take \eqref{eq:eta_g-h^[S](tau)-prefactor} into account (in cx).
          ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
              properGeneralizedEtaQuotient y
          cx := cx * alphaSchoenebergContribution ypg
          monomial(cx, qExponent y)$PX * qPochhammerGeneralized y







)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\bar{r} \in \bar{R}(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion of
$p_{\bar{r},m,\lambda}(\gamma\tau)$, \ie, in terms of
$q^{1/w)}$, \ie, the series from \eqref{eq:p_rbar-m-t(gamma*tau)}
without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

      -- $p_{\bar{r},m,t}(\gamma\tau)$
      --assert(CX has Field)
      puiseuxExpansion(y: SymbolicGeneralizedEtaQuotientGamma): PX ==
          ue: Q := unityExponent y
          px: PX := puiseuxExpansion(y.0, ue) -- $g_{rbar,m,\lambda}$ for lambda=0
          m: P := multiplier y
          one? m => px
          m1: P := asP(m::Z - 1)
          for lambda in 1..m1 repeat px := px + puiseuxExpansion(y.lambda, ue)
          inv(m::CX) * px

      -- $F_{\bar{r},m,t}(\gamma\tau)$
      --assert(CX has Field)
      puiseuxExpansion(y: YM1GEQG): PX ==
          yc: SymbolicGeneralizedEtaQuotientGamma := cofactor y
          yb: SymbolicGeneralizedEtaQuotientGamma := basefactor y
          puiseuxExpansion yc * puiseuxExpansion yb

      -- $F_{\bar{r},m,t}(\gamma\tau)$
      --assert(CX has Field)
      laurentExpansion(y: YM1GEQG): LX ==
          cy: SymbolicGeneralizedEtaQuotientGamma := cofactor y
          nn: P := level cy
          g: SL2Z := gamma cy
          w: P := WIDTH1(nn, cusp(g(1,1),g(2,1)))
          laurent(puiseuxExpansion y, w)

      -- $g_{\bar{r}}(\gamma\tau)$ for all cusps of $\Gamma_1(N)$
      -- $F_{\bar{r},m,t}(\gamma\tau)$ for all cusps of $\Gamma_1(N)$
      --assert(CX has Field)
      laurentExpansions(y: YM1GEQ): QLX ==
          hser: QLX := empty()
          for cusp in cusps y repeat hser.cusp := laurentExpansion(y.cusp)
          hser


















)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
