-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (sifted and generalized) Dedekind Eta Functions into
  $q$-series at various cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of sifted and
  generalized Dedekind eta-quotients that have been turned into a
  modular function by multiplication with a cofactor. Expansions into
  $q$-series of objects are considered at any cusp of $\Gamma_0(N)$ or
  $\Gamma_1(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
GAMMA0 ==> CongruenceSubgroupGamma0
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]
lcmP(a, b) ==> asP lcm(a::Integer, b::Integer)





)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic} and implemented in \PathName{qetaquotsymb.spad}.

Another naming convention is that domains that involve the string
\code{Sifted} correspond to an application of the
$U_m$ operator, \ie, instead of looking on a series
$\sum_{n=0}^\infty{a(n)}
q^n$, we deal with a ``sifted'' series of the form
$\sum_{n=0}^\infty{a(mn+t) q^n}$.

Eta-quotients are considered as modular functions for $\Gamma_0(N)$,
whereas generalized eta-quotients are considered as modular functions
for $\Gamma_1(N)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D EtaQuotientGamma}
\label{sec:EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, and \code{y = etaQuotient(N, r, gamma)} and
\code{e = etaQuotient(y)}, then $e$ represents the tuple
\begin{gather}
  \left(
  \underbrace{y}_{\texttt{symbolicEtaQuotient}}
  ,
  \underbrace{\divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  }_{\texttt{leadingCoefficient}}
  ,
  \underbrace{\divisorprod{N}\prod_{n=1}^{\infty}
    (1-\unityPower{n v_\delta} x^{n e_\delta})^{r_\delta}
  }_{\texttt{series}}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:modular-g_r(gamma*tau)} with
$x=\unityPower{\frac{\tau}{w_\gamma}}$ where $w_\gamma$ is given by
\eqref{eq:width0}.

The exponent of $x$ in formula \eqref{eq:modular-g_r(gamma*tau)} is
given through \code{xExponent(symbolicEtaQuotient(e))} if $e$ is an
element of this domain and is taken into account when
\code{expansion(e)} is computed.

)endif
-------------------------------------------------------------------
)abbrev domain EQG EtaQuotientGamma
++ EtaQuotientGamma(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotient expansions at gamma.
++ The eta-quotient need not be a modular function, but the (c*tau+d)
++ factor is always ignored.
EtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: SymbolicEtaQuotientGamma -> %
      ++ coerce(s) represents the expansion of
      ++ g_r(\gamma \tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c),
      ++ r = exponents(s), and g_r is defined by
      ++ $g_r(\tau) =
      ++   \prod_{\delta in divisors(s)} \eta(\delta \gamma \tau)^{r_{\delta}}$.
    eulerFunctionPower: (P, N, Z) -> LX
      ++ eulerFunctionPower(u, v, p) computes eulerFunction(1)^p and
      ++ replaces q=monomial(1,1)$LC by monomial(xi^v, u)$LX
    symbolicEtaQuotient: % -> SymbolicEtaQuotientGamma
      ++ symbolicEtaQuotient(x) returns meta-data corresponding to x.
    eulerExpansion: % -> LX
      ++ eulerExpansion(e) returns the series expansion of e without
      ++ any prefactor.
      ++ The true series expansion (in terms of fractional x powers of e
      ++ is given by lc * x^p * s where
      ++ lc = leadingCoefficient e,
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c),
      ++ y = symbolicEtaQuotient e,
      ++ c = gamma(y)(2,1),
      ++ p = xExponent y,
      ++ s = eulerExpansion e.
    expansion: % -> LX
      ++ expansion(e) should only be called if modularGamma0?(e) holds,
      ++ otherwise it might return an error.
      ++ expansion(e) returns the series expansion of e in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c),
      ++ c = gamma(symbolicEtaQuotient e)(2,1).
    leadingCoefficient: % -> CX
      ++ leadingCoefficient(x) returns the coefficient corresponding
      ++ to the smallest q-power with non-zero coefficient.
    modularGamma0?: % -> Boolean
      ++ modularGamma0?(x) returns true if the eta-quotient is a
      ++ modular function for Gamma0(nn) where
      ++ nn=level(symbolicEtaQuotient x).

    --TODO: The following function should live somewhere else.
    substitute: (LX, P, N) -> LX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

  Implementation ==> add
    Rep ==> Record(fsymetaquo: SymbolicEtaQuotientGamma, lc: CX, ser: LX)
    -- The true series expansion of e is given by c * x^p * s where
    -- c = leadingCoefficient e
    -- x = \exp(2 \pi i \tau/w) where w=width(m, c)
    -- p = xExponent symbolicEtaQuotient e
    -- s = eulerExpansion e
    xx ==> rep x
    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

    xiPower(v: N): (Z -> CX) == (e: Z): CX +->
         -- Take care of the fact that xi^mx = 1.
        e := positiveRemainder(v*e, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: P, v: N): LX ==
        multiplyExponents(multiplyCoefficients(xiPower v, s), u)

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        zero? rd => 1$LX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    coerce(e: SymbolicEtaQuotientGamma): % ==
        m: P := level e
        divs: LP := divisors e
        s: LX := 1
        for delta in divs for rd in exponents e | not zero? rd repeat
            etadelta: SymbolicEtaDeltaGamma := e.delta
            u: P := edelta(etadelta)
            v: N := asN numer(mx * vdelta(etadelta))
            s := s * eulerFunctionPower(u, v, rd)
        q: Q := mx * unityPower e
        if not one? denom q then
            error "EtaQuotientGamma: denominator does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor e -- leading coefficient
        per [e, cx, s]

    symbolicEtaQuotient(x: %): SymbolicEtaQuotientGamma == xx.fsymetaquo
    leadingCoefficient(x: %): CX == xx.lc
    eulerExpansion(x: %): LX == xx.ser
    expansion(x: %): LX ==
        lc: CX := leadingCoefficient x
        y: SymbolicEtaQuotientGamma := symbolicEtaQuotient x
        ord: Z :=
            not one? denom xExponent y =>
                error "expansion$EtaQuotientGamma: rational exponent"
            numer xExponent y -- order of series
        monomial(lc, ord)$LX * eulerExpansion x

    modularGamma0?(x: %): Boolean == modularGamma0? symbolicEtaQuotient x

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean == symbolicEtaQuotient x = symbolicEtaQuotient y

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularGamma0EtaQuotient}
\label{sec:ModularGamma0EtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R^*(N)$, and \code{e = etaQuotient(N, r)}, then
$e$ represents the information given in
\eqref{eq:modular-g_r(gamma*tau)}
for each cusp $\frac{a}{c}$ of $\Gamma_0(N)$.


)endif
)abbrev domain M0EQ ModularGamma0EtaQuotient
++ ModularGamma0EtaQuotient(C, mx, CX, xi, LX) represents the set
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
ModularGamma0EtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  YEQ ==> SymbolicEtaQuotient
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: YEQ -> %
      ++ coerce(y) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(level y).
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ level(x) returns m such that x corresponds to a modular
      ++ function for Gamma_0(m).
    symbolicEtaQuotient: % -> YEQ
      ++ symbolicEtaQuotient(x) returns the meta data corresponding to x.
      ++ If x=etaQuotient(y) then symbolicEtaQuotient(x)=y.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $g_r(tau)$ at all cusps of Gamma_0(level x) corresponding to
      ++ cusps(symbolicEtaQuotient x).
  Implementation ==> add
    Rep ==> Record(meta: YEQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: YEQ): % ==
        m: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(m, exponents y)$QETAAUX then
            dbgPrint("M0EQ coerce: not a modular function", exponents y)
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            ye: SymbolicEtaQuotientGamma := y.cusp
            e := ye :: EtaQuotientGamma(C, mx, CX, xi)
            hser.cusp := expansion e
        per [y, hser]
    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        (etaQuotient(mm, r, cusps)$YEQ)::%
    etaQuotient(mm: P, r: LZ): % == (etaQuotient(mm, r)$YEQ)::%
    level(x: %): P == level(xx.meta)
    symbolicEtaQuotient(x: %): YEQ == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        symbolicEtaQuotient x = symbolicEtaQuotient y


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SiftedEtaQuotientGamma}
\label{sec:SiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{SiftedEtaQuotientGamma} represents the Puiseux series
expansion of various eta-quotients.
)endif

-------------------------------------------------------------------
)abbrev domain SEQG SiftedEtaQuotientGamma
++ SiftedEtaQuotientGamma is a generalization of
++ EtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of $g_{r,m,t,\lambda}(\gamma \tau)$,
++ $g_{r,m,t}(\gamma \tau)$, $F_{s,r,m,t}(\gamma \tau)$.
++ See \eqref{eq:g_r-m-t-lambda(gamma*tau)}.}
++ This Domain behaves partly like univariate Puiseux series.
SiftedEtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseux: (SymbolicSiftedEtaQuotientLambdaGamma, P) -> %
      ++ puiseux(y, w) represents the
      ++ q-expansion of g_{r,m,t,\lambda}(\gamma \tau) at \tau=i \infity.
    puiseux: (SymbolicSiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $g_{r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    puiseux: (SymbolicSiftedEtaQuotientOrbitProductGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $\prod_{t' \in \modularOrbit{r,m,t}} g_{r,m,t}(\gamma \tau)$
      ++ at $\tau=i \infity$.
    puiseux: (SymbolicModularGamma0SiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    rationalPowerDenominator: % -> P
      ++ If k=order(x) and f=qetaTaylorRep(x) then,
      ++ rationalPowerDenominator(x) returns w such that
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    qetaTaylorRep: % -> TX
      ++ qetaTaylorRep(x) returns the Taylor series representation f of x
      ++ without the prefactor corresponding to $(c \tau + d)$
      ++ If w=rationalPowerDenominator(x) and k=order(x) then
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    order: % -> Q
      ++ If w=rationalPowerDenominator(x) and f=qetaTaylorRep(x) then
      ++ order(x) returns k such that x(q)=z^(k)*f(z) with z=q^(1/w).
      ++ order(x) returns the order o
    laurent: % -> LX
      ++ If order(x) is an integer, then laurent(x) returns the
      ++ Laurent series f of x without the prefactor corresponding to
      ++ $(c \tau + d)$ such that x(q) = f(z) for z=q^(1/w) where
      ++ w=rationalPowerDenominator(x). It is an error if order(x) is
      ++ not an integer.
  Implementation ==> add
    -- If x: % and s = rep(x).ser, d = rep(x).den, then x represents
    -- the series s(q^(1/d)).
    Rep ==> Record(den: P, ord: Q, ser: TX)
    xx ==> rep x

    import from EtaQuotientGamma(C, mx, CX, xi)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    rationalPowerDenominator(x: %): P == xx.den
    order(x: %): Q == xx.ord
    qetaTaylorRep(x: %): TX == xx.ser
    laurent(x: %): LX ==
        ord: Q := order x
        not one? denom ord =>
            error "SEQG: Laurent series with fractional exponent"
        laurent(numer ord, qetaTaylorRep x)$LX
    coerce(x: %): OutputForm == xx::OutputForm

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,t,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-t-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicSiftedEtaQuotientLambdaGamma, w: P): % ==
        -- w=width
        mm: P := level y
        divs: LP := divisors y
        m: P := multiplier y
        d: P := 24*m*w
        s: LX := 1
        for delta in divs for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicSiftedEtaDeltaLambdaGamma := y.delta
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "SiftedEtaQuotientGamma: denominator does not vanish"
            v: N := asN numer(mx * vdelta(etadelta))
            s := s * eulerFunctionPower(asP numer u, v, rd)
        q: Q := mx * unityPower y
        not one? denom q =>
            dbgPrint("mx * unityPower y", q)
            error "SiftedEtaQuotientGamma: denominator for xi does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor y -- leading coefficient
        p: Q := d * qExponent y
        not one? denom p =>
            error "SiftedEtaQuotientGamma: denominator for q does not vanish"
        tx: TX := cx * qetaTaylorRep s
        per [d, p, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SiftedEtaQuotientGamma}
represents the series expansion of
\begin{gather*}
  g_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicSiftedEtaQuotientGamma, w: P): % ==
        m: P := multiplier y
        lx: LX := 0
        m1: P := asP(m::Z - 1)
        for lambda in 0..m1 repeat lx := lx + laurent puiseux(y.lambda, w)
        -- A sifted version of an eta-quotient is a non-zero function.
        -- Thus, we can safely remove initial zeroes.
        --TODO: WARNING: The above is not true.
        -- Try findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)
        lx: LX := removeZeroes(lx)$LX
        -- And, it is safe to ask for the order of the series expansion.
        ord: Z := order lx
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        tx: TX := qetaTaylorRep lx
        stx: Stream CX := coefficients tx
        for i in 1..m1 repeat
            stx := rest stx
            if not zero? first stx then
                dbgPrint("YSEQG c", first stx)
                dbgPrint("Laurent expansion", lx)
                error "SiftedEtaQuotientGamma: m-lambda sum"
        tx := (1/m)$Q::C::CX * multisect(m, 0, tx)
        per [24 * w, ord/m, tx]

    puiseux(y: SymbolicSiftedEtaQuotientOrbitProductGamma, w: P): % ==
        orb := orbit y
        t: N := first orb;
        px: % := puiseux(y.t, w)
        d: P := rationalPowerDenominator px
        tx: TX := qetaTaylorRep px
        ord: Q := order px
        for k in rest orb repeat
            px: % := puiseux(y.k, w)
            tx := tx * qetaTaylorRep px
            ord := ord + order px
        not one? denom ord =>
            error "SiftedEtaQuotientGamma: orbit product: denominator for q does not vanish"
        per [d, ord, tx]

    puiseux(y: SymbolicModularGamma0SiftedEtaQuotientGamma, w: P): % ==
        yc: SymbolicSiftedEtaQuotientGamma := coFactor y
        yo: SymbolicSiftedEtaQuotientOrbitProductGamma := orbitProduct y
        pc: % := puiseux(yc, w)
        po: % := puiseux(yo, w)
        d: P := rationalPowerDenominator pc
        -- Sanity check.
        d ~= 24 * w =>
            error "SiftedEtaQuotientGamma: Puiseux expansion in wrong variable"
        rationalPowerDenominator pc ~= rationalPowerDenominator po =>
            error "SiftedEtaQuotientGamma: expansion in different variables"
        tx: TX := multisect(24, 0, qetaTaylorRep pc * qetaTaylorRep po)
        ord: Q := order pc + order po
        ord := ord * (1$Z/24)-- It's a modular function.
        not one? denom ord =>
            error "SiftedEtaQuotientGamma: modular: denominator for q does not vanish"
        per [w, ord, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularGamma0SiftedEtaQuotient}
\label{sec:ModularGamma0SiftedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{ModularGamma0SiftedEtaQuotient} represents the Puiseux
series expansion of various eta-quotients.

)endif

-------------------------------------------------------------------
)abbrev domain M0SEQ ModularGamma0SiftedEtaQuotient
++ ModularGamma0SiftedEtaQuotient is a generalization of
++ ModularGamma0EtaQuotient. It holds the expansions
++ of F_{s,r,m,t}(\tau) at all cusps of $\Gamma_0(N)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)}.
++ The domain serves as the representation of the underlying q-series.
ModularGamma0SiftedEtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  Exports ==> SetCategory with
    coerce: SymbolicModularGamma0SiftedEtaQuotient -> %
      ++ coerce(y) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at all cusps of $\Gamma_0(N)$ where
      ++ N=level(y).
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    metadata: % -> SymbolicModularGamma0SiftedEtaQuotient
      ++ metadata(x) returns y such that coerce(y) = x.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $F_{s,r,m,t}(tau)$ at all cusps of Gamma_0(N).

  Implementation ==> add
    YM0SEQ ==> SymbolicModularGamma0SiftedEtaQuotient
    Rep ==> Record(meta: YM0SEQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: SymbolicModularGamma0SiftedEtaQuotient): % ==
        PX ==> SiftedEtaQuotientGamma(C, mx, CX, xi)
        import from PX
        nn: P := level y
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurent puiseux(y.cusp, w)
        per [y, hser]
    level(x: %): P == level(xx.meta)
    metadata(x: %): SymbolicModularGamma0SiftedEtaQuotient == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.meta)
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        metadata x = metadata y




)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
