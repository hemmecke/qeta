-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (sifted and generalized) Dedekind Eta Functions into
  $q$-series at various cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of sifted and
  generalized Dedekind eta-quotients that have been turned into a
  modular function by multiplication with a cofactor. Expansions into
  $q$-series of objects are considered at any cusp of $\Gamma_0(N)$ or
  $\Gamma_1(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
GAMMA0 ==> CongruenceSubgroupGamma0
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]
lcmP(a, b) ==> asP lcm(a::Integer, b::Integer)





)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic} and implemented in \PathName{qetaquotsymb.spad}.

Eta-quotients are considered as modular functions for $\Gamma_0(N)$,
whereas generalized eta-quotients are considered as modular functions
for $\Gamma_1(N)$.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D QEtaPuiseuxExpansion (only for QEtaLaurentExpansion)
  $p_{r,m,t}(\gamma\tau)$, $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:QEtaPuiseuxExpansion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{QEtaPuiseuxExpansion} represents the Puiseux series
expansion of various eta-quotients.

Since eta-quotient expansions are expressed in the canonical
variables, these will be Laurent series, thus,
\code{QEtaPuiseuxExpansion} serves as an auxiliary domain that is only
uses for \code{QEtaLaurentExpansion}


)endif

-------------------------------------------------------------------
)abbrev domain QEPX QEtaPuiseuxExpansion
++ QEtaPuiseuxExpansion holds data to compute an eta quotient
++ expansion of $g_{r,m,\lambda}(\gamma \tau)$,
++ $p_{r,m,t}(\gamma\tau)$, $F_{s,r,m,t}(\gamma\tau)$. See
++ \eqref{eq:g_r-m-lambda(gamma*tau)} and
++ \eqref{eq:F_r-m-t-(gamma*tau)}.
++ This domain is used as an auxiliary domain for QEtaLaurentExpansion.
QEtaPuiseuxExpansion(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseux: (SymbolicEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $p_{r,m,t}(\gamma \tau)$.
    puiseux: (SymbolicModularGamma0EtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$.
    rationalPowerDenominator: % -> P
      ++ If k=order(x) and f=qetaTaylorRep(x) then,
      ++ rationalPowerDenominator(x) returns w such that
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    qetaTaylorRep: % -> TX
      ++ qetaTaylorRep(x) returns the Taylor series representation f of x
      ++ without the prefactor corresponding to $(c \tau + d)$
      ++ If w=rationalPowerDenominator(x) and k=order(x) then
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    order: % -> Q
      ++ If w=rationalPowerDenominator(x) and f=qetaTaylorRep(x) then
      ++ order(x) returns k such that x(q)=z^(k)*f(z) with z=q^(1/w).
      ++ order(x) returns the order o

    laurentExpansion: % -> LX
      ++ If order(x) is an integer, then laurentExpansion(x) returns
      ++ the Laurent series f of x without the prefactor corresponding
      ++ to $(c \tau + d)$ such that x(q) = f(z) for z=q^(1/w) where
      ++ w=rationalPowerDenominator(x). It is an error if order(x) is
      ++ not an integer.

    --TODO: The following function should live somewhere else.
    substitute: (LX, P, N) -> LX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

  Implementation ==> add
    -- If x: % and s = rep(x).ser, d = rep(x).den then
    -- x represents the series s(q^(1/d)).
    Rep ==> Record(den: P, ord: Q, ser: TX)
    xx ==> rep x

    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol

    -- Cache for frequently used objects
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

-------------------------------------------------------------------
-- local functions
-------------------------------------------------------------------
    xipow(n: Z): CX ==
         -- Take care of the fact that xi^mx = 1.
        e: Z := positiveRemainder(n, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    xiPower(v: N): (Z -> CX) == (e: Z): CX +-> xipow(v*e)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: P, v: N): LX ==
        multiplyExponents(multiplyCoefficients(xiPower v, s), u)

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        zero? rd => 1$LX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    checkedMultisect(m: P, tx: TX): TX ==
        one? m => tx
        stx: Stream CX := coefficients tx
        for i in 1..m-1 repeat
            stx := rest stx
            if not zero? first stx then
                dbgPrint("checkedMultisect c", first stx)
                dbgPrint("Taylor representation", tx)
                error "nonzero coefficients for multisect"
        tx := multisect(m, 0, tx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    rationalPowerDenominator(x: %): P == xx.den
    order(x: %): Q == xx.ord
    qetaTaylorRep(x: %): TX == xx.ser
    coerce(x: %): OutputForm == xx::OutputForm

    laurentExpansion(x: %): LX ==
        ord: Q := order x
        not one? denom ord =>
            error "QEtaPuiseuxExpansion: fractional exponent in Laurent series"
        laurent(numer ord, qetaTaylorRep x)$LX


)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- local
    puiseuxLambda(y: SymbolicEtaQuotientLambdaGamma, ue: Q, w: P): % ==
        -- w=width
        mm: P := level y
        divs: LP := divisors y
        m: P := multiplier y
        d: P := m*w
        s: LX := 1
        for delta in divs for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicEtaGamma := y.delta
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "QEtaPuiseuxExpansion: denominator does not vanish"
            v: Q := mx * vdelta etadelta
            not one? denom v or v<0 =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("vdelta", [vdelta etadelta, u]$List(Q))
                error "QEtaPuiseuxExpansion: denominator does not vanish"
            s := s * eulerFunctionPower(asP numer u, asN numer v, rd)
        q: Q := mx * (lambda(y)*ue + unityExponent y)
        not one? denom q =>
            dbgPrint("mx * unityExponent y", q)
            error "QEtaPuiseuxExpansion: denominator for xi does not vanish"
        -- leading coefficient
        cx: CX := xipow numer q * squareRoot rationalPrefactor y
        p: Q := d * qExponent y
        not one? denom p =>
            error "QEtaPuiseuxExpansion: denominator for q does not vanish"
        tx: TX := cx * qetaTaylorRep s
        per [d, p, tx]




)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{QEtaPuiseuxExpansion}
represents the series expansion of
\begin{gather*}
  p_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif


    puiseux(y: SymbolicEtaQuotientGamma, w: P): % ==
        m: P := multiplier y
        ue: Q := unityExponent y
        x: % := puiseuxLambda(y.0, ue, w) -- $g_{r,m,\lambda}$
        one? m => x
        lx: LX := laurentExpansion x
        m1: P := asP(m::Z - 1)
        for lambda in 1..m1 repeat
            lx := lx + laurentExpansion puiseuxLambda(y.lambda, ue, w)
        -- A sifted version of an eta-quotient is a non-zero function.
        -- Thus, we can safely remove initial zeroes.
        --TODO: WARNING: The above is not true.
        -- Try findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)
        lx: LX := removeZeroes(lx)$LX
        -- And, it is safe to ask for the order of the series expansion.
        ord: Z := order lx
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        tx: TX := (1/m)$Q::C::CX * checkedMultisect(m, qetaTaylorRep lx)
        per [w, ord/m, tx] -- the */m disappears after multiplying the orbit

    -- local
    puiseuxOrbit(y: SymbolicEtaQuotientOrbitProductGamma, w: P): % ==
        orb := orbit y
        t: N := first orb;
        px: % := puiseux(y.t, w) -- p_{r,m,t}
        d: P := rationalPowerDenominator px
        tx: TX := qetaTaylorRep px
        ord: Q := order px
        for k in rest orb repeat
            px: % := puiseux(y.k, w) -- SymbolicEtaQuotientGamma
            tx := tx * qetaTaylorRep px
            ord := ord + order px
        not one? denom ord =>
            error "QEtaPuiseuxExpansion: orbit product: denominator for q does not vanish"
        per [d, ord, tx]

    puiseux(y: SymbolicModularGamma0EtaQuotientGamma, w: P): % ==
        yc: SymbolicEtaQuotientGamma := cofactor y
        yo: SymbolicEtaQuotientOrbitProductGamma := orbitProduct y
        pc: % := puiseux(yc, 24*w)
        po: % := puiseuxOrbit(yo, 24*w)
        d: P := rationalPowerDenominator pc
        -- Sanity check.
        d ~= 24 * w =>
            error "QEtaPuiseuxExpansion: Puiseux expansion in wrong variable"
        rationalPowerDenominator pc ~= rationalPowerDenominator po =>
            error "QEtaPuiseuxExpansion: expansion in different variables"
        tx: TX := checkedMultisect(24, qetaTaylorRep pc * qetaTaylorRep po)
        ord: Q := order pc + order po
        ord := ord * (1$Z/24)-- It's a modular function.
        not one? denom ord =>
            error "QEtaPuiseuxExpansion: modular: denominator for q does not vanish"
        per [w, ord, tx]









)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaLaurentExpansion
  $p_{r,m,t}(\gamma\tau)$, $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:QEtaLaurentExpansion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The package \code{QEtaLaurentExpansion} provides functions for the
conversion of eta-quotients into Laurent series either at a specific
cusp or at several cusps.


)endif
)abbrev package QELX QEtaLaurentExpansion
++ QEtaLaurentExpansion(C, mx, CX, xi, LX) represents the set
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
QEtaLaurentExpansion(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  QLX ==> XHashTable(Q, LX)
  YEQG ==> SymbolicEtaQuotientGamma
  YEQ ==> SymbolicEtaQuotient

  Exports ==> with
    --assert(one? xi^mx)
    laurentExpansion: (YEQG, P) -> LX
      ++ laurentExpansion(y, w) returns a Laurent expansion
      ++ corresponding to y in terms of the variable z=q^(1/w). It is
      ++ an error if y cannot be expressed in z.
    laurentExpansion: SymbolicModularGamma0EtaQuotientGamma -> LX
      ++ laurentExpansion y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ given by y in the canonical
      ++ variables given by the width of the cusp wrt.
      ++ Gamma_0(level(y)).
    laurentExpansionsGamma0: YEQ -> QLX
      ++ laurentExpansions y represents the expansion of
      ++ $p_{r,m,t}(\tau)$ in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m,c)$CongruenceSubgroupGamma0 at all cusps that are
      ++ given in y. See \eqref{eq:p_r-m-t(gamma*tau)}.
    laurentExpansions: SymbolicModularGamma0EtaQuotient -> QLX
      ++ laurentExpansions y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ at all cusps given by y in the
      ++ canonical variables given by the width of the cusp wrt.
      ++ Gamma_0(level y).

  Implementation ==> add
    QEPX(C, CX) ==> QEtaPuiseuxExpansion(C, mx, CX, xi)

    laurentExpansion(y: YEQG, w: P): LX ==
        x: QEPX(C, CX) := puiseux(y, w)
        laurentExpansion(x)$QEPX(C, CX)

    laurentExpansion(y: SymbolicModularGamma0EtaQuotientGamma): LX ==
        cy: YEQG := cofactor y
        nn: P := level cy
        g: SL2Z := gamma cy
        w: P := WIDTH0(nn, g(2,1))
        x: QEtaPuiseuxExpansion(C, mx, CX, xi) := puiseux(y, w)
        laurentExpansion x

    laurentExpansionsGamma0(y: YEQ): QLX ==
        import from QEtaPuiseuxExpansion(C, mx, CX, xi)
        nn: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(nn, exponents y)$QETAAUX then
            dbgPrint("QEtaLaurenExpansion: not a modular function", exponents y)
        hser: QLX := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurentExpansion(y.cusp, w)
        hser

    laurentExpansions(y: SymbolicModularGamma0EtaQuotient): QLX ==
        import from QEtaPuiseuxExpansion(C, mx, CX, xi)
        nn: P := level y
        hser: QLX := empty()
        for cusp in cusps y repeat hser.cusp := laurentExpansion(y.cusp)
        hser



)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
