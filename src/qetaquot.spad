-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}
% Euler totient function
\newcommand{\eulerphi}{\varphi}

% Abbreviation for \sum_{\divides{\delta}{#1}}\delta {#2}_\delta
\newcommand{\sumdelta}[2][M]{\hat{#2}}

\newcommand{\divisorsum}[2][\delta]{\sum_{\divides{#1}{#2}}}
\newcommand{\divisorprod}[2][\delta]{\prod_{\divides{#1}{#2}}}

% The q-Pochhammer symbol
% https://en.wikipedia.org/wiki/Q-Pochhammer_symbol (for n=\infty)
\newcommand{\qPochhammer}[3][\infty]{\left( #2;#3 \right)_{#1}}
\newcommand{\eulerFunction}[1]{\qPochhammer{q^{#1}}{q^{#1}}}

\newcommand{\setS}{\mathbb{S}}
\newcommand{\modularOrbit}[1]{\mathcal{O}_{#1}}
\DeclareMathOperator{\trace}{tr}

\usepackage{makeidx}
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (sifted) Dedekind Eta Functions into $q$-series at
  various cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of sifted Dedekind eta
  quotients that have been turned into a modular function by
  multiplication with a cofactor. Expansions into $q$-series of
  objects are considered at any cusp of $\Gamma_0(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{gather}
  \defineNotation[GL2+Z]{GL_2^+(\setZ)}
  :=
  \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix}}{a,b,c,d\in\setZ \land ad-bc>0}
\end{gather}

\begin{gather}
  \defineNotation[SL2Z]{\SL2Z} := \SetDef{\gamma\in
    GL_2^+(\setZ)}{\det(\gamma)=1}
\end{gather}

Let $N$ be a positive natural number and define a $\Gamma_0(N)$ as a
subgroup of the special linear group $\SL2Z$ as follows.
\begin{gather*}
\defineNotation[Gamma0N]{\Gamma_0(N)} := \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix} \in \SL2Z}{c \equiv 0 \pmod{N}}
\end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:epsilon}
  Let $\defineNotation[epsilon]{\unityPowerSymbol}: \setC \to \setC$
  be defined by
  \begin{gather*}
    \unityPower{x} := \exp(2\pi i x).
  \end{gather*}
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\defineNotation[H]{\setH}=\SetDef{c\in \setC}{\Im(c)>0}$ denote
the complex upper half-plane.

Let
\begin{gather}\label{eq:eta-expansion}
  \defineNotation[eta]{\eta}: \setH \to \setC, \quad
  \tau \mapsto \unityPower{\frac{\tau}{24}} \prod_{n=1}^{\infty}(1-q^n)
  =
  \unityPower{\frac{\tau}{24}} \eulerFunction{}
\end{gather}
with $\defineNotation[q]{q} = \unityPower{\tau}$
denote the Dedekind eta function.

Note that $\qPochhammer{a}{q} = \prod_{n=0}^{\infty}(1-aq^n)$ denotes
the $q$-Pochhammer symbol. Thus, we have
\begin{gather*}
  \eta(\tau) = \unityPower{\frac{\tau}{24}} \eulerFunction{}
\end{gather*}

In the following $\defineNotation[N]{N}$ denotes a positive integer
and $1=\delta_1<\delta_2\dots<\delta_{\defineNotation[n]{n}}=N$ the
positive divisors of $N$. Let
$\defineNotation[Delta]{\Delta}:=\Set{\delta_1,\ldots,\delta_n}$. For
convenience, we allow to index $n$-dimensional vectors by the divisors
of $N$, instead of the usual index set $\Set{1,\ldots,n}$.
%
For $\delta\in\Delta$ we consider the functions
\begin{gather*}
  \defineNotation[eta-delta]{\eta_\delta}: \setH \to \setC,\quad \tau
  \mapsto \eta(\delta\tau)
\end{gather*}
None of these functions is identically zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
When we write $\divisorsum{N}$ and $\divisorprod{N}$ we mean the sum
and product over all \emph{positive} divisors of $N$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We define $\defineNotation[RN]{R(N)}$ to be the set of integer tuples
$\defineNotation[r^{}]{r} = (r_{\delta_1}, \ldots,
r_{\delta_n})\in \setZ^n$.
%
For $r\in R(N)$ let
\begin{align}
  \defineNotation[g-r-tau]{g_r(\tau)}
  &:=
    \divisorprod{N} \eta(\delta\tau)^{r_\delta}
    =
    q^{{\sumdelta{r}}/{24}}
      \divisorprod{N} \eulerFunction{\delta}^{r_\delta}
  \label{eq:g_r(tau)}
\end{align}
where we have abbreviated
\begin{gather}
  \defineNotation[r]{\sumdelta{r}} := \divisorsum{M} \delta r_\delta.
\end{gather}




By $\defineNotation[R*N]{R^*(N)}$ we denote the subset of all tuples
$r=(r_\delta)_{\delta\in\Delta}$ of $R(N)$ that fulfil the following
conditions.
\begin{align}
 \divisorsum{N} r_\delta &= 0\label{eq:sum=0}\\
 \divisorsum{N} \delta r_\delta &\equiv 0\pmod{24}\label{eq:sigmainfinity}\\
 \divisorsum{N} (N/\delta)r_\delta &\equiv 0\pmod{24}\label{eq:sigma0}\\
 \sqrt{\divisorprod{N}\delta^{r_\delta}} &\in \setQ\label{eq:productsquare}
\end{align}

Note that $R^*(N)$ is an additive monoid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

According to
\cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016},
there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
$\Gamma_0(N)$ that correspond to a divisor $c$ of $N$ where
$\defineNotation[phi]{\eulerphi}$ denotes the Euler totient function.

In the following we always deal with quotients of $\eta$-functions of
level $N$ that are modular functions for $\Gamma_0(N)$.

We implement a domain that deals with such quotients and their
$q$-expansion at all cusps ($q=e^{2\pi i \tau})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transformations of the Dedekind $\eta$-function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's look at the transformation of the $\eta$-function (see
\cite[Lemma~2.27]{Radu:PhD:2010}).

Let
$\defineNotation[gamma]{\gamma} =
\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, then
\begin{gather}
\eta(\gamma\tau) =
\eta\left(\frac{a\tau+b}{c\tau+d}\right) =
(c\tau+d)^{1/2}\,\upsilon(\gamma)\,\eta(\tau)
\label{eq:eta-transformation}
\end{gather}
where
$\defineNotation[upsilon-gamma]{\upsilon(\gamma)} :=
\upsilon_\eta(a,b,c,d)$ as defined as in
\cite[Lemma~2.27]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
\label{thm:matix-splitting}
Let $\gamma',\gamma''\in \SL2Z$.
%
Then $\upsilon(\gamma'\gamma'')^2 = \upsilon(\gamma')^2 \upsilon(\gamma'')^2$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
  Let
  $\gamma'=\left(\begin{smallmatrix}a'&b'\\c'&d'\end{smallmatrix}\right)$
  and
  $\gamma''=\left(\begin{smallmatrix}a''&b''\\c''&d''\end{smallmatrix}\right)$
  be in $\SL2Z$.
  %
  Then
  $\gamma'\gamma'' =
  \left(\begin{smallmatrix}a'a''+b'c''&a'b''+b'd''\\c'a''+d'c''&c'b''+d'd''\end{smallmatrix}\right)$.
  We set $c:=c'a''+d'c''$ and $d:=c'b''+d'd''$.
%
  If $\tau'=\gamma''\tau$, we derive for any $\tau \in \setH$:
  \begin{gather*}
    c' \tau' + d'
    =
      \left(c' \frac{a''\tau + b''}{c''\tau + d''} +d'\right)
    =
      \left(\frac{c'a''\tau + c'b''+ d'c''\tau + d'd''}{c''\tau + d''}\right)
    =
    \left(\frac{c\tau + d}{c''\tau + d''}\right).
  \end{gather*}
%
  \begin{align*}
    (c \tau + d)^{1/2}\,\upsilon(\gamma)\,\eta(\tau)
    &=
    \eta((\gamma'\gamma'')\tau) =
    \eta(\gamma'\tau')
    =
      (c'\tau'+d')^{1/2}\,\upsilon(\gamma')\,\eta(\tau')\\
    &=
      \left(\frac{c\tau + d}{c''\tau + d''}\right)^{1/2} \,(c''\tau+d'')^{1/2}
      \,\upsilon(\gamma')\,\,\upsilon(\gamma'')\eta(\tau).
  \end{align*}
  After squaring both sides and cancelling equal terms, the statement
  of the Lemma can be concluded.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta$ under $GL_2^+(\setZ)$}
\label{sec:eta-transformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$W=\left(\begin{smallmatrix}A&B\\C&D\end{smallmatrix}\right) \in
GL_2^+(\setZ)$.
%
Then for $h=\gcd(A, C)>0$, $a':=\frac{A}{h}$, $c':=\frac{C}{h}$ we
have $\gcd(a', c')=1$ and thus can find $b'$ and $d'$ such that
$a'd'-b'c'=1$.
%
Let
\begin{gather*}
  W':=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix},
  \qquad
  W''
  :=
  \begin{pmatrix}
    h &B d'-D b'\\
    0 & \det(W) / h
  \end{pmatrix}.
\end{gather*}
Then $W'\in \SL2Z$ and $W = W' W''$.


Note that for any integer $s$ whe have:
\begin{align}
W = \begin{pmatrix}A&B\\C&D\end{pmatrix}
&=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}h &B d'- D b'\\0 &\det(W) / h\end{pmatrix}
  \\
&=
  \begin{pmatrix} a'&b' + a' s\\ c'&d' + c' s \end{pmatrix}
  \begin{pmatrix}
    h &B d'- D b'- s \det(W) / h\\
    0 &\det(W) / h\end{pmatrix}.
\end{align}
Therefore, we can choose $b'$ and $d'$ in such a way that
$0 \le B d'-D b' < \det(W)/h$.

Let $\tau' := W''\tau = \frac{h}{\det(W)}(h\tau + B d'- D b')$, then
$\tau'\in\setH$ and
\begin{gather}
\eta(W\tau) =
\eta(W'\tau') =
(c'\tau+d')^{1/2}\,\upsilon_\eta(W')\,\eta(\tau')
\label{eq:eta-W-transformation}
\end{gather}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begingroup
\newcommand{\h}{h}
\begin{Lemma}\label{thm:c*tau+d}
  Let $\gamma := \left(
    \begin{smallmatrix}a&b\\c&d\end{smallmatrix} \right)\in
  \SL2Z$, $\delta>0$, $m>0$, $z\ge0$, and
  \begin{gather*}
    W=
    \begin{pmatrix}
      \delta & z\\
      0      & m
    \end{pmatrix}
    \gamma
    = \begin{pmatrix}
        \delta a + c z & \delta b + d z\\
        c m & d m
      \end{pmatrix}
    \in GL_2^+(\setZ).
  \end{gather*}
  Then $\det(W)=\delta m$.
  %
  If
  $\h:=\gcd(\delta a + c z, cm)$,
  $a':=\frac{\delta a + c z}{\h}$,
  $c':=\frac{c m}{\h}$, and
  $b'$ and $d'$ are such that $a'd'-b'c'=1$ and
  $0 \le (\delta b + d z) d' - d m b' < cm / \h$, \ie,
  \begin{gather*}
    W':=\begin{pmatrix}
      (\delta a + c z) / \h & b'\\
      c m / \h              & d'
    \end{pmatrix},
    \qquad
    W''
    :=
    \begin{pmatrix}
      \h & (\delta b + d z) d' - d m b'\\
      0  & \delta m / \h
    \end{pmatrix}.
  \end{gather*}
  according to the splitting above,
  %
  then with $\tau':=W''\tau$ we have
  $c'\tau'+d' = \frac{\h}{\delta} (c\tau + d)$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\h}{\delta m}(h\tau + (\delta b + d z) d' - d m b')
    \right) + d'\\
  &=
    \frac{c m}{\h}
    \left(
    \frac{\h}{\delta m}(\h \tau + (\delta b + d z) d' - d m b')
    \right) + d'\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + b c \delta d' + c d d' z - c d m b'
    \right) + d'\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + (a d - 1) \delta d' + c d d' z - c d m b'
    + \delta d'
    \right)\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + a d \delta d' + c d d' z - c d m b'
    \right)\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + \h d (a' d' - c' b')
    \right)\\
  &=
    \frac{\h}{\delta} (c\tau + d)
\end{align*}
\end{proof}
\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_\delta$ under $\SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\delta \in \setN\setminus\Set{0}$.

\begin{gather*}
\eta_\delta(\gamma\tau)
=
\eta_\delta\left(\frac{a\tau+b}{c\tau+d}\right) =
\eta\left(\frac{a\delta\tau+b\delta}{c\tau+d}\right)
=
\eta\left(\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
  \tau\right).
\end{gather*}

Let
%
\begin{gather}
  \defineNotation[h-delta]{h_\delta}
  :=
  \gcd(\delta a,c), \label{eq:h_delta}
\end{gather}
%
$\defineNotation[a-delta]{a_\delta}:=\frac{\delta a}{h_\delta}$,
%
$\defineNotation[c-delta]{c_\delta}:=\frac{c}{h_\delta}$,
%
and $\defineNotation[b=delta]{b_\delta}$ and
$\defineNotation[d-delta]{d_\delta}$ are chosen in such a way that
$a_\delta d_\delta - b_\delta c_\delta = 1$.
%
Because of $\gcd(a_\delta, c_\delta)=1$, such $b_\delta$ and $d_\delta$
can be found.
%
Therefore
  $\defineNotation[gamma-delta]{\gamma_\delta} := \left(
  \begin{smallmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{smallmatrix}
\right)\in \SL2Z$.

Note that $h_\delta=\gcd(\delta, c)$, because $\gcd(a,c)=1$ and,
furthermore,
\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\label{eq:naive-matrix-split}
\end{align}
Note that for any integer $s$ whe have:
\begin{align*}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}
    h_\delta&\delta b d_\delta-d b_\delta\\
    0      &\delta / h_\delta\end{pmatrix}
  \\
&=
  \begin{pmatrix}
    a_\delta&b_\delta + a_\delta s\\
    c_\delta&d_\delta + c_\delta s
  \end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta-s \delta / h_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\end{align*}
Therefore, we can choose $b_\delta$ and $d_\delta$ in such a way that
$0 \le \delta b d_\delta-d b_\delta < \delta/h_\delta$.

If $c=0$, then $a=d=1$, $h_\delta=\delta$. We can choose $d_\delta=1$
and $b_\delta= \delta b  d_\delta$ and get
\begin{align}
\begin{pmatrix}\delta&b\delta\\0&1\end{pmatrix}
&=\begin{pmatrix}1&b \delta\\0&1\end{pmatrix}
  \begin{pmatrix}\delta&0\\
                 0      &1\end{pmatrix}.
\end{align}

If we set
\begin{gather}
  \defineNotation[tau-delta]{\tau_\delta}
  :=
  \begin{pmatrix}
    h_\delta & \delta b d_\delta-d b_\delta\\
    0       & \delta / h_\delta
  \end{pmatrix} \tau
  =
  \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta},
  \label{eq:tau_delta}
\end{gather}
then
\begin{gather*}
  \eta_\delta(\gamma\tau)
  =
  \eta(\gamma_\delta \tau_\delta)
  =
  (c_\delta\tau_\delta+d_\delta)^{1/2}
  \,
  \upsilon(\gamma_\delta)
  \,
  \eta(\tau_\delta).
\end{gather*}


From Lemma~\ref{thm:c*tau+d} we get
\begin{align*}
  c_\delta\tau_\delta+d_\delta
  &=
  \frac{h_\delta}{\delta}(c \tau + d).
\end{align*}

Thus, we have
\begin{gather}
\eta_\delta(\gamma\tau)
=
\left(\frac{h_\delta}{\delta}(c \tau+d)\right)^{\!1/2}
\unityPower{\frac{\kappa_\delta}{24}}
\,
\eta(\tau_\delta).
\label{eq:eta_delta(gamma*tau)}
\end{gather}
where
$\defineNotation[kappa-delta]{\kappa_\delta} \in \Set{0,\ldots,23}$ is
defined by
$\unityPower{\frac{\kappa_\delta}{24}} := \upsilon(\gamma_\delta)$.

Note that for
$\gamma=\left(\begin{smallmatrix}1&0\\0&1\end{smallmatrix}\right)$ we
have $\kappa_\delta=0$ for any $\delta$.


For the following definition see \cite[Lemma~2.37]{Radu:PhD:2010} and
\cite[Definition~2.9]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:width0}
  Let
  $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)
  \in \SL2Z$ and $N$ be a positive integer. Then
  \begin{gather}
    \defineNotation[w-gamma]{w_\gamma} = \frac{N}{\gcd(c^2, N)}
    \label{eq:width0}
  \end{gather}
  is called the \emph{width of $\gamma$ with respect to $\Gamma_0(N)$}.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that for
$\gamma=\left(\begin{smallmatrix}1&0\\0&1\end{smallmatrix}\right)$ we
have $w_\gamma=1$.


For
$\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in \SL2Z$ we want to expand $\eta(\tau_\delta)$ in
$\defineNotation[x]{x}:=q^{1/w_\gamma}=\unityPower{\frac{\tau}{w_\gamma}}$
with coefficients from $\setQ(\xi)$ where
$\defineNotation[xi]{\xi} := \unityPower{\frac{c}{24N}}$.

Since we are only interested in expansions at the cusps, we can assume
$0<c\in\Delta$.

In the following let $\delta \in \Delta$. Because of
$x=q^{1/w_\gamma}$, \eqref{eq:tau_delta} and \eqref{eq:width0}, we
have
\begin{gather}
  \defineNotation[q-delta]{q_\delta} = \unityPower{\tau_\delta}
  = q^{u_\delta} \, \unityPower{v_\delta}
  = x^{e_\delta} \, \unityPower{v_\delta}
\label{eq:q_delta}
\end{gather}
for
\begin{gather}
  \defineNotation[u-delta]{u_\delta} :=
  \frac{h_\delta^2}{\delta},
  \qquad
  \defineNotation[e-delta]{e_\delta} :=
  w_\gamma u_\delta,
  \qquad
  \defineNotation[v-delta]{v_\delta} :=
  \frac{\delta b d_\delta-d b_\delta}{\delta/h_\delta}.
  \label{eq:uv_delta}
\end{gather}
Note that for
$\gamma=\left(\begin{smallmatrix}1&0\\0&1\end{smallmatrix}\right)$,
i.e., if $c=0$, then $a=d=1$ and
$w_\gamma=1$,
$h_\delta=\delta$, $u_\delta=e_\delta=\delta$, $v_\delta=0$.

%
Note that $\unityPower{\frac{v_\delta}{24}} = \xi^k$ for
$k = (\delta b d_\delta - d b_\delta) \frac{N}{\lcm(\delta,c)}\in \setZ$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  If $\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in \SL2Z$, $N > 0$, $\delta \in \Delta$, then
$e_\delta \in \setZ$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
If $c=0$, then $e_\delta=\delta\in\setZ$. Without loss of generality,
we can assume $c>0$.
If $p$ is a prime that divides $N$, \ie, $N=N'p^\alpha$ for some
$\alpha>0$, and $\delta = \delta' p^m$, $c=c' p^k$ with
$\gcd(p,N')=\gcd(p,\delta')=\gcd(p,c')=1$, then
\begin{align*}
  e_\delta
  &=
  \frac{N}{\gcd(c^2,N)} \frac{\gcd(\delta,c)^2}{\delta}\\
  &=
  \frac{p^\alpha N' \gcd(p^m \delta', p^k c')^2}{\gcd(p^{2k}
    c'^2,p^\alpha N') p^m \delta'}\\
  &=
  p^{\alpha + 2 \min(m,k) - m - \min(2k, \alpha)}
  \frac{N' \gcd(\delta', c')^2}{\gcd(c'^2, N') \delta'}
\end{align*}
If we can show that $e:=\alpha + 2 \min(m,k) - m - \min(2k,
\alpha)\ge0$ then $e_\delta\in\setN$ follows by repeating the above
process for every prime divisor of $N$.

There are several cases to consider:
\begin{itemize}
\item $0\le m\le k \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2m-m-2k=(\alpha-2k)+m\ge0$.
\item $0\le m\le k \le \alpha < 2k$. Then
  $e=\alpha+2m-m-\alpha=m\ge0$.

\item $0\le k\le m \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2k-m-2k=\alpha-m\ge0$.
\item $0\le k\le m \le \alpha < 2k$. Then
  $e=\alpha+2k-m-\alpha=2k-m\ge0$.
\end{itemize}
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We can expand $\eta(\tau_\delta)$ in terms of $x$ as follows.
\begin{gather*}
  \eta(\tau_\delta)
  =
    \unityPower{{\frac{\tau_\delta}{24}}}
    \prod_{n=1}^{\infty}(1-q_\delta^n)
  =
  \unityPower{\frac{v_\delta}{24}} x^{e_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n).
\end{gather*}

Then \eqref{eq:eta_delta(gamma*tau)} turns into
\begin{align}
\eta_\delta(\gamma\tau)
&=
(c \tau+d)^{1/2}
\,
\left(\frac{h_\delta}{\delta}\right)^{\!\frac{1}{2}}
\,
  \unityPower {\frac{v_\delta + \kappa_\delta}{24}}
  x^{e_\delta/24} \cdot \prod_{n=1}^{\infty}(1-q_\delta^n).
\label{eq:eta_delta(gamma*tau)-expansion}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  For any $c, \delta \in\Delta$, $r\in R(N)$ let us define
  \begin{align}
    \defineNotation[a-N]{a_N}(c, \delta)
    &:= \frac{N}{\gcd(N, c^2)} \frac{\gcd(c,\delta)^2}{\delta},
      \notag\\
    \defineNotation[ord-c-N]{\ord_c^N}(r)
    &:= \frac{1}{24}\divisorsum{N} a_N(c, \delta) \, r_\delta.
    \label{eq:order-r}
  \end{align}
\end{Definition}

With $\defineNotation[ord-gamma-N]{\ord_\gamma^N}$ as defined in
\cite{Radu:RamanujanKolberg:2015}, Theorem~23 of
\cite{Radu:RamanujanKolberg:2015} turns into
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\label{thm:order}
  Let $\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in \SL2Z$ with $c\in\Delta$.
  If $r \in R^*(N)$, then
  $\ord_\gamma^N(g_r) = \ord_c^N(r)$.
\end{Theorem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For a proof we refer to
\cite[Proposition~3.2.8]{Ligozat:CourbesModulaires:1975}.

In the following let us fix $r \in R(N)$ and
$\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in \SL2Z$ with $c \in \Delta$.

From \eqref{eq:eta_delta(gamma*tau)-expansion} follows
\begin{align}
  g_r(\gamma \tau)
  &=
  \divisorprod{N}
  (c \tau+d)^{r_\delta/2}
  \,
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \,
  \unityPower{\frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  q^{r_\delta u_\delta/24}
  \cdot
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}
  \notag
  \\
  %
  &=
  (c \tau+d)^{\divisorsum{N} \frac{r_\delta}{2}}
  \cdot
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  q^{\divisorsum{N} \frac{r_\delta u_\delta}{24}}
  \cdot
    \divisorprod{N} \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}.
  \label{eq:g_r(gamma*tau)}
\end{align}

Note that for
$\gamma=\left(\begin{smallmatrix}1&0\\0&1\end{smallmatrix}\right)$ the
first three products are equal to 1.


If $r\in R^*(N)$, then $g_r$ is a modular function on $\Gamma_0(N)$.
Because of \eqref{eq:sum=0}, $q^{u_\delta}=x^{e_\delta}$,
$e_\delta=a_N(c, \delta)$, and \eqref{eq:order-r}, we can write
\begin{align}
  g_r(\gamma \tau)
  &=
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\ord^N_c(r)}
  \cdot
  \divisorprod{N}
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  \label{eq:modular-g_r(gamma*tau)}
\end{align}
Thus, we can expand $g_r(\gamma\tau)$ as a Laurent series in
$x:=q^{1/w_\gamma}$ with coefficients from $\setQ(\xi)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Root of unity reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that any modular function (in particular $g_r$) can be expressed
as a rational function $f$ in $j$ and $j_N$ where
$j_N(\tau):=j(N\tau)$ and $j$ is Klein's $j$-invariant, \ie,
$g_r(\tau)=f(j, j_N)(\tau) := f(j(\tau), j(N\tau))$.

Let $\frac{a}{c}$ be a cusp of $\Gamma_0(N)$.
%
We can choose $b$ and $d$ such that
%
$\gamma := \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in \SL2Z$ and $\gamma\infty=\frac{a}{c}$.
%
Klein's $j$-function is invariant under any modular transformation.
%
Let us consider the transformation of $j_N$ by $\gamma$.
%
According to \eqref{eq:tau_delta} for $\delta=N$, $j_N(\gamma\tau)$
can be expanded into a Laurent series in
$x=q^{1/w_\gamma}=\unityPower{\tau/w_\gamma}$ with
coefficients from $\setQ(\xi)$ where $\xi$ is a $\frac{N}{c}$-th root
of unity.
%
Since there is some freedom to choose such $b$ and $d$, we show in the
following, how we can obtain an expansion of $j_N(\gamma\tau)$ and
therefore (via $f$) an expansion $g_r(\gamma\tau)$ into a Laurent
series in $x$ with coefficients in $\setQ(\xi)$ where $\xi$ is a
$v$-th root of unity and $1 \leq v \le N/c$ and $v<N/c$ if $c<N$.

Let
$\gamma' = \bigl(
\begin{smallmatrix}
  a & b'\\
  c & d'
\end{smallmatrix}
\bigr) \in \SL2Z$, then also
\begin{align*}
  \gamma
  &:=
    \begin{pmatrix}
      a & b' + as\\
      c & d' + cs
    \end{pmatrix}
  =
    \begin{pmatrix}
      a & b'\\
      c & d'
    \end{pmatrix}
    \begin{pmatrix}
      1 & s\\
      0 & 1
    \end{pmatrix}
    \in \SL2Z
\end{align*}
for any $s\in\setZ$.

For the transformation of $j_N$, we split the matrix as in
\eqref{eq:naive-matrix-split} with $\delta=N$.
\begin{align*}
  \begin{pmatrix}
    N a & N(b' + as)\\
    c & d' + cs
  \end{pmatrix}
      &=
  \begin{pmatrix}
    N a/c & -1\\
    1     &  0
  \end{pmatrix}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix}
\end{align*}
into an element of $SL_2(Z)$ and a triangular matrix.
%
Then we determine natural numbers $u$ and $v$ such that $u v = N/c$
and $\gcd(c, u)=1$. Thus, we can find $s \in \setZ$ such that
$s \equiv -d'c^{-1} \pmod{u}$, \ie, $cs + d' = tu$ for some integer
$t$ with $0\le t<c$.
%
Thus,
\begin{gather*}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix} \tau
  =
  \begin{pmatrix}
    c & u t\\
    0 & u v
  \end{pmatrix} \tau
  =
  \frac{c^2}{N} \tau + \frac{t}{v}
  =
 \frac{w_\gamma c^2}{N} \frac{\tau}{w_\gamma} + \frac{t}{v}
  =
 \frac{c}{\gcd(c,N/c)} \frac{\tau}{w_\gamma} + \frac{t}{v}
  .
\end{gather*}
Note that $u=N/c$ and $v=1$, if $N$ is squarefree.

With the particular $s$ from above, we define $b:=b'+as$, $d:=d'+cs$
and take
%
$\gamma = \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr)$ as the transformation matrix that belongs to the cusp
$\frac{a}{c}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The function $g_{r,m,t}$ and its transformations under
  $\SL2Z$}
  \label{sec:function-g_r-m-t}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the following let
$\defineNotation[m]{m},
\defineNotation[M]{M},
N \in \setN \setminus \Set{0}$, and
$r \in R(M)$
be subject to the following conditions
\begin{gather}
  \text{for every prime $p$ with $\divides{p}{m}$ follows $\divides{p}{N}$,}
  \label{eq:p|m=>p|N}\\
  \text{and, if $\divides{\delta}{M}$ and $r_\delta\ne0$, then
    $\divides{\delta}{mN}$.}
  \label{eq:delta|M=>delta|mN}
\end{gather}

For the above conditions see (13) and (14) in
\cite{Radu:AlgorithmicApproachRamanujanCongruences:2009} or
Section~4.2 in \cite{Radu:PhD:2010}.

Furthermore, we fix $t\in\Set{0,\ldots,m-1}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
\begin{gather*}
  f(\tau)
  =
  \sum_{n=0}^\infty a(n) q^n
  =
  \divisorprod{M}\prod_{n=1}^\infty(1-q^{\delta n})^{r_\delta}
  =
  \divisorprod{M}\eulerFunction{\delta}^{r_\delta}
  =
  \unityPower{-\frac{\tau \, \sumdelta{r}}{24}} g_r(\tau)
\end{gather*}
be the generating function for the sequence $(a(n))_{n\in\setN}$
where we have abbreviated
\begin{gather}
  \sumdelta{r} := \divisorsum{M} \delta r_\delta.
  \label{eq:sumdelta}
\end{gather}

Let $\defineNotation[U-m]{U_m}$ be an operation on functions
$\setH\to\setC$ so that
\begin{gather*}
  (U_m\phi)(\tau) := \frac{1}{m}\sum_{\lambda=0}^{m-1}
  \phi\left(\frac{\tau+\lambda}{m}\right).
\end{gather*}
Let
\begin{gather*}
  f_t(\tau)
  :=\unityPower{-t\tau}f(\tau)
  = \unityPower{-\frac{\tau (24 t + \sumdelta{r})}{24}} g_r(\tau),
\end{gather*}
then
\begin{align*}
  (U_mf_t)(\tau)
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}f_t\left(\frac{\tau+\lambda}{m}\right)
  \\
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{t\tau+t\lambda}{m}}
  \sum_{k=0}^\infty a(k) \unityPower{\frac{k\tau+k\lambda}{m}}
  \\
  &=
  \frac{1}{m}
  \sum_{k=0}^\infty
  a(k)
  \sum_{\lambda=0}^{m-1}
  \unityPower{\frac{(k-t)(\tau+\lambda)}{m}}
  \\
  &=
  \frac{1}{m}
  \sum_{k=0}^\infty
  a(k)\,
  \unityPower{\frac{(k-t)\tau}{m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{\frac{(k-t)\lambda}{m}}
  \\
  &=
    \sum_{n=0}^\infty
    \sum_{l=0}^{m-1} a(mn+l)\,
  \unityPower{\frac{(mn+l-t)\tau}{m}}
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}\unityPower{\frac{(mn+l-t)\lambda}{m}}\\
  &=
    \sum_{n=0}^\infty a(mn+t) q^n
\end{align*}
is the generating function for the series
$(a(mn+t))_{n\in\setN}$.


Note that
$\sum_{\lambda=0}^{m-1}\unityPower{\frac{(mn+l-t)\lambda}{m}}$ is
equal to $m$ for $l=t$ and vanishes in all other cases.

We can also evaluate $(U_mf_t)(\tau)$ in another way.
%
\begin{align*}
  (U_mf_t)(\tau)
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}f_t\left(\frac{\tau+\lambda}{m}\right)\\
  &=
    \frac{1}{m} \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{(\tau+\lambda) (24 t + \sumdelta{r})}{24 m}}
    g_r\left(\frac{\tau+\lambda}{m}\right)
  \\
% &=
% \frac{1}{m} \sum_{\lambda=0}^{m-1}
% \unityPower{-\frac{t\tau+t\lambda}{m} - \frac{\tau+\lambda}{24m} \sumdelta{r}}
% g_r\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m}
  \unityPower{-\frac{\tau (24t+\sumdelta{r})}{24m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda (24t+\sumdelta{r})}{24m}}
  \divisorprod{M}
    \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}
\end{align*}

As abbreviation, we define the function
\begin{align}
  \defineNotation[g-r-m-t-lambda]{g_{r,m,t,\lambda}(\tau)}
  &:=
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
  \divisorprod{M}
  \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}
  \label{eq:g_r-m-t-lambda(tau)}
\end{align}

In the following we consider the function
\begin{align}
  \defineNotation[g-r-m-t]{g_{r,m,t}(\tau)}
  &:= \unityPower{\frac{\tau (24t+\sumdelta{r})}{24m} } (U_mf_t)(\tau)
  =
  \frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\tau)
  \label{eq:g_r-m-t(tau)}
\end{align}
and its transformations under $\SL2Z$.

Note that $g_r = g_{r, 1, 0}$.

We aim at the expansion of $g_{r,m,t}(\tau)$ at all cusps
$\gamma = \left(
  \begin{smallmatrix}a&b\\c&d\end{smallmatrix} \right)\in \SL2Z$
of $\Gamma_0(N)$ into Puiseux series in $x=q^{1/w_\gamma}$ or rather
into Laurent series in
$\defineNotation[z]{z} := q^{\frac{1}{24 w_\gamma}}$. Temporarily (for
the expansion of $\eta_{\delta,m,\lambda}$) we will expand into
Laurent series in
$\defineNotation[z-m]{z_m} := q^{\frac{1}{24 m w_\gamma}}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_{\delta,m,\lambda}$ under
  $\SL2Z$}
  \label{sec:transformation-eta_delta-m-lambda}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\defineNotation[lambda]{\lambda} \in \Set{0,\ldots,m-1}$, and
$\divides{\delta}{M}$.
%
We define
\begin{gather}
  \defineNotation[eta-delta-m-lambda]{\eta_{\delta,m,\lambda}}(\tau)
  := \eta \left(
    \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix} \tau
  \right).
\label{eq:eta_delta-m-lambda}
\end{gather}

Let
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$.
%
Then
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &:= \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix}
  \gamma
  \tau
\right)
=
\eta(W \tau)
\end{align}
where
\begin{align}
  W &:=
  \begin{pmatrix}
    \delta (a + c \lambda) & \delta (b + d \lambda)\\
    c m                   & d m
  \end{pmatrix}.
  \label{eq:W_delta-m-lambda}
\end{align}

Setting $z = \delta \lambda$ in Lemma~\ref{thm:c*tau+d}, we get the
splitting of $W = W' W''$ as
%
\begin{gather}
  W' =
  \begin{pmatrix}
    a' & b'\\
    c' & d'
  \end{pmatrix}
  = \begin{pmatrix}
      \delta(a+c \lambda)/h_{\delta,m,\lambda} & b'\\
      cm/h_{\delta,m,\lambda}                  & d'
    \end{pmatrix},
  \qquad
  W''
  =
  \begin{pmatrix}
    h_{\delta,m,\lambda} & \delta (b + d \lambda) d' - d m b'\\
    0               & \delta m / h_{\delta,m,\lambda}
  \end{pmatrix}
  \label{eq:split-W_delta-m-lambd}
\end{gather}
where $b'$ and $d'$ have been chosen in such a way that
$0\le  \delta (b + d \lambda) d' < \delta m / h_{\delta,m,\lambda}$.
and
\begin{gather}
  \defineNotation[h-delta-m-lambda]{h_{\delta,m,\lambda}} :=
  \gcd(\delta (a + c \lambda), cm).
\end{gather}

Let us define
\begin{gather}
  \defineNotation[u-delta-m-lambda]{u_{\delta,m,\lambda}}
  :=
  \frac{h_{\delta,m,\lambda}^2}{\delta m},
  \qquad
  \defineNotation[v-delta-m-lambda]{v_{\delta,m,\lambda}}
  :=
  \frac{h_{\delta,m,\lambda}(\delta (b + d \lambda) d' - d m b')}{\delta m}.
\end{gather}

And further,
\begin{align*}
  \defineNotation[tau-delta-m-lambda]{\tau_{\delta,m,\lambda}}
  &:=
    W''\tau
    = \frac{h_{\delta,m,\lambda}^2 \tau}{\delta m} +
    \frac{h_{\delta,m,\lambda}(\delta (b + d \lambda) d' - d m
    b')}{\delta m}\\
    &= u_{\delta,m,\lambda} \tau + v_{\delta,m,\lambda}.
\end{align*}
Then
$\defineNotation[q-delta-m-lambda]{q_{\delta,m,\lambda}} :=
\unityPower{\tau_{\delta,m,\lambda}} =
q^{u_{\delta,m,\lambda}}\,\unityPower{v_{\delta,m,\lambda}}$.


Lemma~\ref{thm:c*tau+d} tells us
$c'\tau_{\delta,m,\lambda}+d' = \frac{h_{\delta,m,\lambda}}{\delta} (c \tau + d)$.
%
Therefore,
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &= \eta(W \tau)
    = (c'\tau'+d')^{1/2} \, \upsilon(W')
    \,\eta(\tau_{\delta,m,\lambda})\notag\\
  &=
    (c\tau+d)^{1/2}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{1/2}
    \unityPower{\frac{\kappa_{\gamma,\delta,m,\lambda}}{24}} \,
    q_{\delta,m,\lambda}^{1/24}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)\notag\\
  &=
    (c\tau+d)^{1/2}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{1/2}
    \unityPower{\frac{ v_{\delta,m\lambda} + \kappa_{\gamma,\delta,m,\lambda}}{24}}
    q^{u_{\delta,m,\lambda}/24}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)
    \label{eq:eta_delta-m-lambda(gamma*tau)}
\end{align}
where
$\defineNotation[kappa-gamma-delta-m-lambda]{\kappa_{\gamma,\delta,m,\lambda}}
\in \Set{0,\ldots,23}$ is defined by
$\unityPower{\frac{\kappa_{\gamma,\delta,m,\lambda}}{24}} = \upsilon(W')$.

We expand $\eta_{\delta,m,\lambda}(\gamma \tau)$ into a Laurent series
in $z_m$ with coefficients from $\setQ(\xi_m)$ where
$\xi_m := \unityPower{\frac{1}{24 m N}}$. Note that
$\unityPower{\frac{v_{\delta,m,\lambda}}{24}}=\xi_m^k$ for
$k=\frac{N}{\delta} h_{\delta,m,\lambda}(\delta (b + d \lambda) d' - d
m b') \in \setZ$.
\begin{Hemmecke}
  $\xi_m$ is not yet what we want.
\end{Hemmecke}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $g_{r,m,t,\lambda}$ under $\SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

From its definition~\eqref{eq:g_r-m-t-lambda(tau)} and
\eqref{eq:eta_delta-m-lambda(gamma*tau)}, we can easily find a formula
for the transformation of $g_{r,m,t,\lambda}$ under $\SL2Z$.

\begin{align}
  g_{r,m,t,\lambda}(\gamma\tau)
  &=
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
    \divisorprod{M}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{r_\delta}\notag\\
  \begin{split}
  &=
    (c\tau+d)^{\divisorsum{M} \frac{r_\delta}{2}} \cdot
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)
    + \divisorsum{M}\frac{r_\delta(v_{\delta,m,\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\\
  & \qquad\times
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{r_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24} \tau}
    \cdot
    \divisorprod{M}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{r_\delta}
  \end{split}
  \label{eq:g_r-m-t-lambda(gamma*tau)}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $g_{r,m,t}$ under $\SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

From its definition~\eqref{eq:g_r-m-t(tau)}
and \ref{eq:g_r-m-t-lambda(gamma*tau)}, we can easily find a formula
for the transformation of $g_{r,m,t}$ under $\SL2Z$.

\begin{align}
  g_{r,m,t}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\gamma\tau)\notag\\
  \begin{split}
  &=
    \frac{(c\tau+d)^{\divisorsum{M} \frac{r_\delta}{2}}}{m}
    \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)
    + \divisorsum{M}\frac{r_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\\
  & \qquad\times
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{r_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{r_\delta}
  \end{split}
  \label{eq:g_r-m-t(gamma*tau)}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find ``modular'' cofactor for $g_{r,m,t}(\tau)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~35]{Radu:RamanujanKolberg:2015}
  \label{def:condition-co-eta-quotient-gamma0}
  Let $\Delta^*$ be the set of all tuples $(N, M, r, m, t)$ such that
  $N, M, m \in \setN\setminus\Set{0}$,
  %
  $t \in \Set{0,\ldots,m-1}$,
  %
  $r \in R(M)$
  %
  fulfil conditions \eqref{eq:p|m=>p|N} and \eqref{eq:delta|M=>delta|mN}
  and for
  %
  $\kappa:=\gcd(1-m^2, 24)\ge1$,
  %
  $w' := \gcd(\kappa(24t + \sumdelta{r}),24m)$,
  %
  $w := \frac{24m}{w'}$
  %
  the following conditions hold:
  \begin{gather}
  \kappa \frac{m N^2}{M} \divisorsum{M} \frac{M}{\delta}
    r_\delta \equiv_{24} 0,\label{eq:rv24}\\
  \kappa N \divisorsum{M} r_\delta \equiv_8 0,\label{eq:sum-r}\\
  \divides{w}{N},\label{eq:w|N}\\
  \divides{2}{m} \implies (\divides{4}{\kappa N} \land \divides{8}{N e})
  \lor
  (\divides{2}{e} \land \divides{8}{N(u-1)})\label{eq:even-m}
\end{gather}
where $e, u\in\setZ$ are such that $u$ is odd and
$\divisorprod{M} \delta^{\abs{r_\delta}}=2^e u$.
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}\label{thm:y^2-1}
  Let $y\in \setZ$ be such that $gcd(y, 6)=1$ then
  $y^2 \equiv_{24} 1$, \ie, $ \frac{y^2-1}{24} \in \setZ$.
\end{Lemma}
\begin{proof}
  Let $y = 6k + l$ with $l \in \Set{0,\ldots,5}$. Then
  $\gcd(y, 6)=\gcd(l,6)=1$ only holds for $l=1$ or $l=5$.
  %
  Since $36 k^2 + 12 k l + l^2 = 12k(3k+l) + l^2$, and $12k(3k+l)$ is
  divisible by 24 for $l=1$ or $l=5$, the statement of the Lemma
  follows from the fact that $1^2\equiv_{24} 5^2 \equiv_{24} 1$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~40]{Radu:RamanujanKolberg:2015}
  Let $n \in \setN$, $n>1$. For $x \in \setZ$ we denote by
  $[x]_n\in \setZ_n$ the residue class of $x$ modulo $n$ and define
  \begin{gather*}
    \setS_{n} := \SetDef{[y^2]_n}{y \in \setZ \land \gcd(y, n)=1}
    \subseteq
    \setZ_n.
  \end{gather*}
\end{Definition}

Let $x \in \setZ$ be such that $[x]_{24_m} \in \setS_{24m}$. Then
there exists $y \in \setZ$ with $\gcd(y, 24m)=1$ and
$[x]_{24m}=[y^2]_{24m}$, \ie, $x = y^2 + k (24m)$ for some $k\in
\setZ$. From Lemma~\ref{thm:y^2-1} follows that
$\frac{x-1}{24}=\frac{y^2-1}{24} + km \in\setZ$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~41]{Radu:RamanujanKolberg:2015}
  Let $r \in R(M)$.
  %
  The mapping
  \begin{align*}
    \bar{\odot}_r &: \setS_{24m} \times \Set{0,\ldots,m-1} \to
    \Set{0,\ldots,m-1},
    \qquad
    ([x]_{24m}, t) \mapsto [x]_{24m}  \mathbin{\bar{\odot}_r} t
  \end{align*}
  is uniquely given by
  \begin{gather}
    [x]_{24m} \mathbin{\bar{\odot}_r} t
    :=
    \left( t x + \frac{x-1}{24} \sumdelta{r} \right) \bmod{m}
  \end{gather}
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  (Definition 42 and Lemma 43 of \cite{Radu:RamanujanKolberg:2015})
  For $t\in\Set{0,\ldots,m-1}$, $r \in R(M)$ we define
  %
  \begin{align}
    \defineNotation[O-r-m-t]{\modularOrbit{r,m,t}}
    &:=
      \setS_{24m}  \mathbin{\bar{\odot}_r} t
      =
      \SetDef{x \mathbin{\bar{\odot}_r} t}{x \in \setS_{24m}},
    \\
    %
    \defineNotation[chi-r-m-t]{\chi_{r,m,t}}
    &:=
      \prod_{t' \in \modularOrbit{r,m,t}}
        \unityPower{\frac{(1-m^2)(24 t'+ \sumdelta{r})}{24 m}}.
  \end{align}
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  \label{thm:orbit-sum}
  \cite[Lemma~43]{Radu:RamanujanKolberg:2015}
  \begin{gather}
      \sum_{t' \in \modularOrbit{r,m,t}} (24 t'+ \sumdelta{r}) \equiv_m 0.
    \label{eq:orbit-rum}
  \end{gather}
\end{Lemma}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  \label{thm:stable-O-r-m-t}
  \label{thm:chi-exponent}
  \cite[Lemma~43]{Radu:RamanujanKolberg:2015}
  Let $t\in\Set{0,\ldots,m-1}$, $r \in R(M)$. Then
  \begin{enumerate}
  \item for any $x \in \setS_{24m}$ we have
    $\modularOrbit{r,m,t}
    = x \mathbin{\bar{\odot}_r} \modularOrbit{r,m,t}
    = \SetDef{x \mathbin{\bar{\odot}_r} t'}{t'\in \modularOrbit{r,m,t}}$,
  \item $\chi_{r,m,t}=\unityPower{\frac{\nu}{24}}$ for some
    $\nu \in \Set{0,\ldots,23}$.
  \end{enumerate}
\end{Lemma}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~44]{Radu:RamanujanKolberg:2015}
  Given $t\in\Set{0,\ldots,m-1}$, $r \in R(M)$, $s \in R(N)$, we
  define
  \begin{align}
    P_{r, m, t}(\tau)
    &:= \prod_{k \in \modularOrbit{r,m,t}} g_{r,m,k}(\tau)\\
    %
    F_{s, r, m, t}(\tau)
    &:= \divisorprod{N} \eta(\delta\tau)^{s_\delta} \cdot P_{r, m, t}(\tau)
  \end{align}
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
By \eqref{eq:g_r-m-t(tau)} we can write the following.
\begin{align}
  P_{r, m, t}(\tau)
  &:= \prod_{k \in \modularOrbit{r,m,t}}
    \unityPower{\frac{\tau (24k+\sumdelta{r})}{24m}} (U_mf_{k})(\tau)\\
  &:= \prod_{k \in \modularOrbit{r,m,t}}
    \left[\unityPower{\frac{\tau (24k+\sumdelta{r})}{24m}}
    \cdot \sum_{n=0}^\infty a(mn+k) q^n\right]
  \\
  &:= \unityPower{\tau\sum_{k\in\modularOrbit{r,m,t}}\frac{24k+\sumdelta{r}}{24m}}
    \prod_{k \in \modularOrbit{r,m,t}} \left[\sum_{n=0}^\infty a(mn+k) q^n\right]
  \\
  %
  F_{s, r, m, t}(\tau)
  &:= \divisorprod{N} \eta(\delta\tau)^{s_\delta} \cdot P_{r,m,t}(\tau)
  \\
  &= \divisorprod{N} \eulerFunction{\delta}^{s_\delta}
    \cdot
    \unityPower{\tau\frac{\sumdelta{s}}{24}}
    \cdot
    \unityPower{\tau\sum_{k\in\modularOrbit{r,m,t}}\frac{24k+\sumdelta{r}}{24m}}
    \cdot
    \prod_{k \in \modularOrbit{r,m,t}} \left(\sum_{n=0}^\infty a(mn+k) q^n\right)
    \label{eq:F_s-r-m-t(tau)}
  \\
  &= \divisorprod{N} \eulerFunction{\delta}^{s_\delta}
    \cdot
    % \unityPower{\tau
    q^{
    \left(
    \frac{\sumdelta{s}}{24}
    +
    \sum_{k\in\modularOrbit{r,m,t}}\frac{24k+\sumdelta{r}}{24m}
    \right)
    }
    \cdot
    \prod_{k \in \modularOrbit{r,m,t}} \left(\sum_{n=0}^\infty a(mn+k) q^n\right)
  \\
  &= \divisorprod{N} \eulerFunction{\delta}^{s_\delta}
    \cdot
    % \unityPower{\tau
    q^\alpha
    \cdot
    \prod_{k \in \modularOrbit{r,m,t}} \left(\sum_{n=0}^\infty a(mn+k) q^n\right)
  \\
  \alpha
  &=
    \frac{\sumdelta{s}}{24}
    +
    \sum_{k\in\modularOrbit{r,m,t}}\frac{24k+\sumdelta{r}}{24m}
    \label{eq:alphaInfinity}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $P_{r,m,t}$ under $\SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{align}
  P_{r,m,t}(\gamma\tau)
  &=
    \left(\frac{(c\tau+d)^{\divisorsum{M} \frac{r_\delta}{2}}}{m}\right)^\mu
    \prod_{k\in \modularOrbit{r,m,t}}
    \left[\sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24k+\sumdelta{r}\Bigr)
    + \divisorsum{M}\frac{r_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\right.\notag\\
  &\qquad\times
    \left.
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{r_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M} \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{r_\delta}
    \right]
    \label{eq:P_r-m-t(gamma*tau)}
\end{align}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $F_{s,r,m,t}$ under $\SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\cite[Thm.~45]{Radu:RamanujanKolberg:2015}
  \label{thm:RaduConditions}
  Let $(N, M, r, m, t) \in \Delta^*$ according to
  Definition~\ref{def:condition-co-eta-quotient-gamma0}, $s\in R(N)$,
  $\nu$ and $\mu$ be integers such that
  $\chi_{s,m,t}=\unityPower{\frac{\nu}{24}}$, and
  $\mu=\sizeOfSet{\modularOrbit{r,m,t}}$, then $F_{s,r,m,t}(\tau)$ is
  a modular function on $\Gamma_0(N)$ iff the following conditions
  hold:
  \begin{align}
    \divisorsum{N} s_\delta + \mu \divisorsum{M} r_\delta
    &=
      0,
    \label{eq:Radu-sum=0}\\
    \divisorsum{M} \delta s_\delta + \mu m \divisorsum{N} \delta r_\delta + \nu
    &\equiv
      0 \pmod{24},
    \label{eq:Radu-sigmainfinity}\\
    \divisorsum{N} \frac{N}{\delta} s_\delta
    + \frac{\mu m N}{M} \divisorsum{M} \frac{M}{\delta} r_\delta
    &\equiv
      0 \pmod{24},
    \label{eq:Radu-sigma0}\\
    \sqrt{
    \divisorprod{N}\delta^{s_\delta}
    \divisorprod{M} (m \delta)^{\mu r_\delta}
    } &\in \setQ\label{eq:Radu-productsquare}
  \end{align}
\end{Theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $N, s, M, r, m, t, \nu, \mu$ fulfil all the conditions of
Theorem~\ref{thm:RaduConditions}. Then the exponent of the factor
$c\tau+d$ is zero, \ie, this factor vanishes.

\begin{align}
  F_{s, r, m, t}(\gamma\tau)
  &:= \divisorprod{N} \eta(\delta\gamma\tau)^{s_\delta}
    \cdot
    P_{r, m, t}(\gamma\tau)
  \notag\\
  &=
  (c\tau+d)^{\divisorsum{N} \frac{s_\delta}{2}}
  \cdot
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!\frac{s_\delta}{2}}
  \cdot
  \unityPower{\divisorsum{N} \frac{s_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  q^{\divisorsum{N} \frac{s_\delta u_\delta}{24}}
  \cdot
    \divisorprod{N} \prod_{n=1}^{\infty}(1-q_\delta^n)^{s_\delta} \times\notag\\
  &\qquad\times
    P_{r, m, t}(\gamma\tau)
  \notag\\
  &=
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!\frac{s_\delta}{2}}
  \cdot
  \unityPower{\divisorsum{N} \frac{s_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  q^{\divisorsum{N} \frac{s_\delta u_\delta}{24}}
    \cdot
    \divisorprod{N} \prod_{n=1}^{\infty}(1-q_\delta^n)^{s_\delta} \times\notag\\
  &\qquad\times
    \frac{1}{m^\mu}
    \prod_{k\in \modularOrbit{r,m,t}}
    \left[\sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24k+\sumdelta{r}\Bigr)
    + \divisorsum{M}\frac{s_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\right.\notag\\
  &\qquad\times
    \left.
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{r_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M} \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{r_\delta}
    \right]
    \label{eq:F_s-r-m-t(gamma*tau)}
\end{align}













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The formulas in short and their relations to the
  implementation}
\label{sec:formulas-in-short}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$t \in \Set{0,1,\ldots,m-1}$

\begin{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  f(\tau)
  &=
  \sum_{n=0}^\infty a(n) q^n
  =
  \divisorprod{M}\prod_{n=1}^\infty(1-q^{\delta n})^{r_\delta}
  =
  \divisorprod{M}\eulerFunction{\delta}^{r_\delta}
  =
  \unityPower{-\frac{\sumdelta{r} \tau}{24}} g_r(\tau)
  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  f_t(\tau)
  &:=
  \sum_{n=0}^\infty a(n) q^{n-t}
  =
  \sum_{n=-t}^\infty a(n+t) q^{n}
  =
  \unityPower{-t\tau}f(\tau)
  =
  \unityPower{-\frac{(24t+\sumdelta{r}) \tau}{24}} g_r(\tau)
  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  (U_mf_t)(\tau)
  &=
    \sum_{n=0}^\infty a(mn+t) q^n
  \\
  &=
  \frac{1}{m}
  \unityPower{-\frac{\tau (24t+\sumdelta{r})}{24m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda (24t+\sumdelta{r})}{24m}}
  \divisorprod{M}
    \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}
  \\
  &=
  \frac{1}{m}
  \unityPower{-\frac{\tau (24t+\sumdelta{r})}{24m}}
    \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\tau)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{blue}{\texttt{SymbolicSiftedEtaQuotientLambdaGamma}}
(Section~\ref{sec:SymbolicSiftedEtaQuotientLambdaGamma})

\begin{align*}
  g_{r,m,t,\lambda}(\tau)
  &=
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M}
    \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}
  \\
  e &= \mathtt{etaQuotient}(M, \Delta, r, m, t, \lambda , \gamma)
  \\
  \mathtt{rationalPrefactor}(e)
  &=
    \divisorprod{M} \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}
  \\
  \mathtt{unityPower}(e)
  &=
    -\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr) +
    \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} +
                         \kappa_{\delta,m,\lambda})}{24}
  \\
  \mathtt{qExponent}(e)
  &=
  \divisorsum{M} r_\delta u_{\delta,m,\lambda}.
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{blue}{\texttt{SymbolicSiftedEtaQuotientGamma}}
(Section~\ref{sec:SymbolicSiftedEtaQuotientGamma})

\begin{align*}
  g_{r,m,t}(\tau)
  &=
    \unityPower{\frac{\tau (24t+\sumdelta{r})}{24m} } (U_mf_t)(\tau)
    =
    \frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\tau)
    =
    \unityPower{\frac{\tau (24t+\sumdelta{r})}{24m}} \sum_{n=0}^\infty a(mn+t) q^n
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{blue}{\texttt{SymbolicSiftedEtaQuotientOrbitProductGamma}}
(Section~\ref{sec:SymbolicSiftedEtaQuotientOrbitProductGamma})

\begin{align*}
  P_{r, m, t}(\tau)
  &:=
    \frac{1}{m^\mu}
    \prod_{t' \in \modularOrbit{r,m,t}}
    \left(
    \sum_{\lambda=0}^{m-1} g_{r,m,t'}(\tau)
    \right)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{blue}{\texttt{SymbolicModularSiftedEtaQuotientGamma}}
(Section~\ref{sec:SymbolicSiftedEtaQuotientOrbitProductGamma})

\begin{align*}
  F_{s, r, m, t}(\tau)
  &:=
    \divisorprod{N} \eta(\delta \tau)^{s_\delta} \cdot P_{r, m, t}(\tau)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{blue}{\texttt{SymbolicSiftedEtaQuotientLambdaGamma}}
(Section~\ref{sec:SymbolicSiftedEtaQuotientLambdaGamma})
(actually unused)

\begin{align*}
  g_{r,m,-,\lambda}(\tau)
  &=
    \divisorprod{M}
    \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{blue}{\texttt{SymbolicSiftedEtaQuotientGamma}}
(Section~\ref{sec:SymbolicSiftedEtaQuotientGamma})
(actually unused)

\begin{align*}
  g_{r,m}(\tau)
  &=
    (U_m g_r)(\tau)
    =
    \frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,-,\lambda}(\tau)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




























%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Application of $U_m$ to $g_{r}$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $m \in \setN$, $m>0$, $r \in R^*(mN)$,
$\defineNotation[gamma]{\gamma} =
\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$.
%

In this section we want to determine a formula for
$g_{r,m} := (U_m g_r)$.

We determine the expansions of $(U_m g_r)(\gamma\tau)$, similar to
Section~\ref{sec:function-g_r-m-t}.
%
In fact, we can reuse everything from
Section~\ref{sec:transformation-eta_delta-m-lambda} and then because
of $t=0$, $\divisorsum{M} r_\delta=0$ and the missing factor
$\unityPower{-\frac{\tau(24t+\sumdelta{r})}{24}}$
equation~\eqref{eq:g_r-m-t-lambda(gamma*tau)} simply turns into the
following.
\begin{align}
  g_{r,m,-,\lambda}(\gamma\tau)
  &=
    \divisorprod{M}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{r_\delta}\notag\\
  \begin{split}
  &=
  \unityPower{
      \divisorsum{M}\frac{r_\delta(v_{\delta,m,\lambda}
        +
      \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\\
  & \qquad\times
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{r_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24} \tau}
    \cdot
    \divisorprod{M}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{r_\delta}
  \end{split}
  \label{eq:g_r-m---lambda(gamma*tau)}
\end{align}

Then
\begin{align}
  g_{r,m}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,-,\lambda}(\gamma\tau)\notag\\
  \begin{split}
  &=
    \sum_{\lambda=0}^{m-1}
    \unityPower{\divisorsum{M}\frac{r_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\\
  & \qquad\times
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{r_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{r_\delta}
  \end{split}
  \label{eq:g_r-m(gamma*tau)}
\end{align}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{The trace and the Atkin-Lehner involution applied to
   $g_r$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

See, for example, \cite{Kohnen:WeierstrassPointsAtInfinity:2004}.

We only treat the special case where $m=2$ and $N=121$.

Then
\begin{align*}
  W = W_2^{242}
  &=
    \begin{pmatrix}
      2 & 0\\
      242 & 1
    \end{pmatrix}\\
    %
  \gamma_{2,0}
  &=
    \begin{pmatrix}
      2 & 0\\
      242 & 1
    \end{pmatrix}
    \begin{pmatrix}
      1 & 0\\
      0 & 2
    \end{pmatrix}
  =
    \begin{pmatrix}2&0\\242&2\end{pmatrix}
  =
    \begin{pmatrix}1&0\\121&1\end{pmatrix}
    \begin{pmatrix}2&0\\0&2\end{pmatrix}
  \\
  \gamma_{2,1}
  &=
    \begin{pmatrix}
      2 & 0\\
      242 & 1
    \end{pmatrix}
    \begin{pmatrix}
      1 & 1\\
      0 & 2
    \end{pmatrix}
  =
    \begin{pmatrix}2&2\\242&244\end{pmatrix}
  =
    \begin{pmatrix}1&1\\121&122\end{pmatrix}
    \begin{pmatrix}2&0\\0&2\end{pmatrix}
\end{align*}

Since $\left(\begin{smallmatrix}2&0\\0&2\end{smallmatrix}\right)\tau =
\tau$, we can simply ignore this matrix and write
\begin{align*}
  (U_2 g_{r, W})(\tau)
  &=
    \frac{1}{2}\left(g_r(\gamma'_{2,0}\tau) + g_r(\gamma'_{2,1}\tau)\right)
\end{align*}
for
$\gamma'_{2,0} =
\left(\begin{smallmatrix}1&0\\121&1\end{smallmatrix}\right)$ and
$\gamma'_{2,0} =
\left(\begin{smallmatrix}1&1\\121&122\end{smallmatrix}\right)$.

Since 2 is a prime, we get from
\cite{Kohnen:WeierstrassPointsAtInfinity:2004} that
$\trace_{121}^{242}: M^\infty(242) \to M^\infty(121)$ can be computed via
\begin{gather*}
  g_r|\trace_{121}^{242}
  = g_r + 2 U_2(g_r|W_2^{242})
  = g_r + g_r|\gamma'_{2,0} + g_r|\gamma'_{2,1}.
\end{gather*}
Note that the width of $\gamma'_{2,0}$ and $\gamma'_{2,1}$ is 2, so in
our formula \eqref{eq:modular-g_r(gamma*tau)} we have
$x=q^{\frac{1}{2}}$.

Indeed the identity matrix, $\gamma'_{2,0}$, and $\gamma'_{2,1}$ are
three coset representative for
$\Gamma_0(242) \backslash \Gamma_0(121)$.
%
See function \code{rightCosetRepresentatives} in
\PathName{qetaauxmeq.spad} and \cite[Lemma~2.44]{Radu:PhD:2010}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Z24 ==> IntegerMod 24
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
GAMMA0 ==> CongruenceSubgroupGamma0
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]
lcmP(a, b) ==> asP lcm(a::Integer, b::Integer)

)if LiterateDoc
%$
In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic}.

Another naming convention is that domains that involve the string
\code{Sifted} correspond to an application of the
$U_m$ operator, \ie, instead of looking on a series
$\sum_{n=0}^\infty{a(n)}
q^n$, we deal with a ``sifted'' series of the form
$\sum_{n=0}^\infty{a(mn+t) q^n}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symbolic domains}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicEtaDeltaGamma}
\label{sec:SymbolicEtaDeltaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$,
$\divides{\delta}{N}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SymbolicEtaDelta}
represent the tuple
\begin{gather*}
  \left(\frac{h_{\delta}}{\delta}, e_\delta, v_\delta, \kappa_\delta,
  \frac{v_\delta+\kappa_\delta}{24}\right)
\end{gather*}
from \eqref{eq:eta_delta(gamma*tau)-expansion} where the values are
given through \eqref{eq:h_delta}, \eqref{eq:width0},
\eqref{eq:q_delta}, \eqref{eq:uv_delta}, and
$x=\unityPower{\frac{\tau}{w_\gamma}}$.

If \code{e = eta(m, delta, gamma)}, then we have the following
correspondence.
\code{rationalPrefactor(e)} $= \frac{h_\delta}{\delta}$,
\code{edelta(e)}            $= e_\delta$,
\code{vdelta(e)}            $= v_\delta$,
\code{upsilonExponent(e)}   $= \kappa_\delta$,
\code{unityPower(e)}        $= \frac{v_\delta+\kappa_\delta}{24}$.
)endif

)abbrev domain YEDG SymbolicEtaDeltaGamma
++ SymbolicEtaDeltaGamma collects data for the expansion of
++ eta_delta(\gamma \tau).
++ See \eqref{eq:eta_delta(gamma*tau)}.
SymbolicEtaDeltaGamma: SetCategory with
    eta: (P, P, SL2Z) -> % -- gamma=[[a,b],[c,d]], m=level, delta, r_delta
      ++ eta(m, delta, gamma) represents the expansion of
      ++ \eta_\delta(\gamma \tau) in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c) for some cusp a/c of Gamma0(m).
    level: % -> P
      ++ level(x) returns the level corresponding to x.
    delta: % -> P
      ++ delta(x) returns the delta that was used at creation time of x.
    gamma: % -> SL2Z
      ++ gamma(x) returns the gamma as given at creation time of x.
    rationalPrefactor: % -> Q -- (h_delta/delta)
      ++ See \ref{thm:c*tau+d}.
    upsilonExponent: % -> Z24 -- kappa_delta
      ++ See \eqref{eta_delta(gamma*tau)}.
    edelta: % -> P            -- width*udelta
      ++ See \eqref{eq:uv_delta}
    udelta: % -> Q            -- gcd(delta,c)^2/delta
      ++ See \eqref{eq:uv_delta}
    vdelta: % -> Q            -- b2/d2
      ++ See \eqref{eq:uv_delta}.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,    -- level \Gamma_0(lev)
              fdelta: P,    -- the divisor used at creation
              fgamma: SL2Z, -- the gamma used at creation
              frat: Q,      -- h_delta/delta
              fkappa: Z24,  -- upsilonExponent(a1,b2,c1,d1)
              fedelta: P,   -- edelta = width*hdelta^2/delta \eqref{eq:q_delta}}
              fudelta: Q,   -- edelta = hdelta^2/delta \eqref{eq:q_delta}}
              fvdelta: Q    -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
             )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, gamma: SL2Z): % ==
        c: Z := gamma(2, 1)
        --assert(c>0)
        hdelta: Z := gcd(c, delta)
        rat: Q := hdelta/delta
        rec: Rec := splitMatrix(gamma, delta)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        a2: Z := gamma2(1, 1); wgamma: Z := WIDTH0(mm, c)
        udelta: Q := gcd(c,delta)^2 / delta
        edelta: P := asP numer(wgamma*udelta)
        if not one?(denom(wgamma*udelta)) then
            error "edelta is not integer"
        --assert(edelta = ((a2*wgamma exquo d2) :: Z))
        if udelta ~= a2/d2 then
            error "edelta does not match"
        vdelta: Q := b2/d2
        kappa: Z24 := upsilonExponent(gamma1)$QETAAUX
        per [mm, delta, gamma, rat, kappa, edelta, udelta, vdelta]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    edelta(x: %): P == xx.fedelta
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        gamma x = gamma y




)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicEtaQuotientGamma}
\label{sec:SymbolicEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SymbolicEtaQuotientGamma}
represent the tuple
\begin{gather}
  \left(
  N
  ,
  r
  ,
  \gamma
  ,
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}
  ,
  \divisorsum{N} r_\delta e_\delta
  \right)
\end{gather}
and thus corresponds to the data from \eqref{eq:g_r(gamma*tau)}.

If \code{e = etaQuotient(m, r, gamma)}, then we have the
following correspondence.
\code{rationalPrefactor(e)} $=
  \divisorprod{N} \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}$,
\code{unityPower(e)}        $=
  \divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}$,
\code{xExponent(e)}         $= \divisorsum{N} r_\delta e_\delta$.

)endif
-------------------------------------------------------------------
)abbrev domain YETAQG SymbolicEtaQuotientGamma
++ SymbolicEtaQuotientGamma holds data to compute an eta quotient expansion
++ of g_r(\gamma \tau).
++ See \eqref{eq:g_r(gamma*tau)}.
SymbolicEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, SL2Z) -> %
      ++ etaQuotient(mm, r, gamma) represents the expansion of
      ++ $g_r(\gamma \tau) =
      ++   \prod_{\delta in divisors(m)} \eta(\delta \gamma \tau)^{r_{\delta}}$
      ++ in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=matrix[[a,b],[c,d]]  represents the cusp a/c of Gamma0(mm).
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were
      ++ given at creation time of x.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r(gamma*tau)}.
    unityPower: % -> Q
      ++ unityPower(e) returns sum_{\delta} rdelta*(vdelta+kappa_delta)/24.
      ++ It corresponds to the third product of eq:g_r(gamma*tau).
    xExponent: % -> Z
      ++ xExponent(e) returns 24 times the order of the expansion
      ++ of e in x = \exp(2 \pi i \tau/w) where w is the width of the cusp
      ++ while neglecting the (c \tau+d) factor.
      ++ It corresponds to 24 times the exponent of the fourth product
      ++ of \eqref{eq:g_r(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns 24 times the order of the expansion
      ++ of e in q = \exp(2 \pi i \tau) while neglecting the (c \tau+d)
      ++ factor. It corresponds to 24 times the exponent of the fourth
      ++ product of \eqref{eq:g_r(gamma*tau)}.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(e) returns the smallest positive integer n such that
      ++ the expansion of the function g_r(\gamma \tau) corresponding to
      ++ e=etaQuotient(mm, r, gamma) (neglecting the (c\tau+d)^* factor)
      ++ lives in Q[w][[x]] where w is a n-th root of unity.
    elt: (%, P) -> SymbolicEtaDeltaGamma
      ++ elt(x, delta) returns the data corresponding to the respective
      ++ delta.
    modularGamma0?: % -> Boolean
      ++ modularGamma0?(x) returns true if the eta quotient is a modular
      ++ function for Gamma0(level x), i.e, it returns
      ++ modularGamma0?(level x, exponents x) from
      ++ QEtaAuxiliaryPackage.
 == add
    HT ==> XHashTable(P, SymbolicEtaDeltaGamma) -- mapping delta to \eta_\delta
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_\delta
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
              fxExponent: Z, -- \sum_delta rdelta*edelta
              fqExponent: Q, -- \sum_delta rdelta*udelta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    -- divs must be ALL divisors of m sorted ascendingly
    etaquot(mm: P, r: LZ, gamma: SL2Z, eta: HT): % ==
        divs: LP := DIVISORS mm
        rat: Q := 1
        upower: Q := 0
        xexponent: Z := 0
        qexponent: Q := 0
        for delta in divs for rdelta in r | not zero? rdelta repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            xexponent := xexponent + rdelta * edelta(e)
            qexponent := qexponent + rdelta * udelta(e)

            kappa: Q := (convert(upsilonExponent e)@Z)::Q
            upower := upower + rdelta * (vdelta e + kappa)

        -- Now make the numerator small.
        den: Z := 24 * denom upower -- den-th root of unity
        upower := positiveRemainder(numer upower, den) / den

        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minimalSquareRootOfUnity(p)$QETAAUX)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [mm, divs, r, gamma, eta, rat, upower, xexponent, qexponent, minroot]

    etaQuotient(mm: P, r: LZ, gamma: SL2Z): % ==
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in DIVISORS mm repeat
            eta.delta := eta(mm, delta, gamma)$SymbolicEtaDeltaGamma
        etaquot(mm, r, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    elt(x: %, delta: P): SymbolicEtaDeltaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    xExponent(x: %): Z == xx.fxExponent
    qExponent(x: %): Q == xx.fqExponent
    minimalRootOfUnity(x: %): P == xx.fminroot
    modularGamma0?(x: %): Boolean ==
        modularGamma0?(level x, exponents x)$QETAAUX

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fgamma = yy.fgamma


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicEtaQuotient}
\label{sec:SymbolicEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
elements from the domain \code{SymbolicEtaQuotient}
is a container of data from  \code{SymbolicEtaQuotientGamma} for each
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, corresponding to a cusp of $\Gamma_0(N)$.

If \code{e = etaQuotient(m, r)}, then
for each cusp in
\code{cusps(nn)$CongruenceSubgroupGamma0(nn)}
%$
we have \code{e.cusp} is the corresponding data from
\code{SymbolicEtaQuotientGamma}.

)endif
-------------------------------------------------------------------
)abbrev domain YETAQ SymbolicEtaQuotient
++ SymbolicEtaQuotient holds data to compute an eta quotient expansions
++ of g_r(\tau) at all cusps of $\Gamma_0(N)$ or at the given cusps.
++ See \eqref{g_r(tau)}
SymbolicEtaQuotient: SetCategory with
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ If x=etaQuotient(mm, r) then level(x) returns the level of
      ++ the eta quotient, i.e., level(x)=mm.
    exponents: % -> LZ
      ++ If x=etaQuotient(m, r) then exponents(x) returns the list of
      ++ exponents, i.e., exponents(x)=r.
    cusps: % -> LQ
      ++ If x=etaQuotient(mm, r), then
      ++ cusps(x)=cusp(mm)$CongruenceSubgroupGamma0.
    minimalRootOfUnity: % -> P
      ++ If x=etaQuotient(mm, r), then minimalRootOfUnity(x) returns the
      ++ smallest positive integer n such that the expansion of the
      ++ function g_r(\tau) at any cusp of Gamma_0(mm)
      ++ (neglecting the (c\tau+d)^* factor lives in Q[w][[x]] where w
      ++ is an n-th root of unity.
    elt: (%, Q) -> SymbolicEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    qetaGrades: % -> List Q
      ++ qetaGrades(x) returns the (negated) exponents of a series
      ++ expansion of x at all the cusps in the canonical variables.
      ++ Internally, the matrix of Ligozat is employed.
 == add
    HT ==> XHashTable(Q, SymbolicEtaQuotientGamma)
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(level)
              fexponents: LZ,-- the r vector
              fcusps: LQ,
              feta: HT,      -- mapping delta to \eta_\delta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    qetaGrades(x: %): List Q == [-xExponent(x.cusp)/24 for cusp in cusps x]

    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        divs: LP := DIVISORS mm
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(mm, cusp)$GAMMA0
            e: SymbolicEtaQuotientGamma := etaQuotient(mm, r, gamma)
            h.cusp := e
            minroot := lcmP(minroot, minimalRootOfUnity e)
        per [mm, r, cusps, h, minroot]

    etaQuotient(mm: P, r: LZ): % == etaQuotient(mm, r, cusps(mm)$GAMMA0)

    level(x: %): P == xx.flevel
    exponents(x: %): LZ == xx.fexponents
    cusps(x: %): LQ == xx.fcusps
    elt(x: %, cusp: Q): SymbolicEtaQuotientGamma == xx.feta.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents = yy.fexponents


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaDeltaLambdaGamma}
\label{sec:SymbolicSiftedEtaDeltaLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaDeltaLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  \delta,
  m,
  \lambda,
  \gamma,
  \frac{h_{\delta,m,\lambda}}{\delta}
  ,
  u_{\delta,m,\lambda},
  v_{\delta,m,\lambda},
  \kappa_{\delta,m,\lambda}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:eta_delta-m-lambda(gamma*tau)}, \ie, it computes the
building blocks for $\eta_{\delta,m,\lambda}(\gamma\tau)$.

If \code{e = eta(mm, delta, m, lambda, gamma)}, then we
have the following correspondence:
%
\code{rationalPrefactor(e)} $= \frac{h_{\delta,m,\lambda}}{\delta}$,
\code{udelta(e)}            $= u_{\delta,m,\lambda}$,
\code{vdelta(e)}            $= v_{\delta,m,\lambda}$,
\code{upsilonExponent(e)}   $= \kappa_{\delta,m,\lambda}$.

)endif
-------------------------------------------------------------------
)abbrev domain YSEDLG SymbolicSiftedEtaDeltaLambdaGamma
++ SymbolicSiftedEtaDeltaLambdaGamma is a generalization of
++ SymbolicEtaDeltaGamma. It holds data to compute an eta
++ expansion of $\eta_{delta.m,\lambda}(\gamma \tau)$.
++ See \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
SymbolicSiftedEtaDeltaLambdaGamma: SetCategory with
    eta: (P, P, P, N, SL2Z) -> %
      ++ eta(mm, delta, m, lambda, gamma) represents the
      ++ expansion of $\eta_{\delta,m,\lambda}(\gamma \tau)$ in terms of
      ++ $q = \exp(2 \pi i \tau)$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    delta: % -> P
      ++ delta(x) returns the corresponding delta.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in eta(...,gamma).
    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r(gamma*tau)}
    upsilonExponent: % -> Z24
      ++ Returns $\kappa_{\gamma,\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
    udelta: % -> Q
      ++ Returns $u_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
    vdelta: % -> Q
      ++ Returns $v_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,
              fdelta: P,
              fmultiplier: P,
              flambda: N,
              fgamma: SL2Z, -- gamma
              frat: Q,      -- square of rational prefactor
              fkappa: Z24,  -- upsilonExponent(a1,b2,c1,d1)
              fudelta: Q,   -- udelta = hdelta^2/(delta*m)
                            -- \eqref{eq:uv_delta-m-lambda}}
              fvdelta: Q    -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        --assert(gamma(2, 1)>0)
        rec: Rec := splitMatrix(gamma, delta, m, lambda)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        a2: Z := gamma2(1, 1); b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        rat: Q := a2/delta -- = hdelta/delta
        udelta: Q := a2/d2 -- = hdelta^2/delta/m
        vdelta: Q := b2/d2
        kappa: Z24 := upsilonExponent(gamma1)$QETAAUX
        per [mm, delta, m, lambda, gamma, rat, kappa, udelta, vdelta]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        multiplier x ~= multiplier y => false
        lambda x ~= lambda y => false
        gamma x = gamma y


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaQuotientLambdaGamma}
\label{sec:SymbolicSiftedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $g_{r,m,t,\lambda}(\gamma\tau)$
as well as $g_{r,m,-,\lambda}(\gamma\tau)$.

For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaQuotientLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  r,
  m,
  t,
  \lambda,
  \gamma,
  y,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!r_\delta}
  ,
  -\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr) +
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} r_\delta u_{\delta,m,\lambda}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:g_r-m-t-lambda(gamma*tau)}, \ie, it computes the building
blocks for $g_{r,m,t,\lambda}(\gamma\tau)$.

The special entry $y=(y_\delta)_{\divides{\delta}{M}}$ is a container
of the \code{SymbolicSiftedEtaDeltaLambdaGamma} values for each
divisor $\delta$ of $M$.

If \code{e = etaQuotient(mm, divs, r, m, t, lambda, gamma)}, then we
have the following correspondence:
%
\code{e.delta} $= y_\delta$,
%
\code{rationalPrefactor(e)}
$= \divisorprod{M} \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}$,
%
\code{unityPower(e)}
$= -\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr) +
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} +
  \kappa_{\delta,m,\lambda})}{24}$,
%
\code{qExponent(e)} $= \divisorsum{M} r_\delta u_{\delta,m,\lambda}$.

For the special case $t=-1$, the part
$-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)$ is missing, i.e.,
we get
\begin{gather}
  \left(
  M,
  r,
  m,
  t,
  \lambda,
  \gamma,
  y,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} r_\delta u_{\delta,m,\lambda}
  \right)
\end{gather}
and
\code{unityPower(e)}
$= \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} +
  \kappa_{\delta,m,\lambda})}{24}$.

)endif
-------------------------------------------------------------------
)abbrev domain YSETAQLG SymbolicSiftedEtaQuotientLambdaGamma
++ SymbolicSiftedEtaQuotientLambdaGamma is a generalization of
++ SymbolicEtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of g_{r,m,t,\lambda}(\gamma \tau) or
++ of g_{r,m,-,\lambda}(\gamma \tau).
++ See \eqref{eq:g_r-m-t-lambda(gamma*tau)} and
++ \eqref{eq:g_r-m---lambda(gamma*tau)}.
SymbolicSiftedEtaQuotientLambdaGamma: SetCategory with
    etaQuotient: (P, LZ, P, Z, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, lambda, gamma) represents the
      ++ expansion of $g_{r,m,t,\lambda}(\gamma \tau)$ in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(nn, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c of Gamma0(mm).
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were given
      ++ at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> Z
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    lambda: % -> N
      ++ lambda(x) returns lambda
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).

    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r-m-t-lambda(gamma*tau)}.
    unityPower: % -> Q
      ++ unityPower(e) returns $- lambda*(24*t+\sumdelta{r})/(24*m) +
      ++ sum_{\delta} rdelta*(vdelta+Kappa_delta)/24$. It corresponds to
      ++ the second factor of \eqref{eq:g_r-m-t-lambda(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns 24 times the order of the expansion
      ++ of e in q = \exp(2 \pi i \tau)  while neglecting the (c\tau+d) factor.
      ++ It corresponds to 24 times the exponent of the fourth product
      ++ of \eqref{eq:g_r-m-t-lambda(gamma*tau)}.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(e) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $g_{r,m,t,\lambda}(\gamma \tau)$ corresponding to
      ++ e=etaQuotient(mm, divs, r, m, t, lambda, gamma) (neglecting
      ++ the (c \tau+d)^* factor) lives in Q[w][[z]] where w is a n-th
      ++ root of unity and z a fractional q power.
    elt: (%, P) -> SymbolicSiftedEtaDeltaLambdaGamma
      ++ x.delta returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicSiftedEtaDeltaLambdaGamma)
      -- mapping delta to \eta_{\delta,m,\lambda}
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the s vector
              fmultiplier: P,-- the multiplier m
              foffset: Z,    -- the offset t \in 0..(m-1) or t=-1
              flambda: N,    -- lambda \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_{\delta,m,lambda}
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
                             -- - lambda*(24*t+\sumdelta{s})/(24*m)
              fqExponent: Q, -- \sum_delta rdelta*udelta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaquot(mm: P, divs: LP, r: LZ,
            m: P, t: Z, lambda: N, gamma: SL2Z, eta: HT): % ==
        rat: Q := 1
        upower: Q := 0
        qexponent: Q := 0
        sigmaInfty: Z := 0
        for delta in divs for rdelta in r | not zero? rdelta repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            qexponent := qexponent + rdelta * udelta(e)

            kappa: Q := (convert(upsilonExponent e)@Z)::Q
            upower := upower + rdelta * (vdelta e + kappa)
            sigmaInfty := sigmaInfty + delta * rdelta

        -- Distinguish between g_{s,m,t,\lambda} and g_{s,m,-,\lamnbda}.
        if t>=0 then upower := upower - lambda/m * (24*t + sigmaInfty)

        -- Now make the numerator small.
        den: Z := 24 * denom upower -- den-th root of unity
        upower := positiveRemainder(numer upower, den) / den

        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minimalSquareRootOfUnity(p)$QETAAUX)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [mm, divs, r, m, t, lambda, gamma, eta, rat, upower, qexponent, minroot]

    etaQuotient(mm: P, r: LZ, m: P, t: Z, lambda: N, gamma: SL2Z): % ==
        divs: LP := DIVISORS mm
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in divs repeat
            YSEDLG ==> SymbolicSiftedEtaDeltaLambdaGamma
            eta.delta := eta(mm, delta, m, lambda, gamma)$YSEDLG
        etaquot(mm, divs, r, m, t, lambda, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    elt(x: %, delta: P): SymbolicSiftedEtaDeltaLambdaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): Z == xx.foffset
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    qExponent(x: %): Q == xx.fqExponent
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaQuotientGamma}
\label{sec:SymbolicSiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $g_{r,m,t}(\gamma\tau)$ as well as
$g_{r,m}(\gamma\tau)$.

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{-1, 0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaQuotientGamma} represent the collection
\code{SymbolicSiftedEtaQuotientLambdaGamma} for each $\lambda \in
\Set{0,\ldots,m-1}$ and thus corresponds to the data from
\eqref{eq:g_r-m-t(gamma*tau)}, \ie, it computes the building
blocks for $g_{r,m,t}(\gamma\tau)$ and for $t=-1$ the building blocks
of $g_{r,m}=U_mg_r$.

)endif
-------------------------------------------------------------------
)abbrev domain YSETAQG SymbolicSiftedEtaQuotientGamma
++ SymbolicSiftedEtaQuotientGamma is a generalization of
++ SymbolicEtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of $g_{r,m,t}(\gamma \tau)$ or $g_{r,m}(\gamma \tau)$.
++ See \eqref{eq:g_r-m-t(gamma*tau)} and \eqref{eq:g_r-m(gamma*tau)}.
SymbolicSiftedEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, Z, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the
      ++ expansion of $g_{r,m,t}(\gamma \tau)$ where $r$ is indexed
      ++ by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were
      ++ given at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> Z
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaQuotient(...,gamma).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.lambda) for lambda in 0..m-1].
    elt: (%, N) -> SymbolicSiftedEtaQuotientLambdaGamma
      ++ x.lambda returns the data corresponding to the respective
      ++ lambda.
 == add
    A ==> IndexedOneDimensionalArray(SymbolicSiftedEtaQuotientLambdaGamma, 0)
    Rep ==> Record(
              feta: A,    -- mapping lambda to \eta_{\delta,m,lambda}
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep

    etaQuotient(mm: P, r: LZ, m: P, t: Z, gamma: SL2Z): % ==
        e: SymbolicSiftedEtaQuotientLambdaGamma :=
            etaQuotient(mm, r, m, t, 0, gamma)
        minroot: P := minimalRootOfUnity e
        eta: A := new(m, e) -- fill with dummy values
        for lambda in 1..m-1 repeat -- can start with 1.
            e := etaQuotient(mm, r, m, t, lambda, gamma)
            minroot := lcmP(minroot, minimalRootOfUnity e)
            eta.lambda := e
        per [eta, minroot]

    elt(x: %, lambda: N): SymbolicSiftedEtaQuotientLambdaGamma ==
        rep(x).feta.lambda
    level(x: %): P == level(x.0)
    divisors(x: %): LP == divisors(x.0)
    exponents(x: %): LZ == exponents(x.0)
    multiplier(x: %): P == multiplier(x.0)
    offset(x: %): Z == offset(x.0)
    gamma(x: %): SL2Z == gamma(x.0)
    minimalRootOfUnity(x: %): P == rep(x).fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, x.0)
    ((x: %) = (y: %)): Boolean == x.0 = y.0


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicSiftedEtaQuotientOrbitProductGamma}
\label{sec:SymbolicSiftedEtaQuotientOrbitProductGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicSiftedEtaQuotientOrbitProductGamma} represent the
collection \code{SymbolicSiftedEtaQuotientGamma}
for each
$t' \in \modularOrbit{r, m, t}$ and thus corresponds to the data from
\eqref{eq:P_r-m-t(gamma*tau)}, \ie, it computes the building blocks
for $P_{r,m,t}(\gamma\tau)$.


)endif

-------------------------------------------------------------------
)abbrev domain YSETAQOG SymbolicSiftedEtaQuotientOrbitProductGamma
++ SymbolicSiftedEtaQuotientOrbitProductGamma
++ holds data to compute an eta quotient
++ expansions of $P_{r, m, t}(\gamma \tau)$.
++ See \eqref{eq:P_r-m-t(gamma*tau)}.}
SymbolicSiftedEtaQuotientOrbitProductGamma: SetCategory with
    etaQuotient: (P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the expansion
      ++ of $P_{r, m, t}(\gamma \tau)$.
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).
    orbit: % -> List N
      ++ orbit(x) returns $\modularOrbit{r, m, t}$ where
      ++ r=exponents(x), m=multiplier(x), t=offset(x).
      ++ See definition of orbit in qetacofactorspace.spad
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in orbit(rhat,m,t)]
      ++ where $rhat = \sum_\delta \delta r_\delta$
    elt: (%, N) -> SymbolicSiftedEtaQuotientGamma
      ++ x.u returns the data corresponding to the respective
      ++ orbit element u.
 == add
    YSETAQG ==> SymbolicSiftedEtaQuotientGamma
    HT ==> XHashTable(N, YSETAQG)
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              forbit: List N,-- \modularOrbit(r, m, t}
              fdata: HT,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        divs: LP := DIVISORS mm
        rhat: Z := 0 -- sigmaInfty
        for delta in divs for rdelta in r repeat rhat := rhat + delta * rdelta
        orb: List N := orbit(rhat, m, t)$QEtaCoFactorSpace
        h: HT := empty()
        minroot: P := 1
        for tt in orb repeat
            e: YSETAQG := etaQuotient(mm, r, m, tt, gamma)
            minroot := lcmP(minroot, minimalRootOfUnity e)
            h.tt := e
        per [mm, divs, r, m, t, gamma, orb, h, minroot]

    elt(x: %, tt: N): YSETAQG == rep(x).fdata.tt
    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    gamma(x: %): SL2Z == xx.fgamma
    orbit(x: %): List N == xx.forbit
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.fgamma = yy.fgamma




)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicModularSiftedEtaQuotientGamma}
\label{sec:SymbolicModularSiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicModularSiftedEtaQuotientGamma} represent the product of
an
$\eta$-quotient cofactor to an element of
\code{SymbolicSiftedEtaQuotientOrbitProductGamma} in order to make the
product a modular function.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie, it
computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YMSETAQG SymbolicModularSiftedEtaQuotientGamma
++ SymbolicModularSiftedEtaQuotientGamma
++ holds data to compute an eta quotient
++ expansions of $F_{s, r, m, t}(\gamma \tau)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)} in this file.
SymbolicModularSiftedEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, gamma) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    coFactor: % -> SymbolicSiftedEtaQuotientGamma
      ++ coFactor(x) returns the coFactor part to make $F_{s,r,m,t}$ a
      ++ modular function.
    orbitProduct: % -> SymbolicSiftedEtaQuotientOrbitProductGamma
      ++ orbitProduct(x) returns the orbit product part of $F_{s,r,m,t}$.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in orbit(rhat,m,t)].
 == add
    Rep ==> Record(
              fcoetaqg: SymbolicSiftedEtaQuotientGamma,
              fseqopg: SymbolicSiftedEtaQuotientOrbitProductGamma,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        not modularGamma0?(nn, s, mm, r, m, t)$QEtaCoFactorSpace =>
            error "modular conditions are not fulfilled"
        nndivs: LP := DIVISORS nn
        mmdivs: LP := DIVISORS mm
        coetaqg: SymbolicSiftedEtaQuotientGamma :=
            etaQuotient(nn, s, 1, 0, gamma)
        seqopg: SymbolicSiftedEtaQuotientOrbitProductGamma :=
            etaQuotient(mm, r, m, t, gamma)
        minR1: P := minimalRootOfUnity coetaqg
        minR2: P := minimalRootOfUnity seqopg
        per [coetaqg, seqopg, lcmP(minR1, minR2)]

    coFactor(x: %): SymbolicSiftedEtaQuotientGamma == xx.fcoetaqg
    orbitProduct(x: %): SymbolicSiftedEtaQuotientOrbitProductGamma == xx.fseqopg
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fcoetaqg)
        h := hashUpdate!(h, xx.fseqopg)
        h

    ((x: %) = (y: %)): Boolean ==
        (xx.fcoetaqg = yy.fcoetaqg) and (xx.fseqopg = yy.fseqopg)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SymbolicModularSiftedEtaQuotient}
\label{sec:SymbolicModularSiftedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$, elements from the domain
\code{SymbolicModularSiftedEtaQuotient} represent the collection of
element from \code{SymbolicSiftedEtaQuotienGamma} for all $\gamma \in
\SL2Z$ corresponding to a cusp of $\Gamma_0(N)$.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie,
it computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YMSETAQ SymbolicModularSiftedEtaQuotient
++ SymbolicModularSiftedEtaQuotient holds data to compute an eta
++ quotient expansions of $F_{s, r, m, t}(\gamma \tau)$ at all cusps
++ of $Gamma_0(N)$. See \eqref{eq:F_s-r-m-t(gamma*tau)}.
SymbolicModularSiftedEtaQuotient: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, LQ) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, cusps) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$ for all gamma corresponding to
      ++ the given cusps.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    etaQuotient: (P, LZ, P, LZ, P, N) -> %
      ++ etaQuotient(nn, s, mm, r, m, t) represents the expansion of
      ++ $F_{r,s,m,t}(\gamma \tau)$ for all gamma corresponding to the
      ++ cusps of $\Gamma_0(nn)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    cusps: % -> LQ
      ++ cusps(x) either returns the value that was given to
      ++ etaQuotient at creation time or cusps(level
      ++ x)$CongruenceSubgroupGamma0 if the cusps where not given.
    elt: (%, Q) -> SymbolicModularSiftedEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in cusps x].
 == add
    YMSETAQG ==> SymbolicModularSiftedEtaQuotientGamma
    HT ==> XHashTable(Q, YMSETAQG)
    Rep ==> Record(
              flevel: P,  -- corresponds to Gamma_0(N)
              fcusps: LQ, -- cusps of Gamma_0(N)
              fmseq: HT,  -- mapping gamma to YMSETAQG
              fminroot: P -- minimal root of unity needed for the coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, cusps: LQ): % ==
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(nn, cusp)$GAMMA0
            e: YMSETAQG := etaQuotient(nn, s, mm, r, m, t, gamma)
            h.cusp := e
            minroot := lcmP(minroot, minimalRootOfUnity e)
        per [nn, cusps, h, minroot]

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): % ==
        etaQuotient(nn, s, mm, r, m, t, cusps(nn)$GAMMA0)

    level(x: %): P == xx.flevel
    elt(x: %, cusp: Q): YMSETAQG == xx.fmseq.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot
    cusps(x: %): LQ == xx.fcusps

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.fmseq)
    ((x: %) = (y: %)): Boolean == xx.fmseq = yy.fmseq













)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domains involving Puiseux series}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following domains compute actual series from the data provided by
the ``symbolic'' domains from above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D EtaQuotientGamma}
\label{sec:EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, and \code{y = etaQuotient(N, r, gamma)} and
\code{e = etaQuotient(y)}, then $e$ represents the tuple
\begin{gather}
  \left(
  \underbrace{y}_{\texttt{symbolicEtaQuotient}}
  ,
  \underbrace{\divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  }_{\texttt{leadingCoefficient}}
  ,
  \underbrace{\divisorprod{N}\prod_{n=1}^{\infty}
    (1-\unityPower{n v_\delta} x^{n e_\delta})^{r_\delta}
  }_{\texttt{series}}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:modular-g_r(gamma*tau)} with
$x=\unityPower{\frac{\tau}{w_\gamma}}$ where $w_\gamma$ is given by
\eqref{eq:width0}.


)endif
-------------------------------------------------------------------
)abbrev domain ETAQG EtaQuotientGamma
++ EtaQuotientGamma(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotient expansions at gamma.
++ The eta quotient need not be a modular function, but the (c*tau+d)
++ factor is always ignored.
EtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: SymbolicEtaQuotientGamma -> %
      ++ coerce(s) represents the expansion of
      ++ g_r(\gamma \tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c),
      ++ r = exponents(s), and g_r is defined by
      ++ $g_r(\tau) =
      ++   \prod_{\delta in divisors(s)} \eta(\delta \gamma \tau)^{r_{\delta}}$.
    eulerFunctionPower: (P, N, Z) -> LX
      ++ eulerFunctionPower(u, v, p) computes eulerFunction(1)^p and
      ++ replaces q=monomial(1,1)$LC by monomial(xi^v, u)$LX
    symbolicEtaQuotient: % -> SymbolicEtaQuotientGamma
      ++ symbolicEtaQuotient(x) returns meta-data corresponding to x.
    eulerExpansion: % -> LX
      ++ eulerExpansion(e) returns the series expansion of e without
      ++ any prefactor.
      ++ The true series expansion (in terms of fractional x powers of e
      ++ is given by lc * x^p * s where
      ++ lc = leadingCoefficient e,
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c),
      ++ y = symbolicEtaQuotient e,
      ++ c = gamma(y)(2,1),
      ++ p = (xExponent y) / 24,
      ++ s = eulerExpansion e.
    expansion: % -> LX
      ++ expansion(e) should only be called if modularGamma0?(e) holds,
      ++ otherwise it might return an error.
      ++ expansion(e) returns the series expansion of e in terms of
      ++ x = \exp(2 \pi i \tau/w) where w=width(m, c),
      ++ c = gamma(symbolicEtaQuotient e)(2,1).
    leadingCoefficient: % -> CX
      ++ leadingCoefficient(x) returns the coefficient corresponding
      ++ to the smallest q-power with non-zero coefficient.
    modularGamma0?: % -> Boolean
      ++ modularGamma0?(x) returns true if the eta quotient is a
      ++ modular function for Gamma0(nn) where
      ++ nn=level(symbolicEtaQuotient x).

    --TODO: The following function should live somewhere else.
    substitute: (LX, P, N) -> LX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

  Implementation ==> add
    Rep ==> Record(fsymetaquo: SymbolicEtaQuotientGamma, lc: CX, ser: LX)
    -- The true series expansion of e is given by c * x^p * s where
    -- c = leadingCoefficient e
    -- x = \exp(2 \pi i \tau/w) where w=width(m, c)
    -- p = (xExponent symbolicEtaQuotient e) / 24
    -- s = eulerExpansion e
    xx ==> rep x
    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

    xiPower(v: N): (Z -> CX) == (e: Z): CX +->
         -- Take care of the fact that xi^mx = 1.
        e := positiveRemainder(v*e, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: P, v: N): LX ==
        multiplyExponents(multiplyCoefficients(xiPower v, s), u)

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        zero? rd => 1$LX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    coerce(e: SymbolicEtaQuotientGamma): % ==
        m: P := level e
        divs: LP := divisors e
        s: LX := 1
        for delta in divs for rd in exponents e | not zero? rd repeat
            etadelta: SymbolicEtaDeltaGamma := e.delta
            u: P := edelta(etadelta)
            v: N := asN numer(mx * vdelta(etadelta))
            s := s * eulerFunctionPower(u, v, rd)
        q: Q := mx * unityPower e
        if not one? denom q then
            error "EtaQuotientGamma: denominator does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor e -- leading coefficient
        per [e, cx, s]

    symbolicEtaQuotient(x: %): SymbolicEtaQuotientGamma == xx.fsymetaquo
    leadingCoefficient(x: %): CX == xx.lc
    eulerExpansion(x: %): LX == xx.ser
    expansion(x: %): LX ==
        lc: CX := leadingCoefficient x
        y: SymbolicEtaQuotientGamma := symbolicEtaQuotient x
        ord: Z := (xExponent(y) exquo 24)::Z -- order of series
        monomial(lc, ord)$LX * eulerExpansion x

    modularGamma0?(x: %): Boolean == modularGamma0? symbolicEtaQuotient x

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean == symbolicEtaQuotient x = symbolicEtaQuotient y

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D ModularEtaQuotient}
\label{sec:ModularEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R^*(N)$, and \code{e = etaQuotient(N, r)}, then
$e$ represents the information given in
\eqref{eq:modular-g_r(gamma*tau)}
for each cusp $\frac{a}{c}$ of $\Gamma_0(N)$.


)endif
)abbrev domain METAQ ModularEtaQuotient
++ ModularEtaQuotient(C, mx, CX, xi, LX) represents the set
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
ModularEtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  YETAQ ==> SymbolicEtaQuotient
  Exports ==> SetCategory with
    --assert(one? xi^mx)
    coerce: YETAQ -> %
      ++ coerce(y) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(level y).
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ level(x) returns m such that x corresponds to a modular
      ++ function for Gamma_0(m).
    symbolicEtaQuotient: % -> YETAQ
      ++ symbolicEtaQuotient(x) returns the meta data corresponding to x.
      ++ If x=etaQuotient(y) then symbolicEtaQuotient(x)=y.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $g_r(tau)$ at all cusps of Gamma_0(level x) corresponding to
      ++ cusps(symbolicEtaQuotient x).
  Implementation ==> add
    Rep ==> Record(meta: YETAQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: YETAQ): % ==
        m: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(m, exponents y)$QETAAUX then
            dbgPrint("METAQ coerce: not a modular function", exponents y)
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            ye: SymbolicEtaQuotientGamma := y.cusp
            e := ye :: EtaQuotientGamma(C, mx, CX, xi)
            hser.cusp := expansion e
        per [y, hser]
    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        (etaQuotient(mm, r, cusps)$YETAQ)::%
    etaQuotient(mm: P, r: LZ): % == (etaQuotient(mm, r)$YETAQ)::%
    level(x: %): P == level(xx.meta)
    symbolicEtaQuotient(x: %): YETAQ == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        symbolicEtaQuotient x = symbolicEtaQuotient y


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D SiftedEtaQuotientGamma}
\label{sec:SiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{SiftedEtaQuotientGamma} represents the Puiseux series
expansion of various eta quotients.
)endif

-------------------------------------------------------------------
)abbrev domain SETAQG SiftedEtaQuotientGamma
++ SiftedEtaQuotientGamma is a generalization of
++ EtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of $g_{r,m,t,\lambda}(\gamma \tau)$,
++ $g_{r,m,t}(\gamma \tau)$, $F_{s,r,m,t}(\gamma \tau)$.
++ See \eqref{eq:g_r-m-t-lambda(gamma*tau)}.}
++ This Domain behaves partly like univariate Puiseux series.
SiftedEtaQuotientGamma(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseux: (SymbolicSiftedEtaQuotientLambdaGamma, P) -> %
      ++ puiseux(y, w) represents the
      ++ q-expansion of g_{r,m,t,\lambda}(\gamma \tau) at \tau=i \infity.
    puiseux: (SymbolicSiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $g_{r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    puiseux: (SymbolicSiftedEtaQuotientOrbitProductGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $\prod_{t' \in \modularOrbit{r,m,t}} g_{r,m,t}(\gamma \tau)$
      ++ at $\tau=i \infity$.
    puiseux: (SymbolicModularSiftedEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at $\tau=i \infity$.
    rationalPowerDenominator: % -> P
      ++ If k=order(x) and f=qetaTaylorRep(x) then,
      ++ rationalPowerDenominator(x) returns w such that
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    qetaTaylorRep: % -> TX
      ++ qetaTaylorRep(x) returns the Taylor series representation f of x
      ++ without the prefactor corresponding to $(c \tau + d)$
      ++ If w=rationalPowerDenominator(x) and k=order(x) then
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    order: % -> Q
      ++ If w=rationalPowerDenominator(x) and f=qetaTaylorRep(x) then
      ++ order(x) returns k such that x(q)=z^(k)*f(z) with z=q^(1/w).
      ++ order(x) returns the order o
    laurent: % -> LX
      ++ If order(x) is an integer, then laurent(x) returns the
      ++ Laurent series f of x without the prefactor corresponding to
      ++ $(c \tau + d)$ such that x(q) = f(z) for z=q^(1/w) where
      ++ w=rationalPowerDenominator(x). It is an error if order(x) is
      ++ not an integer.
  Implementation ==> add
    -- If x: % and s = rep(x).ser, d = rep(x).den, then x represents
    -- the series s(q^(1/d)).
    Rep ==> Record(den: P, ord: Q, ser: TX)
    xx ==> rep x

    import from EtaQuotientGamma(C, mx, CX, xi)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    rationalPowerDenominator(x: %): P == xx.den
    order(x: %): Q == xx.ord
    qetaTaylorRep(x: %): TX == xx.ser
    laurent(x: %): LX ==
        ord: Q := order x
        not one? denom ord =>
            error "SETAQG: Laurent series with fractional exponent"
        laurent(numer ord, qetaTaylorRep x)$LX
    coerce(x: %): OutputForm == xx::OutputForm

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,t,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-t-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicSiftedEtaQuotientLambdaGamma, w: P): % ==
        -- w=width
        mm: P := level y
        divs: LP := divisors y
        m: P := multiplier y
        d: P := 24*m*w
        s: LX := 1
        for delta in divs for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicSiftedEtaDeltaLambdaGamma := y.delta
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "SiftedEtaQuotientGamma: denominator does not vanish"
            v: N := asN numer(mx * vdelta(etadelta))
            s := s * eulerFunctionPower(asP numer u, v, rd)
        q: Q := mx * unityPower y
        not one? denom q =>
            dbgPrint("mx * unityPower y", q)
            error "SiftedEtaQuotientGamma: denominator for xi does not vanish"
        n: N := asN positiveRemainder(numer q, mx)
        cx: CX := xi^n * squareRoot rationalPrefactor y -- leading coefficient
        p: Q := d/24 * qExponent y -- the "/24" is missing from qExponent(y)
        not one? denom p =>
            error "SiftedEtaQuotientGamma: denominator for q does not vanish"
        tx: TX := cx * qetaTaylorRep s
        per [d, p, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{SiftedEtaQuotientGamma}
represents the series expansion of
\begin{gather*}
  g_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,t,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    puiseux(y: SymbolicSiftedEtaQuotientGamma, w: P): % ==
        m: P := multiplier y
        lx: LX := 0
        m1: P := asP(m::Z - 1)
        for lambda in 0..m1 repeat lx := lx + laurent puiseux(y.lambda, w)
        -- A sifted version of an eta-quotient is a non-zero function.
        -- Thus, we can safely remove initial zeroes.
        --TODO: WARNING: The above is not true.
        -- Try findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)
        lx: LX := removeZeroes(lx)$LX
        -- And, it is safe to ask for the order of the series expansion.
        ord: Z := order lx
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        tx: TX := qetaTaylorRep lx
        stx: Stream CX := coefficients tx
        for i in 1..m1 repeat
            stx := rest stx
            if not zero? first stx then
                dbgPrint("YSEQG c", first stx)
                dbgPrint("Laurent expansion", lx)
                error "SiftedEtaQuotientGamma: m-lambda sum"
        tx := (1/m)$Q::C::CX * multisect(m, 0, tx)
        per [24 * w, ord/m, tx]

    puiseux(y: SymbolicSiftedEtaQuotientOrbitProductGamma, w: P): % ==
        orb := orbit y
        t: N := first orb;
        px: % := puiseux(y.t, w)
        d: P := rationalPowerDenominator px
        tx: TX := qetaTaylorRep px
        ord: Q := order px
        for k in rest orb repeat
            px: % := puiseux(y.k, w)
            tx := tx * qetaTaylorRep px
            ord := ord + order px
        not one? denom ord =>
            error "SiftedEtaQuotientGamma: orbit product: denominator for q does not vanish"
        per [d, ord, tx]

    puiseux(y: SymbolicModularSiftedEtaQuotientGamma, w: P): % ==
        yc: SymbolicSiftedEtaQuotientGamma := coFactor y
        yo: SymbolicSiftedEtaQuotientOrbitProductGamma := orbitProduct y
        pc: % := puiseux(yc, w)
        po: % := puiseux(yo, w)
        d: P := rationalPowerDenominator pc
        -- Sanity check.
        d ~= 24 * w =>
            error "SiftedEtaQuotientGamma: Puiseux expansion in wrong variable"
        rationalPowerDenominator pc ~= rationalPowerDenominator po =>
            error "SiftedEtaQuotientGamma: expansion in different variables"
        tx: TX := multisect(24, 0, qetaTaylorRep pc * qetaTaylorRep po)
        ord: Q := order pc + order po
        ord := ord * (1$Z/24)-- It's a modular function.
        not one? denom ord =>
            error "SiftedEtaQuotientGamma: modular: denominator for q does not vanish"
        per [w, ord, tx]

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{D ModularSiftedEtaQuotient}
\label{sec:ModularSiftedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{ModularSiftedEtaQuotient} represents the Puiseux
series expansion of various eta quotients.

)endif

-------------------------------------------------------------------
)abbrev domain MSETAQ ModularSiftedEtaQuotient
++ ModularSiftedEtaQuotient is a generalization of
++ ModularEtaQuotient. It holds the expansions
++ of F_{s,r,m,t}(\tau) at all cusps of $\Gamma_0(N)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)}.
++ The domain serves as the representation of the underlying q-series.
ModularSiftedEtaQuotient(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  Exports ==> SetCategory with
    coerce: SymbolicModularSiftedEtaQuotient -> %
      ++ coerce(y) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$ at all cusps of $\Gamma_0(N)$ where
      ++ N=level(y).
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    metadata: % -> SymbolicModularSiftedEtaQuotient
      ++ metadata(x) returns y such that coerce(y) = x.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of
      ++ $F_{s,r,m,t}(tau)$ at all cusps of Gamma_0(N).

  Implementation ==> add
    YMSETAQ ==> SymbolicModularSiftedEtaQuotient
    Rep ==> Record(meta: YMSETAQ, ser: XHashTable(Q, LX))
    xx ==> rep x

    coerce(y: SymbolicModularSiftedEtaQuotient): % ==
        PX ==> SiftedEtaQuotientGamma(C, mx, CX, xi)
        import from PX
        nn: P := level y
        hser: XHashTable(Q, LX) := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurent puiseux(y.cusp, w)
        per [y, hser]
    level(x: %): P == level(xx.meta)
    metadata(x: %): SymbolicModularSiftedEtaQuotient == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.meta)
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the symbolic data
        metadata x = metadata y

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0}
\label{sec:QEtaModularGamma0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta quotient
in order to make it a modular function having a pole only at infinity
or to make the (positive) orders at all cusps (\code{qetaGrades})
small in total sum.

)endif

)abbrev package QETAMG0 QEtaModularGamma0
QEtaModularGamma0: Exports == Implementation where
  Exports ==> with
    qetaGrades: SymbolicModularSiftedEtaQuotient -> XHashTable(Q, Z)
      ++ qetaGrades(y) returns the qetaGrades of the modular
      ++ function corresponding to y.
    qetaGrades: (P, LZ, P, LZ, P, N) -> XHashTable(Q, Z)
      ++ qetaGrades(nn, s, mm, r, m, t) returns
      ++ qetaGrades(y) where
      ++ y=etaQuotient(nn, s, mm, r, m, t)$SymbolicModularSiftedEtaQuotient.
    etaCoFactorInfinity: (P, P, LZ, P, N) -> LZ
      ++ etaCoFactorInfinity(nn,mm,r,m,t) returns a list s such that
      ++ modularGamma0?(nn,s,mm,r,m,t)$QEtaCoFactorSpace and
      ++ etaQuotient(nn,r,mm,s,m,t)$SymbolicModularSiftedEtaQuotient
      ++ corresponds to a modular function with poles only at infinity
      ++ and with smallest pole order.

  Implementation ==> add
    LVZ ==> List VZ
    ZRESULT ==> Record(zinhom: LVZ, zhom: LVZ, zfree: LVZ) -- zsolve$X4ti2
    ECFS ==>  Record(particular: Union(VZ, "failed"), basis: List VZ)
    C ==> Q
    lift2C x ==> map(coerce, x)$SparseUnivariatePolynomialFunctions2(Z, C)
    SUPC ==> SparseUnivariatePolynomial C
    CX ==> SimpleAlgebraicExtension(C, SUPC, supc)
    TX ==> QEtaTaylorSeries CX
    LX ==> QEtaLaurentSeries CX
    YMSETAQ ==> SymbolicModularSiftedEtaQuotient
    MSETAQ ==> ModularSiftedEtaQuotient(C, mx, CX, xi)
    a ==> aLigozat $ QETAAUX

    -- order of eta^r at cusp a/c.
    grade(nn: P, divs: LP, c: Z, r: LZ): Z ==
        l: LZ := [rdelta * a(nn, c, delta) for delta in divs for rdelta in r]
        -(reduce(_+, l, 0) exquo 24)::Z

    -- orders at cusps of Gamma0(nn) different from infinity
    grades(nn: P, divs: LP, cusps: LQ, r: LZ): LZ ==
        [grade(nn, divs, denom cusp, r) for cusp in cusps]

    qetaGrades(y: YMSETAQ): XHashTable(Q, Z) ==
        mx: P := minimalRootOfUnity y
        supc: SUPC := lift2C(cyclotomic(mx)$CyclotomicPolynomialPackage);
        xi := generator()$CX;
        xsym: Symbol := "x"::Symbol;
        msetaq := y::MSETAQ
        e: XHashTable(Q, LX) := expansions(msetaq)
        ht: XHashTable(Q, Z) := empty()
        for cusp in keys e repeat ht.cusp := -order(e.cusp)
        ht

    qetaGrades(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): XHashTable(Q, Z) ==
        y: YMSETAQ := etaQuotient(nn, s, mm, r, m, t);
        qetaGrades y


    -- local function
    -- By adding interger multiples of elements of b we try to
    -- make the length of sinitial as small as possible in a cheap way.
    -- It is not completely necessary to find the minimal vector, since
    -- there is a second optimization step in minimalGrades that makes
    -- the order at the cusps relatively small.
    -- We try to achieve small length by a simple algorithm.
    --
    -- Let b be a vector of bas. Compute v1:=v+b, v2:=v-b. If v1 is
    -- strictly shorter than v, then set v to v1 and iterate. Similar
    -- if v2 is strictly shorter. If neither v1 nor v2 are not
    -- strictly shorter than v continue with the next vector from bas.
    minimizeVector(v: VZ, basis: LVZ): VZ ==
        empty? basis => v
        reduced?: Boolean := true -- to start the loop
        lv := dot(v, v)
        while reduced? repeat
            bas := basis
            reduced? := false
            while not empty? bas and not reduced? repeat
                b := first bas
                bas := rest bas
                u := v + b
                while (lu := dot(u, u)) < lv repeat
                    lv := lu
                    v := u
                    u := v + b
                    reduced? := true
                reduced? => break
                u := v - b
                while (lu := dot(u, u)) < lv repeat
                    lv := lu
                    v := u
                    u := v - b
                    reduced? := true
        v


    -- local function
    -- It might happen that the particular solution of etaCoFactorSpace
    -- has entries that are very big. That would lead to a very heavy
    -- computation when we determine the grades of the respective
    -- eta-quotient at all cusps. We therefore try to "reduce" the vector
    -- by elements of the basis such that the length of the vector becomes
    -- small.
    -- Here we do it by applying the LLL algorithm and trying to reconstruct
    -- a relavtively small vector s such that s = r + dot(c, bas) for some
    -- integer vector c.
    minimizeVectorLLL(rinitial: VZ, b: LVZ): VZ ==
        -- The rinitial vector might have very big numbers in it. We
        -- make them smaller by applying LLL to the system.
        -- Note that the elements of b correspond to exponent vectors that
        -- yield eta-quotients that are modular functions.
        mat: MZ := matrix cons(members rinitial, [members v for v in b])
        el: Record(lll: MZ, trf: MZ) := extendedLLL(mat)$LLLReduction
        -- Now look for 1 or -1 in the first entry of the transformation
        -- matrix.
        tmat: MZ := el.trf
        z: Z := 0
        i: N := 1
        n: N := nrows(tmat)
        while i <= n and not one? abs(z := tmat(i, 1)) repeat i := i+1
        one? abs z => z*row(tmat, i)*mat

        -- Here we were unlucky. No 1 or -1 in the first component found.
        -- Thus we try to construct a 1 by successive gcd computation.
        i := 1
        while i <= n and zero?(z := tmat(i, 1)) repeat i := i + 1
        i > n => rinitial
        -- We know that there is no 1 or -1 in the first position, so
        -- abs(tmat(i, 1)) is not equal to one. If i=n then we have no
        -- chance to change that into a 1.
        i = n => rinitial

        v: VZ := row(tmat, i)
        i := i + 1
        CCG ==> Record(coef1: Z, coef2: Z, generator: Z)
        while i <= n and not one? z repeat
            ccg: CCG := extendedEuclidean(z, tmat(i, 1))
            v := ccg(coef1) * v + ccg(coef2) * row(tmat, i)
            z := ccg.generator
            i := i + 1
        one? z => v*mat
        rinitial


    -- local function
    -- What actually counts is that the grade of eta-quotient corresponding
    -- to sinitial is small.
    -- The initial minimizeVector is only here, because the computation of
    -- qetaGrades involves the actual computation of the Laurent series
    -- expansion of the respective eta-quotient at all cusps. So we
    -- shouldn't have too high exponents.
    minimizeGrades(nn: P, mm: P, r: LZ, m: P, t: N, rinitial: VZ, b: LVZ): LZ ==
        sinitial := minimizeVector(rinitial, b)
        -- Compute the poleorders/grades (at all cusps)for the
        -- particular solution rinitial.
        g: XHashTable(Q, Z) := qetaGrades(nn, members sinitial, mm, r, m, t);
        -- Exclude order at the cusp infinity.
        cusps: LQ := [cusp for cusp in cusps(nn)$GAMMA0 | cusp~=1/nn]
        rhs: LZ := [g.cusp for cusp in cusps]

        -- For the vectors in the basis, we don't need to compute the
        -- series explicitly, since these vectors correspond to
        -- modular eta quotients and thus we can use the matrix of
        -- Ligozat to compute the order vectors.
        nndivs: List P := DIVISORS nn
        bas: List LZ := [grades(nn, nndivs, cusps, members r) for r in b]
        mat: MZ := transpose matrix bas
        rels: VZ := vector [1 for x in 1..#cusps]
        zresult: ZRESULT := zsolve(mat, rels, vector rhs)$X4ti2
        adjustment := members first zresult.zinhom
        members(sinitial - reduce(_+, [x*bb for x in adjustment for bb in b]))

    etaCoFactorInfinity(nn: P, mm: P, r: LZ, m: P, t: N): LZ ==
        ecfs: ECFS := etaCoFactorSpace(nn, mm, r, m, t)$QEtaCoFactorSpace
        n: Z := numberOfDivisors(nn)$IntegerNumberTheoryFunctions
        sinitial: VZ := ((ecfs.particular)::VZ)(1..n)
        b: LVZ := [x(1..n) for x in ecfs.basis]
        members minimizeGrades(nn, mm, r, m, t, sinitial, b)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0Infinity}
\label{sec:QEtaModularGamma0Infinity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta quotient
in order to make it a modular function having a pole only at infinity
or to make the (positive) orders at all cusps (\code{qetaGrades})
small in total sum.

)endif

)abbrev package QETAMG0I QEtaModularGamma0Infinity
QEtaModularGamma0Infinity(C: IntegralDomain): Exports == Implementation where
  T1 C  ==> QEtaTaylorSeries C
  L1 C  ==> QEtaLaurentSeries C
  A1 C ==> Finite0Series C
  ETAQI C  ==> EtaQuotientInfinity C
  Exports ==> with
    modularSiftedEtaQuotientInfinity: (P, LZ, P, LZ, P, N) -> A1 C
      ++ modularSiftedEtaQuotientInfinity(nn, s, mm, r, m, t) returns
      ++ the series expansion of
      ++ etaQuotient(nn,s,mm,r,m,t)$SymbolicModularSiftedEtaQuotient
      ++ at the cusp infinity.
    modularSiftedEtaQuotientInfinity: (P, P, LZ, P, N) -> A1 C
      ++ modularSiftedEtaQuotientInfinity(nn, mm, r, m, t) returns
      ++ modularSiftedEtaQuotientInfinity(nn, s, mm, r, m, t) for s
      ++ equal to etaCoFactorInfinity(nn, mm, r, m, t).
  Implementation ==> add
    -- generating series for a(m*n+t) with cofactor eta quotient and
    -- the fractional q power where \sum_{k=0}^\infty a(k)q^k is
    -- defined by an eta-quotient with exponent vector r.

    modularSiftedEtaQuotientInfinity(nn:P, s:LZ, mm:P, r:LZ, m:P, t:N): A1 C ==
        -- First compute the expansion of the orbit product.
        eulerquo: T1 C := qetaTaylorRep(eulerExpansion(mm, r)$ETAQI(C))

        orb: List N := orbit(mm, r, m, t)$QEtaCoFactorSpace
        tt := first orb
        p: T1 C := multisect(m-tt, tt, eulerquo)
        -- Now multiply the series selecting sum_{n=0}^\infty a(m*n+k)q^n.
        for k in rest orb repeat p := p * multisect(m-k, k, eulerquo)

        -- The expansion of the coFactor is here.
        -- We take care of the right q-order through alphaInfinity.
        cofact: T1 C := qetaTaylorRep(eulerExpansion(nn, s)$ETAQI(C))

        -- We multiply both things together to get (nearly) a modular
        -- function.
        tf: T1 C := cofact * p

        -- We have to multiply by some q-power to get the expansion of
        -- a modular function f.
        alpha: Z := alphaInfinity(nn, s, mm, r, m, t)$QEtaCoFactorSpace
        laurent(alpha, tf)$A1(C)

    modularSiftedEtaQuotientInfinity(nn: P, mm: P, r: LZ, m: P, t: N): A1 C ==
        orb: List N := orbit(mm, r, m, t)$QEtaCoFactorSpace
        tracePrint("orbit", sort orb)
        s: List Z := etaCoFactorInfinity(nn, mm, r, m, t)$QEtaModularGamma0
        tracePrint("cofactor", s)
        modularSiftedEtaQuotientInfinity(nn, s, mm, r, m, t)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularFunctionExpansionsAtCusps}
\label{sec:ModularFunctionExpansionsAtCusps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $s\in R(N)$, and \code{e = etaQuotient(N, s)}, \code{v
  = coerce(expansions e)} then $v$ represents the vector of Laurent
expansions of an eta quotient (corresponding to $s$) at the cusps of
$\Gamma_0(N)$ given in the argument of the constructor.
It is assumed that the corresponding modular function has only poles
at these cusps.
%
These vectors form an algebra that similar to
\code{Finite0Series} have a finite zero test. A vector $v$ is zero, if
\code{qetaGrade(v, k)} is smaller than 0 for all indices $k$ from 1 to
$n$ where $n$ is the number of cusps of the given cusps.

)endif

)abbrev domain MODFUNC ModularFunctionExpansionsAtCusps
++ ModularFunctionExpansionsAtCusps(C, L, cusps) represents the
++ algebra of eta quotients that are modular functions for a certain
++ Gamma_0(m) and have only poles at the given cusps.
ModularFunctionExpansionsAtCusps(C, cusps): Exports == Implementation
 where
  C: IntegralDomain
  L ==> QEtaLaurentSeries C
  cusps: LQ
  Exports ==> XEtaGradedAlgebra C with
    coerce: XHashTable(Q, L) -> %
      ++ If t is a hashtable containing (for each cusp of Gamma_0(m)
      ++ the series expansions at the cusps, then etaQuotient(t) creates
      ++ a data structure that can be used for computations.
    series: (%, P) -> L
      ++ series(x, n) returns the series corresponding to the n-th index.
      ++ Indices can run from 1 to maxIndex().
  Implementation ==> add
    ncusps: P := asP(#cusps)
    Rep ==> DirectProduct(ncusps, L)
    xx ==> rep x
    yy ==> rep y

    coerce(t: XHashTable(Q, L)): % ==
        -- sanity check
        # (cs := keys t) ~= ncusps or sort cs ~= sort cusps =>
            error "keys do not agree with cusps of this domain"
        per directProduct vector [t.c for c in cusps]

    coerce(x: %): OutputForm == xx::OutputForm
    0: % == per(0$Rep)
    1: % == per(1$Rep)
    zero?(x: %): Boolean ==
        for kn in 1..ncusps repeat
            k: P := asP kn
            qetaGrade(x, k, 0) > 0 => return false
            not zero? xx.k.0 => return false
        return true

    _-(x: %): % == per(- xx)
    ((x: %) + (y: %)): % == per(xx + yy)
    ((x: %) - (y: %)): % == per(xx - yy)
    ((x: %) * (y: %)): % == per(xx * yy)
    ((c: C) * (x: %)): % == per map((s: L): L +-> c * s, xx)
    ((x: %) ^ (n: N)): % == per map((s: L): L +-> s^n, xx)
    maxIndex(): P == ncusps
    qetaIndex(x: %): P ==
        --assert(not zero? x) -- therefore for one k qetaGrade(x,k)>=0
        maxGrade: Z := -1 -- dummy value
        idx: N := 0
        for kn in 1 .. ncusps repeat
            k: P := asP kn
            if (mx := qetaGrade(x, k)) > maxGrade then
                maxGrade := mx
                idx: P := k
        return idx
    qetaGrade(x: %, k: P): Z == - order(xx.k)
    qetaGrade(x: %, k: P, mn: Z): Z == - order(xx.k, -mn)
    qetaLeadingCoefficient(x: %, k: P): C == leadingCoefficient(xx.k)
    series(x: %, k: P): L == xx.k
    qetaGrades(x: %): LZ ==
        zero? x => [-1$Z for k in 1..ncusps]
        [qetaGrade(x, asP k) for k in 1..ncusps]
    if C has Field then
        ((x: %) / (y: %)): % ==
            v: Vector L := new(ncusps, 0) -- new vector
            for i in 1..ncusps repeat v.i := xx.i / yy.i
            per(directProduct(v)$Rep)



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D ModularFunctionExpansions}
\label{sec:ModularFunctionExpansions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $s\in R(N)$, and \code{e = etaQuotient(N, s)}, \code{v
  = coerce(expansions e)} then $v$ represents the vector of Laurent
expansions of an eta quotient (corresponding to $s$) at each cusp of
$\Gamma_0(N)$. These vectors form an algebra that similar to
\code{Finite0Series} have a finite zero test. A vector $v$ is zero, if
\code{qetaGrade(v, k)} is smaller than 0 for all indices $k$ from 1 to
$n$ where $n$ is the number of cusps of $\Gamma_0(N)$.

)endif
)abbrev domain MODFUNX ModularFunctionExpansions
++ ModularFunctionExpansions(C, m) represents the algebra of
++ eta quotients that are modular functions for Gamma_0(m).
ModularFunctionExpansions(C, m): Exports == Implementation where
  C: IntegralDomain
  L ==> QEtaLaurentSeries C
  m: P -- level
  Exports ==> XEtaGradedAlgebra C with
    coerce: XHashTable(Q, L) -> %
      ++ If t is a hashtable containing (for each cusp of Gamma_0(m)
      ++ the series expansions at the cusps, then etaQuotient(t) creates
      ++ a data structure that can be used for computations.
    series: (%, P) -> L
      ++ series(x, n) returns the series corresponding to the n-th index.
      ++ Indices can run from 1 to maxIndex().
  cog0 ==> cusps(m)$GAMMA0
  Implementation ==> ModularFunctionExpansionsAtCusps(C, cog0)






















)if LiterateDoc
%$

\begin{Hemmecke}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Stuff for later}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us compare this with \eqref{eq:g_s-m-t(tau)} where we have replaced
$t$ by $t'$ with $t' = t x + \frac{x-1}{24}s+km$ for some
$x\in\setN$ and $k\in\setZ$ such that $0\le t' < m$.
\begin{align}
  g_{s,m,t'}(\tau)
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}
    \Bigl(24\bigl(t x + \frac{x-1}{24}s+km\bigr)+\sumdelta{r}\Bigr)}
  \divisorprod{M}
  \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}.
\end{align}

If we can find some $x\in\setZ$ and $\kappa(r,t)\in\setC$ such that
for every $0\le \lambda<m$
\begin{gather}
  \unityPower{-\frac{\lambda}{24m} (24t + \sumdelta{r})}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
  = \kappa(r, t) \cdot
    \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
\end{gather}

According to
\cite[Thm.~2.14]{Radu:AlgorithmicApproachRamanujanCongruences:2009},
we choose $x=a^2$ and

\begin{gather*}
  \kappa(r,t)
  =
  \beta(\gamma,0) \, \unityPower{\frac{24t+\sumdelta{r}}{24m} ab(1-m^2)}
\end{gather*}

\begin{align*}
  \kappa(r, t)
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m} (\lambda - \lambda_\gamma x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda - ((b + d \lambda) d' - d m b^*) x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda(1 - dd'x) - (b d' - d m b^*) x}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_{\delta,m,\lambda}$ under
  $\Gamma_0(N)\subset \SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's apply the splitting of $W=W'W''$ into a matrix
$W'\in \SL2Z$ and an upper triangular matrix $W''$ as in the
Section~\ref{sec:eta-transformation} and compare with the proof of
Lemma~2.2 of \cite{Radu:AlgorithmicApproachRamanujanCongruences:2009}.

We get
%
$\det(W) = \delta m$, because $\det(\gamma)=1$.

Furthermore,
$h = \gcd(\delta(a + c \lambda), \delta \frac{cm}{\delta})=\delta$,
%
$a' = a + c \lambda$, and
%
$c' = \frac{cm}{\delta}$.
%
From \eqref{eq:delta|M=>delta|mN} and $\divides{N}{c}$ (because
$\gamma \in \Gamma_0(N)$) follows $\divides{\delta}{mc}$ and
$c'\in \setZ$.

Note that $\gcd(a,c)=1$. Thus $\gcd(a + c \lambda, c)=1$ and because of
$\divides{N}{c}$,
% ($\gamma \in \Gamma_0(N)$)
it follows $\gcd(a + c \lambda, N)=1$.
%
Then \eqref{eq:p|m=>p|N} implies $\gcd(a + c \lambda, m)=1$.
%
Therefore $\gcd(a + c \lambda, cm)=1$ and we can find $b^*$ and $d'$ such
that $(a + c \lambda) d' - b^* cm =1$. It also holds $\gcd(a', c')=1$ and we
can choose $b'=\delta b^*$ such that $\det(W')=1$ for
\begin{gather}
  W'= \begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  = \begin{pmatrix}a+c \lambda& \delta b^*\\cm/\delta&d'\end{pmatrix}.
  \label{eq:W'_delta-m-lambda}
\end{gather}

For the matrix $W''$ we obtain
\begin{gather}
  W''
  =
  \begin{pmatrix}
    \delta & \delta ((b + d \lambda) d' - d m b^*)\\
    0      & m
  \end{pmatrix}
  =
  \begin{pmatrix}
    \delta & \delta \lambda_\gamma\\
    0      & m
  \end{pmatrix}.
  \label{eq:W''_delta-m-lambda}
\end{gather}
where
\begin{gather}
  \lambda_\gamma := (b + d \lambda) d' - d m b^*.
  \label{eq:lambda_gamma}
\end{gather}

Note that
\begin{align*}
  W = W'\cdot W''
  &=
    \begin{pmatrix}a'& b'\\c'&d'\end{pmatrix}
    \cdot
    \begin{pmatrix}1& \delta s\\0&1\end{pmatrix}
    \begin{pmatrix}1&-\delta s\\0&1\end{pmatrix}
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& b' + a'\delta s\\c'&d' + c' \delta s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&-s\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& \delta(b^* + (a+c \lambda)s)\\c'&d' + c m s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma-sm\\0&m\end{pmatrix}
\end{align*}


Clearly, we can choose $s\in\setZ$ such that
$0 \le \lambda_\gamma - sm < m$.
%
In the following, we assume that already in the first place we have
chosen $b^*$ and $d'$ in such a way that $0\le \lambda_\gamma < m$. In
other words, we assume functions $(\gamma,\delta,m,\lambda)\mapsto W'$
and $(\gamma,m,\lambda)\mapsto \lambda_\gamma$.

Note that $\lambda_\gamma$ does depend on $\gamma$, $\lambda$, and
$m$, but it does not depend on $\delta$.

With $\tau':=W''\tau$ we have
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d' - d m b'}{m}
    \right) + d'\\
  &=
    \frac{cm}{\delta}
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d'}{m}
    \right)  - d b' c' + d'\\
  &=
    c\tau + c(b + d \lambda) d' - d (a' d' -1) + d'\\
  &=
    c\tau + d + c(b + d \lambda) d' - d a' d' + d'\\
  &=
    c\tau + d + [c(b + d \lambda) - d (a + c \lambda) + 1]d'\\
  &=
    c\tau + d
\end{align*}
and thus
\begin{align*}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &= \eta(W \tau) = \eta(W'W''\tau) = \eta(W'\tau')\\
  &= (c'\tau'+d')^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \,\eta(\tau')\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta(W''\tau)\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta
    \left(
    \begin{pmatrix}
      \delta & \delta \lambda_\gamma\\
      0      & m
    \end{pmatrix}
    \tau
    \right)\\
  &= (c\tau+d)^{1/2} \upsilon_{\gamma,\delta,m,\lambda} \, \eta_{\delta,m,\lambda_\gamma}(\tau)
\end{align*}
where $\upsilon_{\gamma,\delta,m,\lambda} := \upsilon(W')$ and
$\lambda_\gamma = d d' \lambda + b d' - d m b^*$, see \eqref{eq:lambda_gamma}.

Note that $d$ and $d'$ are invertible modulo $m$, \ie, given
$\lambda_\gamma$, we can find $\lambda$ such that
$\lambda\in\Set{0,\ldots,m-1}$ and
$\lambda_\gamma= d d' \lambda +  b d' - d m b^*$ holds.
%
We have $\gcd(d',m)=1$ by choice of $d'$. Because $\det(\gamma)=1$ and
$\divides{N}{c}$, it follows $\gcd(N, d)=1$. From \eqref{eq:p|m=>p|N}
follows invertibility of $d$ modulo $m$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $g_{r,m,t}$ under
  $\Gamma_0(N) \subset \SL2Z$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Hemmecke}
  Cannot use this section for expansion, since it only describes
  formulas for $\Gamma_0(N)$.
\end{Hemmecke}

From the previous section, we can easily find a formula for the
transformation of $g_{r,m,t}$ under $\SL2Z$.

\begin{align*}
  g_{r,m,t}(\gamma\tau)
  &:=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
  \divisorprod{M}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{r_\delta}
  \\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
    (c\tau+d)^{\divisorsum{M} r_\delta/2}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\divisorsum{M} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\divisorsum{M} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
    \divisorprod{M} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}
\end{align*}

Let us compare this with \eqref{eq:g_s-m-t(tau)} where we have replaced
$t$ by $t'$ with $t' = t x + \frac{x-1}{24}s+km$ for some
$x\in\setN$ and $k\in\setZ$ such that $0\le t' < m$.
\begin{align}
  g_{r,m,t'}(\tau)
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}
    \Bigl(24\bigl(t x + \frac{x-1}{24}s+km\bigr)+s\Bigr)}
  \divisorprod{M}
  \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}.
\end{align}

If we can find some $x\in\setZ$ and $\kappa(r,t)\in\setC$ such that
for every $0\le \lambda<m$
\begin{gather}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
  = \kappa(r, t) \cdot
    \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
\end{gather}

According to
\cite[Thm.~2.14]{Radu:AlgorithmicApproachRamanujanCongruences:2009},
we choose $x=a^2$ and

\begin{gather*}
  \kappa(r,t)
  =
  \beta(\gamma,0) \, \unityPower{\frac{24t+\sumdelta{r}}{24m} ab(1-m^2)}
\end{gather*}

\begin{align*}
  \kappa(r, t)
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m} (\lambda - \lambda_\gamma x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda - ((b + d \lambda) d' - d m b^*) x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda(1 - dd'x) - (b d' - d m b^*) x}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
\end{align*}
\end{Hemmecke}











\bibliography{qeta}
\printindex
\end{document}
)endif
