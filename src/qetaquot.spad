-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (generalized) Dedekind Eta Functions into $q$-series
  at various cusps}

\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals with expansions of (generalized)
  Dedekind eta-quotients that have been turned into a modular function
  by multiplication with a cofactor. Expansions into $q$-series of
  objects are considered at any cusp of $\Gamma_0(N)$ or
  $\Gamma_1(N)$.

  It is a generalisation of the code in \PathName{qetaquotinf.spad}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
LSL2Z ==> List SL2Z
VZ ==> Vector Z
OF ==> OutputForm
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$CongruenceSubgroupGamma0)
WIDTH1(nn, c) ==> asP(width(nn, c)$CongruenceSubgroupGamma1)





)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We do the compuation in an extension of the coefficient field by a
root of unity. We determine the order of the root of unity that is
needed to represent the coefficients of the expansion at any cusp via
\emph{symbolic} domains. These domains hold all relevant data to be
able to turn them into an actual series expansion.

All these domains are marked with the prefix \code{Symbolic} and
implemented in \PathName{qetaquotsymb.spad}.

In this file we assume that \code{mx} holds the order of the minimal
root of unity needed and that \code{xi} is such a primitive root of
unity and \code{CX} is $C[\xi]$.

Eta-quotients are considered as modular functions for $\Gamma_0(N)$,
whereas generalized eta-quotients are considered as modular functions
for $\Gamma_1(N)$.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D QEtaPuiseuxExpansion (only for QEtaLaurentExpansion)
  $p_{r,m,t}(\gamma\tau)$, $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:QEtaPuiseuxExpansion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The domain \code{QEtaPuiseuxExpansion} represents the Puiseux series
expansion of various eta-quotients.

Since eta-quotient expansions are expressed in the canonical
variables, these will be Laurent series, thus,
\code{QEtaPuiseuxExpansion} serves as an auxiliary domain that is only
uses for \code{QEtaLaurentExpansion}


)endif

-------------------------------------------------------------------
)abbrev domain QEPX QEtaPuiseuxExpansion
++ QEtaPuiseuxExpansion holds data to compute an eta quotient
++ expansion of $g_{r,m,\lambda}(\gamma \tau)$,
++ $p_{r,m,t}(\gamma\tau)$, $F_{s,r,m,t}(\gamma\tau)$. See
++ \eqref{eq:g_r-m-lambda(gamma*tau)} and
++ \eqref{eq:F_r-m-t-(gamma*tau)}.
++ This domain is used as an auxiliary domain for QEtaLaurentExpansion.
QEtaPuiseuxExpansion(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseux: (SymbolicEtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $p_{r,m,t}(\gamma \tau)$.
    puiseux: (SymbolicModularGamma0EtaQuotientGamma, P) -> %
      ++ puiseux(y, w) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$.
    rationalPowerDenominator: % -> P
      ++ If k=order(x) and f=qetaTaylorRep(x) then,
      ++ rationalPowerDenominator(x) returns w such that
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    qetaTaylorRep: % -> TX
      ++ qetaTaylorRep(x) returns the Taylor series representation f of x
      ++ without the prefactor corresponding to $(c \tau + d)$
      ++ If w=rationalPowerDenominator(x) and k=order(x) then
      ++ x(q)=z^(k)*f(z) with z=q^(1/w).
    order: % -> Q
      ++ If w=rationalPowerDenominator(x) and f=qetaTaylorRep(x) then
      ++ order(x) returns k such that x(q)=z^(k)*f(z) with z=q^(1/w).
      ++ order(x) returns the order o

    laurentExpansion: % -> LX
      ++ If order(x) is an integer, then laurentExpansion(x) returns
      ++ the Laurent series f of x without the prefactor corresponding
      ++ to $(c \tau + d)$ such that x(q) = f(z) for z=q^(1/w) where
      ++ w=rationalPowerDenominator(x). It is an error if order(x) is
      ++ not an integer.

    --TODO: The following function should live somewhere else.
    substitute: (LX, P, N) -> LX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

  Implementation ==> add
    -- If x: % and s = rep(x).ser, d = rep(x).den then
    -- x represents the series s(q^(1/d)).
    Rep ==> Record(den: P, ord: Q, ser: TX)
    xx ==> rep x

    -- Cache for frequently used objects
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

-------------------------------------------------------------------
-- local functions
-------------------------------------------------------------------
    xipow(n: Z): CX ==
         -- Take care of the fact that xi^mx = 1.
        e: Z := positiveRemainder(n, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    xiPower(v: N): (Z -> CX) == (e: Z): CX +-> xipow(v*e)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: P, v: N): LX ==
        multiplyExponents(multiplyCoefficients(xiPower v, s), u)

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        zero? rd => 1$LX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    checkedMultisect(m: P, tx: TX): TX ==
        one? m => tx
        stx: Stream CX := coefficients tx
        for i in 1..m-1 repeat
            stx := rest stx
            if not zero? first stx then
                dbgPrint("checkedMultisect c", first stx)
                dbgPrint("Taylor representation", tx)
                error "nonzero coefficients for multisect"
        tx := multisect(m, 0, tx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    rationalPowerDenominator(x: %): P == xx.den
    order(x: %): Q == xx.ord
    qetaTaylorRep(x: %): TX == xx.ser
    coerce(x: %): OutputForm == xx::OutputForm

    laurentExpansion(x: %): LX ==
        ord: Q := order x
        not one? denom ord =>
            error "QEtaPuiseuxExpansion: fractional exponent in Laurent series"
        laurent(numer ord, qetaTaylorRep x)$LX


)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- local
    puiseuxLambda(y: SymbolicEtaQuotientLambdaGamma, ue: Q, w: P): % ==
        -- w=width
        mm: P := level y
        divs: LP := divisors y
        m: P := multiplier y
        d: P := m*w
        s: LX := 1
        for delta in divs for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicEtaGamma := y.delta
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "QEtaPuiseuxExpansion: denominator does not vanish"
            v: Q := mx * vdelta etadelta
            not one? denom v or v<0 =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("vdelta", [vdelta etadelta, u]$List(Q))
                error "QEtaPuiseuxExpansion: denominator does not vanish"
            s := s * eulerFunctionPower(asP numer u, asN numer v, rd)
        uexp: Q := mx * (lambda(y)*ue + unityExponent y)
        not one? denom uexp =>
            dbgPrint("mx * unityExponent y", uexp)
            error "QEtaPuiseuxExpansion: denominator for xi does not vanish"
        -- leading coefficient
        cx: CX := xipow numer uexp * squareRoot rationalPrefactor y
        p: Q := d * qExponent y
        not one? denom p =>
            error "QEtaPuiseuxExpansion: denominator for q does not vanish"
        tx: TX := cx * qetaTaylorRep s
        per [d, p, tx]




)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain \code{QEtaPuiseuxExpansion}
represents the series expansion of
\begin{gather*}
  p_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif


    puiseux(y: SymbolicEtaQuotientGamma, w: P): % ==
        m: P := multiplier y
        ue: Q := unityExponent y
        x: % := puiseuxLambda(y.0, ue, w) -- $g_{r,m,\lambda}$
        one? m => x
        lx: LX := laurentExpansion x
        m1: P := asP(m::Z - 1)
        for lambda in 1..m1 repeat
            lx := lx + laurentExpansion puiseuxLambda(y.lambda, ue, w)
        -- A sifted version of an eta-quotient is a non-zero function.
        -- Thus, we can safely remove initial zeroes.
        --TODO: WARNING: The above is not true.
        -- Try findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)
        lx: LX := removeZeroes(lx)$LX
        -- And, it is safe to ask for the order of the series expansion.
        ord: Z := order lx
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        tx: TX := (1/m)$Q::C::CX * checkedMultisect(m, qetaTaylorRep lx)
        per [w, ord/m, tx] -- the */m disappears after multiplying the orbit

    -- local
    puiseuxOrbit(y: SymbolicEtaQuotientOrbitProductGamma, w: P): % ==
        orb := orbit y
        t: N := first orb;
        px: % := puiseux(y.t, w) -- p_{r,m,t}
        d: P := rationalPowerDenominator px
        tx: TX := qetaTaylorRep px
        ord: Q := order px
        for k in rest orb repeat
            px: % := puiseux(y.k, w) -- SymbolicEtaQuotientGamma
            tx := tx * qetaTaylorRep px
            ord := ord + order px
        not one? denom ord =>
            error "QEtaPuiseuxExpansion: orbit product: denominator for q does not vanish"
        per [d, ord, tx]

    puiseux(y: SymbolicModularGamma0EtaQuotientGamma, w: P): % ==
        yc: SymbolicEtaQuotientGamma := cofactor y
        yo: SymbolicEtaQuotientOrbitProductGamma := orbitProduct y
        pc: % := puiseux(yc, 24*w)
        po: % := puiseuxOrbit(yo, 24*w)
        d: P := rationalPowerDenominator pc
        -- Sanity check.
        d ~= 24 * w =>
            error "QEtaPuiseuxExpansion: Puiseux expansion in wrong variable"
        rationalPowerDenominator pc ~= rationalPowerDenominator po =>
            error "QEtaPuiseuxExpansion: expansion in different variables"
        tx: TX := checkedMultisect(24, qetaTaylorRep pc * qetaTaylorRep po)
        ord: Q := order pc + order po
        ord := ord * (1$Z/24)-- It's a modular function.
        not one? denom ord =>
            error "QEtaPuiseuxExpansion: modular: denominator for q does not vanish"
        per [w, ord, tx]









)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaLaurentExpansion
  $p_{r,m,t}(\gamma\tau)$, $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:QEtaLaurentExpansion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The package \code{QEtaLaurentExpansion} provides functions for the
conversion of eta-quotients into Laurent series either at a specific
cusp or at several cusps.


)endif
)abbrev package QELX QEtaLaurentExpansion
++ QEtaLaurentExpansion(C, mx, CX, xi, LX) represents the set
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
QEtaLaurentExpansion(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX ==> QEtaLaurentSeries CX -- domain for the series expansions
  QLX ==> XHashTable(Q, LX)
  YEQG ==> SymbolicEtaQuotientGamma
  YEQ ==> SymbolicEtaQuotient

  Exports ==> with
    --assert(one? xi^mx)
    laurentExpansion: (YEQG, P) -> LX
      ++ laurentExpansion(y, w) returns a Laurent expansion
      ++ corresponding to y in terms of the variable z=q^(1/w). It is
      ++ an error if y cannot be expressed in z.
    laurentExpansion: SymbolicModularGamma0EtaQuotientGamma -> LX
      ++ laurentExpansion y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ given by y in the canonical
      ++ variables given by the width of the cusp wrt.
      ++ Gamma_0(level(y)).
    laurentExpansionsGamma0: YEQ -> QLX
      ++ laurentExpansions y represents the expansion of
      ++ $p_{r,m,t}(\tau)$ in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m,c)$CongruenceSubgroupGamma0 at all cusps that are
      ++ given in y. See \eqref{eq:p_r-m-t(gamma*tau)}.
    laurentExpansions: SymbolicModularGamma0EtaQuotient -> QLX
      ++ laurentExpansions y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ at all cusps given by y in the
      ++ canonical variables given by the width of the cusp wrt.
      ++ Gamma_0(level y).

  Implementation ==> add
    QEPX(C, CX) ==> QEtaPuiseuxExpansion(C, mx, CX, xi)

    laurentExpansion(y: YEQG, w: P): LX ==
        x: QEPX(C, CX) := puiseux(y, w)
        laurentExpansion(x)$QEPX(C, CX)

    laurentExpansion(y: SymbolicModularGamma0EtaQuotientGamma): LX ==
        cy: YEQG := cofactor y
        nn: P := level cy
        g: SL2Z := gamma cy
        w: P := WIDTH0(nn, g(2,1))
        x: QEtaPuiseuxExpansion(C, mx, CX, xi) := puiseux(y, w)
        laurentExpansion x

    laurentExpansionsGamma0(y: YEQ): QLX ==
        import from QEtaPuiseuxExpansion(C, mx, CX, xi)
        nn: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(nn, exponents y)$QETAAUX then
            dbgPrint("QEtaLaurenExpansion: not a modular function", exponents y)
        hser: QLX := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurentExpansion(y.cusp, w)
        hser

    laurentExpansions(y: SymbolicModularGamma0EtaQuotient): QLX ==
        import from QEtaPuiseuxExpansion(C, mx, CX, xi)
        nn: P := level y
        hser: QLX := empty()
        for cusp in cusps y repeat hser.cusp := laurentExpansion(y.cusp)
        hser
















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaSeriesExpansion
  $p_{r,m,t}(\gamma\tau)$, $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:QEtaSeriesExpansion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The package \code{QEtaSeriesExpansion} turns an element of a
\emph{symbolic} domain into a Puiseux series or a Laurent series if
the respective width of the cusp is given.



)endif

-------------------------------------------------------------------
)abbrev package QESX QEtaSeriesExpansion
++ QEtaSeriesExpansion computes an eta quotient expansion of
++ $g_{r,m,\lambda}(\gamma \tau)$, $p_{r,m,t}(\gamma\tau)$,
++ $F_{s,r,m,t}(\gamma\tau)$. See \eqref{eq:g_r-m-lambda(gamma*tau)}
++ and \eqref{eq:F_s-r-m-t(gamma*tau)}.
QEtaSeriesExpansion(C, mx, CX, xi): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  -- We need Algebra(Q) for multiplication with (1/m)
  mx: P -- mx-th root of unity needed.
  CX: Join(Algebra C, Field)
  xi: CX --primitive mx-th root of unity.
  TX ==> QEtaTaylorSeries CX
  LX ==> QEtaLaurentSeries CX
  PX ==> QEtaPuiseuxSeries CX
  QLX ==> XHashTable(Q, LX)
  YM1GEQG ==> SymbolicModularGamma1GeneralizedEtaQuotientGamma
  YM1GEQ ==> SymbolicModularGamma1GeneralizedEtaQuotient

  -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    puiseuxExpansion: (SymbolicEtaQuotientLambdaGamma, Q) -> PX
      ++ puiseuxExpansion(y, r) computes the Puiseux expansion of
      ++ $g_{r,m,\lambda(\gamma\tau)$ in terms of $q$ multiplied by
      ++ $\exp(2\pi i r)$. The $(c\tau+d)$ factor is missing.
      ++ See \eqref{eq:g_r-m-lambda(gamma*tau)}.
    puiseuxExpansion: SymbolicEtaQuotientGamma -> PX
      ++ puiseuxExpansion(y) computes the Puiseux expansion of the
      ++ q-expansion of $p_{r,m,t}(\gamma \tau)$, see
      ++ \eqref{eq:p_r-m-t(gamma*tau)}. The $(c\tau+d)$ factor is
      ++ missing.
    puiseuxExpansion: SymbolicEtaQuotientOrbitProductGamma -> PX
      ++ puiseuxExpansion(x) computes the PuiseuX expansion of
      ++ P_{r,m,t}(\gamma\tau), see \eqref{eq:P_r-m-t(gamma*tau)}.
      ++ The $(c\tau+d)$ factor is missing.
    puiseuxExpansion: SymbolicModularGamma0EtaQuotientGamma -> PX
      ++ puiseuxExpansion(y) represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma \tau)$, see
      ++ \eqref{eq:F_s-r-m-t(gamma*tau)}.

    laurent: (PX, P) -> LX
      ++ If p(q)=s(z) is a Puiseux series p expressed as a Laurent
      ++ series s in the variable z=q^r, then laurent(x, w) returns
      ++ the laurent series l such that l(x)=s(z)=p(q) where x=q^(1/w)
      ++ in case r*w is an integer. It might happen that r*w is not an
      ++ integer. That is even to be expected since non-modular
      ++ eta-quotients involve a factor in terms of q^(1/24). If
      ++ r=s/t, then we take only every t-th term and check that the
      ++ intermediate terms come indeed with a zero coefficient.

    laurentExpansion: SymbolicModularGamma0EtaQuotientGamma -> LX
      ++ laurentExpansion y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ given by y in the canonical
      ++ variables given by the width of the cusp wrt.
      ++ Gamma_0(level(y)).
    laurentExpansionsGamma0: SymbolicEtaQuotient -> QLX
      ++ laurentExpansions y represents the expansion of
      ++ $p_{r,m,t}(\tau)$ in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m,c)$CongruenceSubgroupGamma0 at all cusps that are
      ++ given in y. See \eqref{eq:p_r-m-t(gamma*tau)}.
    laurentExpansions: SymbolicModularGamma0EtaQuotient -> QLX
      ++ laurentExpansions y represents the q-expansion of
      ++ $F_{s,r,m,t}(\gamma\tau)$ at all cusps given by y in the
      ++ canonical variables given by the width of the cusp wrt.
      ++ Gamma_0(level y).

    --TODO: The following function should live somewhere else.
    substitute: (LX, Q, N) -> PX
      ++ If s(q) is a series in q, then substitute(s, u, v) returns a
      ++ series t(q) such that t(q)=s(q^u*xi^v).

--    puiseuxExpansion: (SymbolicProperGeneralizedEtaQuotientLambdaGamma, Q) -> PX
    puiseuxExpansion: (SymbolicGeneralizedEtaQuotientLambdaGamma, Q) -> PX
    puiseuxExpansion: SymbolicGeneralizedEtaQuotientGamma -> PX
    puiseuxExpansion: YM1GEQG -> PX
    laurentExpansion: YM1GEQG -> LX
    laurentExpansionsGamma1: SymbolicGeneralizedEtaQuotient -> QLX
    laurentExpansions: YM1GEQ -> QLX



  Implementation ==> PX add
    Rep ==> PX
    xx ==> rep x

    -- Cache for frequently used objects
    ef: LX := eulerFunction(1)$QFunctions(CX, LX)
    ef1: CX := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower LX := ef :: CachedPower(LX)
    ps: LX := partitionSeries(1)$QFunctions(CX, LX)
    ps1: CX := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower LX := ps :: CachedPower(LX)
    xic: CachedPower CX := xi :: CachedPower(CX)

    SUPF2 ==> SparseUnivariatePolynomialFunctions2
    SUP ==> SparseUnivariatePolynomial
    -- Note that cycZ is the same polynomial as in MINROOTPOL
    -- in etamacros.input.
    cycZ: SUP Z := cyclotomic(mx)$CyclotomicPolynomialPackage
    cycQ: SUP Q := map(coerce, cycZ)$SUPF2(Z, Q)
    Qxi ==> SimpleAlgebraicExtension(Q, SUP Q, cycQ)
    qxi := generator()$Qxi

-------------------------------------------------------------------
-- local functions
-------------------------------------------------------------------
    xipow(n: Z): CX ==
         -- Take care of the fact that xi^mx = 1.
        e: Z := positiveRemainder(n, mx)
        zero? e => 1$CX
        power!(xic, asP e)$CachedPower(CX)

    xiPower(v: Z): (Z -> CX) == (e: Z): CX +-> xipow(v*e)

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LX, u: Q, v: N): PX ==
        puiseux(u, multiplyCoefficients(xiPower v, s))

    eulerFunctionPower(u: Q, v: N, rd: Z): PX ==
        zero? rd => 1$PX
        rd < 0 => substitute(power!(psc, -rd)$CachedPower(LX), u, v)
        substitute(power!(efc, rd)$CachedPower(LX), u, v)

    -- We assume that CX has been chosen in such a way that the square
    -- root of the argument of squareRoot can be expressed in it.
    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QETAAUX
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------
    laurent(x: PX, w: P): LX ==
        x := multiplyExponents(x, w)
        r: Q := rationalPower x
        -- Here we assume that the Puiseux series x is indeed a
        -- Laurent series in q^(1/w).
        d: P := denom(r)::P
        n: P := numer(r)::P
        lx: LX := qetaLaurentRep x
        -- if possible, get rid of some initial zeros up to degree 0
        lx := removeZeroes(-degree lx, lx)
        one? d => -- lucky case, no multisect needed
            one? n => return lx -- avoid needless "multiplyExponents"
            return multiplyExponents(lx, n)
        lx := choose(d, 0, lx)$LX
        one? n => return lx
        return multiplyExponents(lx, n)


)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion
of $g_{r,m,\lambda}(\gamma\tau)$, \ie, in terms of $q^{1/(24 m w)}$
where $w$ must be a multiple of the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} r_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with $r_\delta\ne0$, \ie, the series from
\eqref{eq:g_r-m-lambda(gamma*tau)} without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- local
    -- The q-Pochhammer part (last product) of \eqref{g_r-m-lambda(gamma*tau)}.
    qPochhammerPure(y: SymbolicEtaQuotientLambdaGamma): PX ==
        px: PX := 1
        for delta in divisors y for rd in exponents y | not zero? rd repeat
            etadelta: SymbolicEtaGamma := y.delta
            u: Q := udelta etadelta
            v: Q := mx * vdelta etadelta
            not one? denom v or v<0 =>
                dbgPrint("delta", delta)
                dbgPrint("vdelta", [vdelta etadelta, u]$List(Q))
                error "QEtaSeriesExpansion: denominator does not vanish"
            px := px * eulerFunctionPower(u, asN numer v, rd)
        return px

    -- $g_{r,m,\lambda}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicEtaQuotientLambdaGamma, ue: Q): PX ==
        uexp: Q := mx * (lambda(y)*ue + unityExponent y)
        not one? denom uexp =>
            dbgPrint("mx * unityExponent y", uexp)
            error "QEtaSeriesExpansion: denominator for xi does not vanish"
        -- leading coefficient
        cx: CX := xipow numer uexp * squareRoot rationalPrefactor y
        monomial(cx, qExponent y) * qPochhammerPure y


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function computes
\begin{gather*}
  p_{r,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{r,m,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_r-m-t(gamma*tau)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- $p_{r,m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicEtaQuotientGamma): PX ==
        ue: Q := unityExponent y
        px: PX := puiseuxExpansion(y.0, ue) -- $g_{r,m,\lambda}$ for lambda=0
        m: P := multiplier y
        one? m => px
        m1: P := asP(m::Z - 1)
        for lambda in 1..m1 repeat px := px + puiseuxExpansion(y.lambda, ue)
        -- Summation possibly produces zero leading coefficients.
        -- We try to remove at most 100 leading coefficients.
        --TODO: Make 100 dependent on some parameters.
        -- "lx: LX := removeZeroes(lx)$LX" would be nice the following
        -- gives the zero series and thus wouldn't terminate.
        -- "findIdentity(4,1,[8],4,3)$QEtaRamanujanKolberg(Q)"
        (1/m)$Q::C::CX * px

    -- $P_{r,m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicEtaQuotientOrbitProductGamma): PX ==
        orb: List N := orbit y
        t: N := first orb;
        px: PX := puiseuxExpansion(y.t) -- p_{r,m,t}
        for k in rest orb repeat px := px * puiseuxExpansion(y.k)
        px

    -- $f_{s,r,m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicModularGamma0EtaQuotientGamma): PX ==
        puiseuxExpansion cofactor y * puiseuxExpansion orbitProduct y

    -- $F_{s,r,m,t}(\gamma\tau)$
    laurentExpansion(y: SymbolicModularGamma0EtaQuotientGamma): LX ==
        cy: SymbolicEtaQuotientGamma := cofactor y
        nn: P := level cy
        g: SL2Z := gamma cy
        w: P := WIDTH0(nn, g(2,1))
        laurent(puiseuxExpansion y, w)

    -- $g_r(\gamma\tau)$ for all cusps of $\Gamma_0(N)$
    laurentExpansionsGamma0(y: SymbolicEtaQuotient): QLX ==
        nn: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma0?(nn, exponents y)$QETAAUX then
            dbgPrint("QEtaSeriesExpansion: not a modular function", exponents y)
        hser: QLX := empty()
        for cusp in cusps y repeat
            w: P := WIDTH0(nn, denom cusp) -- width of cusp
            hser.cusp := laurent(puiseuxExpansion(y.cusp), w)
        hser

    -- $F_{s,r,m,t}(\gamma\tau)$ for all cusps of $\Gamma_0(N)$
    laurentExpansions(y: SymbolicModularGamma0EtaQuotient): QLX ==
        hser: QLX := empty()
        for cusp in cusps y repeat hser.cusp := laurentExpansion(y.cusp)
        hser



)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\bar{r} \in \bar{R}(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion of
$g_{\tilde{r},m,\lambda}(\gamma\tau)$, \ie, in terms of
$q^{1/w)}$, \ie, the series from
\eqref{eq:g_rtilde-m-lambda(gamma*tau)}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif



    -- local

    -- inv1minusxi(n) computes (1-xi^n)^(-1). Since xi is a mx-th root
    -- of unity, the result is in Z[xi] and thus can be expressed in
    -- C[x] witout knowing that CX is a field.
    -- The strategy is that we compute (1-xi^n)^(-1) in Q[xi] (which
    -- is a field) convert to Z[xi] and then to CX=C[xi].
    -- Here we use the property that we require CX: Algebra C.
    inv1minusxi(z: Z): CX ==
        -- assert(not zero?(positiveRemainder(z, mx)))
        n: P := asP positiveRemainder(z, mx)
        f: Qxi := inv(1-qxi^n)
        pol: SUP Q := convert(f)@SUP(Q)
        -- now substitude xi into pol
        mons: List SUP Q := reverse! monomials pol
        cx: CX := 0
        while not empty? mons repeat
            mon := first mons
            mons := rest mons
            cx := cx + numer(leadingCoefficient mon) * xi^leadingSupport(mon)
        cx

    -- local
    -- Note that xi is a mx-th root of unity so, we have to multiply
    -- the (rational) exponent of xi by mx.
    alphaSchoenemann(g: Z, h: Z, nn: Z, rdg: Z): CX ==
        not zero?(g rem nn) or zero?(h rem nn) or zero? rdg => 1$CX

        uexp: Q := (mx/2)*fractionalBernoulli1(h/nn)$QETAAUX
        not one? denom uexp =>
            dbgPrint("mx * Bernoulli1", uexp)
            error "QEtaSeriesExpansion: alphaSchoenemann"
        cx := xipow(rdg * numer uexp)

        uexp: Q := -mx*h/nn
        not one? denom uexp =>
            dbgPrint("mx * alphaexp", uexp)
            error "QEtaSeriesExpansion: alphaSchoenemann"

        rdg > 0 => cx * (1 - xipow(numer uexp))^(asP rdg)
        cx * inv1minusxi(numer uexp)^asP(- rdg)

    -- local
    alphaSchoenemannProperGeneralized(_
      y: SymbolicProperGeneralizedEtaQuotientLambdaGamma): CX ==
        cx: CX := 1
        for l in exponents y repeat
            delta := asP l.1; g := asP l.2; rdg := l.3;
            ygeg := y(delta, g)
            g1 := gamma1 ygeg
            cx := cx * alphaSchoenemann(g1(1,1)*g, g1(1,2)*g, delta, rdg)
        cx

    -- local
    -- Compute $\tilde{r}_\delta$ from $\tilde{r}$. See definition
    -- below \eqref{eq:p_rbar-m-lambda(gamma*tau)}, i.e.
    -- $\tilde{r}_\delta := \sum_{0 < g < \frac{\delta}{2}} r_{\delta,g}$.
    rtilde(delta: P, y: SymbolicProperGeneralizedEtaQuotientLambdaGamma): Z ==
        rd: Z := 0
        for l in exponents y | delta = asP l.1 repeat rd := rd + l.3;
        rd

    -- local
    -- The q-Pochhammer part (last product) of
    -- \eqref{eq:p_rbar-m-lambda(gamma*tau)}.
    -- It includes the pure and properGeneralized part, because we
    -- employ the jacobiProduct to compute it.
    qPochhammerGeneralized(_
      y: SymbolicGeneralizedEtaQuotientLambdaGamma): PX ==
        ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
        ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
            properGeneralizedEtaQuotient y

        -- We first compute the first q-Pochhammer product (with
        -- exponent $r_\delta - \tilde{r}_\delta$, see
        -- \eqref{eq:p_rbar-m-lambda(gamma*tau)}.
        -- Compare also with implementation of qPochhammerPure
        px: PX := 1
        for delta in divisors ypure for rd in exponents ypure _
                | not zero?(expo := rd - rtilde(delta, ypg)) repeat
            etadelta: SymbolicEtaGamma := ypure.delta
            u: Q := udelta etadelta
            v: Q := mx * vdelta etadelta
            not one? denom v or v<0 =>
                dbgPrint("delta", delta)
                dbgPrint("vdelta", [vdelta etadelta, u]$List(Q))
                error "QEtaSeriesExpansion: denominator does not vanish"
            px := px * eulerFunctionPower(u, asN numer v, expo)

        -- Now the jacobiFunction part.
        for l in exponents ypg repeat
            delta := asP l.1; g := asP l.2; rdg := l.3;
            ygeg: SymbolicGeneralizedEtaGamma := ypg(delta, g)
            g1 := gamma1 ygeg
            alphabeta := fractionalPart(g1(1,1)*g/delta)$QETAAUX
            alpha: Z := numer alphabeta
            beta: Z  := denom alphabeta
            -- exponent for mx-th root of unity
            h: Q := mx*g1(1,2)*g/delta -- is made smaller in xipow
            not one? denom h => -- mx should be such that h is integral
                dbgPrint("mx*h'/delta", h)
                error "QEtaSeriesExpansion: denom for xi does not vanish"
            jac ==> jacobiFunction $ QFunctions(CX, LX)
            -- See \eqref{eq:mimimalRootOfUnity-g_rtilde-m-lambda}.
            nh: Z := numer h
            lx: LX := jac(xiPower nh, beta::P, alpha::P)^rdg
            u: Q := udelta(ygeg)
            v: Q := vdelta(ygeg)
            vbeta: Q := mx * v * (1/beta)
            not one? denom vbeta =>
                dbgPrint("vbeta", vbeta)
                error "QEtaSeriesExpansion: denom for xi does not vanish"
            px := px * substitute(lx, (1/beta)*u, asP numer vbeta)
        return px










)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\bar{r} \in \bar{R}(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion of
$g_{\bar{r},m,\lambda}(\gamma\tau)$, \ie, in terms of
$q^{1/w)}$, \ie, the series from \eqref{eq:g_rbar-m-lambda(gamma*tau)}
without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- $g_{\bar{r},m,\lambda}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicGeneralizedEtaQuotientLambdaGamma,
                     ue: Q): PX ==
        -- Theoretically, the following would be sufficient.
        --
        --: ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
        --: ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
        --:     properGeneralizedEtaQuotient y
        --: puiseuxExpansion(ypure, ue) * puiseuxExpansion(ypg, 0)
        --
        -- However, in certain cases the expansion of the pure
        -- eta-quotient with the unityExponent ue for the
        -- generalized eta-quotient would lead to the necessity of
        -- not only a mx-th root of unity, but a bigger root of unity.
        -- This could be solved in different ways.
        --
        -- (a) Change the minimalRootOfUnity computation for
        --     SymbolicGeneralizedEtaQuotientGamma, in order to be
        --     able to use the above simple code.
        -- (b) Split ue in the respective ue for the pure
        --     eta-quotient and a rest (basically \sigma_\infty
        --     for the proper generalized part), adapt the code
        --     above accordingly, and also adapt the
        --     minimalRootOfUnity computation accordingly.
        -- (c) Implement according to what is under the sum sign in
        --     \eqref{eq:p_rbar-m-t(gamma*tau)}.
        --
        -- We decided for (c), because that avoids some
        -- multiplication with coefficients and monomials.

        uexp: Q := mx * (lambda(y)*ue + unityExponent y)
        not one? denom uexp =>
            dbgPrint("mx * unityExponent y", uexp)
            error "QEtaSeriesExpansion: denominator for xi does not vanish"

        -- leading coefficient
        ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
        cx: CX := xipow numer uexp * squareRoot rationalPrefactor ypure

        -- Take \eqref{eq:eta_g-h^[S](tau)-prefactor} into account (in cx).
        ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
            properGeneralizedEtaQuotient y
        cx := cx * alphaSchoenemannProperGeneralized ypg
        px := monomial(cx, qExponent y)$PX * qPochhammerGeneralized y
        px







)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\bar{r} \in \bar{R}(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, the following function represents the Puiseux expansion of
$p_{\bar{r},m,\lambda}(\gamma\tau)$, \ie, in terms of
$q^{1/w)}$, \ie, the series from \eqref{eq:p_rbar-m-t(gamma*tau)}
without the $(c\tau+d)$-part.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

    -- $p_{\bar{r},m,t}(\gamma\tau)$
    puiseuxExpansion(y: SymbolicGeneralizedEtaQuotientGamma): PX ==
        ue: Q := unityExponent y
        px: PX := puiseuxExpansion(y.0, ue) -- $g_{rbar,m,\lambda}$ for lambda=0
        m: P := multiplier y
        one? m => px
        m1: P := asP(m::Z - 1)
        for lambda in 1..m1 repeat px := px + puiseuxExpansion(y.lambda, ue)
        (1/m)$Q::C::CX * px

    -- $F_{\bar{r},m,t}(\gamma\tau)$
    puiseuxExpansion(y: YM1GEQG): PX ==
        yc: SymbolicGeneralizedEtaQuotientGamma := cofactor y
        yb: SymbolicGeneralizedEtaQuotientGamma := basefactor y
        puiseuxExpansion yc * puiseuxExpansion yb

    -- $F_{\bar{r},m,t}(\gamma\tau)$
    laurentExpansion(y: YM1GEQG): LX ==
        cy: SymbolicGeneralizedEtaQuotientGamma := cofactor y
        nn: P := level cy
        g: SL2Z := gamma cy
        w: P := WIDTH1(nn, g(2,1))
        laurent(puiseuxExpansion y, w)

    -- $g_{\bar{r}}(\gamma\tau)$ for all cusps of $\Gamma_1(N)$
    laurentExpansionsGamma1(y: SymbolicGeneralizedEtaQuotient): QLX ==
        nn: P := level y
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function.
        if not modularGamma1?(nn, exponents y)$QETAAUX then
            dbgPrint("QEtaSeriesExpansion: not a modular function", exponents y)
        hser: QLX := empty()
        for cusp in cusps y repeat
            w: P := WIDTH1(nn, denom cusp) -- width of cusp
            hser.cusp := laurent(puiseuxExpansion(y.cusp), w)
        hser

    -- $F_{\bar{r},m,t}(\gamma\tau)$ for all cusps of $\Gamma_1(N)$
    laurentExpansions(y: YM1GEQ): QLX ==
        hser: QLX := empty()
        for cusp in cusps y repeat hser.cusp := laurentExpansion(y.cusp)
        hser


















)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
