-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018, 2020-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
warnPrint(x,y) ==> tracePrint(x,y)
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Finding co-factors for sifted (generalized) Eta-Quotients}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The package \code{QEtaCofactorSpace} implements functions to help
  turning a sifted eta-quotient into a modular function by finding an
  appropriate cofactor.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu_RamanujanKolberg_2015} and also for
\cite[Sect.~10]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.

Assume that we are given a series
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
\end{gather*}
and want to express $\sum_{n=0}^\infty a(mn+t) q^n$ where $m$ and $M$
are a positive integers with $m|M$, $r\in R(M)$, and
$t\in\Set{0,\ldots,m-1}$ as a $\setQ$-linear combination of
eta-quotients and (maybe) an appropriate power of
$q^{1/24}=\unityPowerTau{\frac{1}{24}}=\unityPower{\frac{\tau}{24}}$.

For mathematical background see \PathName{qeta.tex}.

As an extensionn of the above problem, we assume that
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  g_{\bar{r}}(\tau)
\end{gather*}
is given by \ref{eq:g_rbar(tau)}.

By multiplication with a prefactor, we want to make
$\sum_{n=0}^\infty a(mn+t) q^n$ into a modular function for
$\Gamma_0(N)$ or $\Gamma_1(N)$ (for a suitable positive number $N$).
In case of $\Gamma_0(N)$, the sum might have to be multiplied with
similar sums in order to take care of the fact that by an arbitrary
transformation with a matrix from $\Gamma_0(N)$ we might come to a sum
with a different $t$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
VZ ==> Vector Z
MZ ==> Matrix Z -- consider only 2x2 matricies
MQ ==> Matrix Q
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
INDICES ==> LLZ
QETAAUX ==> QEtaAuxiliaryPackage
SPEC ==> QEtaSpecification

asN x ==> x pretend N
asP x ==> x pretend P

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]

ECS ==> Record(indices:INDICES, particular:Union(VZ,"failed"), basis:List VZ)
ECSS ==> Record(comatrix: MZ, rhs: VZ)
SOL ==> Record(particular: Union(VZ, "failed"), basis: List VZ)

-- Note that in the following correspondence between programming variables
-- and notation in the mathematical description in qetaq.tex.
-- Variable   <--> mathematical notation
-- m               m
-- mm              M
-- nn              N
-- sigmaInfty      \sigmainfty{r}

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaCofactorSpace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev package QETACOFS QEtaCofactorSpace
QEtaCofactorSpace: Exports == Implementation where
  Exports ==> with
    etaCofactorSpace0System: (P, SPEC, P, N, INDICES) -> ECSS
      ++ etaCofactorSpace0System(nn,rsoec,m,t,idxs) returns a matrix
      ++ mat and a vector v such that for the integer solutions s of
      ++ the equation mat*s=v it holds modularGamma0?(sspec,rspec,m,t)
      ++ where sspec results from the list of the first #idxs entries
      ++ of s. With idxs one can specify what indexes should be
      ++ allowed in the solution space.
    etaCofactorSpace1System: (P, SPEC, P, N, INDICES) -> ECSS
      ++ etaCofactorSpace1System(nn,rspec,m,t,idxs) returns a matrix
      ++ mat and a vector v such that for the integer solutions s of
      ++ the equation mat*s=v it holds modularGamma1?(sspec,rspec,m,t)
      ++ where sbar is the translation of s into a generalized
      ++ eta-quotient specification, see
      ++ generalizedEtaQuotientSpecification. With idxs one can
      ++ specify what indexes should be allowed in the solution space.
    etaCofactorSpace0: (P, SPEC, P, N, INDICES) -> ECS
      ++ etaCofactorSpace0(nn,rspec,m,t,idxs) returns a vector v and the
      ++ basis of a space such that #v=#idxs  and
      ++ modularGamma0?(nn,members(s),rspec,m,t) is true for any
      ++ s = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
      ++ The indices part of the result is a list of divisors of
      ++ nn where each divisor is represented as a one-element list.
    etaCofactorSpace1: (P, SPEC, P, N, INDICES) -> ECS
      ++ etaCofactorSpace1(nn,rspec,m,t,idxs) returns a vector v and
      ++ the basis of a space such that #v=#idxs and
      ++ modularGamma1?(sspec,rspec,m,t) is true for any
      ++ sbar = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
      ++ The indices part of the result is equal to idxs and
      ++ corresponds to the entries of the solution vectors.
      ++ If idxs=[] then the computation is done for
      ++ idxs=generalizedEtaFunctionIndices(nn)$QETAAUX..
    etaCofactorSpace0: (P, SPEC, P, N) -> ECS
      ++ etaCofactorSpace0(nn,rspec,m,t) returns
      ++ etaCofactorSpace0(nn,rspec,m,t,idxs) for
      ++ idxs=etaFunctionIndices(nn)$QETAAUX.
    etaCofactorSpace1: (P, SPEC, P, N) -> ECS
      ++ etaCofactorSpace1(nn,rspec,m,t) returns
      ++ etaCofactorSpace1(nn,rspec,m,t,idxs) for
      ++ idxs=generalizedEtaFunctionIndices(nn)$QETAAUX.
    alphaInfinity: (SPEC, SPEC, P, List N) -> Z
      ++ alphaInfinity(sspec,rspec,m,orb) implements the definition
      ++ \eqref{eq:alphabarInfinity} and \eqref{eq:alphaInfinity},
      ++ i.e., the definition of Radu in
      ++ \cite{Radu_RamanujanKolberg_2015},
      ++ DOI=10.1016/j.jsc.2017.02.001,
      ++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
      ++ and can also be extracted from from formula (10.4) of
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
      ++ when the respective cofactor part is taken into account. Note
      ++ that it does not agree with \alpha(t) as defined in
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.

  Implementation ==> add
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FL ==> List Record(flag: fUnion, factor: Z, exponent: N)
    DIVISIBLEBY?(k, z) ==> zero?(z rem k)

    -- local
    etaCofactorSpace(ecss: ECSS, idxs: INDICES): ECS ==
        mat: MZ := ecss.comatrix
        v := ecss.rhs
        -- Now we have a matrix mat and a right-hand side v and need to
        -- solve mat*x=v for x.
        sol: SOL := diophantineSystem(mat, v)$SmithNormalForm(Z, VZ, VZ, MZ)
        n := #idxs
        sol.particular case "failed" => [idxs, "failed", []]
        part: VZ := ((sol.particular)::VZ)(1..n)
        bas: List VZ := [x(1..n) for x in sol.basis]
        [idxs, part, bas]

    etaCofactorSpace0System(nn:P, rspec:SPEC, m:P, t:N, idxs:INDICES): ECSS ==
        import from QEtaCofactorConditions
        not conditionCoEtaQuotientGamma0?(nn, rspec, m, t)$QEtaCofactorConditions =>
            error "conditionCoEtaQuotientGamma0 not met"

        -- Setup matrix.
        matmod0: MZ := matrixModularGamma0(nn, idxs)$QETAAUX

        -- Setup right-hand side.
        w: Z := reduce(_+, pureExponents rspec, 0)$List(Z)
        sigmaInfty: Z := numer sigmaInfinity rspec
        sigma0: Z := sigma0 rspec
        orb: List N := modularGamma0Orbit(rspec, m, t)$QEtaCofactorConditions
        orbitSize: Z := # orb
        nu: Z := chiExponent(rspec, m, t)
        nr: N := nrows matmod0
        v: Vector Z := new(nr, 0)
        v.1 := - orbitSize * w                   -- \ref{eq:Radu-sum=0}
        v2 := - nu - orbitSize * m * sigmaInfty  -- \ref{eq:Radu-sigmainfinity}
        v.2 := positiveRemainder(v2, 24)
        x: Z := orbitSize * m * nn * sigma0
        v3 := - ((x exquo level rspec)::Z)       -- \ref{eq:Radu-sigma0}
        v.3 := positiveRemainder(v3, 24)
        fl: FL := factorList factor nn
        -- Determine the cofactor according to (37) of
        -- \cite{Radu_RamanujanKolberg_2015} for each prime separately.
        -- Or see \ref{eq:Radu-productsquare} in qeta.tex.
        if even? orbitSize then
            for i in 1..#fl for fe in fl repeat qsetelt!(v, i+3, 0)
        else
            for i in 1..#fl for fe in fl repeat
                p: P := asP(fe.factor) -- extract prime factor
                em: N := primePower(m, p)$QETAAUX
                e: Z := 0
                for l in purePart rspec | odd? specExponent l repeat -- exponent
                    e := e + em + primePower(specDelta l, p)$QETAAUX
                qsetelt!(v, i+3, positiveRemainder(e, 2))
        return [matmod0, v]

    etaCofactorSpace0(nn: P, rspec: SPEC, m: P, t: N, idxs: INDICES): ECS ==
        not pure? rspec => error "specification is not for a pure eta-quotient"
        if empty? idxs then idxs := etaFunctionIndices(nn)$QETAAUX
        ecss: ECSS := etaCofactorSpace0System(nn, rspec, m, t, idxs)
        etaCofactorSpace(ecss, idxs)

    etaCofactorSpace0(nn: P, rspec: SPEC, m: P, t: N): ECS ==
        etaCofactorSpace0(nn, rspec, m, t, [])

    -- Compute the common denominator den of the rowidx-th row of mat1
    -- and the value rval intended for the right-hand side. Then
    -- multiply the rowidx-th row of mat1 and copy it into the
    -- rowidx-th row of mat. Set also v.rowidx to rval*den.
    -- local
    copyRowAndSetRhs!(mat: MZ, v: VZ, nn: P, rowidx: Z,
                      mat1: MQ, rval: Q): Void ==
        den: Z := lcm [denom mat1(rowidx, j) for j in 1..ncols mat1]
        den := lcm(denom rval, den)
        for j in 1..ncols mat1 repeat mat(rowidx,j) := numer(den*mat1(rowidx,j))
        v.rowidx := numer(den * fractionalPart(rval)$QETAAUX)

    -- loccal
    productSquareElement(idx: LZ, a: Z): Z ==
        empty? idx => error "etaCofactorSpace1System: idx is empty"
        d := idx.1
        #idx=1 => if jacobi(d, a)$INTF < 0 then 1 else 0
        q := (a-1) * fractionalBernoulli1(idx.2/d)$QETAAUX
        not one? denom q =>
            error "etaCofactorSpace1System: e exponent not integral"
        if odd? numer q then 1 else 0

    -- compute the row (condisiont) for the respective a
    -- The result is a list that consists of n row elements prepended
    -- by the respective element for the right-hand side.
    -- This corresponds to condition (4) in
    -- \cite[Thm~10.1]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.
    -- See also \eqref{eq:CDZ-productsquare}.
    -- local
    productSquareRhsRow(rspec: SPEC, m: N, idxs: INDICES, a: Z): LZ ==
        row: LZ := [productSquareElement(idx, a) for idx in idxs]
        -- prepend the entry for the right-hand side
        expo: Q := 0
        for l in properGeneralizedPart rspec repeat --assert(#l=3) l=[d,g,e]
            d := specDelta l; g := specSubindex l; e := specExponent l
            expo := expo + e * fractionalBernoulli1(g/d)$QETAAUX
        expo := (a-1) * expo
        not one? denom expo =>
            error "etaCofactorSpace1System: exponent not integral"
        isOdd?: Boolean := odd? numer expo
        for l in purePart rspec | odd? specExponent l
                                  and jacobi(m*specDelta(l),a)$INTF < 0 repeat
            isOdd? := not isOdd?
        if isOdd? then cons(1, row) else cons(0, row)

    -- Extend the matrix by the product rows (with slack variable conditions).
    -- local
    extendByProductSquareRows(mat: MZ, v: VZ,
                              nn: P, rspec: SPEC, m: N, idxs: INDICES): ECSS ==
        rows: LLZ := [productSquareRhsRow(rspec, m, idxs, a) _
                      for a in 1..11*nn+1 by nn | one? gcd(a, 6)]
        -- remove duplicate lines to reduce slack variables
        rows := [row for row in removeDuplicates rows | not every?(zero?, row)]
        n := #rows
        nr := nrows mat
        nc := ncols mat
        --assert(#v=nr)
        emat: MZ := new(nr + n, nc + n, 0)
        for i in 1..nr repeat for j in 1..nc repeat emat(i,j) := mat(i,j)
        for i in 1..n for row in rows repeat
            v := concat(v, first row)
            for e in rest row for j in 1..nc repeat emat(nr+i,j) := e
            emat(nr + i, nc + i) := 2 -- for slack variable
        return [emat, v]$ECSS

    etaCofactorSpace1System(nn:P, rspec:SPEC, m:P, t:N, idxs:INDICES): ECSS ==
        -- \cite[Thm~10.1]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
        import from QEtaCofactorConditions
        not conditionCoEtaQuotientGamma1?(nn, rspec, m, t) =>
            error "conditionCoEtaQuotientGamma1? not met"
        mat1: MQ := matrixModularGamma1(nn, idxs)$QETAAUX
        mat: MZ := new(nrows mat1, ncols mat1, 0)
        v: VZ := new(nrows mat1, 0)
        nspec: SPEC := purify rspec -- we must normalize!!!
        -----------------------------------------------------------
        -- CDZ Condition (1), \eqref{eq:CDZ-sum=0}
        for j in 1..ncols mat1 repeat mat(1,j) := numer(mat1(1,j))
        v.1 := - reduce(_+, pureExponents nspec, 0) -- fill right-hand side
        -----------------------------------------------------------
        -- For the following two lines:
        -- Since matrixModularGamma1 refers to mod 1 instead of mod 24,
        -- we must divide the sigma-expression by 24.
        -----------------------------------------------------------
        -- CDZ Condition (3), \eqref{eq:CDZ-sigmainfinity=0}
        -- We transform \eqref{eq:CDZ-sigmainfinity=0} into
        -- 1/m * (m^2 sigma + (1 - m^2)*24*t + (1-m^2) * sigma)
        -- = 1/m * (24*t*(1-m^2) + sigma)
        rval: Q := - (1/(24*m))*((24*t*(1-m^2))::Q + sigmaInfinity(nspec))
        copyRowAndSetRhs!(mat, v, nn, 2, mat1, rval)
        -----------------------------------------------------------
        -- CDZ Condition (2), \eqref{eq:CDZ-sigma0=0}
        rval := - nn * m * sigma0(nspec) / (24 * level(nspec))
        copyRowAndSetRhs!(mat, v, nn, 3, mat1, rval)
        -----------------------------------------------------------
        -- CDZ condition (4), \eqref{eq:CDZ-productsquare}
        extendByProductSquareRows(mat, v, nn, rspec, m, idxs)

    etaCofactorSpace1(nn: P, rspec: SPEC, m: P, t: N, idxs: INDICES): ECS ==
        if empty? idxs then idxs := generalizedEtaFunctionIndices(nn)$QETAAUX
        ecss: ECSS := etaCofactorSpace1System(nn, rspec, m, t, idxs)
        etaCofactorSpace(ecss, idxs)

    etaCofactorSpace1(nn: P, rspec: SPEC, m: P, t: N): ECS ==
        etaCofactorSpace1(nn, rspec, m, t, [])

-------------------------------------------------------------------
-- use of conditions from above
-------------------------------------------------------------------

    alphaInfinity(sspec: SPEC, rspec: SPEC, m: P, orb: List N): Z ==
        sbarhat: Q := sigmaInfinity sspec
        rbarhat: Q := sigmaInfinity rspec
        l: List Q := [24*k::Q + rbarhat for k in orb]
        orbsumrbarhat: Q := reduce(_+, l, 0)
        alpha: Q := (1/24)*(sbarhat + (1/m)*orbsumrbarhat)
        not one? denom alpha => error "alpha not an integer"
        return numer alpha

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
