-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018, 2020-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
warnPrint(x,y) ==> tracePrint(x,y)
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Finding co-factors for sifted (generalized) Eta-Quotients}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The package \code{QEtaCofactorSpace} implements functions to help
  turning a sifted eta-quotient into a modular function by finding an
  appropriate cofactor.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu_RamanujanKolberg_2015} and also for
\cite[Sect.~10]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.

Assume that we are given a series
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
\end{gather*}
and want to express $\sum_{n=0}^\infty a(mn+t) q^n$ where $m$ and $M$
are a positive integers with $m|M$, $r\in R(M)$, and
$t\in\Set{0,\ldots,m-1}$ as a $\setQ$-linear combination of
eta-quotients and (maybe) an appropriate power of
$q^{1/24}=\unityPowerTau{\frac{1}{24}}=\unityPower{\frac{\tau}{24}}$.

For mathematical background see \PathName{qeta.tex}.

As an extensionn of the above problem, we assume that
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  g_{\bar{r}}(\tau)
\end{gather*}
is given by \ref{eq:g_rbar(tau)}.

By multiplication with a prefactor, we want to make
$\sum_{n=0}^\infty a(mn+t) q^n$ into a modular function for
$\Gamma_0(N)$ or $\Gamma_1(N)$ (for a suitable positive number $N$).
In case of $\Gamma_0(N)$, the sum might have to be multiplied with
similar sums in order to take care of the fact that by an arbitrary
transformation with a matrix from $\Gamma_0(N)$ we might come to a sum
with a different $t$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
VZ ==> Vector Z
MZ ==> Matrix Z -- consider only 2x2 matricies
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
QETAAUX ==> QEtaAuxiliaryPackage
SPEC ==> QEtaSpecification

asN x ==> x pretend N
asP x ==> x pretend P

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]

ECS ==> Record(indices: LLZ, particular: Union(VZ, "failed"), basis: List VZ)
ECSS ==> Record(comatrix: MZ, rhs: VZ)
SOL ==> Record(particular: Union(VZ, "failed"), basis: List VZ)

SIGMAINFINITY ==> sigmaInfinity $ QETAAUX
SIGMA0 ==> sigma0 $ QETAAUX

-- Note that in the following correspondence between programming variables
-- and notation in the mathematical description in qetaq.tex.
-- Variable   <--> mathematical notation
-- m               m
-- mm              M
-- nn              N
-- sigmaInfty      \sigmainfty{r}

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaCofactorSpace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev package QETACOFS QEtaCofactorSpace
QEtaCofactorSpace: Exports == Implementation where
  Exports ==> with
    etaCofactorSpace0System: (P, SPEC, P, N) -> ECSS
      ++ etaCofactorSpace0System(nn, rsoec, m, t) returns a matrix mat
      ++ and a vector v such that for the integer solutions s of the
      ++ equation mat*s=v it holds
      ++ modularGamma0?(ssoec,rspec,m,t) where sspec results from
      ++ the list of the first #divisors(nn) entries of s.
    etaCofactorSpace1System: (P, SPEC, P, N) -> ECSS
      ++ etaCofactorSpace1System(nn, rspec, m, t) returns a matrix
      ++ mat and a vector v such that for the integer solutions s of
      ++ the equation mat*s=v it holds
      ++ modularGamma1?(sspec,rspec,m,t) where sbar is the
      ++ translation of s into a generalized eta-quotient
      ++ specification, see generalizedEtaQuotientSpecification.
    etaCofactorSpace0: (P, SPEC, P, N) -> ECS
      ++ etaCofactorSpace0(nn,rspec,m,t) returns a vector v and the
      ++ basis of a space such that #v=#divisors(nn) and
      ++ modularGamma0?(nn,members(s),rspec,m,t) is true for any
      ++ s = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
      ++ The indices part of the result is a list of divisors of
      ++ nn where each divisor is represented as a one-element list.
    etaCofactorSpace1: (P, SPEC, P, N, LLZ) -> ECS
      ++ etaCofactorSpace1(nn,rspec,m,t,idxs) returns a vector v and
      ++ the basis of a space such that #v=#idxs and
      ++ modularGamma1?(ssepc,rspec,m,t) is true for any
      ++ sbar = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
      ++ The indices part of the result is equal to idxs and
      ++ corresponds to the entries of the solution vectors.
      ++ If idxs=[] then the computation is done for
      ++ idxs=generalizedEtaFunctionIndices(nn)$QETAAUX..
    etaCofactorSpace1: (P, SPEC, P, N) -> ECS
      ++ etaCofactorSpace1(nn,rspec,m,t) returns
      ++ etaCofactorSpace1(nn,rspec,m,t,idxs) for
      ++ idxs=generalizedEtaFunctionIndices(nn)$QETAAUX.
    alphaInfinity: (SPEC, SPEC, P, List N) -> Z
      ++ alphaInfinity(sspec,rspec,m,orb) implements the definition
      ++ \eqref{eq:alphabarInfinity} and \eqref{eq:alphaInfinity},
      ++ i.e., the definition of Radu in
      ++ \cite{Radu_RamanujanKolberg_2015},
      ++ DOI=10.1016/j.jsc.2017.02.001,
      ++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
      ++ and can also be extracted from from formula (10.4) of
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
      ++ when the respective cofactor part is taken into account. Note
      ++ that it does not agree with \alpha(t) as defined in
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.

  Implementation ==> add
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FL ==> List Record(flag: fUnion, factor: Z, exponent: N)
    DIVISIBLEBY?(k, z) ==> zero?(z rem k)

    etaCofactorSpace0System(nn: P, rspec: SPEC, m: P, t: N): ECSS ==
        import from QEtaCofactorConditions
        not conditionCoEtaQuotientGamma0?(nn, rspec, m, t) =>
            error "conditionCoEtaQuotientGamma0 not met"

        -- Setup matrix.
        matmod0: MZ := matrixModularGamma0(nn)$QETAAUX

        -- Setup right-hand side.
        w: Z := reduce(_+, pureExponents rspec, 0)$List(Z)
        sigmaInfty: Z := numer sigmaInfinity rspec
        sigma0: Z := sigma0 rspec
        orb: List N := modularGamma0Orbit(rspec, m, t)$QEtaCofactorConditions
        orbitSize: Z := # orb
        nu: Z := chiExponent(rspec, m, t)
        nr: N := nrows matmod0
        v: Vector Z := new(nr, 0)
        v.1 := - orbitSize * w                   -- \ref{eq:Radu-sum=0}
        v2 := - nu - orbitSize * m * sigmaInfty  -- \ref{eq:Radu-sigmainfinity}
        v.2 := positiveRemainder(v2, 24)
        x: Z := orbitSize * m * nn * sigma0
        v3 := - ((x exquo level rspec)::Z)       -- \ref{eq:Radu-sigma0}
        v.3 := positiveRemainder(v3, 24)
        fl: FL := factorList factor nn
        -- Determine the cofactor according to (37) of
        -- \cite{Radu_RamanujanKolberg_2015} for each prime separately.
        -- Or see \ref{eq:Radu-productsquare} in qeta.tex.
        if even? orbitSize then
            for i in 1..#fl for fe in fl repeat qsetelt!(v, i+3, 0)
        else
            for i in 1..#fl for fe in fl repeat
                p: P := asP(fe.factor) -- extract prime factor
                em: N := primePower(m, p)$QETAAUX
                e: Z := 0
                for l in purePart rspec | odd?(l.2) repeat -- exponent
                    e := e + em + primePower(asP(l.1), p)$QETAAUX -- l.1=delta
                qsetelt!(v, i+3, positiveRemainder(e, 2))
        return [matmod0, v]

    etaCofactorSpace0(nn: P, rspec: SPEC, m: P, t: N): ECS ==
        not pure? rspec => error "specification is not for a pure eta-quotient"
        ecss: ECSS := etaCofactorSpace0System(nn, rspec, m, t)
        matmod0 := ecss.comatrix
        v := ecss.rhs
        -- Now we have a matrix mat and a right-hand side v and need to
        -- solve mat*x=v for x.
        sol: SOL := diophantineSystem(matmod0, v)$SmithNormalForm(Z, VZ, VZ, MZ)
        nndivs := DIVISORS nn
        idxs: LLZ := [[d] for d in nndivs]
        sol.particular case "failed" => [idxs, "failed", []]
        n := #nndivs
        part: VZ := ((sol.particular)::VZ)(1..n)
        bas: List VZ := [x(1..n) for x in sol.basis]
        [idxs, part, bas]

    etaCofactorSpace1System(nn: P, rspec: SPEC, m: P, t: N): ECSS ==
        -- \cite[Thm~10.1]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
        import from QEtaCofactorConditions
        not conditionCoEtaQuotientGamma1?(nn, rspec, m, t) =>
            error "conditionCoEtaQuotientGamma1? not met"

        nndivs: List P := DIVISORS nn
        numOfVars: N := lengthOfGeneralizedEtaFunctionIndices(nn)$QETAAUX

        -- rows/cols for condition (4)
        k: N := 0 -- need k more rows and k slack variable
        for i in 1..11 repeat if one? gcd(i*nn+1, 6) then k := k + 1

        cols: N := numOfVars+k+2 -- the 2 is for mod 24 slack variables
        rows: N := k+3 -- for conditions (4) + conditions (1), (2), (3)
        -- The matrix columns correspond to the following variables
        -- (in this order).
        -- [a(d) for d in nndivs]
        -- [[a(d,g) for g in 1..ceiling(d/2)-1] for d in nndivs]
        mat: MZ := new(rows, cols, 0)
        v: VZ := new(rows, 0)

        r: LZ := pureExponents rspec
        rtilde: LLZ := properGeneralizedPart rspec
        n: Z := # nndivs

        -----------------------------------------------------------
        ii: Z := 1 -- the row index
        -- CDZ Condition (1), \eqref{eq:CDZ-sum=0}
        for j in 1..n repeat qsetelt!(mat, ii, j, 1)
        v.ii := - reduce(_+, r, 0) -- fill right-hand side
        -----------------------------------------------------------
        -- CDZ Condition (3) and slack variable for mod 24
        -- \eqref{eq:CDZ-sigmainfinity=0}
        -- We multiply the entries and the rhs by nn to remove denominators.
        ii := ii + 1
        jj := 0
        for d in nndivs for j in 1..n repeat
            qsetelt!(mat, ii, j, nn*d)
            for g in 1..ceiling(d/2)$Q -1 repeat
                jj := jj + 1
                x: Z := numer(12*nn*d*fractionalBernoulli2(g/d)$QETAAUX)
                qsetelt!(mat, ii, n + jj, x)
        qsetelt!(mat, ii, numOfVars+1, 24*nn) -- slack variable for (mod 24)

        mm: P := level rspec
        --assert(DIVISIBLEBY?(mm, nn))
        -- fill the right-hand side
        nnrbarhat: Z := numer(nn*sigmaInfinity(rspec)) -- is integral
        q:Q := (nnrbarhat + 24*t*(1-m^2)*nn)/m -- is integral
        -- Security check. Should never fail because of Condition 8 on page 37
        -- of \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.
        not one? denom q =>
            error "etaCofactorSpace1System: not divisible by m"
        v.ii := positiveRemainder(- numer q, 24*nn)

        -----------------------------------------------------------
        -- CDZ Condition (2) and slack variable for mod 24
        -- \eqref{eq:CDZ-sigma0=0}
        ii := ii + 1
        jj: Z := 0
        for d in nndivs for j in 1..n repeat
            nnd := numer(nn/d)
            qsetelt!(mat, ii, j, nnd)
            for g in 1..ceiling(d/2)-1 repeat
                jj := jj + 1
                qsetelt!(mat, ii, n + jj, 2*nnd)
        qsetelt!(mat, ii, numOfVars+2, 24) -- slack variable for (mod 24)
        --assert(DIVISIBLEBY?(mm, nn))
        v.ii := - m * ((nn exquo mm)::Z) * sigma0(rspec) -- fill right-hand side

        -----------------------------------------------------------
        -- Condition (4) and slack variable for mod 2 for all a
        -- \eqref{eq:CDZ-productsquare}
        mmdivs: List P := divisors rspec
        for i in 1..11 repeat
            a: Z := nn*i+1
            one? gcd(a,6) =>
                ii := ii + 1
                -- setEntries!(mat, v, n, ii, ...)
                jj := 0
                for d in nndivs for j in 1..n repeat
                    if jacobi(d, a) < 0 then qsetelt!(mat, ii, j, 1)
                    for g in 1..ceiling(d/2)-1 repeat
                        jj := jj + 1
                        q := (a-1) * (g/d-1/2)
                        not one? denom q =>
                            error "etaCofactorSpace1System: e exponent not integral"
                        if odd? numer q then qsetelt!(mat, ii, n + jj, 1)
                -- slack variable for (mod 2)
                qsetelt!(mat, ii, numOfVars+ii-1, 2)

                -- fill right-hand side
                expo: Q := 0
                for l in rtilde repeat --assert(#l=3) -- l=[d,g,e]
                    expo := expo + (l.2/l.1 - 1/2) * l.3 -- (g/d-1/2)*e
                expo := (a-1) * expo
                not one? denom expo =>
                    error "etaCofactorSpace1System: exponent not integral"
                isOdd?: Boolean := odd? numer expo
                for d in mmdivs for rd in r | odd? rd repeat
                    if jacobi(m*d, a) < 0 then isOdd? := not isOdd?
                if isOdd? then v.ii := 1 -- else v.ii := 0
        return [mat, v]$ECSS

    etaCofactorSpace1(nn: P, rspec: SPEC, m: P, t: N, idxs: LLZ): ECS ==
        ecss: ECSS := etaCofactorSpace1System(nn, rspec, m, t)
        v := ecss.rhs
        -- Now we have a matrix mat and a right-hand side v and need to
        -- solve mat*x=v for x.
        allIndices := generalizedEtaFunctionIndices(nn)$QETAAUX
        if empty? idxs then
            idxs := allIndices
            mat: MZ := ecss.comatrix
          else
            -- The first columns of the above matrix are sorted like
            -- allIndices. We build a new matrix that consists of all
            -- columns with index > #allIndices prepended by the columns
            -- corresponding to idxs.
            -- It is an error if idxs is not a subset of allIndices.
            lcols: LZ := [i for i in #allIndices+1 .. ncols(ecss.comatrix)]

            h: XHashTable(LZ, Z) := table()
            for idx in reverse idxs repeat
                c := position(idx, allIndices)
                zero? c =>
                    errorPrint("forbidden", idx)
                    errorPrint("allowed", allIndices)
                    error "etaCofactorSpace1: forbidden index"
                lcols := cons(c, lcols)
            mat: MZ := (ecss.comatrix)(1..nrows(ecss.comatrix), lcols)

        sol: SOL := diophantineSystem(mat, v)$SmithNormalForm(Z, VZ, VZ, MZ)
        n := #idxs
        sol.particular case "failed" => [idxs, "failed", []]
        part: VZ := ((sol.particular)::VZ)(1..n)
        bas: List VZ := [x(1..n) for x in sol.basis]
        [idxs, part, bas]

    etaCofactorSpace1(nn: P, rspec: SPEC, m: P, t: N): ECS ==
        etaCofactorSpace1(nn, rspec, m, t, [])

-------------------------------------------------------------------
-- use of conditions from above
-------------------------------------------------------------------

    alphaInfinity(sspec: SPEC, rspec: SPEC, m: P, orb: List N): Z ==
        sbarhat: Q := sigmaInfinity sspec
        rbarhat: Q := sigmaInfinity rspec
        l: List Q := [24*k::Q + rbarhat for k in orb]
        orbsumrbarhat: Q := reduce(_+, l, 0)
        alpha: Q := (1/24)*(sbarhat + (1/m)*orbsumrbarhat)
        not one? denom alpha => error "alpha not an integer"
        return numer alpha

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
