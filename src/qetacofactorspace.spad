-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018, 2020-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Finding co-factors for sifted (generalized) Eta Functions}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The package \code{QEtaCoFactorSpace} implements functions to help
  turning a sifted eta quotient into a modular function by finding an
  appropriate cofactor.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu:RamanujanKolberg:2015} and also for
\cite[Sect.~10]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

Assume that we are given a series
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
\end{gather*}
and want to express $\sum_{n=0}^\infty a(mn+t) q^n$ where $m$ and $M$
are a positive integers with $m|M$, $r\in R(M)$, and
$t\in\Set{0,\ldots,m-1}$ as a $\setQ$-linear combination of
eta-quotients and (maybe) an appropriate power of
$q^{1/24}=\unityPower{\frac{\tau}{24}}$.

For mathematical background see \PathName{qetaquot.spad}.

As an extensionn of the above problem, we assume that
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  g_{\bar{r}}(\tau)
\end{gather*}
is given by \ref{eq:g_rbar(tau)}.

By multiplication with a prefactor, we want to make
$\sum_{n=0}^\infty a(mn+t) q^n$ into a modular function for
$\Gamma_0(N)$ or $\Gamma_1(N)$ (for a suitable positive number $N$).
In case of $\Gamma_0(N)$, the sum might have to be multiplied with
similar sums in order to take care of the fact that by an arbitrary
transformation with a matrix from $\Gamma_0(N)$ we might come to a sum
with a different $t$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

asN x ==> x pretend N
asP x ==> x pretend P

VZ ==> Vector Z
MZ ==> Matrix Z
EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
QETAAUX ==> QEtaAuxiliaryPackage

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]

SIGMAINFINITY ==> sigmaInfinity $ QETAAUX
SIGMA0 ==> sigma0 $ QETAAUX

-- Note that in the following correspondence between programming variables
-- and notation in the mathematical description in qetaquot.spad.
-- Variable   <--> mathematical notation
-- m               m
-- mm              M
-- nn              N
-- sigmaInfty      \sumdelta{r}
-- kappa(m)        \kappa

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaCoFactorSpace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev package QETACOFS QEtaCoFactorSpace
QEtaCoFactorSpace: Exports == Implementation where
  Exports ==> with
    conditionPrimeDivisors?: (P, P) -> Boolean
      ++ conditionExponentSum?(nn, m) returns true if every prime
      ++ divisor of m is also a divisor of nn. This corresponds to
      ++ (28) in \cite{Radu:RamanujanKolberg:2015} and to
      ++ \eqref{eq:p|m=>p|N} in qetaquot.spad.

    conditionMmN?: (P, P, LZ, P) -> Boolean
      ++ conditionMmN(nn, mm, r, m) returns true if every divisor d of
      ++ mm (for which r_d is non-zero) is also a devisor of m*N. This
      ++ corresponds to condition (4.7) in \cite{Radu:PhD:2010} and in
      ++ equation \eqref{eq:delta|M=>delta|mN} in qetaquot.spad.

    conditionSigma0?: (P, P, LZ, P) -> Boolean
      ++ conditionSigma0?(nn, mm, r, m) returns true if
      ++ (kappa(m)*m*nn^2/mm)*sigma0(nn, r) = 0 mod 24. This
      ++ corresponds to \eqref{eq:sv24} in qetaquot.spad and to the
      ++ first condition on page~241 of
      ++ \cite{Radu:RamanujanKolberg:2015} (Definition 35).

    conditionGSigma0?: (P, P, LLZ, P) -> Boolean
      ++ conditionSigma0?(nn, mm, gr, m) returns true if
      ++ (kappa(m)*m*nn^2)*sum(g*e/d for [d,g,e] in gr) = 0 mod 2.
      ++ This corresponds to condition 3 on page 37 of Chapter 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

    conditionSigma0?: (P, P, LLZ, P) -> Boolean
      ++ conditionSigma0?(nn, mm, gr, m) returns true if
      ++ (kappa(m)*m*nn^2)*sum(e/d for [d,g,e] in gr) = 0 mod 12.
      ++ This corresponds to condition 5 on page 37 of Chapter 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

    conditionSumExponents?: (P, LZ, P) -> Boolean
      ++ conditionSumExponents?(nn, r, m) returns true if the sum of
      ++ the entries of s multiplied by kappa(m)*nn is divisible by 8.
      ++ This corresponds to \eqref{eq:sum-r} in qetaquot.spad second
      ++ condition on page~241 of \cite{Radu:RamanujanKolberg:2015}
      ++ (Definition 35).

    conditionSumExponents?: (P, LLZ, P) -> Boolean
      ++ conditionSumExponents?(nn, gr, m) returns true if the sum of
      ++ the entries (corresponding to the exponents) of gr multiplied
      ++ by kappa(m)*nn is divisible by 4.
      ++ This corresponds to condition 4 on page 37 of Chapter 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

    conditionNDivisor?: (P, P, LZ, P, N) -> Boolean
      ++ conditionNDivisor?(nn, mm, r, m, t) returns true if the
      ++ expression
      ++ (24*m)/gcd(kappa(m)*(-24*t-sigmaInfinity(mm,r)),24*m) is a
      ++ divisor of nn. This corresponds to \eqref{eq:w|N} in
      ++ qetaquot.spad third condition on page~241 of
      ++ \cite{Radu:RamanujanKolberg:2015} (Definition 35).

    conditionNDivisor?: (P, P, LZ, LLZ, P, N) -> Boolean
      ++ conditionNDivisor?(nn, mm, r, gr, m, t) returns true if the
      ++ expression (24*m*mm)/gcd(mm*kappa(m)*alpha, 24*m*mm) is a
      ++ divisor of nn where
      ++ alpha=-mm(sigmaInfinity(mm,r)+12*sum(d*fractionalBernoulli2(g/d)*e
      ++ for [d,g,e] in gr)+24*mm*t).
      ++ This corresponds to condition 7 on page 37 of Chapter 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

    conditionEvenMultiplier?: (P, P, LZ, P) -> Boolean
      ++ conditionEvenMultiplier?(nn, mm, r, m) returns true if
      ++ various divisibility conditions are fulfilled.
      ++ This corresponds to \eqref{eq:even-m} in
      ++ qetaquot.spad fourth condition on page~241 of
      ++ \cite{Radu:RamanujanKolberg:2015} (Definition 35).

    conditionCoEtaQuotientGamma0?: (P, P, LZ, P, N) -> Boolean
      ++ conditionCoEtaQuotientGamma0?(nn, mm, r, m, t) returns
      ++ true iff all the conditions for the parameters are fulfilled.
      ++ This checks whether (nn, mm, r, m, t) is in \Delta^* as
      ++ defined in
      ++ Definition~\ref{def:condition-co-eta-quotient-gamma0} in
      ++ qetaquot.spad and in Definition 35 of
      ++ \cite{Radu:RamanujanKolberg:2015}

    conditionCoEtaQuotientGamma1?: (P, P, LZ, P, N) -> Boolean
      ++ conditionCoEtaQuotientGamma1?(nn, mm, r, m, t) returns true
      ++ iff the conditions of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
      ++ just before Theorem 2.1 are fulfilled. These are slight
      ++ modifications of conditions appearing in Definition 35 of
      ++ \cite{Radu:RamanujanKolberg:2015}.

    conditionCoEtaQuotientGamma1?: (P, P, LLZ, P, N) -> Boolean
      ++ conditionCoEtaQuotientGamma01?(nn, mm, rr, m, t) returns true
      ++ iff the conditions in Chapter 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
      ++ just before Theorem 10.1 are fulfilled. These are conditions
      ++ for the existence of a product of eta- and generalized
      ++ eta-quotient to exist as a cofactor for a disection of such a
      ++ quotient.
      ++ The parameter rr specifies the generalized eta-quotient via
      ++ generalizedEtaQuotient(rr).

    conditionOrbitLength?: (P, P, LZ, P, N) -> Boolean
      ++ conditionOrbitLength?(nn, mm, r, m, t) returns true if the
      ++ conditions for an orbit of length 1 are satisfied.
      ++ This corresponds to condition 7 on page 6 of Chapter 2 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

    conditionOrbitLength?: (P, P, LZ, LLZ, P, N) -> Boolean
      ++ conditionOrbitLength?(nn, mm, r, gr, m, t) returns true if
      ++ the conditions for an orbit of length 1 are satisfied. This
      ++ corresponds to condition 10 on page 37 of Chapter 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.
      ++ The parameters r and gr specify the defining eta-quotient and
      ++ generalized eta-quotient part.

    minimalLevelCoEtaQuotientGamma0: (P, LZ, P, N) -> P
      ++ minimalLevelCoEtaQuotientGamma0(mm, r, m, t) returns the
      ++ smallest nn such that conditionCoEtaQuotientGamma0?(nn, mm,
      ++ r, m, t) is true, i.e. that (nn, mm, r, m, t) is an element
      ++ of \Delta^* as defined in
      ++ Definition~\ref{def:condition-co-eta-quotient-gamma0}.

    minimalLevelCoEtaQuotientGamma1: (P, LZ, P, N) -> P
      ++ minimalLevelCoEtaQuotientGamma1(mm, r, m, t) returns the
      ++ smallest nn such that conditionCoEtaQuotientGamma1?(nn, mm,
      ++ r, m, t) is true, i.e. that (nn, mm, r, m, t) fulfills the 7
      ++ conditions as defined in Section 2 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

    minimalLevelCoEtaQuotientGamma1: (P, LLZ, P, N) -> P
      ++ minimalLevelCoEtaQuotientGamma1(mm, rr, m, t) returns the
      ++ smallest nn such that
      ++ conditionCoEtaQuotientGamma1?(nn,mm,rr,m,t) is true, i.e.
      ++ that (nn,mm,rr m,t) fulfills the 10 conditions as defined in
      ++ Section 10 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.
      ++ The parameter rr specifies the generalized eta-quotient via
      ++ generalizedEtaQuotient(rr).

    modularGamma0?: (P, LZ, P, LZ, P, N) -> Boolean
      ++ modularGamma0?(nn, s, mm, r, m, t) returns true iff all
      ++ the conditions of Theorem~\ref{thm:RaduConditions} are
      ++ fulfilled.
      ++ Compare with modularGamma0? from QEtaAuxiliaryPackage.

    modularGamma1?: (P, LLZ, P, LLZ, P, N) -> Boolean
      ++ modularGamma1?(nn, ss, mm, rr, m, t) returns true iff all the
      ++ conditions of Theorem~10.1 of
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.
      ++ are fulfilled. Here the parameter ss stands for the exponents
      ++ a_\delta and a_{\delta,g}.

    orbit: (Z, P, N) -> List N
      ++ orbit(sigmaInfty, m, t) computes the elements of
      ++ $\modularOrbit{r,m,t)$ as defined in qetaquot.spad,
      ++ \cite[Def.~42]{Radu:RamanujanKolberg:2015} and
      ++ \cite[Lemma 4.35]{Radu:PhD:2010}.
      ++ We assume $sigmaInfty = \sum_{\delta|M} \delta r_\delta$.
    orbit: (P, List Z, P, N) -> List N
      ++ orbit(mm, r, m, t) computes the elements of
      ++ $\modularOrbit{r,m,t)$ as defined in qetaquot.spad,
      ++ \cite[Def.~42]{Radu:RamanujanKolberg:2015} and
      ++ \cite[Lemma 4.35]{Radu:PhD:2010}.
      ++ orbit(r, m, t) returns the same as
      ++ orbit(sigmaInfinity(mm, r), m, t).
      ++ We assume $sigmaInfty = \sum_{\delta|M} \delta r_\delta$.
    chiExponent: (Z, P, List N) -> Z
      ++ chiExponent(sigmaInfty, m, orb) computes e such that
      ++ $\exp(2\pi i e / 24) = \chi_{r,m,t)$.
      ++ We assume $sigmaInfty = \sum_{\delta|mm} \delta r_\delta$.
      ++ See Lemma \ref{thm:chi-exponent}.
      ++ Furthermore, we assume that orb = orbit(sigmaInfty, m, t).
    etaCoFactorSpace: (P, P, List Z, P, N) -> Record(particular: Union(VZ, "failed"), basis: List VZ)
      ++ etaCoFactorSpace(nn, mm, r, m, t) returns a vector v and the
      ++ basis of a space such that #v=#divisors(nn) and
      ++ modularGamma0?(nn, members s, mm, r, m, t) is true for any
      ++ s = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
    etaCoFactorSpace: (P, P, LLZ, P, N) -> Record(particular: Union(VZ, "failed"), basis: List VZ)
      ++ etaCoFactorSpace(nn, mm, rr, m, t) returns a vector v and the
      ++ basis of a space such that #v=#divisors(nn) and
      ++ modularGamma1?(nn, ss, mm, r, m, t) is true for any
      ++ ss = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
    alphaInfinity: (P, LZ, P, LZ, P, N) -> Z
      ++ If modularGamma0?(nn, s, mm, r, m, t) then
      ++ alphaInfinity(nn, s, mm, r, m, t) computes the order of the
      ++ q-expansion of $F_{s, r, m, t}$ as defined in qetaquot.spad,
      ++ see~\eqref{eq:alphaInfinity}. It is the same as the \alpha as
      ++ defined in the abstract of \cite{Radu:RamanujanKolberg:2015},
      ++ DOI=10.1016/j.jsc.2017.02.001,
      ++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf.

  Implementation ==> add
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FL ==> List Record(flag: fUnion, factor: Z, exponent: N)
    DIVISIBLEBY?(k, z) ==> zero?(z rem k)

    -- auxiliary (local) functions

    -- kappa: P -> P
    --   ++ kappa(m) computes gcd(1-m^2,24).
    kappa(m: P): P == -- gcd(1-m^2, 24)
        ++ \cite[Def.~35]{Radu:RamanujanKolberg:2015}
        (even? m => 1; 8) * (DIVISIBLEBY?(3, m) => 1; 3)

    odotBar(a2: Z, sigmaInfty: Z, m: P, t: N): N ==
        --assert(one? positiveRemainder(a2, 24))
        -- \cite[Def.~41]{Radu:RamanujanKolberg:2015}
        z: Z := positiveRemainder(t*a2+(((a2-1) exquo 24)::Z)*sigmaInfty, m)
        asN z

    -- Return true iff \eqref{eq:Radu-productsquare} holds.
    checkSquare?(nn: P, s: LZ, mm: P, r: LZ, m: P, orbitSize: Z): Boolean ==
        nndivs: LP := DIVISORS nn
        mmdivs: LP := DIVISORS mm
        fl: FL := factorList factor nn
        -- By \eqref{eq:p|m=>p|N} and \eqref{eq:delta|M=>delta|mN}, it is
        -- enough to consider all prime divisors of N.
        for fe in fl repeat -- do for all primes dividing nn
            p: P := asP(fe.factor) -- extract prime factor
            -- Determine whether an even power of p divides
            -- \prod_{\delta|N}\delta^rdelta.
            e1: Z := 0
            for delta in rest nndivs for sdelta in rest s|odd? sdelta repeat
                e1 := e1 + primePower(delta, p)$QETAAUX
            e2: Z := 0
            if odd? orbitSize then
                -- check 2nd prod in eq:Radu-productsquare
                em: N := primePower(m, p)
                -- for all divisors of mm > 1
                if odd? first r then e2 := em -- case: delta=1
                for d in rest mmdivs for rdelta in rest r | odd? rdelta repeat
                    -- mod 2, only odd sdelta is relevant.
                    e2 := e2 + em + primePower(d, p)
            if odd?(e1 + e2) then return false
        return true

    -- local function
    -- return true if for some a in
    -- \cite[Thm~10.1(4)]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
    -- the condition is true.
    checkSquare1?(nn: P, s: LZ, gs: LLZ, mm: P, r: LZ, gr: LLZ, m: P,
                 a: Z): Boolean ==
        --assert(one? gcd(a, d)) for every divisor of nn (and of mm).
        z: Z := 1
        nndivs: List P := DIVISORS nn
        mmdivs: List P := DIVISORS mm
        for d in nndivs for sd in s repeat if odd? sd then z := z * jacobi(d, a)
        for d in mmdivs for rd in r repeat
            if odd? rd then z := z * jacobi(m*d, a)
        zero? z => error "checkSquare1?: zero jacobi symbol"

        expo: Q := 0
        for l in gr repeat --assert(#l=3) -- l=[d,g,e]
            not DIVISIBLEBY?(l.1, mm) =>
                error "checkSquare1?: delta is not a divisor"
            expo := expo + (l.2/l.1 - 1/2) * l.3 -- (g/d-1/2)*e
        for l in gs repeat --assert(#l=3) -- l=[d,g,e]
            not DIVISIBLEBY?(l.1, nn) =>
                error "checkSquare1?: delta is not a divisor"
            expo := expo + (l.2/l.1 - 1/2) * l.3 -- (g/d-1/2)*e
        expo := (a-1) * expo -- this should give an integer
        not one? denom expo => error "checkSquare1?: expo not integral"

        (z > 0 and even? numer expo) or (z < 0 and odd? numer expo)

    -- local function
    alphaAux(mm: P, r: LZ, gr: LLZ, t: N): Q ==
        (24*t)::Q + SIGMAINFINITY(mm, r, gr)

    -- exported functions

    -- The following function computes \modularOrbit{r, m, t} with the
    -- optimization given by Radu in \cite[Lemma 4.35]{Radu:PhD:2010},
    -- i.e., we do not need to check all entries of \setS_{24m}, but
    -- only those that are not equivalent mod w.
    orbit(sigmaInfty: Z, m: P, t: N): List N ==
        m24: Z := 24*m
        g := gcd(kappa(m)*(24*t + sigmaInfty), m24)
        w: P := asP((m24 exquo g)::Z)
        result: List N := empty()
        for a in 0..w-1 | one? gcd(a, w) repeat
            y := a
            while y < m24 and not one? gcd(y, m24) repeat y := y + w
            -- Note that m24=g*w and gcd(a + k*w, m24) =
            -- gcd(a+k*w,g*w) = 1 for k chosen to be the product of
            -- all prime divisors of g that do not divide a and do not
            -- divide w. In other words, the above while loop also
            -- terminates without the "y < m24" condition.
            e := odotBar(positiveRemainder(y^2, m24), sigmaInfty, m, t)
            if not member?(e, result) then result := cons(e, result)
        result

    orbit(mm: P, r: List Z, m: P, t: N): List N ==
        orbit(SIGMAINFINITY(mm, r), m, t)

    chiExponent(sigmaInfty: Z, m: P, orb: List N): Z ==
        x: Z := 24*reduce(_+, orb, 0) + sigmaInfty * #orb
        positiveRemainder((1-m^2)*((x exquo m)::Z), 24)

    etaCoFactorSpace(nn: P, mm: P, r: List Z, m: P, t: N): _
      Record(particular: Union(VZ, "failed"), basis: List VZ) ==
        not conditionCoEtaQuotientGamma0?(nn, mm, r, m, t) =>
            error "conditionCoEtaQuotientGamma0 not met"

        -- Setup matrix. Then solve inhomogeneous system.
        matmod0: MZ := matrixModularGamma0(nn)$QETAAUX
        nr: N := nrows matmod0
        divs: List Z := divisors(mm)$INTF
        d: VZ := vector divs
        n: N := # divs
        w: Z := 0
        sigmaInfty: Z := 0
        sigma0: Z := 0
        for j in 1..n for rdelta in r repeat
            w := w + rdelta
            sigmaInfty := sigmaInfty + d.j * rdelta
            sigma0 := sigma0 + d(n+1-j) * rdelta
        -- Compute \modularOrbit{r, m,t}.
        orb: List N := orbit(sigmaInfty, m, t)
        orbitSize: Z := # orb
        nu: Z := chiExponent(sigmaInfty, m, orb)
        v: Vector Z := new(nr, 0)
        v.1 := - orbitSize * w                   -- \ref{eq:Radu-sum=0}
        v.2 := - nu - orbitSize * m * sigmaInfty -- \ref{eq:Radu-sigmainfinity}
        x: Z := orbitSize * m * nn * sigma0
        v.3 := - ((x exquo mm)::Z)               -- \ref{eq:Radu-sigma0}
        fl: FL := factorList factor nn
        -- Determine the cofactor according to (37) of
        -- \cite{Radu:RamanujanKolberg:2015} for each prime separately.
        -- Or see \ref{eq:Radu-productsquare} in qetaquot.spad.
        if even? orbitSize then
            for i in 1..#fl for fe in fl repeat qsetelt!(v, i+3, 0)
        else
            for i in 1..#fl for fe in fl repeat
                p: P := asP(fe.factor) -- extract prime factor
                em: N := primePower(m, p)$QETAAUX
                -- for all divisors of mm > 1
                e: Z := if odd? first r then em else 0 -- case: delta=1
                for j in 2..n for rdelta in rest r | odd? rdelta repeat
                    -- Mod 2 only odd rdelta is relevant.
                    e := e + em + primePower(asP(d.j), p)$QETAAUX
                qsetelt!(v, i+3, positiveRemainder(e, 2))
        -- Now we have a matrix mat and a right-hand side v and need to
        -- solve mat*x=v for x.
        diophantineSystem(matmod0, v)$SmithNormalForm(Z, VZ, VZ, MZ)

    etaCoFactorSpace(nn: P, mm: P, rr: List List Z, m: P, t: N): _
      Record(particular: Union(VZ, "failed"), basis: List VZ) ==
        -- \cite[Thm~10.1]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}

        not conditionCoEtaQuotientGamma1?(nn, mm, rr, m, t) =>
            error "conditionCoEtaQuotientGamma1 not met"

        nndivs: List P := DIVISORS nn
        numOfVars: N := 0 -- number of the s_d and s_{d,g} variables
        for d in nndivs repeat numOfVars := numOfVars + asN ceiling(d/2)

        -- rows/cols for condition (4)
        k: N := 0 -- need k more rows and k slack variable
        for i in 1..11 repeat if one? gcd(i*nn+1, 6) then k := k + 1

        cols: N := numOfVars+k+2 -- the 2 is for mod 24 slack variables
        rows: N := k+3 -- for conditions (4) + conditions (1), (2), (3)
        -- The matrix columns correspond to the following variables
        -- (in this order).
        -- [a(d) for d in nndivs]
        -- [[a(d,g) for g in 1..ceiling(d/2)-1] for d in nndivs]
        mat: MZ := new(rows, cols, 0)
        v: VZ := new(rows, 0)

        rrec: Record(etaQuotientExponents: LZ, generalizedParameters: LLZ) :=
            splitEtaQuotientSpecification(mm, rr)$QETAAUX
        r: LZ := rrec.etaQuotientExponents
        gr: LLZ := rrec.generalizedParameters
        n: Z := # nndivs

        -- Condition (1)
        for d in nndivs for j in 1..n repeat qsetelt!(mat, 1, j, 1)
        v.1 := - reduce(_+, r, 0) -- fill right-hand side

        -- Condition (2) and slack variable for mod 24
        jj: Z := 0
        for d in reverse nndivs for j in 1..n repeat
            -- Note that we reverse nndivs!
            qsetelt!(mat, 2, j, d)
            for g in 1..ceiling(d/2)-1 repeat
                jj := jj + 1
                qsetelt!(mat, 2, n + jj, 2*d)
        qsetelt!(mat, 2, numOfVars+1, 24) -- slack variable for (mod 24)
        v.2 := - m * SIGMA0(mm, r, gr) -- fill right-hand side

        -- Condition (3) and slack variable for mod 24
        -- We multiply the entries and the rhs by nn to remove denominators.
        jj := 0
        for d in nndivs for j in 1..n repeat
            qsetelt!(mat, 3, j, nn*d)
            for g in 1..ceiling(d/2)-1 repeat
                jj := jj + 1
                x: Z := 12*numer(nn*d*fractionalBernoulli2(g/d)$QETAAUX)
                qsetelt!(mat, 3, n + jj, x)
        qsetelt!(mat, 3, numOfVars+2, 24*nn) -- slack variable for (mod 24)

        -- fill right-hand side
        --assert(DIVISIBLEBY?(mm, nn))
        nnrrhat: Z := numer(nn*SIGMAINFINITY(mm, r, gr)) -- is integral
        nnalpha: Z := nnrrhat + 24*t*nn -- nn*alphaAux(mm, r, gr, t)
        q: Q := nnalpha*(m^2-1)/m -- intermediate
        -- Security check. Should never fail because of Condition 8 on page 37
        -- of \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.
        not one? denom q => error "etaCoFactorSpace: nnalpha not divisible by m"
        v.3 := - (m*nnrrhat - numer q)

        -- Condition (4) and slack variable for mod 2 for all a
        ii: Z := 3
        mmdivs: List P := DIVISORS mm
        for i in 1..11 repeat
            a: Z := nn*i+1
            one? gcd(a,6) =>
                ii := ii+1
                -- setEntries!(mat, v, n, ii, ...)
                expo: Q := 0
                for l in gr repeat --assert(#l=3) -- l=[d,g,e]
                    not DIVISIBLEBY?(l.1, mm) =>
                        error "etaCoFactorSpace: delta is not a divisor"
                    expo := expo + (l.2/l.1 - 1/2) * l.3 -- (g/d-1/2)*e
                expo := (a-1)*expo
                not one? denom expo =>
                    error "etaCoFactorSpace: exponent not integral"
                isOdd?: Boolean := odd? numer expo
                for d in mmdivs for rd in r | odd? rd repeat
                    if jacobi(m*d, a) < 0 then isOdd? := not isOdd?
                if isOdd? then v.ii := 1 -- fill right-hand side

                qsetelt!(mat, ii, n+ii+1, 2) -- slack variable for (mod 2)
                jj := 0
                for d in nndivs for j in 1..n repeat
                    if jacobi(d, a) < 0 then qsetelt!(mat, ii, j, 1)
                    for g in 1..ceiling(d/2)-1 repeat
                        jj := jj + 1
                        q := (a-1)*(g/d-1/2)
                        not one? denom q =>
                            error "etaCoFactorSpace: e exponent not integral"
                        if odd? numer q then qsetelt!(mat, ii, n + jj, 1)

        -- We have to solve mat*z=v for some integer vector z.
        diophantineSystem(mat, v)$SmithNormalForm(Z, VZ, VZ, MZ)

    conditionPrimeDivisors?(nn: P, m: P): Boolean ==
        fm: Factored Z := factor m
        mfl: FL := factorList fm
        nnprimes := [f.factor for f in factorList factor nn]
        for f in mfl repeat
            not member?(f.factor, nnprimes) => return false
        return true

    conditionMmN?(nn: P, mm: P, r: LZ, m: P): Boolean ==
        mmdivs: LP := DIVISORS mm
        #mmdivs ~= #r =>  false

        divs: LP := DIVISORS(m*nn)
        for delta in mmdivs for rdelta in r | not zero? rdelta repeat
            not member?(delta, divs) => return false
        return true

    conditionSigma0?(nn: P, mm: P, r: LZ, m: P): Boolean ==
        sv: Z := SIGMA0(mm, r)
        x: Z := kappa(m)*m*nn*nn*sv
        DIVISIBLEBY?(24, (x exquo mm) :: Z)

    conditionSumExponents?(nn: P, r: LZ, m: P): Boolean ==
        ssum: Z := 0
        for rdelta in r repeat ssum := ssum + rdelta
        DIVISIBLEBY?(8, kappa(m)*nn*ssum)

    conditionNDivisor?(nn: P, mm: P, r: LZ, m: P, t: N): Boolean ==
        a: Z := kappa(m)*(24*t + SIGMAINFINITY(mm, r))
        --assert(a = kappa(m)*numer(alphaAux(mm, r, [], t)))
        n: Z := 24*m
        w: Z := (n exquo gcd(a, n)) :: Z
        DIVISIBLEBY?(w, nn)

    conditionEvenMultiplier?(nn: P, mm: P, r: LZ, m: P): Boolean ==
        odd? m => true
        u: Z := 1
        for delta in DIVISORS mm for rdelta in r | not zero? rdelta repeat
            adelta: P := asP abs(rdelta)
            u := u * delta^adelta
        e: Z := 0
        while even? u repeat
            e := e + 1
            u := shift(u, -1)

        b1: Boolean := DIVISIBLEBY?(4, kappa(m)*nn) and DIVISIBLEBY?(8, nn*e)
        b2: Boolean := even? e and DIVISIBLEBY?(8, nn*(u-1))
        return (b1 or b2)

    -- See condition 7 in section "2. Finding Modular Functions for
    -- $\Gamma_1(N)$.
    conditionOrbitLength?(nn: P, mm: P, r: LZ, m: P, t: N): Boolean ==
        n: P := 24*m*mm
        rhat := SIGMAINFINITY(mm, r)
        for i in 0.. (n quo nn) repeat
            j := nn*i+1 -- (j = 1 (mod nn))
            one? gcd(j, n) => -- then 24|(j^2-1)
               not zero?((((j^2 - 1) quo 24)*(rhat+24*t)) rem m) => return false
        return true

    conditionCoEtaQuotientGamma0?(nn: P, mm: P, r: LZ, m: P, t: N): Boolean ==
        t >= m => error "0<=t<m is a necessary condition"
        conditionPrimeDivisors?(nn, m) -- \eqref{eq:p|m=>p|N}
         and conditionMmN?(nn, mm, r, m) -- \eqref{eq:delta|M=>delta|mN}
          and conditionSigma0?(nn, mm, r, m) -- \eqref{eq:sv24}
           and conditionSumExponents?(nn, r, m) --\eqref{eq:sum-r}
            and conditionNDivisor?(nn, mm, r, m, t) -- \eqref{eq:w|N}
             and conditionEvenMultiplier?(nn, mm, r, m) -- \eqref{eq:even-m}

    conditionCoEtaQuotientGamma1?(nn: P, mm: P, r: LZ, m: P, t: N): Boolean ==
        t >= m => error "0<=t<m is a necessary condition"
        DIVISIBLEBY?(mm, nn) -- M|N
         and conditionPrimeDivisors?(nn, m) --\eqref{eq:p|m=>p|N}
          and conditionSumExponents?(nn, r, m) --\eqref{eq:sum-r}
           and conditionSigma0?(nn, mm, r, m) --\eqref{eq:sv24}
            and conditionNDivisor?(nn, mm, r, m, t) --\eqref{eq:w|N}
             and conditionEvenMultiplier?(nn, mm, r, m) --\eqref{eq:even-m}
              and conditionOrbitLength?(nn, mm, r, m, t) -- CDZ condition 7.

-------------------------------------------------------------------
-- generalized eta quotients allowed in input
-------------------------------------------------------------------

    -- CDZ condition 3 (p. 37)
    conditionGSigma0?(nn: P, mm: P, gr: LLZ, m: P): Boolean ==
        rv: Q := 0
        for l in gr repeat rv := rv + l.2*l.3/l.1
        x: Q := kappa(m)*nn*rv
        one? denom x and even? numer x

    -- CDZ condition 4 (p. 37)
    conditionSumExponents?(nn: P, gr: LLZ, m: P): Boolean ==
        rsum: Z := 0
        for l in gr repeat rsum := rsum + l.3
        x: Z := kappa(m)*nn*rsum
        DIVISIBLEBY?(4, x)

    -- CDZ condition 5 (p. 37)
    conditionSigma0?(nn: P, mm: P, gr: LLZ, m: P): Boolean ==
        rv: Q := 0
        for l in gr repeat rv := rv + l.3/l.1
        x: Q := kappa(m)*nn*nn*rv
        one? denom x and DIVISIBLEBY?(12, numer x)

    -- CDZ condition 8 (p. 37)
    conditionNDivisor?(nn: P, mm: P, r: LZ, gr: LLZ, m: P,t: N): Boolean ==
        a: Z := kappa(m)*numer(mm*alphaAux(mm, r, gr, t))
        n: Z := 24*m*mm
        w: Z := (n exquo gcd(a, n)) :: Z
        DIVISIBLEBY?(w, nn)

    -- CDZ condition 10 (p. 38)
    conditionOrbitLength?(nn: P, mm: P, r: LZ, gr: LLZ, m: P, t: N): Boolean ==
        a: Q := alphaAux(mm, r, gr, t)
        n: P := 24*m*mm
        for i in 0.. (n quo nn) repeat
            j := nn*i+1 -- (j = 1 (mod nn)) (j^2-1 is in S_{n})
            one? gcd(j, n) => -- then 24|(j^2-1)
               x: Q := ((j^2 - 1)/24) * a
               not one? denom x => error "x should be integral"
               not zero?(numer(x) rem m) => return false
        return true

    -- condition for the disection of mixed-generalized eta-quotients
    conditionCoEtaQuotientGamma1?(nn: P, mm: P, rr: LLZ, m: P, t: N): Boolean ==
        t >= m => error "0<=t<m is a necessary condition"
        -- separate the true eta-quotient part from the generalized part
        -- i.e. extract an r-vector and a gr list.
        rec: Record(etaQuotientExponents: LZ, generalizedParameters: LLZ) :=
            splitEtaQuotientSpecification(mm, rr)$QETAAUX
        r: LZ := rec.etaQuotientExponents
        gr: LLZ := rec.generalizedParameters

        zero?(nn rem mm) -- M|N
         and conditionPrimeDivisors?(nn, m) --\eqref{eq:p|m=>p|N}
          and conditionGSigma0?(nn, mm, gr, m) -- CDZ condition 3 (p. 37)
           and conditionSumExponents?(nn, gr, m) -- CDZ condition 4 (p. 37)
            and conditionSigma0?(nn, mm, gr, m) -- CDZ condition 5 (p. 37)
             and conditionSumExponents?(nn, r, m) --\eqref{eq:sum-r}
              and conditionSigma0?(nn, mm, r, m) -- \eqref{eq:sv24}
               and conditionNDivisor?(nn, mm, r, gr, m, t) -- CDZ 8 (p.37)
                and conditionEvenMultiplier?(nn, mm, r, m) --\eqref{eq:even-m}
                 and conditionOrbitLength?(nn, mm, r, gr, m, t) -- CDZ cond. 10

-------------------------------------------------------------------
-- use of conditions from above
-------------------------------------------------------------------

    minimalLevelCoEtaQuotientGamma0(mm: P, r: LZ, m: P, t: N): P ==
        for nn in 1..24*m*mm repeat
            conditionCoEtaQuotientGamma0?(asP nn, mm, r, m, t) => return asP nn
        error "minimalLevelCoEtaQuotientGamma0: should not be here"

    minimalLevelCoEtaQuotientGamma1(mm: P, r: LZ, m: P, t: N): P ==
        for nn in 1..24*m*mm repeat
            conditionCoEtaQuotientGamma1?(asP nn, mm, r, m, t) => return asP nn
        error "minimalLevelCoEtaQuotientGamma0: should not be here"

    minimalLevelCoEtaQuotientGamma1(mm: P, rr: LLZ, m: P, t: N): P ==
        for nn in 1..24*m*mm repeat
            conditionCoEtaQuotientGamma1?(asP nn, mm, rr, m, t) => return asP nn
        error "minimalLevelCoEtaQuotientGamma0: should not be here"

    modularGamma0?(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): Boolean ==
        not conditionCoEtaQuotientGamma0?(nn, mm, r, m, t) => false

        nndivs: LP := DIVISORS nn
        #nndivs ~= #s =>
            dbgPrint("size of s: s", s)
            false

        rhat: Z := SIGMAINFINITY(mm, r)
        orb: List N := orbit(rhat, m, t)
        orbitSize: Z := # orb

        --\eqref{eq:Radu-sum=0}
        not zero?(reduce(_+, s, 0) + orbitSize * reduce(_+, r, 0)) =>
            dbgPrint("eq:Radu-sum=0 s", s)
            dbgPrint("eq:Radu-sum=0 r", r)
            dbgPrint("eq:Radu-sum=0 orbitSize", orbitSize)
            false

        --\eqref{eq:Radu-sigmainfinity}
        shat: Z := SIGMAINFINITY(nn, s)
        nu: Z := chiExponent(rhat, m, orb)
        z: Z := shat + orbitSize * m * rhat + nu
        not DIVISIBLEBY?(24, z) =>
            dbgPrint("eq:Radu-sigmainfinity s", s)
            dbgPrint("eq:Radu-sigmainfinity r", r)
            dbgPrint("eq:Radu-sigmainfinity orbitSize", orbitSize)
            dbgPrint("eq:Radu-sigmainfinity nu", nu)
            false

        --\eqref{eq:Radu-sigma0}
        sv: Z := SIGMA0(nn, s)
        rv: Z := SIGMA0(mm, r)
        -- conditionCoEtaQuotientGamma0?(nn, mm, r, m, t) \implies f \in Z
        -- See conditionMmN?(nn, mm, r, m).
        f: Z := ((m * nn) exquo mm)::Z

        not DIVISIBLEBY?(24, sv + orbitSize * f * rv) =>
            dbgPrint("eq:Radu-sigma0 s", s)
            dbgPrint("eq:Radu-sigma0 r", r)
            dbgPrint("eq:Radu-sigma0 orbitSize", orbitSize)
            false

        --\eqref{eq:Radu-productsquare}
        not checkSquare?(nn, s, mm, r, m, orbitSize) =>
            dbgPrint("eq:Radu-productsquare nn", nn)
            dbgPrint("eq:Radu-productsquare s", s)
            dbgPrint("eq:Radu-productsquare mm", mm)
            dbgPrint("eq:Radu-productsquare r", r)
            dbgPrint("eq:Radu-productsquare orbitSize", orbitSize)
            false

        true

    modularGamma1?(nn: P, ss: LLZ, mm: P, rr: LLZ, m: P, t: N): Boolean ==
        not conditionCoEtaQuotientGamma1?(nn, mm, rr, m, t) => false

        -- \cite[Thm~10.1]{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
        rrec: Record(etaQuotientExponents: LZ, generalizedParameters: LLZ) :=
            splitEtaQuotientSpecification(mm, rr)$QETAAUX
        r: LZ := rrec.etaQuotientExponents
        gr: LLZ := rrec.generalizedParameters

        srec: Record(etaQuotientExponents: LZ, generalizedParameters: LLZ) :=
            splitEtaQuotientSpecification(nn, ss)$QETAAUX
        s: LZ := srec.etaQuotientExponents
        gs: LLZ := srec.generalizedParameters

        -- Condition (1)
        not zero?(reduce(_+, s, 0) + reduce(_+, r, 0)) =>
            dbgPrint("Chen: Theorem 10.1(1) nn", nn)
            dbgPrint("Chen: Theorem 10.1(1) ss", ss)
            dbgPrint("Chen: Theorem 10.1(1) mm", mm)
            dbgPrint("Chen: Theorem 10.1(1) rr", rr)
            false

        -- Condition (2)
        rrv: Z := SIGMA0(mm, r, gr)
        ssv: Z := SIGMA0(nn, s, gs)
        z: Z := ssv + m*rrv
        not DIVISIBLEBY?(24, z) =>
            dbgPrint("Chen: Theorem 10.1(2) nn", nn)
            dbgPrint("Chen: Theorem 10.1(2) ss", ss)
            dbgPrint("Chen: Theorem 10.1(2) mm", mm)
            dbgPrint("Chen: Theorem 10.1(2) rr", rr)
            dbgPrint("Chen: Theorem 10.1(2) z", z)
            false

        -- Condition (3)
        rrhat: Q := SIGMAINFINITY(mm, r, gr)
        sshat: Q := SIGMAINFINITY(nn, s, gs)
        alpha: Q := rrhat + (24*t)::Q -- alphaAux(mm, r, gr, t)
        q: Q := sshat + m*rrhat - ((m^2-1)/m)*alpha
        not one? denom q or not DIVISIBLEBY?(24, z) => --shouldn't happen
            dbgPrint("Chen: Theorem 10.1(3) nn", nn)
            dbgPrint("Chen: Theorem 10.1(3) ss", ss)
            dbgPrint("Chen: Theorem 10.1(3) mm", mm)
            dbgPrint("Chen: Theorem 10.1(3) rr", rr)
            dbgPrint("Chen: Theorem 10.1(3) q", q)
            false

        -- Condition (4)
        for i in 1..11 repeat
            a: Z := nn*i+1
            one? gcd(a,6) and not checkSquare1?(nn,s,gs,mm,r,gr,m,a) =>
                dbgPrint("Chen: Theorem 10.1(4) nn", nn)
                dbgPrint("Chen: Theorem 10.1(4) ss", ss)
                dbgPrint("Chen: Theorem 10.1(4) mm", mm)
                dbgPrint("Chen: Theorem 10.1(4) rr", rr)
                dbgPrint("Chen: Theorem 10.1(4) a", a)
                return false

        true

    alphaInfinity(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): Z ==
        not modularGamma0?(nn, s, mm, r, m, t) =>
            error "input does not correspond to a modular function"
        shat: Z := SIGMAINFINITY(nn, s)
        rhat: Z := SIGMAINFINITY(mm, r)
        orb: List N := orbit(rhat, m, t)
        alpha: Q := shat/24 + reduce(_+, [24*k+rhat for k in orb], 0)/(24*m)
        not one? denom alpha => error "alpha not an integer"
        return numer alpha

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
