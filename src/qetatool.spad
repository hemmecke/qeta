-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Conversion, Evaluation, and Gr\"obner bases} %"
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
Auxiliary packages to help with the implementation of algorithms from
\cite{Radu:RamanujanKolberg:2015},
\cite{Hemmecke:DancingSambaRamanujan:2018}, and
\cite{Hemmecke+Radu:EtaRelations:2018}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code implements a number of conversion and evaluation tools.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
LSym ==> List Symbol

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We want variables that are easy to parse when written to a file.
)endif

)abbrev package QAUXTOOL QAuxiliaryTools
++ Miscellaneous tools to deal with polynomials.
QAuxiliaryTools(): with
    indexedSymbols: (String, N) ->  List Symbol
        ++ indexedSymbols(s, n) returns indexedSymbols(s, [i for i in 1..n])
    indexedSymbols: (String, List Z) ->  List Symbol
        ++ indexedSymbols(s, l) creates a list of symbols of the form
        ++ [sx for x in l] where sx denotes the symbol with a name that
        ++ starts with the string s and ends with the number x.
    clearDenominator: Polynomial Q -> Polynomial Z
        ++ clearDenominator(p) multiplies the polynomial p over rational numbers
        ++ with the least common multiple of all its coefficients and
        ++ returns the result as a polynomial over the integers.
  == add
    indexedSymbols(s: String, n: N): List Symbol ==
        [concat(s, convert(i)@String)::Symbol for i in 1..n]
    indexedSymbols(s: String, l: List Z): List Symbol ==
        [concat(s, convert(i)@String)::Symbol for i in l]
    clearDenominator(p: Polynomial Q): Polynomial Z ==
        zero? p => 0$Polynomial(Z)
        c: Z := lcm [denom x for x in coefficients p]
        mon(x) ==> monomial(numer(c*leadingCoefficient x), degree x)$Polynomial(Z)
        lm: List Polynomial Z := [mon(x) for x in monomials p]
        reduce(_+, lm)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Auxiliary package to create a series from another series by picking a
subsequence of coefficients.
)endif

)abbrev package QFUNTOOL QFunctionTools
++ QFunctionTools allows to create a series from another series.
QFunctionTools(C: Ring, L: UnivariateLaurentSeriesCategory C): with
    choose: (N -> N, L) -> L
      ++ choose(f, x) returns the power series whose n-th coefficient
      ++ is the f(n)-th coefficient of x.
  == add
    streamAux(n: N, f: N -> N, x: L): Stream C == delay
        cons(coefficient(x, f n), streamAux(n+1, f, x))
    chooseStream(f: N -> N, x: L): Stream C == streamAux(0, f, x)
    choose(f: N -> N, x: L): L == laurent(0, chooseStream(f, x))

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Convert convert power series by mapping coefficients.
)endif

)abbrev package FIN0SER2 Finite0SeriesFunctions2
++ Finite0SeriesFunctions2 maps coefficients of the series.
Finite0SeriesFunctions2(C1, C2, sym1, sym2, cen1, cen2): Exports == Impl where
  C1: CommutativeRing
  C2: CommutativeRing
  sym1: Symbol
  sym2: Symbol
  cen1: C1
  cen2: C2
  L1 ==> UnivariateLaurentSeries(C1, sym1, cen1)
  F1 ==> Finite0Series(C1, sym1, cen1)
  F2 ==> Finite0Series(C2, sym2, cen2)
  ULSF2 ==> UnivariateLaurentSeriesFunctions2(C1, C2, sym1, sym2, cen1, cen2)
  Exports ==> with
    map: (C1 -> C2, F1) -> F2
        ++ \spad{map(f, g(x))} applies the map f to the coefficients of
        ++ the series \spad{g(x)}.
  Impl ==> add
    map(f: C1 -> C2, s: F1): F2 == (map(f, s::L1)$ULSF2) :: F2

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\code{PolynomialConversion} converts a polynomial from the generic
\spadtype{Polynomial}\code{(C)} to a more specific polynomial ring of
the form \spadtype{PolynomialRing}\code{(C, E)} with a given domain of the
exponents.
)endif

)abbrev package POLYCONV PolynomialConversion
PolynomialConversion(_
  C: Ring, _
  E: OrderedAbelianMonoid with (
       directProduct: Vector N -> %; members: % -> List N),_
  syms: LSym): with
    coerce: Polynomial C -> PolynomialRing(C, E)
    coerce: PolynomialRing(C, E) -> Polynomial C
 == add
    R ==> PolynomialRing(C, E)
    coerce(p: Polynomial C): R ==
        r: R := 0
        while not zero? p repeat
            c: C := leadingCoefficient p
            v: Vector N := vector degree(leadingMonomial p, syms)
            e: E := directProduct(v)$E
            p := reductum p
            r := r + monomial(c, e)
        r

    coerce(r: R): Polynomial C ==
        p: Polynomial(C) := 0
        while not zero? r repeat
            c: C := leadingCoefficient r
            e: E := leadingSupport r
            r := reductum r
            exponents: List N := members e
            p := p + monomial(c::Polynomial(C), syms, exponents)
        p

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Evaluate a polynomial at a certain point.
)endif

)abbrev package POLYEVAL PolynomialEvaluation
PolynomialEvaluation(_
  C: Ring, _
  S: with (_
      _+: (%, %) -> %; _
      _*: (%, %) -> %; _
      _^: (%, NonNegativeInteger) -> %)_
 ): with
    eval: (Polynomial C, C -> S, LSym, List S) -> S
 == add
    eval(p: Polynomial C, embed: C -> S, vars: LSym, vals: List S): S ==
        E ==> IndexedExponents Symbol
        PE ==> PolynomialCategoryLifting(E, Symbol, C, Polynomial C, S)
        map((s:Symbol):S +-> vals.position(s, vars), embed, p)$PE

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The following package helps to compute $I\cap C[E]$ where $I \subset
C[Y,E]$ and $Y=(Y_1,\ldots,Y_n$), $E=(E_1,\ldots, E_n)$.
)endif

)abbrev package POLYAUX PolynomialTool
PolynomialTool(R: Ring): with
    xPolynomials: (List Polynomial R, Character) -> List Polynomial R
      ++ xPolynomials(pols, c) returns all polynomials p from
      ++ pols such that variables(p) contains only variables starting
      ++ with the character c.
 == add
    -- variables not starting with the character c.
    xVariables(p: Polynomial(R), c: Character): List Symbol ==
        [x for x in variables p | (string x).1 ~= c]

    -- Is it a polynomial just in variables starting with the character c?
    xPolynomial?(p: Polynomial R, c: Character): Boolean ==
        degs: List N := degree(p, xVariables(p, c))
        zero? reduce(_+, degs, 0)

    -- Extract all polynomials just in variables that begin with the
    -- character c.
    xPolynomials(pols: List Polynomial R, c: Character): List Polynomial R ==
        [x for x in pols | xPolynomial?(x, c)]

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The following package implements a denominator free reduction that
records the reduction steps.
)endif

)abbrev package EXTRED ExtendedPolynomialReduction
++ ExtendedPolynomialReduction(C, E, R) is a package that allows
++ denominatorFree reductions of a polynomial r from R wrt a list
++ of polynomials from R (usually such a list is a Groebner basis wrt
++ the order given via E). Additionally, the reduction steps are recorded
++ and provided in the output.
ExtendedPolynomialReduction(C, E, R): Exports == Implementation where
  C: GcdDomain
  E: OrderedAbelianMonoidSup
  R: Join(FiniteAbelianMonoidRing(C, E), VariablesCommuteWithCoefficients)
  V ==> Vector R
  X ==> Record(poly: R, repr: V, mult: C)
    -- The triple [p,r,m] stands for (p+dot(r,b))/m where n=#r=#b
    -- and dot(v, b) = reduce(_+, [v.i * b.i for i in 1..n]).
  Exports ==> with
    reduce: (R, List R) -> X
      ++ reduce(r, bas) returns a triple (p, v, m) such that
      ++ m*r = sum(bas.i * v.i, i=1..#bas) + p
  Implementation ==> add
    -- local functions
    polynomial(x: X): R == x.poly
    representation(x: X): V == x.repr
    multiplier(x: X): C == x.mult

    cancelGcd(c1: C, c2: C): Record(co1: C, co2: C) ==
        g: C := gcd(c1, c2)
        [(c1 exquo  g)::C, (c2 exquo g)::C]

    -- A basis element a is put into the structure X such that it represents
    -- the zero polynomial.
    embedBasisElement(r: R, i: N, n: N): X ==
        v: V := new(n, 0)
        v.i := -1
        -- The multiplier part is uninteresting here and will never be used.
        [r, v, 1] -- For consistency, we set the multiplier to 1.

    -- Reduce x wrt basis and remember multiplier with which x had been
    -- multiplied in order to stay denominator free.
    -- Assumption: For every b in the basis it holds:
    -- b.poly = dot(b.repr, basis).                                 (*1)
    -- Invariant:
    -- Let z = denominatorFreeTopReduce(x, basis) then the following holds:
    -- (x.poly + dot(x.repr, basis))/x.mult  =
    -- (z.poly + dot(z.repr, basis))/z.mult                         (*2)
    -- Proof the invariant:
    -- Let's abbreviate x.poly by xp, x.repr by xr, x.mult by xm.
    -- Assume that u is the value of z at the beginning of the while
    -- body and v is the value of z at the end of the while body.
    -- Then we have:
    -- vp := f1      * up - f2 * bp
    -- vr := (f1::R) * ur - f2 * br
    -- vm := f1      * um
    -- Thus
    -- (vp + dot(vr, basis))/vm =
    --   = (f1*up - f2 * bp + dot(f1*ur, basis) - dot(f2*br, basis))/(f1*um)
    --   = (up + dot(ur, basis)/um - f2*(bp + dot(br, basis))/(f1*um)
    -- Because of (*1) we have bp + dot(br, basis)=0.
    denominatorFreeTopReduce(x: X, basis: List X): X ==
        -- The multiplier entries in the input are ignored except for
        -- the multiplier stored in x.
        z: X := [polynomial x, representation x, multiplier x] -- copy
        bas := basis
        while not zero?(pz := polynomial z) and not empty? bas repeat
            b := first bas
            pb: R := polynomial b
            ee: Union(E, "failed") := subtractIfCan(degree pz, degree pb)
            if ee case E then
                l := lcmCoef(leadingCoefficient pz, leadingCoefficient pb)
                f1: C := l.coeff1
                f2: R := monomial(l.coeff2, ee::E)
                z.poly := f1 * reductum pz - f2 * reductum pb
                -- normalize leading coefficient
                a: C := unitNormal(leadingCoefficient z.poly).associate
                z.poly := a * z.poly
                f1 := a * f1
                f2 := a * f2
                z.repr := (f1::R) * representation z - f2 * representation b
                z.mult := f1      * multiplier z
                bas := basis
            else
                bas := rest bas
        return z

    -- Reduce the non-leading terms of x (which is assumed to be non-zero.
    -- Assumption (*1) from denominatorFreeTopReduce holds.
    -- If z = tailReduce(x, basis) then also (*2) from above holds.
    -- For the while loop below we need another invariant.
    -- Let the unprimed variables denote the values at the beginning of
    -- the while body and the primed ones at the end of the while body.
    -- Then:
    -- (r + p + dot(v, basis))/m = (r' + p' + dot(v', basis))/m'      (*3)
    -- Note that after assigning the values r, p, v, m for the first time
    -- and computing the reductum of p, we have
    -- (x.poly + dot(x.repr, basis))/x.mult = (r + p + dot(v, basis))/m
    -- By specification of denominatorFreeTopReduce, we have
    -- (x'.poly + dot(x'.repr, basis))/x'.mult = p + dot(v, basis).
    -- v' = x'.repr
    -- r' + p' = x'.mult * r + x'.poly
    -- m' = m * x'.mult
    -- Thus
    -- (r' + p' + dot(v', basis))/m' =
    --   = (x'.mult * r + x'.mult*((x'.poly + dot(x'.repr, basis))/x'.mult))/m'
    --   = x'.mult * (r + p + dot(v, basis))/(m*x'.mult)
    --   = (r + p + dot(v, basis))/m
    -- Since eventually p=0, the proof is completed.
    tailReduce(x: X, basis: List X): X ==
        --assert(not zero? polynomial p)
        empty? basis => x
        -- We iterate over the non-leading terms of polynomial(x), i.e,
        -- we don't need the representation part of x.
        p: R := polynomial x
        -- z will become the result, so we attach the representation
        -- part to it.
        r: R := leadingMonomial p
        p := reductum p
        -- We keep the representation part attached to y and thus hand it
        -- over to denominatorFreeReduce. Thus
        -- we get the representation from the reduced polynomial.
        -- In the following we rely on the fact the degree(0)=1, i.e.,
        -- leadingMonomial(0)=0 and reductum(0)=0.
        v: V := representation x
        m: C := multiplier x
        while not zero? p repeat
            x := denominatorFreeTopReduce([p, v, 1], basis)
            v := representation x
            p := polynomial x
            r := multiplier(x) * r + leadingMonomial p
            p := reductum p
            m := m * multiplier x
        [r, v, m]

    -- exported function
    reduce(r: R, basis: List R): X ==
        -- First we coerce every element into %. Then we reduce.
        empty? basis => [r, empty()$V, 1]
        n: N := #basis
        x: X := [r, new(n, 0)$V, 1]
        bas: List X := [embedBasisElement(b, i, n) for b in basis for i in 1..n]
        x := denominatorFreeTopReduce(x, bas)
        tailReduce(x, bas)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A wrapper for \GB{} omputations.
)endif

)abbrev package QETAGB QEtaGroebner
++ QEtaGroebner(C, E) is a wrapper around the GrobnerPackage. It basically
++ converts given polynomials to elements in PolynomialRing(C, E), does
++ some Groebner basis computation or reduction and then converts back.
QEtaGroebner(C, E): Exports == Implementation where
  C: GcdDomain
  ExponentCat ==> OrderedAbelianMonoidSup with _
    (directProduct: Vector N -> %; members: % -> List N)
  E: ExponentCat
  Pol ==> Polynomial C
  LPol ==> List Pol
  R ==> PolynomialRing(C, E)
  X ==> Record(poly: R, repr: Vector R, mult: C)
  Exports ==> with
    groebner: (LPol, LSym) -> LPol
      ++ groebner(lpol, syms) considers the list of polynomials as
      ++ polynomials in syms, and computes a Groebner basis with
      ++ respect to the order given by E.
      ++ We assume that each of the polynomials in lpol is indeed a
      ++ polynomial in syms (and no other variables) and that E
      ++ corresponds to exactly #syms variables.
    groebnerExtend: (LPol, LPol, LSym) -> LPol
      ++ groebnerExtend(lpol, gb, syms) computes a Groebner basis of the
      ++ union of lpos and gb under the assumption that gb is already
      ++ a Groebner basis wrt. the order given by E.
      ++ We assume that each of the polynomials in lpol and gb is indeed a
      ++ polynomial in syms (and no other variables) and that E
      ++ corresponds to exactly #syms variables.
    normalForms: (LPol, LPol, LSym) -> LPol
      ++ normalForms(lpol, gb, syms) reduces each polynomial from lpol
      ++ with respect to the Groebner basis given by gb.
      ++ We assume that each of the polynomials in lpol and gb is indeed a
      ++ polynomial in syms (and no other variables) and that E
      ++ corresponds to exactly #syms variables.
    extendedNormalForm: (Pol, LPol, LSym, Symbol, String) -> Pol
      ++ extendedNormalForm(pol, gb, syms, f, g) returns
      ++ extendedNormalForm(pol, gb, syms, f, gsyms) for
      ++ gsyms := indexedSymbols(g, #gb).
    extendedNormalForm: (Pol, LPol, LSym, Symbol, LSym) -> Pol
      ++ extendedNormalForm(pol, gb, syms, f, gsyms) reduces pol with
      ++ respect to gb and returns that reduced polynomial together
      ++ with its relations in terms of gb. The original polynomial
      ++ is represented by the variable f and the Groebner basis
      ++ elements by the variables gsyms.
      ++ We assume that each of the polynomials pol and gb is indeed a
      ++ polynomial in syms (and no other variables) and that E
      ++ corresponds to exactly #syms variables.
    extendedNormalForms: (LPol, LPol, LSym, String, String) -> LPol
      ++ extendedNormalForms(lpol, gb, syms, f, g) returns
      ++ [extendedNormalForm(p, gb, syms, f, g)
      ++   for p in lpol for f in indexedSymbols(f, #lpol)]
  Implementation ==> add
    -- local
    -- toPol(x, syms, sym, gsyms) returns a polynomial that describes
    -- the representation of x.poly in terms of x.repr
    toPol(x: X, syms: LSym, sym: Symbol, gsyms: LSym): Pol ==
        import from PolynomialConversion(C, E, syms)
        p: Pol := (x.mult)*(sym::Pol) - (x.poly)::Pol
        for gsym in gsyms for r in members(x.repr) repeat
            p := p - (gsym::Pol)*(r::Pol)
        return primitivePart p

    -- exported
    groebner(lpol: LPol, syms: LSym): LPol ==
        import from PolynomialConversion(C, E, syms)
        rs: List R := [p::R for p in lpol]
        gb: List R := groebner(rs)$GroebnerPackage(C, E, R)
        [r::Pol for r in gb]

    groebnerExtend(lpol: LPol, gb: LPol, syms: LSym): LPol ==
        import from PolynomialConversion(C, E, syms)
        import from GroebnerInternalPackage(C, E, R)
        rs: List R := [p::R for p in lpol]
        rgb: List R := [p::R for p in gb]
        xgb: List R := gbasisExtend(rs, rgb, 2, 1)
        mgb: List R := minGbasis(sort((x, y) +-> degree x > degree y, xgb))
        [r::Pol for r in mgb]

    normalForms(lpol: LPol, gb: LPol, syms: LSym): LPol ==
        import from PolynomialConversion(C, E, syms)
        import from GroebnerInternalPackage(C, E, R)
        rs: List R := [p::R for p in lpol]
        rgb: List R := [p::R for p in gb]
        [(primitivePart redPol(x, rgb))::Pol for x in rs]

    extendedNormalForm(pol: Pol, gb: LPol, syms: LSym, f: Symbol, g: String): Pol ==
        gsyms: LSym := indexedSymbols(g, #gb)$QAuxiliaryTools
        extendedNormalForm(pol, gb, syms, f, gsyms)

    extendedNormalForm(pol: Pol, gb: LPol, syms: LSym, f: Symbol, gsyms: LSym): Pol ==
        import from PolynomialConversion(C, E, syms)
        import from ExtendedPolynomialReduction(C, E, R)
        rgb: List R := [p::R for p in gb]
        x: X := reduce(pol::R, rgb)
        toPol(x, syms, f, gsyms)

    extendedNormalForms(lpol: LPol, gb: LPol, syms: LSym, f: String, g: String): LPol ==
        import from PolynomialConversion(C, E, syms)
        import from ExtendedPolynomialReduction(C, E, R)
        rs: List R := [p::R for p in lpol]
        rgb: List R := [p::R for p in gb]
        lx: List X := [reduce(r, rgb) for r in rs]
        import from QAuxiliaryTools
        fsyms: LSym := indexedSymbols(f, #lpol)
        gsyms: LSym := indexedSymbols(g, #gb)
        [toPol(x, syms, fsym, gsyms) for fsym in fsyms for x in lx]

)if LiterateDoc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unused}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbcode}
)abbrev package UPEVAL UnivariatePolynomialEvaluation
UnivariatePolynomialEvaluation(C: CommutativeRing, R: Algebra C): with
    eval: (UP, R) -> R
  == add
    eval(p: UP, x: R): R ==
        zero? p => 0
        leadingCoefficient(p)$UP * (x^degree(p)$UP) + eval(reductum p, x)
\end{verbcode}

\bibliography{qeta}
\end{document}
)endif
