-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2020-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{The congruence subgroup $\Gamma_1(N)$}
\author{Ralf Hemmecke}
\date{05-Dec-2020}
\maketitle
\begin{abstract}
  The domain \code{CongruenceSubgroupGamma1} contains helper
  functions like genus, number of cusps, index of $\Gamma_1(N)$ in
  $\SL2Z$, etc.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indroduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $N$ be a positive natural number and $\Gamma_1(N)$ be as defined
in \eqref{eq:Gamma1}.

For some formulas see
\url{https://www.wstein.org/books/modform/modform/dimension_formulas.html}.
for the computation of the genus of $X_1(N)$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

First of all for debugging.
)endif

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
%$
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
SL2Z ==> Matrix Z -- represents SL_2(Z), will be a 2x2 square matrix
EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)

INTF ==> IntegerNumberTheoryFunctions

asN x ==> x pretend N
asP x ==> x pretend P


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package CongruenceSubgroupGamma1: Congruence subgroup
$\Gamma_1(N)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain GAMMA1 CongruenceSubgroupGamma1
++ CongruenceSubgroupGamma1(nn) implements functions connected to the
++ congruence subgroup $\Gamma_1(N)$.
++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
CongruenceSubgroupGamma1(nn: P): with
    width: Cusp -> Z
      ++ width(m, cusp) returns the width of the cusp for Gamma_1(m).
      ++ If cusp=(a:c), the width is independent of a and given by
      ++ m/gcd(c,m) except when m=4 and gcd(c,m)=2 where the width is 1.
      ++ See Equation (2.49) in
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
      ++ which is in Corollary 4 (2) of
      ++ \cite{ChoKooPark_ArithmeticRamanujanGoellnitzGordon_2009}.
    cuspWidth: (Z, Z) -> Z
      ++ cuspWidth(a, c) returns the width of the cusp a/c of
      ++ Gamma_1(nn)
    index: () -> P
      ++ index() computes the index of Gamma_1(nn) in SL2Z.
    projectiveIndex: () -> P
      ++ projectivIndex() computes the index of the image of
      ++ Gamma_1(nn) in PSL2Z.
    cusps: () -> List Cusp
      ++ cusps() returns representative for all the (inequivalent)
      ++ cusps for Gamma_1(nn) sorted ascendingly. cusp(0,1) will be
      ++ the first and cusp(1,0)=infinity() will be the last.
    nu2: () -> Z
      ++ nu2() returns the number of $\Gamma_1(nn)$ inequivalent
      ++ elliptic points of order 2. This is \mu_{1,2}(nn) of
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
      ++ and known to be zero if nn > 2.
    nu3: () -> Z
      ++ nu3(n) returns the number of $\Gamma_1(n)$ inequivalent
      ++ elliptic points of order 3. This is \mu_{1,3}(n) of
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
      ++ and known to be zero if n > 3.
    numberOfCusps: () -> P
      ++ numberOfCusps() returns the number of cusps of $\Gamma_1(nn)$. See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    genus: () -> N
      ++ genus() returns the genus of the congruence subgroup
      ++ Gamma_1(nn). We use formulae given at
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
      ++ See Section "Modular Formas for $\Gamma_1(N)$" in
      ++ \cite{Stein_ModularForms_2007}.
    cuspToMatrix: Cusp -> SL2Z
      ++ For cusp=(a:c), cuspToMatrix(cusp) returns a matrix
      ++ gamma=[[a,b],[c,d]] corresponding to the cusp (a:c) of
      ++ Gamma1(nn). We assume that a/c is a normalized cusp, i.e.
      ++ cusp=normalizeCusp(cusp).
    member?: SL2Z -> Boolean
      ++ member?(mat) returns true if mat is an element of
      ++ $\Gamma_1(nn)$, i.e. if entry (2,1) is a multiple of nn and
      ++ entries (1,1) and (2,2) are congruent 1 (mod nn).
      ++ Here it is assumed that determinant(mat)=1.
    equivalentCusps?: (Cusp, Cusp) -> Boolean
      ++ equivalentCusps?(cusp1, cusp2) returns true iff the cusp
      ++ cusp1=(a:c) is equivalent to cusp2=(u:w) modulo the action of
      ++ Gamma1(nn).
      ++ Two cusps (a:c) and (u:w) are equivalent modulo the action of
      ++ Gamma1(N) if either (1) c = w (mod N) and a = u (mod gcd(c,N)
      ++ or (2) c = -w (mod N) and a = -u (mod gcd(c, N). For c=0, we
      ++ interpret (a:c) as the cusp infinity. See Proposition 2.27 in
      ++ the PhD thesis of William Stein:
      ++ https://www.wstein.org/thesis/.
    normalizeCusp: Cusp -> Cusp
      ++ normalizeCusp(cusp) normalizes the cusp to another
      ++ (equivalent modulo Gamma1(nn)) cusp (u:w) such that numerator
      ++ and denominator are positive and small.
      ++ Exceptions are 0=(0:1) and infinity()=(1:0).
    dimensionOfCuspForms: Z -> N
      ++ dimensionOfCuspForms(w) computes the dimension of
      ++ S_w(\Gamma_1(nn)). See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    dimensionOfEisensteinSubspace: Z -> N
      ++ dimensionOfEisensteinSubspace(w) computes the dimension of
      ++ E_w(\Gamma_1(nn)), the Eisenstein subspace of modular forms
      ++ See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    dimensionOfModularForms: Z -> N
      ++ dimensionOfModularForms(w) computes the dimension of
      ++ M_w(\Gamma_1(nn)). See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    rightCosetRepresentatives: P -> List SL2Z
      ++ rightCosetRepresentatives(mm) returns a list of right coset
      ++ representatives of $\Gamma_1(mm*nn) \backslash \Gamma_1(mm)$.
    rightCosetRepresentatives: () -> List SL2Z
      ++ rightCosetRepresentatives() returns
      ++ rightCosetRepresentatives(nn, 1). It is a list of right coset
      ++ representatives of $\Gamma_1(nn) \backslash \Gamma_1(1)$.
    doubleCosetRepresentatives: () -> List SL2Z
      ++ doubleCosetRepresentatives() returns a list of double
      ++ coset representatives of
      ++ $\Gamma_1(nn) \backslash \Gamma_1(1) / SL_2(\setZ)_\infty$
      ++ where $SL_2(\setZ)_\infty$ are matrices of the form [[1,h],[0,1]]
      ++ with h being an integer.

  == add

    index(): P ==
        nn = 1 => 1
        nn = 2 => 3
        r: Q := 1
        for f in factorList factor nn repeat
            r := r * (1 - 1/(f.factor)^2)
        asP numer(nn^2*r)

    projectiveIndex(): P ==
        nn < 3 => index()
        asP shift(index(), -1)

    width(cusp: Cusp): Z ==
        c := denom cusp
        nn=4 and gcd(c,nn)=2 => 1
        (nn exquo gcd(c, nn)) :: Z

    cuspWidth(a: Z, c: Z): Z ==
        g: SL2Z := cuspToMatrix(cusp(a, c))$Cusp
        ig: SL2Z := matrix [[g(2,2), -g(1,2)],[-g(2,1), g(1,1)]]
        for d in 1..index() repeat
            member?(g * matrix [[ 1,d],[0, 1]] * ig) => return d
            member?(g * matrix [[-1,d],[0,-1]] * ig) => return d
        error "width(Gamma1): we should not come here"

    cusps(): List Cusp ==
        nn = 1 => [infinity()]
        nn = 2 => [cusp(0, 1), infinity()]
        nn = 3 => [cusp(0,1), infinity()]
        nn = 4 => [cusp(0,1), cusp(1,2), infinity()]
        h: XHashTable(Cusp, Cusp) := table()
        for c in 1..nn repeat
            g: Z := gcd(c, nn)
            if one? g then g := 2
            for x in 1..g-1 | one? gcd(x, g) repeat
                a: Z := x
                while not one? gcd(a, c) repeat a := a + g
                cusp := normalizeCusp(cusp(a, c))
                h.cusp := cusp -- might override existing cusp
        sort!(keys h)

    nu2(): Z == -- number of elliptic points of order 2
        nn > 2 => 0
        1

    nu3(): Z == -- number of elliptic points of order 3
        nn >= 4 or nn = 2 => 0
        1

    numberOfCusps(): P ==
        --assert(one? first divisors level)
        nn < 3 => nn
        nn < 5 => asP(nn - 1)
        n: Z := 0
        phidivs := [eulerPhi d for d in divisors(nn)$INTF]
        for c in phidivs for d in reverse phidivs repeat n := n + c*d
        odd? n => error "something is rotten"
        asP(shift(n, -1)) -- divide by 2

    genus(): N ==
        -- general formula is
        -- g = 1 + mu/12 - nu2/4 - nu3/3 - nuinfinity/2
        -- where mu is the index of Gamma1(m) in PSL2Z,
        q: Q := projectiveIndex()/12 - nu2()/4 - nu3()/3 - numberOfCusps()/2
        not one? denom q =>
            tracePrint("[nn,index,nu2,nu3,cusps]",[nn,index(),nu2(),nu3(),numberOfCusps()]$List(Z))
            tracePrint("q,",q)
            error "genus(Gamma1): non-vanishing denominator"
        asN(1 + numer(q))

    cuspToMatrix(cusp: Cusp): SL2Z == cuspToMatrix(cusp)$Cusp

    member?(mat: SL2Z): Boolean ==
        zero?(mat(2,1) rem nn) _
           and zero?((mat(1,1)-1) rem nn) _
           and zero?((mat(2,2)-1) rem nn)

    equivalentCusps?(c1: Cusp, c2: Cusp): Boolean ==
        pr ==> positiveRemainder
        c := pr(denom c1, nn)
        g := gcd(c, nn)
        c = pr(  denom c2, nn) and zero? pr(numer c1 - numer c2, g) => true
        c = pr(- denom c2, nn) and zero? pr(numer c1 + numer c2, g) => true
        false

    -- local
    coprimeRemainder(a: Z, c: Z, d: Z): Z ==
        a := positiveRemainder(a, d)
        while not one? gcd(a, c) and a < c repeat a := a + d
        a

    -- local
    normCusp(a: Z, c: Z): Cusp ==
        one? c => cusp(0, 1)
        cusp(a, c)

    normalizeCusp(cusp: Cusp): Cusp ==
        a: Z := numer cusp
        c: Z := denom cusp
--        not one? gcd(a, c) => error "normalizeCusp: cusp not in lowest terms"
        one? nn => infinity() -- = cusp infinity
        c: Z := positiveRemainder(c, nn)
        zero? c =>
            a := positiveRemainder(a, nn)
            a := min(a, nn - a) -- cannot be zero
            one? a =>  infinity()
            cusp(a, nn)

        a: Z := positiveRemainder(a, c)
        zero? a => cusp(0, 1)

        d: Z := gcd(c, nn)
        c2: Z := nn - c
        one? d => normCusp(1, min(c, c2))

        c < c2 => normCusp(coprimeRemainder( a, c , d), c)
        c > c2 => normCusp(coprimeRemainder(-a, c2, d), c2)
        -- c=c2
        a := min(coprimeRemainder(a, c, d), coprimeRemainder(-a, c, d))
        normCusp(a, c)

    doubleCosetRepresentatives(): List SL2Z ==
        [cuspToMatrix cusp for cusp in cusps()]

    dimensionOfCuspForms(w: Z): N ==
        error "dimensionOfCuspForms: not implemented"

    dimensionOfEisensteinSubspace(w: Z): N ==
        error "dimensionOfEisensteinSubspace: not implemented"

    dimensionOfModularForms(w: Z): N ==
        dimensionOfCuspForms w +  dimensionOfEisensteinSubspace w

    rightCosetRepresentatives(mm: P): List SL2Z ==
        error "rightCosetRepresentatives: not implemented"

    rightCosetRepresentatives(): List SL2Z ==
        error "rightCosetRepresentatives: not implemented"



)if LiterateDoc
%$
\bibliography{qeta}
\end{document}
)endif
