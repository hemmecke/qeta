-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2020  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))

dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
--dbgPrint(x,y) ==> display(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF)::Formatter(Format1D))
xdbgPrint(x,y) ==> rhx:="42"




)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{xifthen}

\newcommand{\eps}{\varepsilon}

\newcommand{\degree}[2][]{%
  \ifthenelse{\equal{#1}{}}{\deg(#2)}{\deg_{#1}(#2)}}

\newcommand{\opdegreeSize}{\psi}
\newcommand{\degreeSize}[1]{\opdegreeSize(#1)}

\newcommand{\opdegreeIndexSize}{\Psi}
\newcommand{\degreeIndexSize}[1]{\opdegreeIndexSize(#1)}

\newcommand{\opeuclideanSize}{\varphi}
\newcommand{\euclideanSize}[1]{\opeuclideanSize(#1)}

\DeclareMathOperator{\opidx}{idx}
\newcommand{\idx}[1]{\opidx(#1)}

\DeclareMathOperator{\oplc}{lc} % leading coefficient
\newcommand{\lc}[2][]{\ifthenelse{\equal{#1}{}}{\oplc(#2)}{\oplc_{#1}(#2)}}

\DeclareMathOperator{\opinitial}{in} % initial = coefficient * power product
\newcommand{\initial}[2][]{%
  \ifthenelse{\equal{#1}{}}{\opinitial(#2)}{\opinitial_{#1}(#2)}}

\DeclareMathOperator{\zero}{zero} % zero testing
\DeclareMathOperator{\true}{true} % zero testing
\DeclareMathOperator{\false}{false} % zero testing

\DeclareMathOperator{\select}{select}
\DeclareMathOperator{\reduce}{reduce}
\DeclareMathOperator{\oneStepReduce}{red}
\DeclareMathOperator{\reducible}{reducible}

\newcommand{\FunSelect}[2]{\select_{{#1},{#2}}}
\newcommand{\FunReduce}[3][]{\reduce^{#1}_{{#2},{#3}}}

\newcommand{\applySelect}[3]{\FunSelect{#2}{#3}({#1})}
\newcommand{\applyReduce}[4][]{\FunReduce[#1]{#3}{#4}({#2})}
\newcommand{\applyOneStepReduce}[3]{\oneStepReduce(#1, #2, #3)}

\newcommand{\RelReduce}[2][]{\mathrel{\rightarrow_{#2}^{#1}}}
\newcommand{\canBeReducedTo}[4][]{#3\RelReduce[#1]{#2}{#4}}

\newcommand{\RelFunReduce}[2][]{\mathrel{\mapsto_{#2}^{#1}}}
\newcommand{\reducesTo}[4][]{#3\RelFunReduce[#1]{#2}{#4}}

\newcommand{\RelLessThanLex}{\mathrel{<_{\textsf{lex}}}}
\newcommand{\ltLex}[2]{#1\RelLessThanLex{#2}}
\newcommand{\RelLessEqualLex}{\mathrel{\le_{\textsf{lex}}}}
\newcommand{\leLex}[2]{#1\RelLessEqualLex{#2}}

\newcommand{\RelDivisibilityN}{\sqsubseteq}
\newcommand{\dividesN}[2]{#1\RelDivisibilityN{#2}}
\newcommand{\RelProperDivisibilityN}{\sqsubset}
\newcommand{\dividesProperlyN}[2]{#1\RelProperDivisibilityN{#2}}

\newcommand{\RelDivisibilityMod}[1]{\trianglelefteq_{#1}}
\newcommand{\dividesMod}[3][]{#2\RelDivisibilityMod{#1}#3}
\newcommand{\RelProperDivisibilityMod}[1]{\vartriangleleft_{#1}}
\newcommand{\dividesModProperly}[3][]{#2\RelProperDivisibilityMod{#1}#3}

\usepackage{makeidx}
\makeindex

%\usepackage{rhxterm} % define \useterm and \defineterm
\def\defineterm#1{\textcolor{red}{\emph{#1}}}
\def\useterm{}

\newtheorem{Remark}[Theorem]{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{The PowerSamba Algorithm}
\author{Ralf Hemmecke}
\date{26-Apr-2018}
\maketitle
\begin{abstract}
  This code implements the \algoPowerSamba{} algorithm.
  There is no proof yet that it works as one would expect.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on the article
\cite{Hemmecke:DancingSambaRamanujan:2018} by Ralf Hemmecke but uses
newer ideas in order to work not only for rings of the form $R=C[x]$,
but also for modules of the form $R=C[x]^r$.
%
In fact, it works for a $C$-module $M$ and a (multi-)degree function:
$\deg: M \to \setZ^r \cup \Set{\infty}$ with the condition that
$\deg(m) < 0$ ($<$ in each component), then $m=0$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Definitions and Notations}%
\label{sec:Definitions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\defineNotation[N]{\setN}$ denote the natural numbers (including
0).
%
Let $\defineNotation{C}$ be a computable Euclidean domain and let
$\defineNotation[phi]{\opeuclideanSize}: C\setminus\Set{0} \to
\setN\setminus\Set{0}$ be a Euclidean size function (also known as
Euclidean degree or simply Euclidean function) on $C$. By
$\defineNotation{C^\times}$ we denote the set of invertible elements
of $C$.
%
At the moment we assume $R=C[x]$ and $M=R^n$. We shall see later, that
everything also works in a more general context.

For $f=\sum_{k=0}^r c_k x^k \in R$, we denote by
$\defineNotation[initial]{\initial{f}}=c_r x^r$,
$\defineNotation[lc]{\lc{f}}=c_r$,
$\defineNotation[deg]{\degree{f}}=r$ the initial, the leading
coefficient and the degree of $f$. In particular, we define
$\initial{0}=0$, $\lc{0}=0$, $\degree{0}=-\infty$.

Let $\defineNotation[Mstar]{M^*}=M\setminus\Set{0}$.
%
For $f=(f_1, \ldots f_n) \in M^*$, we denote by
%
$\defineNotation[idx]{\idx{f}}$ the maximal $j$ such that $f_j \ne 0$.
%
Furthermore, for $i \in \Set{1,\ldots,n}$,
%
$\defineNotation[initiali]{\initial[i]{f}} = \initial{f_i}$,
%
$\defineNotation[lci]{\lc[i]{f}} = \lc{f_i}$,
%
$\defineNotation[degreei]{\degree[i]{f}} = \degree{f_i}$
%
the initial, the leading coefficient and the degree of $f$. In
particular, we define $\initial[i]{0}=0$, $\lc[i]{0}=0$,
$\degree[i]{0}=-\infty$.

To ease notation, we also define $\degree{f}=\degree[\idx{f}]{f}$ and
$\lc{f}=\lc[\idx{f}]{f}$ for $f \in M^*$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}%
  \label{def:Ordering}%
  \label{def:degreeSize}%
  \label{def:degreeIndexSize}%
  Let $\defineNotation[<lex]{\RelLessThanLex}\subset\setN^3$ and
  $\defineNotation[<divisibility]{\RelDivisibilityN}\subset\setN^2$ be
  two relation defined by
  \begin{align*}
    \ltLex{(n_1,n_2,n_3)}{(n_1',n_2', n_3')}
    &\iff
      n_1 < n_1' \lor (n_1 = n_1' \land n_2< n_2') \lor
      (n_1 = n_1' \land n_2= n_2'  \land n_3< n_3')
    \\
    \dividesN{(n_1,n_2)}{(n_1',n_2')} &\iff n_1\le n_1' \land n_2\le n_2',
  \end{align*}
  for $n_1, n_2, n_3, n_1', n_2', n_3' \in \setN$.
%
  We denote by $\defineNotation[<=lex]{\RelLessEqualLex}$ the
  reflexive closure of $\RelLessThanLex$.

  For $f \in R^*= R\setminus\Set{0}$, let
  %
  $\defineNotation[psi]{\opdegreeSize}: R^* \to \setN^2$
  %
  be defined by
  %
  $\degreeSize{f}=(\degree{f}, \euclideanSize{\lc{f}})$.

  For $f\in M^*$, let
  $\defineNotation[Psi]{\opdegreeIndexSize}: M^* \to \setN^3$ be
  defined by
  $\degreeIndexSize{f} = (\degree{f}, \idx{f},
  \euclideanSize{\lc{f}})$.

  Let $d\in\setN\setminus\Set{0}$, $n, n' \in \setZ$. By
  $n \mathrel{\defineNotation[=d]{\equiv_d}} n'$ we denote that $n$
  and $n'$ are \defineterm{congruent modulo $d$}, \ie, that there
  exists $a\in\setZ$ such that $n=n'+ad$.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}%
  \label{def:reducibility}%
  Let $u, b \in M^*$. We say that $u$ is
  %
  \defineterm{reducible by $b$ modulo $d$} (denoted by
  $\defineNotation[<divides]{\dividesMod[d]{b}{u}}$) if and only if
  \begin{gather*}
    u_i \ne 0
    \land
    \degreeSize{b_i} \sqsubseteq \degreeSize{u_i}
    \land
    \deg(b_i) \equiv_d \deg(u_i)
  \end{gather*}
  for $i = \idx{b}$.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that from $\dividesMod[d]{b}{u}$ follows
$\degree{b}\le\degree{u}$, but not necessarily $\idx{b}=\idx{u}$.

In general, from $\dividesMod[d]{b}{u}$ and $\dividesMod[d]{u}{b}$
follows only $i:=\idx{b}=\idx{u}$, and
$\degreeSize{b_i} = \degreeSize{u_i}$, but neither $b=u$ nor
$\initial{b} = \initial{u}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:ReductionRelation}
  For $u, t, b\in M^*$, $u'\in M$, the relation
  $\defineNotation[->tbu]{\canBeReducedTo{t, b}{u}{u'}}$ holds (in
  words: $u$ \defineterm{reduces in one step modulo $t$ and $b$} to
  $u'$) if and only if there exists $i\in\Set{1,\ldots,n}$ such that
  $i=\idx{t}=\idx{b}$,
  %
  $\dividesMod[d]{b}{u}$ for $d=\deg(t_i)$,
  %
  and there exist $c\in C$ and $a\in\setN$ such that
  $u = c t^a b + u'$ and either $u'=0$ or
  $\ltLex{\degreeIndexSize{u'}}{\degreeIndexSize{u}}$.

  If $B=\Set{b_1, \ldots, b_r}\subset M^*$ and
  $T=\Set{t_1, \ldots, t_s}\subset M^*$, with $\degree{t_i}>0$ for all
  $i=1,\ldots,s$, then $\defineNotation[->TBu]{\canBeReducedTo{T, B}{u}{u'}}$ holds (in words:
  $u$ \defineterm{can be reduced in one step modulo $T$ and $B$} to
  $u'$) if and only if there exists $b \in B$ and $t \in T$ such that
  $\canBeReducedTo{t, b}{u}{u'}$.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Remark}\label{remark:oneStepReduce}
  Clearly, if $\canBeReducedTo{t, b}{u}{u'}$, then
  $\dividesMod[d]{b}{u}$ for $d=\degree{t}$ by definition.

  Conversely, let $u, t, b \in M^*$ with $i:=\idx{b}=\idx{t}$,
  $d=\degree{t_i}>0$, $\lc{t_i}=1$ and assume $\dividesMod[d]{b}{u}$.
  %
  Then $a=\frac{\degree{u_i} - \degree{b_i}}{d}\in\setN$ and
  $\euclideanSize{\lc{b_i}} \le \euclideanSize{\lc{u_i}}$.
  %
  Furthermore, since $C$ is a Euclidean domain, there exists $c\in C$
  such that $\lc{u_i} = c \lc{b_i} + r$ with either $r=0$ or
  $\euclideanSize{r} < \euclideanSize{\lc{b_i}}$.
  %
  Thus, if the operations in $C$ are computable, we can compute
  $(a,c)\in \setN\times C$ and $u'=u - ct^ab$ such that either $u'=0$
  or $u'_i=0$ (and, thus, $\idx{u'} < \idx{u}$) or
  $\degree{u'_i}<\degree{u_i}$ or
  $\euclideanSize{\lc{u_i'}}<\euclideanSize{u_i}$
  %
  \ie, $\ltLex{\degreeIndexSize{u'}}{\degreeIndexSize{u}}$, in other
  words, we can compute $u'$ with $\canBeReducedTo{t, b}{u}{u'}$.

  In general, Euclidean division does not necessarily yield unique $c$
  and $r$ with the above properties. Consider, for example, the case of
  Gaussian integers $C=\setZ[i]$ with $\euclideanSize{a+bi}=a^2+b^2$.
  Then $3 = (1-i)\cdot(1+i) + 1 = (2-i)\cdot(1+i)-i$ are two different
  Euclidean division steps of $3$ by $1+i$.

  In order to make the reduction functional, we assume a computable
  function
  $\defineNotation[red]{\oneStepReduce}: M^3\to \setN \times C$ such
  that if $u, t, b \in M^*$,
  %
  $i=\idx{b}=\idx{t}$,
  %
  $d=\degree{t_i}>0$,
  %
  $\lc{t_i}=1$,
  %
  $\dividesMod[d]{b}{u}$,
  %
  $(a, c) = \applyOneStepReduce{u}{t}{b}$, and
  %
  $u'=u-ct^ab\ne0$, then
  %
  $\ltLex{\degreeIndexSize{u'}}{\degreeIndexSize{u}}$.
\end{Remark}

\begin{Hemmecke}
\begin{Definition}
  For $d\in \setN\setminus\Set{0}$, a set $B\subseteq R^*$ is called
  \defineterm{interreduced modulo $d$}, if for any $b, b' \in B$,
  $b\ne b'$ neither $\dividesMod[d]{b}{b'}$ nor $\dividesMod[d]{b'}{b}$
  holds.
\end{Definition}

\begin{Remark}\label{remark:abmiguity}
  Suppose that the set $B\subseteq R^*$ is \useterm{interreduced
    modulo $d$}. If $C$ is a field, then $\euclideanSize{c}=1$ for any
  $c\in C\setminus\Set{0}$. It follows that for any $u\in R^*$ there
  is at most one $b\in B$ such that $\dividesMod[d]{b}{u}$.

  In general, however, for $u\in R^*$ it is still possible that there
  exist $b, b' \in B$, with $b\ne b'$, $\dividesMod[d]{b}{u}$, and
  $\dividesMod[d]{b'}{u}$. For example, consider $C=\setZ$,
  $\euclideanSize{z}=\abs{z}$. If $b, b' \in B$, $b \ne b'$ with
  $\deg b = d + \deg b'$,
  $\euclideanSize{\lc b} < \euclideanSize{\lc b'}$, and $u\in R^*$ is
  such that $\deg u = \deg b$ and
  $\euclideanSize{\lc{u}} = \euclideanSize{\lc{b'}}$. To be more
  concrete, consider $t=x^2$, \ie, $d=2$ and $u=3x^5$, $b=3x^3$,
  $b'=2x^5$. Then $u=tb+0=b'+x^5$.
\end{Remark}

To remove such ambiguity as described in
Remark~\ref{remark:abmiguity}, we introduce a reduction relation where
among possible multiple choices, the element is preferred that has
maximal degree in $x$.

\begin{Definition}
  Let $t, u \in R^*$, $d=\deg t>0$, $B \subset R^*$ be
  \useterm{interreduced modulo $d$}, and let there exist $b \in B$
  with $\dividesMod[d]{b}{u}$. We denote by
  \defineNotation[select]{\applySelect{u}{t}{B}} the element $b \in B$
  such that
  $\deg b = \max \SetDef{\deg b'}{b'\in B\land \dividesMod[d]{b'}{u}}$.

  We say that the relation $\reducesTo{t,B}{u}{u'}$ holds if and only
  if $\canBeReducedTo{t,b}{u}{u'}$ and $u'= u-ct^ab$ for
  $b = \applySelect{u}{t}{B}$ and
  $(a, c) = \applyOneStepReduce{u}{t}{b}$.
%
  By $\RelFunReduce[*]{t ,B}$ we denote the reflexive and transitive
  closure of $\RelFunReduce{t,B}$.
  %
  By \defineNotation[reduce]{\applyReduce{u}{t}{B}}, we denote the
  $u'\in R$ such that $\reducesTo[*]{t, B}{u}{u'}$ and there does
  not exist $b\in B$ with $\dividesMod[d]{b}{u'}$.
  %
  If $u' = \applyReduce{u}{t}{B}$, we say $u$ \defineterm{reduces
    modulo $t$ and $B$} to $u'$.
\end{Definition}

\begin{Remark}
  Under the assumption that $B$ is finite, $\dividesMod[d]{b}{u}$ is
  decidable algorithmically and the function $\oneStepReduce$ from
  Remark~\ref{remark:oneStepReduce} is computable, also
  $\FunSelect{t}{B}$ and $\FunReduce{t}{B}$ are computable.
\end{Remark}

\begin{Remark}
  By keeping track of the individual reduction steps, it is clear that
  if $u' = \applyReduce{u}{t}{B}$, then for every $b\in B$ there
  exists $p_b\in C[x]$ such that
  \begin{gather}
    u = u' + \sum_{b\in B} p_b(t) b\label{eq:repr-u}
  \end{gather}
  and
  $\degreeSize{u} = \max_{\RelLessThanLex} (\Set{\degreeSize{u'}} \cup
  \SetDef{\degreeSize{p_b(t)b}}{b\in B, p_b\ne0})$.
  In particular, we want to emphasize that there is no summand $s$ on
  the right-hand side of~\eqref{eq:repr-u} with
  $\ltLex{\degreeSize{u}}{\degreeSize{s}}$.
\end{Remark}
\end{Hemmecke}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
%$
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
IDX ==> XHashTable(P, P)
MUL ==> XHashTable(P, F)
    -- There should be multipliers for each component k
    -- This is the mapping from k to multiplier.
    -- Let gk be grade(mul.k, k)
H ==> XHashTable(Z, List F)
    -- For each component k and each i from 1 to gk-1 there should
    -- be a basisElement b such that grade(b, k) = i mod gk
V ==> Vector H -- mapping k -> H

asN x ==> x pretend N
asP x ==> x pretend P

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category XEtaAlgebraBasisCategory: Data structure for
  \algoPowerSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev category XABC XEtaAlgebraBasisCategory
++ XEtaAlgebraBasisCategory(C, F) is a category for a data
++ structure that can be used for reduction modulo an algebra basis
++ (samba basis).
XEtaAlgebraBasisCategory(C, F): Category == Exports where
  C: EuclideanDomain
  F: XEtaGradedAlgebra C
  Exports ==> CoercibleTo OutputForm with
    indexPermutation: % -> IDX
      ++ indexPermutaion(x) returns a computed permutation of the
      ++ component indices of F so that it fit best during the
      ++ computation.
      ++ The reduction and creation of the basis according to the theory
      ++ is done from i=n down to i=1 where n=maxIndex() of F, i.e. the grade
      ++ in the last component will be reduced first.
      ++ indexPermutation(x).n then gives the actual component index that
      ++ corresponds to "last".
      ++ By this dynamical reordering we try to keep the grades small.
    multipliers: % -> MUL
      ++ multipliers(x) returns the elements by which it can be
      ++ multiplied with an arbitrary positive power.
    basisElements: % -> V
      ++ basisElements(x) returns the basis elements that are stored
      ++ in the structure x.
    component: (F, IDX) -> Z -- auxiliary function
      ++ Let k = qetaIndex(u), g := grade(u,k), and  I = sort(keys idx).
      ++ component(u, idx) returns c where
      ++ c is -k if empty?(I).
      ++ c is the idx(max(J)) if
      ++ J = [i for i in I | grade(u, k) = grade(u, idx.i)] is nonempty.
      ++ If J is empty, then c = -k otherwise.

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain XEtaAlgebraBasis: Data structure for
  \algoPowerSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain XETAAB XEtaAlgebraBasis
++ XEtaAlgebraBasis(C, F) is a domain holding the special
++ structure of an algebra basis with elements that can be used during
++ a reduction in arbitrary positive power (the multipliers), the
++ linear basis elements and an order on the component given by an
++ index permutation idx if i<j then component idx.i should be counted
++ as smaller than component idx.j.
XEtaAlgebraBasis(C, F): Exports == Implementation where
  C: EuclideanDomain
  F: XEtaGradedAlgebra C
  Exports ==> XEtaAlgebraBasisCategory(C, F) with
    empty: () -> %
      ++ empty() returns an empty structure with no multipliers and no
      ++ basisElements.
  Implementation ==> add
    Rep ==> Record(idx: IDX, mul: MUL, be: V)
    xx ==> rep x
    import from Rep

    n: P := maxIndex()$F

    coerce(x: %): OutputForm == xx::OutputForm

    empty(): % ==
        v: V := new(maxIndex()$F, empty()$H)
        -- We need a new hash table structure in every component of v.
        for k in 1..maxIndex()$F repeat v.k := empty()$H
        per [empty()$IDX, empty()$MUL, v]

    indexPermutation(x: %): IDX == xx.idx
    multipliers(x: %): MUL == xx.mul
    basisElements(x: %): V == xx.be

    component(u: F, ix: IDX): Z ==
        k: P := qetaIndex u
        empty? ix => -k -- no multiplier available
        g: Z := qetaGrade(u, k)
        for ii in n .. 1 by -1 | key?(i := asP ii, ix) repeat
            c := ix.i
            qetaGrade(u, c) = g => return c::Z
        return -k



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category XEtaReductionCategory: Restricted reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Hemmecke}
According to \cite{Hemmecke:DancingSambaRamanujan:2018}, we use a
restricted reduction for the algorithm \algoSamba.

An element $x$ is not reducible by $b$ not only when its grade is
bigger than that of $b$, but also when the grades are equal and the
(Euclidean) size of the leading coefficient of $x$ is smaller than
that of $b$.
\end{Hemmecke}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif


)abbrev category XREDCAT XEtaReductionCategory
XEtaReductionCategory(C, F, AB): Category == Exports where
  C: EuclideanDomain
  F: XEtaGradedAlgebra C
  AB: Type -- XEtaAlgebraBasisCategory(C, F)
  Exports ==> with
    topReducible?: (F, F, P) -> Boolean
      ++ topReducible?(u, b, k) returns true iff there exists f in F
      ++ such that for v = u - f*b, lc = qetaLeadingCoefficient, and
      ++ grade = qetaGrade:
      ++ (grade(u, k) > grade(v, k) or
      ++ (grade(u, k) = grade(v, k) and
      ++ euclideanSize lc(u, k) > euclideanSize lc(v, k)
    reducer: (F, H, Z, P) -> Union(F, "failed")
      ++ reducer(u, basis, grdt, k) returns an element b from the
      ++ basis or b=1 such that qetaGrade(u, k) - qetaGrade(b, k) is
      ++ divisible by grdt or returns "failed" if no such b exists.
    noTraceEnter: (F, AB) -> Void
      ++ A functions that does nothing.
    noTrace: F -> Void
      ++ A function that does nothing.
    traceEnter: N -> (F, AB) -> Void
      ++ traceEnter(n)(x, a) returns void() and depending on the value
      ++ of n returns more and more information. Where a higer version
      ++ of n means more information. trace(0) is equivalent with
      ++ noTraceEnter.
    traceLoop: N -> F -> Void
      ++ traceLoop(n)(x) just returns void() without any side
      ++ effect and depending on the value of n returns more and more
      ++ information. Where a higer version of n means more
      ++ information. trace(0) is equivalent with noTraceElement.
    traceReturn: N -> F -> Void
      ++ traceReturn(n)(x) just returns void() without any side
      ++ effect and depending on the value of n returns more and more
      ++ information. Where a higer version of n means more
      ++ information. trace(0) is equivalent with noTraceElement.
    tracedReduce: ((F, AB) -> Void, F -> Void, F -> Void) -> ((F, AB) -> F)
      ++ tracedReduce(traceEnter, traceLoop, traceReturn)(u, ab) behaves
      ++ identical to reduce(u, ab) except that at enter and exit
      ++ time the functions traceEnter(u, ab) and traceExit(w)
      ++ are called where w is the value that will be returned. Inside
      ++ the internal while loop the function traceLoop(v) is called
      ++ with v being the intermediately reduced u.
      ++ These hooks are provided to print a trace of the reduction.
    reduce: (F, AB) -> F
      ++ reduce(u, ab) returns an element v such that
      ++ v is not reducible modulo ab and
      ++ "u reduces modulo ab to v".
    greaterGrade?: P -> (F, F) -> Boolean
      ++ greaterGrade?(k)(x, y) returns qetaGrade(x, k)>qetaGrade(y,k).
   add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F

    greaterGrade?(k: P): (F, F) -> Boolean == (x: F, y: F): Boolean +->
        qetaGrade(x, k) > qetaGrade(y, k)

    topReducible?(u: F, b: F, k: P): Boolean ==
        -- This is a very special test for top-reducibility.
        -- We already know that there is an appropriate element
        -- t.k (see selectReducer) that can potentially reduce
        -- u. But we must check whether the grade of b is actually
        -- greater than that of u in the k-th component and
        -- whether the leading coefficient of u can be reduced.
        --assert(not zero? u)
        --assert(qetaIndex b = k)
        --assert(not zero? leadingCoefficient(b, k))
        --assert(not zero? leadingCoefficient(u, k))
        grdu: Z := grade(u, k)
        grdb: Z := grade(b, k)
        grdu < grdb => false
        lcu: C := leadingCoefficient(u, k)
        lcb: C := leadingCoefficient(b, k)
        euclideanSize lcu >= euclideanSize lcb

    -- For tracing the computation, other functions (that print
    -- something) could be used.
    noTraceEnter(u: F, ab: AB): Void == void()
    noTrace(u: F): Void == void()

    reduce(u: F, ab: AB): F ==
        tracedReduce(noTraceEnter, noTrace, noTrace)(u, ab)

    -- To save time we assume that u is nonzero.
    -- Return an element b from the basis or b=1 such that
    -- grade u - grade b is divisible by grdt or return "failed" if no such
    -- b exists.
    -- This functions corresponds to the function "select_{t,basis}(u)" as
    -- in Definition 2.6 of \cite{Hemmecke:DancingSambaRamanujan:2018}.
    -- That reducer yields the element with biggest possible grade is
    -- ensured by the requirement that "basis" is appropriately sorted by
    -- greaterGrade?.
    reducer(u: F, basis: H, grdt: Z, k: P): Union(F, "failed") ==
        -- It is enough to reduce each component to grade > 0.
        grade(u, k, -1) < 0 => "failed"
        i: Z := positiveRemainder(grade(u, k), grdt)
        -- if zero? i there is no corresponding element in basis, but
        -- we can use the element 1, i.e. we reduce u by a power of t.
        zero? i => return (1$F)::Union(F, "failed")
        candidates: List F := elt(basis, i, empty())
            -- candidates contains all basis elements b with
            -- positiveRemainder(grade b, grdt) = i in the same order
            -- as given in basis.
        for b in candidates repeat
            if topReducible?(u, b, k) then return b::Union(F, "failed")
        "failed"

    traceEnter(verbosity: N): (F, AB) -> Void == (f: F, ab: AB): Void +->
        zero? verbosity => void() -- abort early
        vPrint("-------------------------------red u", traceout(verbosity)(f))
        not (AB has XEtaAlgebraBasisCategory(C, F)) => void()
        if verbosity > 1 then
            idx := indexPermutation ab
            vPrint("red idx", idx)
        if verbosity > 2 then
            mults: MUL := multipliers ab
            vPrint("red mults", [qetaGrades m for m in entries mults])
        if verbosity > 3 then
            be: V := basisElements ab
            n: P := maxIndex()$F
            v: Vector List List List Z :=
                l := [[[qetaGrades b for b in lb] for lb in entries be.k] for k in 1..n]
            vPrint("red be", v)

    traceLoop(verbosity: N): F -> Void == (f: F): Void +->
        zero? verbosity => void() -- abort early
        vPrint("red loop", traceout(verbosity)(f))

    traceReturn(verbosity: N): F -> Void == (f: F): Void +->
        zero? verbosity => void() -- abort early
        vPrint("redx", traceout(verbosity)(f))


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package XEtaReduction: Restricted reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package XETARED XEtaReduction
XEtaReduction(C, F, AB): Exports == Implementation where
  C: EuclideanDomain
  F: XEtaGradedAlgebra C
  AB: XEtaAlgebraBasisCategory(C, F)
  Exports ==> XEtaReductionCategory(C, F, AB)
  Implementation ==> add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    tracedReduce(trEnter: (F, AB) -> Void,_
                 trLoop: F -> Void,_
                 trReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        trEnter(u, ab)
        -- Reduce component qetaIndex u!!! as long as u is nonzero and
        -- a reducer does exist. If there does not exist a reducer, then
        -- don't try to reduce in another component.
        idx: IDX := indexPermutation ab
        mul: MUL := multipliers ab
        be: V := basisElements ab
        while not zero? u repeat
            trLoop u
            kz := component(u, idx)
            kz <= 0 => return u -- no top-reduction possible
            k: P := asP kz
            -- u := reduceComponents(u, mul.k, be.k, k)
            t: F := mul.k
            grdt: Z := grade(t, k)
            basis: H := be.k
            --assert(grade(t, k)=grade(t)) -- i.e. qetaIndex(t)=k
            --assert(grade(t, k)>0) -- that is by construction of mul
            --assert(one? leadingCoefficient(t, k)) -- invertible is enough
            --assert(grade(b, k)=grade b for all b in basis)
            ---- by construction of be.k
            --assert grade(b, k)>0 for all b in basis -- by construction of be
            --assert(not zero? positiveRemainder(grade(b), grade t) _
            --       for all b in basis) -- by construction of be
            (r := reducer(u, basis, grdt, k)) case "failed" => return u
            grdu: Z := grade(u, k)
            v: F := r :: F
            j: Z := ((grdu - grade(v, k)) exquo grdt) :: Z
            v: F := v*t^asN(j)

            -- cc: Record(quotient: C, remainder: C)
            cc := divide(leadingCoefficient(u, k), leadingCoefficient(v, k))
            u := u - (cc.quotient)*v
--TODO: Cannot simplify coefficient, since contrary to Finite0Series,
-- leadingCoefficient(u, k) does not give 0, but currently runs forever.
--TODO: zero? u => return u
--TODO: uca := unitNormal leadingCoefficient(u, k)
--TODO: u := (uca.associate)*u
        trReturn u
        return u

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package XEtaSambaPackage:
  \underline{S}ub\underline{A}lgebra%
  \underline{M}odule\underline{B}asis%
  \underline{A}lgorithm}

See \cite{Hemmecke:DancingSambaRamanujan:2018} for the specification
of \algoSamba{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif
)abbrev package XSAMBA XEtaSambaPackage
++ XEtaSambaPackage implements the algorithm Samba from an
++ article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
XEtaSambaPackage(C, F, AB, Y): Exports == Implementation where
  C: EuclideanDomain
  F: XEtaGradedAlgebra C
  AB: XEtaAlgebraBasisCategory(C, F)
  Y: QEtaComputationCategory(F, AB)
  Exports ==> with
    sambaComputation: List F -> Y
    sambaComputation: (List F, oneStep!: Y -> Y) -> Y
    samba: List F -> AB
      ++ samba(m) returns a list t and a list z such that
      ++ C[m] and the C[t]-module generated by 1 and z are equal as sets.
    samba: (List F, oneStep!: Y -> Y) -> AB
      ++ samba(m) returns a list t and a list z such that
      ++ C[m] and the C[t]-module generated by 1 and z are equal as sets.
  Implementation ==> add
    sambaComputation(m: List F, oneStep!: Y -> Y): Y ==
        --?assert(not empty? m)
        --?assert(qetaGrade t > 0)
        y: Y := initialize m
        while criticalElements? y repeat y := oneStep! y
        return postProcess! y

    samba(m: List F, oneStep!: Y -> Y): AB ==
        y: Y := sambaComputation(m, oneStep!)
        algebraBasis y

    sambaComputation(m: List F): Y == sambaComputation(m, oneStep!)
    samba(m: List F): AB == samba(m, oneStep!)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain XEtaComputation: Algorithm \algoPowerSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain XETAC XEtaComputation
XEtaComputation(C, F, AB, R): Exports == Implementation where
  C: EuclideanDomain
  F: XEtaGradedAlgebra C
  AB: XEtaAlgebraBasisCategory(C, F) with
      empty: () -> %
      basisElements: % -> V
  R: XEtaReductionCategory(C, F, AB)
  G ==> Record(sgi: List List Z, elem: F)
  FF ==> Record(sgi: List List Z, xf1: F, xf2: F)
  Products ==> XHashTable(Z, List FF)
  Exports ==> QEtaComputationCategory(F, AB) with
    oneVerboseStep!: (N, N, N, N) -> (% -> %)
      ++ oneVerboseStep!(ny, n0, nl, nr) is equivalent with
      ++ oneTracedStep!(trace ny, traceEnter(n0)$R, traceLoop(nl)$R, traceReturn(nr)$R).
  Implementation ==> add
    QEVAUX ==> QEtaQuotientExponentVectorsAux
    Rep ==> Record(ab: AB, cbe: List G, pairs: Products)
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    xx ==> rep x
    import from Rep
    n: P := maxIndex()$F
    coerce(x: %): OutputForm == xx::OutputForm

    algebraBasis(x: %): AB == xx.ab
    indexPermutation(x: %): IDX == indexPermutation(xx.ab)
    multipliers(x: %): MUL == multipliers(xx.ab)
    basisElements(x: %): V == basisElements(xx.ab)

    smallerGradeG?(g1: G, g2: G): Boolean ==
        smallerGrade?(g1.sgi, g2.sgi)$QEVAUX

    smallerGradeFF?(ff1: FF, ff2: FF): Boolean ==
        smallerGrade?(ff1.sgi, ff2.sgi)$QEVAUX

    toG(f: F): G ==
        ffsgi: List List Z := sort!(_>, [[grade(f, asP k), k] for k in 1..n])
        [ffsgi, f]$G

    toFF(f1: F, f2: F): FF ==
        ffsgi: List List Z :=
            sort!(_>, [[grade(f1, asP k) + grade(f2, asP k), k] for k in 1..n])
        [ffsgi, f1, f2]$FF

    insertNew!(ff: FF, ffs: List FF): List FF ==
        merge!(smallerGradeFF?, [ff], ffs)

    addPair!(products: Products, f1: F, f2: F): Products ==
        ff: FF := toFF(f1, f2)
        -- ff.sgi = [[g1,i1], [g2,i2], ...,[gn,in]] where g1 is highest grade
        g := first first ff.sgi -- this gives g1
        products.g := insertNew!(ff, elt(products, g, empty()))
        products

    addMultiplierPairs!(x: %): Void ==
        -- Add all products of multipliers except squares.
        products: Products := xx.pairs
        mul: MUL := multipliers x
        mults: List F := entries mul
        empty? mults => void()
        --TODO: Since element from the multipliers can have the same
        -- grade in different components, we also must check products
        -- of multipliers.
        t: F := first mults
        while not empty?(mults := rest mults) repeat
            for b in mults repeat addPair!(products, t, b)
            t := first mults

    -- Add pairs for a new basis element u that has just been
    -- added to the basis and has not made any other basis element
    -- become reducible by u.
    addBasisElementPairs!(u: F, basis: List F, x: %): Void ==
        products: Products := xx.pairs
        -- Add a pair (u, v) where v runs over all multipliers...
        for t in entries multipliers x repeat addPair!(products, u, t)
        -- and basis elements (including u itself)
        for b in basis repeat addPair!(products, u, b)

    basisElementList(x: %): List F ==
        be: V := basisElements x
        basis: List F := empty()
        for i in 1..n repeat
            for lb in entries be.i repeat
                for b in lb repeat basis := cons(b, basis)
        basis

    addNewBasisElementPairs!(u: F, x: %): Void ==
        addBasisElementPairs!(u, basisElementList x, x)

    addComponentGapPairs!(products: Products, t: F, basis: H, k: P): Products ==
        d: Z := grade(t, k)
        for bs in entries(basis) repeat -- bs: List F
            -- bs = all basis elements of same grade g (mod d)
            -- bs is non-empty and sorted by greaterGrade?
            b := first bs
            bas := rest bs
            g: Z := grade(b, k)
            while not empty? bas repeat
                b := first bas
                e: Z := grade(b, k)
                j: Z := ((g - e) exquo d) :: Z
                tj: F := t^asN(j)
                --assert(grade(tj*b, k)=g)
                --It might happen that qetaIndex(tj*b)~=k!!!
                addPair!(products, tj, b)
                bas := rest bas
                g := e
        products

    addGapPairs!(x: %): Void ==
        products: Products := xx.pairs
        mul: MUL := multipliers x
        be: V := basisElements x
        --TODO: check comment!
        -- Additionally, we have to add products of the form t^j*b
        -- where qetaGrade(b,k)+j*d=qetaGrade(b',k) and b, b' in x.be
        -- b different from b' and j>0 is minimal with that property.
        -- That corresponds to the set S (line 13) in the algorithm samba
        -- as presented in \cite{doi:10.1016/j.jsc.2017.02.001}
        -- We do this for each component separately.
        for kn in 1..n | key?(k := asP kn, mul) repeat
            addComponentGapPairs!(products, mul.k, be.k, k)

    computePairs!(x: %): Void ==
        addMultiplierPairs! x
        basis: List F := basisElementList x
        --assert(not empty? basis) -- so there is at least one product
        while not empty? basis repeat -- do not add a pair twice
            addBasisElementPairs!(first basis, basis, x)
            basis := rest basis
        addGapPairs! x

    updateNonMultiplier!(u: F, x: %, k: P): Void ==
        -- Now we look at every potentially reducible element in
        -- the basis and move such element to the critical element list.
        mul: MUL := multipliers x
        t: F := mul.k
        grdt: Z := grade(t, k)
        grdu: Z := grade(u, k)
        -- update basis
        -- Since u is not top-reducible by any basis element, we can add
        -- u to the basis. We move elements that become top-reducible by u
        -- from the basis into the critical elements.
        i: Z := positiveRemainder(grdu, grdt)
        -- i is not zero, because otherwise u would be reducible by t.
        basis: H := basisElements(x).k
        potentiallyReducible: List F := elt(basis, i, empty())
        red: List F := empty()
        irr: List F := empty()

        for b in potentiallyReducible repeat
            if topReducible?(b, u, k) then
                -- add b to criticalElements
                red := cons(b, red)
            else
                irr := cons(b, irr)
        basis.i := sort(greaterGrade? k, cons(u, irr))
        -- We don't need to redo reduction of pairs if no basis element
        -- has been removed.
        if empty? red then
            addNewBasisElementPairs!(u, x)
        else
            gred: List G := [toG f for f in red]
            gred := sort!(smallerGradeG?, gred)
            xx.cbe := merge!(smallerGradeG?, gred, xx.cbe)
            computePairs! x

    -- Destructively updates multipliers, basis, and critical elements
    update!(u: F, x: %): Void ==
        --assert(not zero? u)
        --u is not top reducible by x
        --assert(every?(x+->x, concat [_
        --      [not topReducible?(u, b, k) for all b in xx.cbe.k] _
        --    for all k in keys(multipliers x)]))
        idx: IDX := indexPermutation x
        kz := component(u, idx) --assert(not zero? kz)
        kz > 0 => updateNonMultiplier!(u, x, asP kz)
        k: P := asP(-kz)
        -- There must still be an unassigned index.
        -- maybe we should reduce all the other multipliers by u.
        i: P := n
        while key?(i, idx) repeat i := asP(i - 1)
        idx.i := k
        mul: MUL := multipliers x
        mul.k := u -- we've found a new multiplier
        -- if a new multiplier has been added, then remove the pairs
        computePairs! x

    initialize(m: List F): % ==
        --assert(not empty? m)
        gm: List G := sort!(smallerGradeG?, [toG f for f in m])
        x: % := per [empty()$AB, gm, empty()]
        computePairs! x
        x

    criticalElements?(x: %): Boolean ==
        not empty?(xx.cbe) or not empty?(xx.pairs)

    extractNext!(x: %): F ==
        p: Products := xx.pairs
        sgic: List List Z := empty()
        if not empty? xx.cbe then sgic := first(xx.cbe).sgi
        if not empty? p then
            g: Z := reduce(min, indices p)$List(Z) -- minimal grade
            r: FF := first(p.g) -- the element of this grade
            sgip: List List Z := r.sgi
            if empty? sgic or smallerGrade?(sgip, sgic)$QEVAUX then
                l: List FF := rest(p.g) -- remove u
                if empty? l then remove!(g, p) else p.g := l
                return r.xf1 * r.xf2
        --assert(empty? p or (not empty? sgic and not(sgip < sgic)))
        f := first(xx.cbe).elem
        xx.cbe := rest xx.cbe
        f

    oneTracedStepComputation!(tr: % -> Void, _
                   trEnter: (F, AB) -> Void,_
                   trLoop: F -> Void,_
                   trReturn: F -> Void): (%, % -> F) -> % ==
      (x: %, next!: % -> F): % +->
        --assert(criticalElements? x)
        -- Selection process: Take the first element from cbe or
        -- products with smallest degree prefer cbe if equal degree.
        tr x
        f: F := next! x
        tReduce ==> tracedReduce $ R
        u := tReduce(trEnter, trLoop, trReturn)(f, algebraBasis x)
        if not zero? u then update!(u, x)
        return x

    trace(verbosity: N): % -> Void == (x: %): Void +->
        zero? verbosity => void() -- abort early
        vPrint("==================================step(#cbe,#pairs)",_
            [#(xx.cbe), #(xx.pairs)]$List(Z))
        one? verbosity => void()
        vPrint("+++ keys(pairs)", [sort keys xx.pairs]$List(Z))
        verbosity = 2 => void()
        vPrint("+++ grades(cbe)", [b.sgi for b in xx.cbe]$List(List List Z))

    oneVerboseStep!(ny: N, n0: N, nl: N, nr: N): % -> % ==
        oneTracedStep!(trace ny, traceEnter(n0)$R,
                       traceLoop(nl)$R, traceReturn(nr)$R)


)if LiterateDoc
%$
\bibliography{qeta}
\printindex
\end{document}
)endif
