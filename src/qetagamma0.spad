-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018, 2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Auxiliary functions for the congruence subgroup $\Gamma_0(N)$}
\author{Ralf Hemmecke}
\date{04-Dec-2020}
\maketitle
\begin{abstract}
  The packages \code{CongruenceSubgroupGamma0} contain helper
  functions like genus, number of cusps, index of $\Gamma_0(N)$ in
  $\SL2Z$, etc.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indroduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $N$ be a positive natural number and $\Gamma_0(N)$ be as defined
in \eqref{eq:Gamma0}.

The width of a cusp is implemented according to
\cite[Lemma~2.37]{Radu_PhD_2010} and
\cite[Definition~2.9]{Radu_PhD_2010}.

For the computation of the genus of $X_0(N)$ we use
\cite[p.~25]{Shimura_ArithmeticTheory_1994}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

First of all for debugging.
)endif

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
%$
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
SL2Z ==> Matrix Z -- represents SL_2(Z), will be a 2x2 square matrix
EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)

INTF ==> IntegerNumberTheoryFunctions

asN x ==> x pretend N
asP x ==> x pretend P


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package CongruenceSubgroupGamma0: Congruence subgroup
$\Gamma_0(N)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The width of a cusp is implemented according to
\cite[Lemma~2.37]{Radu_PhD_2010} and
\cite[Definition~2.9]{Radu_PhD_2010}.

For the computation of the genus of $X_0(N)$ we use
\cite[p.~25]{Shimura_ArithmeticTheory_1994}.

)endif

)abbrev package GAMMA0 CongruenceSubgroupGamma0
++ CongruenceSubgroupGamma0 implements functions connected to the
++ congruence subgroup $\Gamma_0(N)$.
++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
CongruenceSubgroupGamma0: with
    width: (P, Cusp) -> Z
      ++ width(m, cusp) returns the width of the cusp=(a:c) for Gamma_0(m)
      ++ The width is independent of a and given by m/gcd(c^2,m).
      ++ \cite[Lemma~2.37]{Radu_PhD_2010}
    dedekindPsi:P -> P
      ++ dedekindPsi(n) computes the value of the Dedekind psi function.
      ++ https://en.wikipedia.org/wiki/Dedekind_psi_function
    index: P -> P
      ++ index(n) computes the index of Gamma_0(n) in SL2Z.
      ++ index(n) is equal to dedekindPsi(n).
    cusps: P -> List Cusp
      ++ According to
      ++ \cite[Lemma~2.45]{Radu_PhD_2010},
      ++ there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
      ++ $\Gamma_0(N)$ that correspond to a divisor $c$ of $N$.
      ++ cusps(m) returns representatives for all the (inequivalent)
      ++ cusps for Gamma_0(m) sorted by their size as rational numbers
      ++ with infinity being the biggest cusp.
    nu2: P -> Z
      ++ nu2(n) returns the number of $\Gamma_0(n)$ inequivalent
      ++ elliptic points of order 2.
      ++ \cite[p.~25]{Shimura_ArithmeticTheory_1994} and Proposition
      ++ 1.40.
    nu3: P -> Z
      ++ nu3(n) returns the number of $\Gamma_0(n)$ inequivalent
      ++ elliptic points of order 3. See
      ++ \cite[p.~25]{Shimura_ArithmeticTheory_1994} and Proposition
      ++ 1.40.
    numberOfCusps: P -> P
      ++ numberOfCusps(m) returns the number of cusps of $\Gamma_0(m)$.
      ++ \cite[p.~25]{Shimura_ArithmeticTheory_1994} and Proposition
      ++ 1.40.
    genus: P -> N
      ++ genus(level) returns the genus of the congruence
      ++ subgroup Gamma_0(level). It corresponds to the series
      ++ https://oeis.org/A001617 .
      ++ \cite[p.~25]{Shimura_ArithmeticTheory_1994} and Proposition
      ++ 1.40.
    dimensionOfCuspForms: (P, Z) -> N
      ++ dimensionOfCuspForms(m, w) computes the dimension of
      ++ S_w(\Gamma_0(m)). See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    dimensionOfEisensteinSubspace: (P, Z) -> N
      ++ dimensionOfEisensteinSubspace(m, w) computes the
      ++ dimension of E_w(\Gamma_0(m)), the Eisenstein subspace of
      ++ modular forms See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    dimensionOfModularForms: (P, Z) -> N
      ++ dimensionOfModularForms(m, w) computes the dimension of
      ++ M_w(\Gamma_0(m)). See
      ++ https://www.wstein.org/books/modform/modform/dimension_formulas.html
    rightCosetRepresentatives: (P, P) -> List SL2Z
      ++ rightCosetRepresentatives(nn, mm) returns a list of right
      ++ coset representatives of
      ++ $\Gamma_0(mm*nn) \backslash \Gamma_0(mm)$.
    rightCosetRepresentatives: (P) -> List SL2Z
      ++ rightCosetRepresentatives(nn) returns
      ++ rightCosetRepresentatives(nn, 1). It is a list of right coset
      ++ representatives of $\Gamma_0(nn) \backslash \Gamma_0(1)$.
    cuspToMatrix: (P, Cusp) -> SL2Z
      ++ For cusp=(a:c), cuspToMatrix(m, cusp) returns a matrix
      ++ gamma=[[a,b],[c,d]] corresponding to the cusp (a:c) of
      ++ Gamma0(m). We assum that a/c is a normalized cusp, i.e.
      ++ cusp=normalizeCusp(m,cusp).
    doubleCosetRepresentatives: P -> List SL2Z
      ++ doubleCosetRepresentatives(nn) returns a list of double
      ++ coset representatives of
      ++ $\Gamma_0(nn) \backslash \Gamma_0(1) / SL_2(\setZ)_\infty$
      ++ where $SL_2(\setZ)_\infty$ are matrices of the form [[1,h],[0,1]]
      ++ with h being an integer.
    member?: (SL2Z, P) -> Boolean
      ++ member?(mat, n) returns true if mat is an element of
      ++ $\Gamma_0(n)$, i.e. if entry (2,1) is a multiple of n.
      ++ Here it is assumed that determinant(mat)=1.
    equivalentCusps?: (P, Cusp, Cusp) -> Boolean
      ++ equivalentCusps?(nn, cusp1, cusp2) returns true iff the cusp
      ++ cusp1=(a:c) is equivalent to cusp2=(u:w) modulo the action of
      ++ Gamma0(nn).
      ++ Two cusps (a:c) and (u:w) are equivalent modulo the action of
      ++ Gamma0(N) if either
      ++ (1) gcd(c,N)=gcd(w,N)
      ++ or
      ++ (2) c = -w (mod N) and a = -u (mod gcd(c, N).
      ++ See Proposition 2.27 in the PhD thesis of
      ++ William Stein: https://www.wstein.org/thesis/.
    normalizeCusp: (P, Cusp) -> Cusp
      ++ normalizeCusp(nn,cusp) normalizes the cusp to another
      ++ (equivalent modulo Gamma0(nn)) cusp such that if
      ++ cusp is not equivalent to infinity, then infinity() is returned,
      ++ if cusp is equivalent to (0:1), (0:1) is returned.
      ++ Otherwise the numerator and denominator are positive
      ++ and small and w is a divisor of nn.

  == add
    width(m: P, cusp: Cusp): Z == (m exquo gcd(denom(cusp)^2, m)) :: Z

    index(m: P): P == dedekindPsi(m)
    dedekindPsi(m: P): P ==
        r: Q := 1
        for f in factorList factor m repeat
            r := r * (1 + 1/(f.factor))
        asP numer(m*r)

)if LiterateDoc

We use \cite[Lemma~2.45]{Radu_PhD_2010} to compute the cusps of
$\Gamma_0(N)$ as the set of all $\frac{a}{c}$ such that $c|N$ and
$a\in X_c$.

)endif

    cusps(level: P): List Cusp ==
        -- We use \cite[Lemma~2.45]{Radu_PhD_2010} with \delta replaced by
        -- c and N replaced by level.
        divs: List Z := divisors(level)$INTF
        result: List Cusp := empty()
        for c in divs repeat
            -- Let's compute the list corresponding to $X_c$.
            g: Z := gcd(c, (level exquo c)::Z)
            for x in 1..g | one? gcd(x, g) repeat
                a: Z := x
                while not one? gcd(a, c) repeat a := a + g;
                -- The variable a corresponds to an element of X_\delta
                -- from \cite[Lemma~2.45]{Radu_PhD_2010}.
--                exgcd: EXGCD := extendedEuclidean(a, c)
--                d: Z := exgcd.coef1
--                b: Z := -exgcd.coef2
                result := cons(normalizeCusp(level, cusp(a, c)), result)
        sort! result

    numberOfCusps(level: P): P ==
        --assert(one? first divisors level)
        n: Z := 1  -- eulerPhi(gcd(1, level))
        for c in rest divisors(level)$INTF repeat
            n := n + eulerPhi(gcd(c, (level exquo c)::Z))
        asP n

    nu2(m: P): Z ==
        s: Z := 1
        for f in factorList factor m repeat
            p := f.factor
            even? p =>
                f.exponent >= 2 => return 0 -- 4|m
            r := positiveRemainder(p, 4)
            r = 3 => return 0
            if one? r then s := 2*s
        return s

    nu3(m: P): Z ==
        s: Z := 1
        for f in factorList factor m repeat
            p := f.factor
            p = 3 =>
                f.exponent >= 2 => return 0 -- 9|m
            r := positiveRemainder(p, 3)
            r = 2 => return 0
            if r=1 then s := 2*s
        return s

    genus(m: P): N ==
        -- general formula is
        -- g = 1 + mu/12 - nu2/4 - nu3/3 - nuinfinity/2
        -- where mu is the index of Gamma0(m) in SL2Z
        -- nu2 and nu3 are the number of solutions in Z/mZ of
        -- x^2+1=0 and x^2+x+1=0 and nuinfinity is the number of cusps
        -- of Gamma0(m).
        q: Q := index(m)/12 - nu2(m)/4 - nu3(m)/3 - numberOfCusps(m)/2
        not one? denom q => error "genus(Gamma0): non-vanishing denominator"
        asN(1 + numer(q))

    dimensionOfCuspForms(m: P, w: Z): N ==
        -- https://www.wstein.org/books/modform/modform/dimension_formulas.html
        w < 0 or odd? 2 => 0
        w = 2 => genus m
        wz: Z := w::Z
        w2: Z := shift(wz, -1) -- division by 2
        d: Z :=   (wz-1) * (genus(m)-1)_
                + (w2-1) * numberOfCusps(m)_
                + nu2(m) * floor(wz/4)$Q_
                + nu3(m) * floor(wz/3)$Q
        return d::N

    dimensionOfEisensteinSubspace(m: P, w: Z): N ==
        -- https://www.wstein.org/books/modform/modform/dimension_formulas.html
        w < 0 or odd? w => 0
        zero? w => 1
        c: N := numberOfCusps m
        if w = 2 then asN(c - 1) else c

    dimensionOfModularForms(m: P, w: Z): N ==
        dimensionOfCuspForms(m, w) +  dimensionOfEisensteinSubspace(m, w)

-------------------------------------------------------------------
-- auxiliary function
-------------------------------------------------------------------

    coprimePart(n: Z, c: Z): Z ==
       u := n
       while (g := gcd(u, c)) > 1 repeat u := (u exquo g)::Z
       u

    -- This function corresponds to $\rho_{m,n}(\lambda)$ in
    -- \cite[Definition~2.42]{Radu_PhD_2010}.
    -- The loop terminates because of \cite[Lemma~2.41]{Radu_PhD_2010}.
    rho(lambda: Z, m: Z, n: Z): Z ==
        --assert(lambda>=0)
        --assert(m*n>0)
        --assert(one? gcd [lambda, m, n])
        r := lambda
        while not one? gcd(r, n) repeat r := r + m
        return r

    -- This function corresponds to S_{N,\delta} in
    -- \cite[Definition~2.44]{Radu_PhD_2010}.
    lambdas(delta: Z, nn: Z): List Z ==
        --assert(delta*nn>0)
        --assert((nn exquo delta) case Z)
        m: Z := (nn exquo delta)::Z
        g: Z := gcd(m, delta)
        [rho(lambda, m, delta) for lambda in 0..m-1 | one? gcd(g, lambda)]

    -- This function corresponds to just one matrix from R_{N,\delta}
    -- for a concrete \lambda.
    cosetRep(lambda: Z, delta: Z, qm: Z): SL2Z ==
        --assert(lambda>=0)
        --assert(delta*qm>0)
        --assert(one? gcd(delta, qm))
        c := lambda * qm
        REC ==> Record(coef1: Z, coef2: Z, generator: Z)
        rec: REC := extendedEuclidean(delta, lambda*qm)
        return matrix [[rec.coef1, -rec.coef2], [c, delta]]

    -- This function corresponds to R_{N,\delta} in
    -- \cite[Lemma~2.44]{Radu_PhD_2010}.
    rightCosetReps(delta: Z, nn: Z, mm: Z): List SL2Z ==
        --assert(delta * mm * nn > 0)
        [cosetRep(lambda, delta, mm) for lambda in lambdas(delta, nn)]

-------------------------------------------------------------------
-- exported function
-------------------------------------------------------------------
    equivalentCusps?(level: P, c1: Cusp, c2: Cusp): Boolean ==
        -- implementation according to Proposition 8.13 of
        -- \cite{Stein_ModularFormas_2007}.
        pr ==> positiveRemainder
        u1: Z := numer c1; v1: Z := denom c1;
        u2: Z := numer c2; v2: Z := denom c2;
        g: Z := gcd(v1*v2, level)
        exgcd: EXGCD := extendedEuclidean(u1, v1)
        s1 := exgcd.coef1
        exgcd := extendedEuclidean(u2, v2)
        s2 := exgcd.coef1
        zero? positiveRemainder(s1*v2 - s2*v1, g)

    -- local function
    coprimeRemainder(a: Z, c: Z, d: Z): Z ==
        a := positiveRemainder(a, d)
        while not one? gcd(a, c) and a < c repeat a := a + d
        a

    normalizeCusp(level: P, cusp: Cusp): Cusp ==
        -- Algorithm according to PhD Thesis of Silviu Radu.
        -- Lemma 2.45 of \cite{Radu_PhD_2010}
        -- First compute the corresponding b and d for the matrix.
        a: Z := numer cusp
        c: Z := denom cusp
        zero? positiveRemainder(c, level) => infinity()
        exgcd: EXGCD := extendedEuclidean(a, c)
        not one? exgcd.generator =>
            error "normalizeCusp: cusp not in lowest terms"
        b: Z := -exgcd.coef2
        d: Z := exgcd.coef1
        zero? d => cusp(0, 1) -- Then c=1 (mod level). So this is the cusp 0=1.
        delta: Z := gcd(c, level)
        cdelta := (c exquo delta)::Z
        ndelta := (level exquo delta)::Z
        g: Z := gcd(delta, ndelta)
        -- compute the inverse of d mod g
        -- Note that
        -- gcd(d,g)=gcd(d,delta,N/delta)=gcd(d,c,N,N/delta)=gcd(c,d)=1.
        exgcd := extendedEuclidean(d, g)
        alambda := coprimeRemainder(cdelta * exgcd.coef1, delta, g)
        cusp(alambda, delta)

    cuspToMatrix(nn: P, cusp: Cusp): SL2Z ==
        gamma: SL2Z := cuspToMatrix(cusp)$Cusp
        infinity? cusp => gamma -- identity matrix
        a: Z := gamma(1,1)
        c: Z := gamma(2,1)
        -- assert(not zero? c)
        dprime: Z := gamma(2,2)
        -- The extended Euclidean algorithm leave some freedom in the choice
        -- of cofactors. We improve in the following in such a way to make
        -- d as small as possible, since that corresponds to a d-th root
        -- of unity in the coefficients of the transformed series.
        -- An important property here is that for any cusp a/c of Gamma0(nn)
        -- c is a divisor of nn.
        nnc: Z := (nn exquo c) :: Z
        u: Z := coprimePart(nnc, c)
        -- v: Z := (nnc exquo u) :: Z -- ((not meeded here))
        t: Z := mulmod(dprime, invmod(u, c), c)
        d: Z := t*u
        -- s: Z := ((t*u - dprime) exquo c) :: Z
        b := ((a*d -1) exquo c) :: Z -- instead of s we use that det=1
        -- update destructively
        gamma(1,2) := b
        gamma(2,2) := d
        return gamma

    rightCosetRepresentatives(nn: P, mm: P): List SL2Z ==
        concat [rightCosetReps(delta, nn, mm) for delta in divisors(nn)$INTF]

    rightCosetRepresentatives(nn: P): List SL2Z ==
        rightCosetRepresentatives(nn, 1)

    doubleCosetRepresentatives(nn: P): List SL2Z ==
        [cuspToMatrix(nn, cusp) for cusp in cusps(nn)]

    member?(mat: SL2Z, nn: P): Boolean == zero?(mat(2,1) rem nn)

)if LiterateDoc
%$
\bibliography{qeta}
\end{document}
)endif
