-------------------------------------------------------------------
---
--- FriCAS QFunctions
--- Copyright (C) 2019,  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:

-- 1. Redistributions of source code must retain the above copyright notice,
--    this list of conditions and the following disclaimer.
-- 2. Redistributions in binary form must reproduce the above copyright
--    notice, this list of conditions and the following disclaimer in the
--    documentation and/or other materials provided with the distribution.

-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\begin{document}
\title{Newton-Puiseux Method}
\author{Ralf Hemmecke}
\date{08-Aug-2019}
\maketitle
\begin{abstract}
  \url{https://homepages.math.uic.edu/~jan/mcs563s14/puiseux.pdf}
\end{abstract}

\tableofcontents

\section{Overview}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

)endif

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))

N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

)abbrev package GNEWTONP GeneralNewtonPolygon
++ Author: Ralf Hemmecke
++ Description:
++ Implement Newton polygon computation
GeneralNewtonPolygon(K, var, cen, PX, PXY): Exports == Implementation where
  K: Field
  var: Symbol
  cen: K
  ULS ==> UnivariateLaurentSeries(K, var, cen)
  PX: UnivariatePuiseuxSeriesConstructorCategory(K, ULS) -- K<<x>>
  PXY: UnivariatePolynomialCategory PX                   -- K<<x>>[y]
  Point ==> Record(ypow: Z, xpow: Q) -- actually: ypow >= 0
  SlopePoints ==> Record(slope: Q, start: Point, end: List Point)

  Exports ==> with
    pointsOfNewtonPolygon: PXY -> List Point
      ++ pointsOfNewtonPolygon(p) returns the vertices of the
      ++ Newton polygon corresponding to p.
      ++ Assume that degree(p)>0 and #monomials(p)>0.
    slopePointsOfNewtonPolygon: PXY -> List SlopePoints
      ++ slopePointsOfNewtonPolygon(p) returns the slopes
      ++ of the Newton polygon corresponding to p together with the
      ++ points forming this slope.
      ++ Assume that degree(p)>0 and #monomials(p)>0.
    toPXY: (Polynomial K, Symbol, Symbol) -> PXY

  Implementation ==> add
    pointsOfNewtonPolygon(p: PXY): List Point ==
        --assert(#monomials(p)>1)
        points: List Point := empty()
        while not zero? p repeat
            yp: Z := degree p
            xp: Q := order leadingCoefficient p
            points := cons([yp, xp], points)
            p := reductum p
        -- points are ordered with smallest ypow first
        -- Note that all ypow of points are different.
        --assert(#points>1) -- condition on p
        -- points.1 and points(#points) are certainly vertices of the
        -- Newton polygon. We start with points.1, add new points, but
        -- while adding new points, old points are removed from the
        -- Newton polygon, if they lie above the edge with a previous
        -- point of the current Newton polygon.
--        dbgPrint("POINTS", points)
        p1: Point := first points;  points := rest points
        p2: Point := first points;  points := rest points
        npPoints: List Point := [p2, p1] -- Newton polygon points
        slopes: List Q := [(p2.xpow  - p1.xpow) * (1 / (p2.ypow - p1.ypow))]
        for np in points repeat -- newpoint
--            dbgPrint("points", points)
--            dbgPrint("npPoints", npPoints)
--            dbgPrint("slopes", slopes)
--            dbgPrint("np", np)
            pt: Point := first npPoints
            slope: Q := (np.xpow - pt.xpow) * (1 / (np.ypow - pt.ypow))
            while not empty? slopes and slope <= first slopes repeat
                -- remove old points
                slopes := rest slopes
                npPoints := rest npPoints
                pt := first npPoints
                slope := (np.xpow - pt.xpow) * (1 / (np.ypow - pt.ypow))
            slopes := cons(slope, slopes)
            npPoints := cons(np, npPoints)
        reverse! npPoints

    slopePointsOfNewtonPolygon(p: PXY): List SlopePoints ==
        --assert(#monomials(p)>1)
        points: List Point := empty()
        while not zero? p repeat
            yp: Z := degree p
            xp: Q := order leadingCoefficient p
            points := cons([yp, xp], points)
            p := reductum p
        -- points are ordered with smallest ypow first
        -- Note that all ypow of points are different.
        --assert(#points>1) -- condition on p
        -- points.1 and points(#points) are certainly vertices of the
        -- Newton polygon. We start with points.1, add new points, but
        -- while adding new points, old points are removed from the
        -- Newton polygon, if they lie above the edge with a previous
        -- point of the current Newton polygon.
--        dbgPrint("POINTS", points)
        p1: Point := first points;  points := rest points
        p2: Point := first points;  points := rest points
        npPoints: List Point := [p2, p1] -- Newton polygon points
        slope: Q := (p2.xpow  - p1.xpow) * (1 / (p2.ypow - p1.ypow))
        slopes: List Q := [slope]
        slopePointList: List SlopePoints := [[slope, p1, [p2]]]
        for np in points repeat -- newpoint
--            dbgPrint("points", points)
--            dbgPrint("npPoints", npPoints)
--            dbgPrint("slopes", slopes)
--            dbgPrint("np", np)
--            dbgPrint("slopePointList", slopePointList)
            pt: Point := first npPoints
            slope: Q := (np.xpow - pt.xpow) * (1 / (np.ypow - pt.ypow))
--            dbgPrint("slope", slope)
            if slope = first slopes then
                slopePoints: SlopePoints := first slopePointList
                endPoints := slopePoints.end
                slopePoints.end := cons(np, endPoints)
                npPoints := cons(np, rest npPoints)
            else
                while not empty? slopes and slope < first slopes repeat
                    -- remove old points
                    slopes := rest slopes
                    slopePointList := rest slopePointList
                    npPoints := rest npPoints
                    pt := first npPoints
                    slope := (np.xpow - pt.xpow) * (1 / (np.ypow - pt.ypow))
                slopes := cons(slope, slopes)
                slopePointList := cons([slope, pt, [np]], slopePointList)
                npPoints := cons(np, npPoints)
        reverse! slopePointList

    toPXY(p: Polynomial K, x: Symbol, y: Symbol): PXY ==
        s: PXY := 0
        -- sanity check
        sort variables p ~= sort [x, y] =>
            error "not a polynomial in the given variables"
        mons := monomials p
--        dbgPrint("mons", mons)
        for m in mons repeat
            mx := monomial(leadingCoefficient m, degree(m, x)::Q)$PX
            s := s + monomial(mx, degree(m, y))$PXY
        s

)abbrev package NEWTONP NewtonPolygon
++ Author: Ralf Hemmecke
++ Description:
++ Implements computaton of Newton polygon
NewtonPolygon(K): Exports == Implementation where
  K: Field
  PX ==> UnivariatePuiseuxSeries(K, x, 0) -- K<<x>>
  PXY ==> UnivariatePolynomial(y, PX)  -- K<<x>>[y]
  Point ==> Record(ypow: Z, xpow: Q) -- actually: ypow >= 0
  SlopePoints ==> Record(slope: Q, start: Point, end: List Point)

  Exports ==> with
    pointsOfNewtonPolygon: (Polynomial K, Symbol, Symbol) -> List Point
      ++ pointsOfNewtonPolygon(p, x, y) returns the vertices of the
      ++ Newton polygon corresponding to p.
      ++ Assume that degree(p, y) > 0 and #monomials(p) > 0.
    slopePointsOfNewtonPolygon: (Polynomial K, Symbol, Symbol) -> List SlopePoints
      ++ slopePointsOfNewtonPolygon(p, x, y) returns the slopes
      ++ of the Newton polygon corresponding to p together with the
      ++ points forming this slope.
      ++ Assume that degree(p, y) > 0 and #monomials(p) > 0.

  Implementation ==> add

    pointsOfNewtonPolygon(p: Polynomial K, x: Symbol, y: Symbol): List Point ==
        import from GeneralNewtonPolygon(K, x, 0, PX, PXY)
        pxy: PXY := toPXY(p, x, y)
        pointsOfNewtonPolygon(pxy)

    slopePointsOfNewtonPolygon(p: Polynomial K, x: Symbol, y: Symbol): List SlopePoints ==
        import from GeneralNewtonPolygon(K, x, 0, PX, PXY)
        pxy: PXY := toPXY(p, x, y)
        slopePointsOfNewtonPolygon(pxy)

-------------------------------------------------------------------

)abbrev package NEWTPUIS NewtonPuiseux
++ Author: Ralf Hemmecke
++ Description:
++ Implements computaton of Newton polygon
NewtonPuiseux(K, var, cen, PX, PXY): Exports == Implementation where
  K: AlgebraicallyClosedField
  var: Symbol
  cen: K
  ULS ==> UnivariateLaurentSeries(K, var, cen)
  PX: UnivariatePuiseuxSeriesConstructorCategory(K, ULS) -- K<<x>>
  PXY: UnivariatePolynomialCategory PX                   -- K<<x>>[y]
  KX ==> SparseUnivariatePolynomial K -- K[x]
  Point ==> Record(ypow: Z, xpow: Q) -- actually: ypow >= 0
  SlopePoints ==> Record(slope: Q, start: Point, end: List Point)

  Exports ==> with
    puiseuxCoefficients: PXY -> List Record(coef: K, expo: Q)
      ++ puiseuxCoefficients(p) returns the leading coefficients
      ++ together with the respective negative slope of the Newton
      ++ polygon.

  Implementation ==> add

    coefficientRelation(p: PXY, points: List Point): KX ==
        defPoly: KX := 0
        minypow: Z := first(points).ypow
        for point in points repeat
            yex: Z := point.ypow
            cx: PX := coefficient(p, qcoerce(yex)@N)
            c: K := coefficient(cx, point.xpow)
            defPoly := defPoly + monomial(c, qcoerce(yex - minypow)@N)
        primitivePart defPoly

    puiseuxCoefficients(p: PXY): List Record(coef: K, expo: Q) ==
        import from GeneralNewtonPolygon(K, var, cen, PX, PXY)
        slopePointList: List SlopePoints := slopePointsOfNewtonPolygon p
        result: List Record(coef: K, expo: Q) := empty()
        for slopePoints in slopePointList repeat
            points := cons(slopePoints.start, slopePoints.end)
            dp := coefficientRelation(p, points)
            result := cons([rootOf dp, - slopePoints.slope], result)
        result



)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
