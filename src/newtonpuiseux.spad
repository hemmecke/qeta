-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2019-2020,  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:

-- 1. Redistributions of source code must retain the above copyright notice,
--    this list of conditions and the following disclaimer.
-- 2. Redistributions in binary form must reproduce the above copyright
--    notice, this list of conditions and the following disclaimer in the
--    documentation and/or other materials provided with the distribution.

-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\begin{document}
\title{Newton-Puiseux Method}
\author{Ralf Hemmecke}
\date{08-Aug-2019}
\maketitle
\begin{abstract}
  \url{https://homepages.math.uic.edu/~jan/mcs563s14/puiseux.pdf}
\end{abstract}

\tableofcontents

\section{Overview}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
SY ==> Symbol
POLYK ==> Polynomial K
KX ==> SparseUnivariatePolynomial K -- K[x]
KXY ==> SparseUnivariatePolynomial KX -- KX[y]
KPX ==> PolynomialRing(K, Q) -- Puiseux polynomials
KPXY ==> SparseUnivariatePolynomial KPX -- KPX[y]
SlopePoints K ==> Record(slope: K, points: List Point K)
PRENP(K) ==> PreNewtonPuiseux K

asN x ==> x pretend N
asP x ==> x pretend P
asZ x ==> x pretend Z

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{QPowers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif
)abbrev domain QPOWER QPower
QPower(v: SY): Join(QuotientFieldCategory Z, OpenMath, Canonical) == Q add
    Rep ==> Q
    xx ==> rep x
    coerce(x: %): OutputForm ==
        o: OutputForm := v::OutputForm
        if not one? xx then o := o ^ (xx::OutputForm)
        return o

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{NewtonPolygon}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif
)abbrev package NEWTONP NewtonPolygon
++ Author: Ralf Hemmecke
++ Description:
++ Implement Newton polygon computation
NewtonPolygon(K: Join(Field, OrderedSet)): Exports == Implementation where
  Exports ==> with

    pointsOfNewtonPolygon: List Point K -> List Point K
      ++ pointsOfNewtonPolygon(points) returns the vertices of the
      ++ Newton polygon corresponding to points.
    slopePointsOfNewtonPolygon: List Point K -> List SlopePoints K
      ++ slopePointsOfNewtonPolygon(points) returns the slopes
      ++ of the Newton polygon corresponding to p together with the
      ++ points forming this slope.

  Implementation ==> add

    normalize(points: List Point K): List Point K ==
        -- Check whether all points are 2-dimensional
        for point in points repeat
            if dimension point ~= 2 then
                error "not all points live in a plane"

        -- points are ascendingly ordered first by x-coordinate
        -- then by y-coordinate.
        points := sort(_<, points)$List(Point K)
        -- Take only the points with different x part.
        p1: Point K := first points
        points := rest points
        pts: List Point K := [p1]
        for p2 in points repeat
            if p2.1 > p1.1 then
                p1 := p2
                pts := cons(p2, pts)
        reverse! pts

    pointsOfNewtonPolygon(points: List Point K): List Point K ==
        points := normalize points
        -- points.1 and points(#points) are certainly vertices of the
        -- Newton polygon. We start with points.1, add new points, but
        -- while adding new points, old points are removed from the
        -- Newton polygon, if they lie above the edge with a previous
        -- point of the current Newton polygon.
        p1: Point K := first points;  points := rest points
        p2: Point K := first points;  points := rest points
        npPoints: List Point K := [p2, p1] -- Newton polygon points
        slopes: List K := [(p2.2  - p1.2) / (p2.1 - p1.1)]
        for np in points repeat -- newpoint
            pt: Point K := first npPoints
            slope: K := (np.2 - pt.2) / (np.1 - pt.1)
            while not empty? slopes and slope <= first slopes repeat
                -- remove old points
                slopes := rest slopes
                npPoints := rest npPoints
                pt := first npPoints
                slope := (np.2 - pt.2) / (np.1 - pt.1)
            slopes := cons(slope, slopes)
            npPoints := cons(np, npPoints)
        reverse! npPoints

    slopePointsOfNewtonPolygon(points: List Point K): List SlopePoints K ==
        points := normalize points
        -- points.1 and points(#points) are certainly vertices of the
        -- Newton polygon. We start with points.1, add new points, but
        -- while adding new points, old points are removed from the
        -- Newton polygon, if they lie above the edge with a previous
        -- point of the current Newton polygon.
        p1: Point K := first points;  points := rest points
        p2: Point K := first points;  points := rest points
        slope: K := (p2.2  - p1.2) * (1 / (p2.1 - p1.1))
        slopePointList: List SlopePoints K := [[slope, [p1, p2]]]
        for np in points repeat -- newpoint
            slopePoints: SlopePoints K := first slopePointList
            sPoints: List Point K := slopePoints.points
            -- p1 := sPoints.1 -- startpoint of last slope
            pt := sPoints.2 -- endpoint of last slope
            slope: K := (np.2 - pt.2) / (np.1 - pt.1)
            if slope = slopePoints.slope then
                slopePoints.points := cons(sPoints.1, cons(np, rest sPoints))
            else
                while not empty? slopePointList and
                      slope < first(slopePointList).slope repeat
                    -- remove useless slopes (and points)
                    pt := first(first(slopePointList).points) --
                    slopePointList := rest slopePointList
                    slope := (np.2 - pt.2) / (np.1 - pt.1)
                slopePointList := cons([slope, [pt, np]], slopePointList)
        reverse! slopePointList


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PreNewtonPuiseux}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PreNewtonPuiseux holds data that is later used for the creation of the
Puiseux series that are zeros of the given (bivariate) polynomial.

)endif

)abbrev domain PRENP PreNewtonPuiseux
++ Author: Ralf Hemmecke
++ Description:
++ A container that holds all data necessary to create the respective
++ Puiseux series in case maxidx = #arr.
PreNewtonPuiseux(K): Exports == Implementation where
  K: Field
  PUIMON ==> Record(root: K, expo: Q)
  PUIREC ==> Record(mons: List PUIMON, nextpol: KPXY)
  Exports ==> CoercibleTo OutputForm with
    new: N -> %
    _#: % -> N
    maxIndex: % -> N
    elt: (%, N) -> PUIREC
    setelt!: (%, N, PUIREC) -> PUIREC
    extend!: (%, PUIREC) -> PUIREC
  Implementation ==> add
    Rep ==> Record(maxidx: N, arr: PrimitiveArray PUIREC)
    import from Rep
    coerce(x: %): OutputForm == rep(x)::OutputForm
    emptyPUIREC: PUIREC := [empty()$List(PUIMON), 0$KPXY]
    new(n: N): % == per [0, new(n, emptyPUIREC)]
    #(x: %): N == #(rep(x).arr)
    maxIndex(x: %):N == rep(x).maxidx
    elt(x: %, i: N): PUIREC == rep(x).arr.(asZ(i)-1)
    setelt!(x: %, i: N, pr: PUIREC): PUIREC ==
        a: PrimitiveArray PUIREC := rep(x).arr
        a.(asZ(i) - 1) := pr
    extend!(x: %, pr: PUIREC): PUIREC ==
        a: PrimitiveArray PUIREC := rep(x).arr
        i: N := rep(x).maxidx
        dbgPrint("maxidx", i)
        rep(x).maxidx := i+1
        a.i := pr


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{NewtonPuiseux}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev package NEWTPUIS NewtonPuiseux
++ Author: Ralf Hemmecke
++ Description:
++ Implements the computation of a Puiseux series satisfying a bivariate
++ polynomial.
NewtonPuiseux(K): Exports == Implementation where
  K: Join(AlgebraicallyClosedField, PolynomialFactorizationExplicit)
  PUIMON ==> Record(root: K, expo: Q)
  PUIREC0 ==> Record(mon: PUIMON, nextpol: KPXY)
  PUIREC ==> Record(mons: List PUIMON, nextpol: KPXY)

  Exports ==> with
    leadingPuiseuxMonomials: (KPXY, Q) -> List PUIREC0
    leadingPuiseuxMonomials: KPXY -> List PUIREC0
      ++ leadingPuiseuxMonomials(p) returns for each slope of the
      ++ Newton polygon of p the leading monomial of the Puiseux
      ++ series Y satisfying p(x, Y(x)) = 0 in terms of the defining
      ++ polynomial for the leading coefficient, i.e., one monomial
      ++ might correspond to several coefficients according to the
      ++ degree of the defining polynomial.
    leadingPuiseuxMonomials: KXY -> List PUIREC0
      ++ leadingPuiseuxMonomials(p) returns for each slope of the
      ++ Newton polygon of p the leading monomial of the Puiseux
      ++ series Y satisfying p(x, Y(x)) = 0 in terms of the defining
      ++ polynomial for the leading coefficient, i.e., one monomial
      ++ might correspond to several coefficients according to the
      ++ degree of the defining polynomial.
    leadingPuiseuxMonomials: (POLYK, Symbol, Symbol) -> List PUIREC0
      ++ leadingPuiseuxMonomials(p, x, y) returns for each slope of
      ++ the Newton polygon of p the leading monomial of the Puiseux
      ++ series Y satisfying p(x, Y(x)) = 0 in terms of the defining
      ++ polynomial for the leading coefficient, i.e., one monomial
      ++ might correspond to several coefficients according to the
      ++ degree of the defining polynomial.

    polynomial2Points: (POLYK, Symbol,Symbol) -> List Point Q
    polynomial2Points: KXY -> List Point Q
    polynomial2Points: KPXY -> List Point Q

    poly2KPXY: (POLYK, Symbol, Symbol) -> KPXY
    nextY: (KPXY, PUIMON) -> KPXY
    nextPuiseuxMonomials: PRENP K -> PRENP K
    coefficientRelation: (KPXY, List Point Q) -> KX
      ++ coefficientRelation(p, points) returns the relation that the
      ++ coefficient must fulfil in order to be a coefficient of the
      ++ puiseux series.

  Implementation ==> add
    -- For hacking the fact that the implementation of AlgebraicNumber
    -- is actually not of category noZeroDivisors, we introduce the
    -- functions removeZeroCoefficients[X].
    removeZeroCoefficientsX(p: KPX): KPX ==
        zero? p => p
        m := leadingMonomial p
        z := removeZeroCoefficientsX reductum p
        c: K := leadingCoefficient m
        zero? c => z
        m + z

    removeZeroCoefficients(p: KPXY): KPXY ==
        zero? p => p
        m := leadingMonomial p
        z := removeZeroCoefficients reductum p
        c: KPX := leadingCoefficient m
        zero? removeZeroCoefficientsX c => z
        m + z

    coefficientRelation(p: KPXY, points: List Point Q): KX ==
        --assert(#point > 1)
        --assert(one? denom(pt.1) for all pt in points)
        coefficientPoly: KX := 0
        ymin: Z := numer(first(points).1)
        for point in rest points repeat ymin := min(ymin, numer point.1)
        for point in points repeat
            yex: Z := numer(point.1)
            cx: KPX := coefficient(p, asN(yex))
            c: K := coefficient(cx, point.2)
            if not zero? c then
                coefficientPoly := coefficientPoly + monomial(c, asN(yex-ymin))
        coefficientPoly := squareFreePart coefficientPoly
        zero? ymin => coefficientPoly
        monomial(1,1)$KX * coefficientPoly

    toKPX(p: KX): KPX ==
        z: KPX := 0
        for m in reverse monomials p repeat -- from smallest to highest degree
            z := z + monomial(leadingCoefficient p, degree(p)::Q)
        return z

    toKPXY(p: KXY): KPXY ==
        z: KPXY := 0
        for m in reverse monomials p repeat -- from smallest to highest degree
            z := z + monomial(toKPX leadingCoefficient p, degree p)
        return z

    poly2KPXY(p: POLYK, x: Symbol, y: Symbol): KPXY ==
        -- sanity check
        sort variables p ~= sort [x, y] =>
            error "not a polynomial in the given variables"
        z: KPXY := 0
        for m in monomials p repeat
            mx: KPX := monomial(leadingCoefficient m, degree(m, x)::Q)$KPX
            z := z + monomial(mx, degree(m, y))$KPXY
        z

    -- We don't need exponents in the result that are smaller than e.
    biggerOrderThan?(e: Q): Q -> Boolean == (o: Q): Boolean +-> o > e
    leadingPuiseuxMonomialsOrder(p: KPXY, cond?: Q -> Boolean): List PUIREC0 ==
        import from NewtonPolygon(Q)
        points: List Point Q := polynomial2Points p
        slopePointList: List SlopePoints Q := slopePointsOfNewtonPolygon points
        result: List PUIREC0 := empty()$List(PUIREC0)
        for slopePoints in slopePointList | cond?(e:=-slopePoints.slope) repeat
            cp: KX := coefficientRelation(p, slopePoints.points)
            roots: List K := rootsOf cp
            for c in roots repeat -- loop over the roots of the defining poly
                y := monomial(monomial(c, e)$KPX, 0) + monomial(1, 1)$KPXY
                newpol: KPXY := p y
                -- Hack: If K is AlgebraicNumber then the new element
                -- c might have introduced zerodivisors.
                -- https://groups.google.com/forum/#!msg/fricas-devel/sowcAymy04s/xWBnEr1QCAAJ
                -- In order to avoid zero coefficients in polynomials
                -- from KPX, we explicitly remove such possible zero
                -- coefficients.
                rec: PUIREC0 := [[c, e]$PUIMON, removeZeroCoefficients newpol]
                result := cons(rec, result)
        result
-- exported functions

    polynomial2Points(p: POLYK, x: Symbol, y: Symbol): List Point Q ==
        sort variables p ~= sort [x, y] =>
            error "not a polynomial in the given variables"
        [point [degree(m, y)::Q, degree(m, x)::Q] for m in monomials p]

    polynomial2Points(p: KXY): List Point Q ==
        points: List Point Q := empty()
        while not zero? p repeat
            ydeg := degree p
            cx: KX := leadingCoefficient p
            p := reductum p
            while not zero? cx repeat
                xdeg: Z := degree cx
                c: K := leadingCoefficient cx
                cx := reductum cx
                points := cons(point [ydeg::Q, xdeg::Q], points)
        return points

    polynomial2Points(p: KPXY): List Point Q ==
        points: List Point Q := empty()
        while not zero? p repeat
            ydeg := degree p
            cx: KPX := leadingCoefficient p
            p := reductum p
            while not zero? cx repeat
                xdeg: Q := degree cx
                c: K := leadingCoefficient cx
                cx := reductum cx
                points := cons(point [ydeg::Q, xdeg], points)
        return points

    leadingPuiseuxMonomials(p: KPXY, e: Q): List PUIREC0 ==
        leadingPuiseuxMonomialsOrder(p, biggerOrderThan? e)

    leadingPuiseuxMonomials(p: KPXY): List PUIREC0 ==
        l := leadingPuiseuxMonomialsOrder(p, (o: Q): Boolean +-> true)
        -- We only need non-zero terms.
        [x for x in l | not zero?(x.mon.root)]

    leadingPuiseuxMonomials(p: KXY): List PUIREC0 ==
        pp: KPXY := toKPXY p
        leadingPuiseuxMonomials(pp)

    leadingPuiseuxMonomials(p: POLYK, x: Symbol, y: Symbol): List PUIREC0 ==
        leadingPuiseuxMonomials poly2KPXY(p, x, y)

    nextPuiseuxMonomials(prenp: PRENP K): PRENP K ==
        maxidx: N := maxIndex prenp
        for i in 1..maxidx | (r := prenp.i; p := r.nextpol; not zero? p) repeat
            dbgPrint("i", i)
            m := r.mons
            -- We only need monomials that are bigger than what we
            -- already have.
            ex: Q := first(m).expo
            lr: List PUIREC0 := leadingPuiseuxMonomials(p, ex)
            -- If it is empty we mark that we don't have to do anything
            -- in the next step, i.e., we set nextpol:=0.
            dbgPrint("lr", lr)
            empty? lr => r.nextpol := 0
            puirec0: PUIREC0 := first lr
            lr := rest lr
            r.mons := cons(puirec0.mon, m)
            r.nextpol := puirec0.nextpol
            while not empty? lr repeat -- extend the prenp array
                puirec0: PUIREC0 := first lr
                lr := rest lr
                newpuirec: PUIREC := [cons(puirec0.mon, m), puirec0.nextpol]
                dbgPrint("newpuirec", newpuirec)
                extend!(prenp, newpuirec)
        prenp

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
