-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Metadata for (sifted and generalized) Dedekind Eta Functions
  for expansion as several cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The domains in this file collect all the (meta) data that is needed
  to compute the actual Puiseux series expansion of the object in
  question, but do not itself hold the series expansion.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
LSL2Z ==> List SL2Z
GAMMA0 ==> CongruenceSubgroupGamma0
GAMMA1 ==> CongruenceSubgroupGamma1
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)
WIDTH1(nn, c) ==> asP(width(nn, c)$GAMMA1)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]
lcmP(a, b) ==> asP lcm(a::Integer, b::Integer)

)if LiterateDoc
%$
In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic}.
%
These \emph{Symbolic} domains actually only serve the purpose to
compute an upper bound for $k$ so that the the series expansions all
live in $\setQ[\xi][x]$ where $\xi=\exp\bigl(\frac{2\pi i}{k}\bigr)$
is a $k$-th primitive root of unity and $x$ is a fractional power of
$q$.

Domains in the second category are implemented in the file
\PathName{qetaquot.spad}.











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaGamma $\eta_{\delta,m,\lambda}(\gamma\tau)$}
\label{sec:SymbolicEtaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  \delta,
  m,
  \lambda,
  \gamma,
  \gamma_1,
  \gamma_2,
  \frac{h_{\delta,m,\lambda}}{\delta},
  \kappa_{\delta,m,\lambda},
  u_{\delta,m,\lambda},
  v_{\delta,m,\lambda}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:eta_delta-m-lambda(gamma*tau)}, \ie, it computes the
building blocks for $\eta_{\delta,m,\lambda}(\gamma\tau)$.
We have $\gamma_1=\gamma_{\delta,m,\lambda}$ and $\gamma=\gamma_1\gamma_2$.

)endif

)abbrev domain YEG SymbolicEtaGamma
++ SymbolicEtaGamma collects data for the expansion of
++ eta_delta(\gamma \tau).
++ See \eqref{eq:eta_delta(gamma*tau)}.
SymbolicEtaGamma: SetCategory with
    eta: (P, P, P, N, SL2Z) -> %
      ++ eta(mm, delta, m, lambda, gamma) represents the
      ++ expansion of $\eta_{\delta,m,\lambda}(\gamma \tau)$ in terms of
      ++ $q = \exp(2 \pi i \tau)$.
      ++ See \eqref{eq:eta_delta-m-lambda-gamma-tau}.
      ++ We require that c>0 in gamma=matrix[[a,b],[c,d]].
    eta: (P, P, N, SL2Z) -> %
      ++ eta(delta, m, lambda, gamma) returns
      ++ eta(delta, delta, m, lambda, gamma)
    eta: (P, P, SL2Z) -> % -- gamma=[[a,b],[c,d]], mm=level, delta
      ++ eta(mm, delta, gamma) represents the expansion of
      ++ \eta_\delta(\gamma \tau) in terms of
      ++ q = \exp(2 \pi i \tau).
      ++ It is the same as eta(mm, delta, 1, 0, gamma).
      ++ See \eqref{eq:eta_delta-m-lambda-gamma-tau} for m=1, lambda=0.
    eta: (P, SL2Z) -> %
      ++ eta(delta, gamma) returns eta(delta, delta, gamma).
    level: % -> P
      ++ level(x) returns the level corresponding to x.
    delta: % -> P
      ++ delta(x) returns the delta that was used at creation time of x.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in eta(...,gamma).
    gamma1: % -> SL2Z
      ++ gamma1(x) returns the SL2Z part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    gamma2: % -> MZ
      ++ gamma2(x) returns the triangular part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    rationalPrefactor: % -> Q -- (h_delta/delta)
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
      ++ See \ref{thm:c*tau+d}.
    upsilonExponent: % -> Z -- kappa_delta
      ++ Returns $\kappa_{\gamma_{\delta,m,\lambda}}$.
      ++ See \eqref{eq:eta_delta-m-lambda(gamma*tau)}
      ++ and \eqref{eta_delta(gamma*tau)}.
    udelta: % -> Q
      ++ Returns $u_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
      ++ See \eqref{eq:uv_delta}
    vdelta: % -> Q
      ++ Returns $v_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
      ++ See \eqref{eq:uv_delta}.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,
              fdelta: P,
              fmultiplier: P,
              flambda: N,
              fgamma: SL2Z, -- gamma
              fgamma1: SL2Z,-- splitMatrix.red
              fgamma2: MZ,  -- splitMatrix.triang
              frat: Q,      -- square of rational prefactor
              fkappa: Z,    -- upsilonExponent(a1,b2,c1,d1)
              fudelta: Q,   -- udelta = hdelta^2/(delta*m)
                            -- \eqref{eq:uv_delta-m-lambda}}
              fvdelta: Q    -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        --assert(gamma(2, 1)>0)
        gamma(2, 1) <= 0 ==> error "QEtaSymbolicData: we want gamma(2,1)>0"
        rec: Rec := splitMatrix(gamma, delta, m, lambda)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        a2: Z := gamma2(1, 1); b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        rat: Q := a2/delta -- = hdelta/delta
        udelta: Q := a2/d2 -- = hdelta^2/delta/m
        vdelta: Q := b2/d2
        kappa: Z := upsilonExponent(gamma1)$QETAAUX
        per [mm, delta, m, lambda, gamma,
             gamma1, gamma2,rat, kappa, udelta, vdelta]

    eta(delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        eta(delta, delta, m, lambda, gamma)

    eta(mm: P, delta: P, gamma: SL2Z): % == eta(mm, delta, 1, 0, gamma)
    eta(delta: P, gamma: SL2Z): % == eta(delta, delta, gamma)

    level(x: %): P == rep(x).flevel
    delta(x: %): P == xx.fdelta
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z == xx.fkappa
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
    ((x: %) = (y: %)): Boolean ==
        delta x ~= delta y => false
        multiplier x ~= multiplier y => false
        lambda x ~= lambda y => false
        gamma x = gamma y






)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotientLambdaGamma $g_{r,m,\lambda}(\gamma\tau)$}
\label{sec:SymbolicEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $g_{r,m,\lambda}(\gamma\tau)$.

For $m, M\in\setN$, $r \in R(M)$, $\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaQuotientLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  r,
  m,
  \lambda,
  \gamma,
  y,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} \frac{r_\delta u_{\delta,m,\lambda}}{24}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:g_r-m-lambda(gamma*tau)}, \ie, it computes the building
blocks for $g_{r,m,\lambda}(\gamma\tau)$.

The special entry $y=(y_\delta)_{\divides{\delta}{M}}$ is a container
of the \code{SymbolicEtaGamma} values for each
divisor $\delta$ of $M$.


)endif


-------------------------------------------------------------------
)abbrev domain YEQLG SymbolicEtaQuotientLambdaGamma
++ SymbolicEtaQuotientLambdaGamma holds data to compute an eta
++ quotient expansion of g_{r,m,\lambda}(\gamma \tau).
++ See \eqref{eq:g_r-m-lambda(gamma*tau)} and
++ \eqref{eq:g_r-m---lambda(gamma*tau)}.
SymbolicEtaQuotientLambdaGamma: SetCategory with
    etaQuotient: (P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, lambda, gamma) represents the
      ++ expansion of $g_{r,m,\lambda}(\gamma \tau)$ in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(nn, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c.
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta-quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were given
      ++ at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).

    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r-m-lambda(gamma*tau)}.
    unityExponent: % -> Q
      ++ unityExponent(e) returns
      ++ $sum_{\delta} rdelta*(vdelta+Kappa_delta)/24$.
      ++ It corresponds to the second factor of
      ++ \eqref{eq:g_r-m-lambda(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns the order of the expansion
      ++ of e in q = \exp(2 \pi i \tau)  while neglecting the (c\tau+d) factor.
      ++ It corresponds to the exponent of the fourth product
      ++ of \eqref{eq:g_r-m-lambda(gamma*tau)}.
      ++ Compare also with \eqref{eq:modular-g_r(gamma*tau)}.
    elt: (%, P) -> SymbolicEtaGamma
      ++ x.delta returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicEtaGamma)
      -- mapping delta to \eta_{\delta,m,\lambda}
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fmultiplier: P,-- the multiplier m
              flambda: N,    -- lambda \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_{\delta,m,lambda}
              frat: Q,       -- square of rational prefactor
              funityExponent: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
              fqExponent: Q  -- \sum_delta rdelta*udelta/24
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaquot(mm: P, divs: LP, r: LZ, m: P, lambda: N, gamma: SL2Z, eta: HT): % ==
        import from QETAAUX
        rat: Q := 1
        uexponent: Q := 0 -- unityExponent
        qexponent: Q := 0
        for delta in divs for rdelta in r | not zero? rdelta repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            rd := rdelta/24
            qexponent := qexponent + rd * udelta(e)
            kappa: Q := (upsilonExponent e)::Q
            uexponent := uexponent + rd * (vdelta e + kappa)

        -- Now make the numerator small.
        uexponent: Q := fractionalPart(uexponent)$QETAAUX

        per [mm, divs, r, m, lambda, gamma,
             eta, rat, uexponent, qexponent]

    etaQuotient(mm: P, r: LZ, m: P, lambda: N, gamma: SL2Z): % ==
        divs: LP := DIVISORS mm
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in divs repeat
            eta.delta := eta(mm, delta, m, lambda, gamma)$SymbolicEtaGamma
        etaquot(mm, divs, r, m, lambda, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    elt(x: %, delta: P): SymbolicEtaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityExponent(x: %): Q == xx.funityExponent
    qExponent(x: %): Q == xx.fqExponent

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotientGamma $p_{r,m,t}(\gamma\tau)$}
\label{sec:SymbolicEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $p_{r,m,t}(\gamma\tau)$.

\begin{align*}
p_{r,m,t}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sigmainfty{r}\Bigr)}
    g_{r,m,\lambda}(\gamma\tau)
\end{align*}

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaQuotientGamma} represent the collection
\code{SymbolicEtaQuotientLambdaGamma} for each $\lambda \in
\Set{0,\ldots,m-1}$ and thus corresponds to the data from
\eqref{eq:p_r-m-t(gamma*tau)}, \ie, it computes the building
blocks for $p_{r,m,t}(\gamma\tau)$.

)endif
-------------------------------------------------------------------
)abbrev domain YEQG SymbolicEtaQuotientGamma
++ SymbolicEtaQuotientGamma holds data to compute an eta
++ quotient expansion of $p_{r,m,t}(\gamma \tau)$.
++ See \eqref{eq:p_r-m-t(gamma*tau)}.
SymbolicEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, Z, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the
      ++ expansion of $p_{r,m,t}(\gamma \tau)$ where $r$ is indexed
      ++ by the divisors of $mm$.
    etaQuotient: (P, LZ, SL2Z) -> %
      ++ etaQuotient(mm, r, gamma) returns etaQuotient(mm,r,1,0,gamma)
      ++ and represents the expansion of $p_r(\gamma \tau)$ in terms
      ++ of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c. $r$ is
      ++ indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta-quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were
      ++ given at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> Z
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaQuotient(...,gamma).
    unityExponent: % -> Q
      ++ unityExponent(x) returns -(24*t + \hat{r})/(24*m) if
      ++ x = etaQuotient(mm,r,m,t,gamma).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $p_{r,m,t}(\gamma\tau)$ corresponding to x=etaQuotient(mm,
      ++ divs, r, m, t, gamma) (neglecting the (c \tau+d)^* factor)
      ++ lives in Q[w][[z]] where w is a n-th root of unity and z a
      ++ fractional q power.
    elt: (%, N) -> SymbolicEtaQuotientLambdaGamma
      ++ x.lambda returns the data corresponding to the respective
      ++ lambda.
 == add
    A ==> IndexedOneDimensionalArray(SymbolicEtaQuotientLambdaGamma, 0)
    Rep ==> Record(
              feta: A,    -- mapping lambda to \eta_{\delta,m,lambda}
              foffset: Z, -- the subsequence offset
              funityExponent: Q, -- (24 t + \hat{r})/(24 m)
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep

    -- local returns the minimal root of unity needed to express a
    -- part of a summand of \eqref{eq:p_r-m-t(gamma*tau)} for the
    -- lambda stored in y.
    minRootOfUnity(y: SymbolicEtaQuotientLambdaGamma): P ==
        -- minimal root of unity needed for the expansion is
        -- determined from expressing the squareroot of the rational
        -- prefactor in roots of unity.
        rat := rationalPrefactor y
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        minroot: P := minimalSquareRootOfUnity(rr.rootOf)$QETAAUX

        -- Additionally, we have to consider the root of unity factor
        -- in $q_{\delta,m,\lambda}$, i.e., the denominator of the
        -- $v_{\delta,m,\lambda}$.
        -- minroot for the q-Pochhammer part (last product) in
        -- \eqref{eq:g_r-m-lambda(gamma*tau)}
        divs: LP := divisors y
        for delta in divs repeat minroot := lcmP(minroot, denom vdelta(y.delta))
        minroot

    etaQuotient(mm: P, r: LZ, m: P, t: Z, gamma: SL2Z): % ==
        e: SymbolicEtaQuotientLambdaGamma := etaQuotient(mm, r, m, 0, gamma)
        minroot: P := lcmP(minRootOfUnity e, denom unityExponent e)
        eta: A := new(m, e) -- fill with dummy values
        rhat := sigmaInfinity(level e, exponents e)$QETAAUX
        uexponent: Q := fractionalPart(-(24*t + rhat)/(24*m))
        for lambda in 1..m-1 repeat -- can start with 1.
            eta.lambda := e := etaQuotient(mm, r, m, lambda, gamma)
            -- We also must take the sum of unityExponent(e) and
            -- lambda(e)*uexponent into account.
            den: Z := denom(lambda(e)*uexponent + unityExponent e) -- \in P
            minroot := lcmP(minroot, lcm(den, minRootOfUnity e))
        per [eta, t, uexponent, minroot]

    etaQuotient(mm: P, r: LZ, gamma: SL2Z): % ==
        etaQuotient(mm, r, 1, 0, gamma)

    elt(x: %, lambda: N): SymbolicEtaQuotientLambdaGamma ==
        rep(x).feta.lambda
    level(x: %): P == level(x.0)
    divisors(x: %): LP == divisors(x.0)
    exponents(x: %): LZ == exponents(x.0)
    multiplier(x: %): P == multiplier(x.0)
    offset(x: %): Z == rep(x).foffset
    gamma(x: %): SL2Z == gamma(x.0)
    unityExponent(x: %): Q == rep(x).funityExponent
    minimalRootOfUnity(x: %): P == rep(x).fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, x.0)
    ((x: %) = (y: %)): Boolean == x.0 = y.0





















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotientOrbitProductGamma $P_{r, m, t}(\gamma\tau)$}
\label{sec:SymbolicEtaQuotientOrbitProductGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align*}
  P_{r, m, t}(\gamma\tau)
  &:= \prod_{k \in \modularOrbit{r,m,t}} p_{r,m,k}(\gamma\tau)\\
\end{align*}

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaQuotientOrbitProductGamma} represent the
collection \code{SymbolicEtaQuotientGamma}
for each
$t' \in \modularOrbit{r, m, t}$ and thus corresponds to the data from
\eqref{eq:P_r-m-t(gamma*tau)}, \ie, it computes the building blocks
for $P_{r,m,t}(\gamma\tau)$.


)endif

-------------------------------------------------------------------
)abbrev domain YEQOG SymbolicEtaQuotientOrbitProductGamma
++ SymbolicEtaQuotientOrbitProductGamma
++ holds data to compute an eta-quotient
++ expansions of $P_{r, m, t}(\gamma \tau)$.
++ See \eqref{eq:P_r-m-t(gamma*tau)}.}
SymbolicEtaQuotientOrbitProductGamma: SetCategory with
    etaQuotient: (P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the expansion
      ++ of $P_{r, m, t}(\gamma \tau)$.
      ++ $r$ is indexed by the divisors of $mm$.
    level: % -> P
      ++ level(x) returns the level of the eta-quotient.
      -- Returns mm.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).
    orbit: % -> List N
      ++ orbit(x) returns $\modularOrbit{r, m, t}$ where
      ++ r=exponents(x), m=multiplier(x), t=offset(x).
      ++ See definition of orbit in qetacofactorspace.spad
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in orbit(rhat,m,t)]
      ++ where $rhat = \sum_\delta \delta r_\delta$
    elt: (%, N) -> SymbolicEtaQuotientGamma
      ++ x.u returns the data corresponding to the respective
      ++ orbit element u.
 == add
    YEQG ==> SymbolicEtaQuotientGamma
    HT ==> XHashTable(N, YEQG)
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              forbit: List N,-- \modularOrbit(r, m, t}
              fdata: HT,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        divs: LP := DIVISORS mm
        rhat: Z := 0 -- sigmaInfty
        for delta in divs for rdelta in r repeat rhat := rhat + delta * rdelta
        orb: List N := orbit(rhat, m, t)$QEtaCofactorSpace
        h: HT := empty()
        minroot: P := 1
        for tt in orb repeat
            e: YEQG := etaQuotient(mm, r, m, tt, gamma)
            minroot := lcmP(minroot, minimalRootOfUnity e)
            h.tt := e
        per [mm, divs, r, m, t, gamma, orb, h, minroot]

    elt(x: %, tt: N): YEQG == rep(x).fdata.tt
    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    gamma(x: %): SL2Z == xx.fgamma
    orbit(x: %): List N == xx.forbit
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.fgamma = yy.fgamma




)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma0EtaQuotientGamma
  $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:SymbolicModularGamma0EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{align*}
  F_{s, r, m, t}(\gamma\tau)
  &:= \divisorprod{N} \eta(\delta\tau)^{s_\delta} \cdot P_{r, m, t}(\tau)
\end{align*}

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicModularGamma0EtaQuotientGamma} represent the product of
an
eta-quotient cofactor to an element of
\code{SymbolicEtaQuotientOrbitProductGamma} in order to make the
product a modular function.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie, it
computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM0EQG SymbolicModularGamma0EtaQuotientGamma
++ SymbolicModularGamma0EtaQuotientGamma
++ holds data to compute an eta-quotient
++ expansions of $F_{s, r, m, t}(\gamma \tau)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)}.
SymbolicModularGamma0EtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, gamma) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    cofactor: % -> SymbolicEtaQuotientGamma
      ++ cofactor(x) returns the cofactor part to make $F_{s,r,m,t}$ a
      ++ modular function.
    orbitProduct: % -> SymbolicEtaQuotientOrbitProductGamma
      ++ orbitProduct(x) returns the orbit product part of $F_{s,r,m,t}$.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the lcm of the
      ++ minimalRootUnity(cofactor(x)) and
      ++ [minimalRootOfUnity(x.u) for u in orbit(rhat,m,t)].
 == add
    Rep ==> Record(
              fcoetaqg: SymbolicEtaQuotientGamma,
              fyeqopg: SymbolicEtaQuotientOrbitProductGamma,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        not modularGamma0?(nn, s, mm, r, m, t)$QEtaCofactorSpace =>
            error "modular conditions are not fulfilled"
        nndivs: LP := DIVISORS nn
        mmdivs: LP := DIVISORS mm
        coetaqg: SymbolicEtaQuotientGamma :=
            etaQuotient(nn, s, 1, 0, gamma)
        yeqopg: SymbolicEtaQuotientOrbitProductGamma :=
            etaQuotient(mm, r, m, t, gamma)
        minR1: P := minimalRootOfUnity coetaqg
        minR2: P := minimalRootOfUnity yeqopg
        per [coetaqg, yeqopg, lcmP(minR1, minR2)]

    cofactor(x: %): SymbolicEtaQuotientGamma == xx.fcoetaqg
    orbitProduct(x: %): SymbolicEtaQuotientOrbitProductGamma == xx.fyeqopg
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fcoetaqg)
        h := hashUpdate!(h, xx.fyeqopg)
        h

    ((x: %) = (y: %)): Boolean ==
        (xx.fcoetaqg = yy.fcoetaqg) and (xx.fyeqopg = yy.fyeqopg)











)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotient $(p_{r,m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
elements from the domain \code{SymbolicEtaQuotient}
is a container of data from  \code{SymbolicEtaQuotientGamma} for each
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, corresponding to a cusp of $\Gamma_0(N)$ or other given cusps.

If \code{e = etaQuotient(nn, r)}, then
for each cusp in
\code{cusps(nn)$CongruenceSubgroupGamma0(nn)}
%$
we have \code{e.cusp} is the corresponding data from
\code{SymbolicEtaQuotientGamma}.

)endif
-------------------------------------------------------------------
)abbrev domain YEQ SymbolicEtaQuotient
++ SymbolicEtaQuotient holds data to compute an eta-quotient expansions
++ of g_r(\tau) at all cusps of $\Gamma_0(N)$ or at the given cusps.
++ See \eqref{g_r(tau)}
SymbolicEtaQuotient: SetCategory with
    etaQuotient: (P, LZ, LQ) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    level: % -> P
      ++ If x=etaQuotient(mm, r) then level(x) returns the level of
      ++ the eta-quotient, i.e., level(x)=mm.
    exponents: % -> LZ
      ++ If x=etaQuotient(m, r) then exponents(x) returns the list of
      ++ exponents, i.e., exponents(x)=r.
    cusps: % -> LQ
      ++ If x=etaQuotient(mm, r), then
      ++ cusps(x)=cusp(mm)$CongruenceSubgroupGamma0.
    minimalRootOfUnity: % -> P
      ++ If x=etaQuotient(mm, r), then minimalRootOfUnity(x) returns the
      ++ smallest positive integer n such that the expansion of the
      ++ function g_r(\tau) at any cusp of Gamma_0(mm)
      ++ (neglecting the (c\tau+d)^* factor lives in Q[w][[x]] where w
      ++ is an n-th root of unity.
    elt: (%, Q) -> SymbolicEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    qetaGrades: % -> List Z
      ++ qetaGrades(x) returns the (negated) exponents of a series
      ++ expansion of x at all the cusps in the canonical variables,
      ++ i.e. in x=q^(1/w) where w=width(level x, denom q)$GAMMA0
      ++ Internally, the matrix of Ligozat is employed.
      ++
 == add
    HT ==> XHashTable(Q, SymbolicEtaQuotientGamma)
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(level)
              fexponents: LZ,-- the r vector
              fcusps: LQ,
              feta: HT,      -- mapping delta to \eta_\delta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    xExponent(x: %, cusp: Q): Z ==
        qe: Q := qExponent(x.cusp.0)$SymbolicEtaQuotientLambdaGamma
        xe: Q := WIDTH0(level x, denom cusp) * qe
        not one? denom xe =>
            error "SymbolicEtaQuotient: fractional exponent"
        numer xe
    qetaGrades(x: %): List Z == [-xExponent(x, cusp) for cusp in cusps x]

    etaQuotient(mm: P, r: LZ, cusps: LQ): % ==
        divs: LP := DIVISORS mm
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(mm, cusp)$GAMMA0
            y: SymbolicEtaQuotientGamma := etaQuotient(mm, r, gamma)
            h.cusp := y
            minroot := lcmP(minroot, minimalRootOfUnity y)
        per [mm, r, cusps, h, minroot]

    etaQuotient(mm: P, r: LZ): % == etaQuotient(mm, r, cusps(mm)$GAMMA0)

    level(x: %): P == xx.flevel
    exponents(x: %): LZ == xx.fexponents
    cusps(x: %): LQ == xx.fcusps
    elt(x: %, cusp: Q): SymbolicEtaQuotientGamma == xx.feta.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents = yy.fexponents
















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma0EtaQuotient
  $(F_{s,r,m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicModularGamma0EtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$, elements from the domain
\code{SymbolicModularGamma0EtaQuotient} represent the collection of
element from \code{SymbolicModularGamma0EtaQuotienGamma} for all
$\gamma \in \SL2Z$ corresponding to a cusp of $\Gamma_0(N)$.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie,
it computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM0EQ SymbolicModularGamma0EtaQuotient
++ SymbolicModularGamma0EtaQuotient holds data to compute an eta
++ quotient expansions of $F_{s, r, m, t}(\gamma \tau)$ at all cusps
++ of $Gamma_0(N)$. See \eqref{eq:F_s-r-m-t(gamma*tau)}.
SymbolicModularGamma0EtaQuotient: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, LQ) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, cusps) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$ for all gamma corresponding to
      ++ the given cusps.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    etaQuotient: (P, LZ, P, LZ, P, N) -> %
      ++ etaQuotient(nn, s, mm, r, m, t) represents the expansion of
      ++ $F_{r,s,m,t}(\gamma \tau)$ for all gamma corresponding to the
      ++ cusps of $\Gamma_0(nn)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    cusps: % -> LQ
      ++ cusps(x) either returns the value that was given to
      ++ etaQuotient at creation time or cusps(level
      ++ x)$CongruenceSubgroupGamma0 if the cusps where not given.
    elt: (%, Q) -> SymbolicModularGamma0EtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in cusps x].
 == add
    YM0EQG ==> SymbolicModularGamma0EtaQuotientGamma
    HT ==> XHashTable(Q, YM0EQG)
    Rep ==> Record(
              flevel: P,  -- corresponds to Gamma_0(N)
              fcusps: LQ, -- cusps of Gamma_0(N)
              fy: HT,     -- mapping gamma to YM0EQG
              fminroot: P -- minimal root of unity needed for the coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, cusps: LQ): % ==
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(nn, cusp)$GAMMA0
            e: YM0EQG := etaQuotient(nn, s, mm, r, m, t, gamma)
            h.cusp := e
            minroot := lcmP(minroot, minimalRootOfUnity e)
        per [nn, cusps, h, minroot]

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): % ==
        etaQuotient(nn, s, mm, r, m, t, cusps(nn)$GAMMA0)

    level(x: %): P == xx.flevel
    elt(x: %, cusp: Q): YM0EQG == xx.fy.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot
    cusps(x: %): LQ == xx.fcusps

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.fy)
    ((x: %) = (y: %)): Boolean == xx.fy = yy.fy












)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaGamma
  $\eta_{\delta,g,m,\lambda}^{[R]}(\gamma \tau)$}
\label{sec:SymbolicGeneralizedEtaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain domain
\code{SymbolicGeneralizedEtaGamma} represent data for the expansion of
$\eta_{\delta,g}^{[R]} \left( \left(\begin{smallmatrix}
      1 & \lambda\\
      0 & m
  \end{smallmatrix}\right)
  \gamma \tau \right)$
as given implicitly in equation
\eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.


)endif
-------------------------------------------------------------------
)abbrev domain YGEG SymbolicGeneralizedEtaGamma
++ SymbolicGeneralizedEtaGamma holds data to compute a generalized
++ eta-function expansion of
++ \eta_{\delta.g,m,\lambda}^{[R]}(\gamma\tau). See
++ \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.
SymbolicGeneralizedEtaGamma: SetCategory with
    generalizedEta: (P, P, P, N, SL2Z) -> %
      ++ generalizedEta(delta, g, m, lambda, gamma) represents the
      ++ expansion of $\eta_{\delta.g,m,\lambda}^{[R]}(\gamma\tau)$.
      ++ See \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.
    generalizedEta: (P, P, SL2Z) -> %
      ++ generalizedEta(delta, g, gamma) returns
      ++ generalizedEta(delta,g,1,0,gamma).
    level: % -> P
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ level(x) returns delta.
    general: % -> P
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ general(x) returns g.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ gamma(x) returns gamma.
    gamma1: % -> SL2Z
      ++ gamma1(x) returns the SL2Z part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    gamma2: % -> MZ
      ++ gamma2(x) returns the triangular part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    kappaSchoeneberg: % -> Q
      ++ kappaSchoeneberg(x) returns the respective exponent that
      ++ corresponds to the transformation of the generalized
      ++ eta-function.
    udelta: % -> Q            -- gcd(delta,c)^2/delta
      ++ See \eqref{eq:uv_delta-m-lamnbda}.
    vdelta: % -> Q            -- b2/d2
      ++ See \eqref{eq:uv_delta-m-lamnbda}.
    unityExponent: % -> Q
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ unityExponent(x) returns the argument of the first product of
      ++ \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.
    qExponent: % -> Q
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ qExponent(x) returns the argument of the third product of
      ++ \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}, i.e.,
      ++ $\frac{u_{\delta,m,\lambda}}{2} P_2\left(\frac{a'g}{\delta}\right)$.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $\eta_{\delta,g,m,lambda}^{[R]}(\gamma \tau)$ corresponding
      ++ to x=generalizedEtaQuotient(nn, delta, g, m, lambda, gamma)
      ++ lives in Q[w][[x]] where w is a n-th root of unity.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              fdelta: P,     -- delta
              fgeneral: P,   -- g
              fmultiplier: P,-- m
              flambda: N,    -- lambda
              fgamma: SL2Z,  -- gamma
              fgamma1: SL2Z, -- $gamma_{\delta,m,\lambda}$
              fgamma2: MZ,   -- triangular matrix
              fkappa: Q,     -- kappaSchoeneberg
              fudelta: Q,    -- u_{\delta,m,\lambda} {eq:uv_delta-m-lambda}
              fvdelta: Q,    -- v_{\delta,m,\lambda} {eq:uv_delta-m-lambda}
                             -- =b2.d2, 0<=b2<d2, 0<d2
              funityExponent: Q,-- kappa_{g,0,d,gamma_d}
                             --   + vdelta/2*P_2(adelta*g/delta)
              fqExponent: Q  -- order of expansion in q
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEta(delta: P, g: P, m: P, lambda: N, gamma: SL2Z): % ==
        gamma(2,1) <= 0 =>
            error "generalizedEtaQuotient: expect gamma(2,1) to be positive"
        rec: Rec := splitMatrix(gamma, delta)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        kappa: Q := kappaSchoeneberg(delta, g, 0, gamma1)$QETAAUX
        udelta: Q := gamma2(1,1) / gamma2(2,2)
        vdelta: Q := gamma2(1,2) / gamma2(2,2)
        gprime: Z := gamma1(1,1)*g -- $a' g$
        hprime: Z := gamma1(1,2)*g -- $b' g$
        p2: Q := (1/2)*fractionalBernoulli2(gprime/delta)
        uexponent: Q := fractionalPart(kappa + vdelta * p2)
        qexponent: Q := udelta * p2
        per [delta, g, m, lambda, gamma, gamma1, gamma2, kappa,
             udelta, vdelta, uexponent, qexponent]

    generalizedEta(delta: P, g: P, gamma: SL2Z): % ==
        generalizedEta(delta, g, 1, 0, gamma)

    level(x: %): P == xx.fdelta
    general(x: %): P == xx.fgeneral
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    gamma1(x: %): SL2Z == xx.fgamma1
    gamma2(x: %): MZ == xx.fgamma2
    kappaSchoeneberg(x: %): Q == xx.fkappa
    udeleta(x: %): Q == xx.fudelta
    vdeleta(x: %): Q == xx.fvdelta
    unityExponent(x: %): Q == xx.funityExponent
    qExponent(x: %): Q == xx.fqExponent

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fdelta)
        h := hashUpdate!(h, xx.fgeneral)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.fdelta ~= yy.fdelta => false
        xx.fgeneral ~= yy.fgeneral => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


















)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicProperGeneralizedEtaQuotientLambdaGamma
  $g_{\tilde{r},m,\lambda}(\gamma \tau)$}
\label{sec:SymbolicProperGeneralizedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$g_{\bar{r},m,\lambda}(\tau) = g_{r,m,\lambda}(\tau) \,
g_{\tilde{r},m,\lambda}(\tau)$ be a generalized eta-quotient of the
form \eqref{eq:g_rbar-m-lambda(tau)},
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$,
%
$\bar{r} = (r, \tilde{r})$ as defined in Definition~\ref{def:rbar}.
%
Then elements from the domain\\
\code{SymbolicProperGeneralizedEtaQuotientLambdaGamma} represent
$g_{\tilde{r},m,\lambda}(\gamma\tau)$ through the tuple
\begin{gather*}
  \left(
  M
  ,
  \tilde{r}
  ,
  m
  ,
  \lambda
  ,
  \gamma
  ,
  \underbrace{\gensum
  r_{\delta,g}
  \left(
    \kappa_{g,0,\delta,\gamma_\delta}^{[S]}
    +
    \frac{v_\delta}{2} P_2\left(\frac{a_\delta g}{\delta}\right)
  \right)
  }_{\texttt{unityExponent}}
  ,
  \underbrace{
  \gensum[M]
  \frac{r_{\delta,g} u_\delta}{2} P_2\left(\frac{a_\delta g}{\delta}\right)
  }_{\texttt{qExponent}}
  ,
  \tilde{y}
\right)
\end{gather*}
according to \eqref{eq:g_rtilde-m-lambda(gamma*tau)} where
$\tilde{y}=(y_{\delta,g})_{\substack{\divides{\delta}{N}\\0<g<\frac{\delta}{2}}}$
and $y_{\delta,g} = \text{\code{generalizedEta(delta,g,gamma)}}$ is an
element of \code{SymbolicGeneralizedEtaGamma}.



)endif

-------------------------------------------------------------------
)abbrev domain YPGEQLG SymbolicProperGeneralizedEtaQuotientLambdaGamma
++ SymbolicProperGeneralizedEtaQuotientLambdaGamma holds data to
++ compute a proper generalized eta-quotient expansion of
++ $g_{\tilde{r},m,\lambda}(\gamma\tau)$. See
++ \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
SymbolicProperGeneralizedEtaQuotientLambdaGamma: SetCategory with
    properGeneralizedEtaQuotient: (P, LLZ, P, N, SL2Z) -> %
      ++ properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma)
      ++ represents the
      ++ expansion of $g_{\tilde{r},m,\lambda}(\gamma\tau)$. see
      ++ \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
    properGeneralizedEtaQuotient: (P, LLZ, SL2Z) -> %
      ++ properGeneralizedEtaQuotient(nn,rtilde,gamma) returns
      ++ properGeneralizedEtaQuotient(nn,rtilde,1,0,gamma).
    level: % -> P
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ level(x) returns nn.
    exponents: % -> LLZ
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ exponents(x) returns rtilde.
    multiplier: % -> P
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ multiplier(x) returns m.
    lambda: % -> N
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ gamma(x) returns gamma.
    unityExponent: % -> Q
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ unityExponent(x) returns the argument of the first product of
      ++ \eqref{eq:g_rtilde(gamma*tau)}.
    qExponent: % -> Q
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ qExponent(x) returns the argument of the third product of
      ++ \eqref{eq:g_rtilde(gamma*tau)}, i.e.,
      ++ $\gensum
      ++   \frac{r_{\delta,g} u_\delta}{2}
      ++   P_2\left(\frac{a_\delta g}{\delta}\right)$.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(e) returns the smallest positive integer n
      ++ such that the expansion of the function g_rtilde(\gamma \tau)
      ++ corresponding to e=etaQuotient(nn, rtilde, gamma) lives in
      ++ Q[w][[x]] where w is a n-th root of unity.
    elt: (%, P, P) -> SymbolicGeneralizedEtaGamma
      ++ elt(x, delta, g) returns the data corresponding to the
      ++ respective (delta, g) pair.
 == add
    YGEG ==> SymbolicGeneralizedEtaGamma
    HT ==> XHashTable(Z, YGEG)
            -- mapping (delta, g) to $\eta_{\delta, g}^{[R]}$ where
            -- (delta, g) is encoded by n=level*delta+g
    Rep ==> Record(
              flevel: P,      -- level \Gamma_1(lev)
              fexponents: LLZ,-- rtilde
              fmultiplier: P, -- m
              flambda: N,     -- lambda
              fgamma: SL2Z,   -- gamma
              feta: HT,       -- mapping (delta,g) to $\eta_{\delta,g}^{[R]}$
              funityExponent: Q, -- sum of unityExponent of elements in fdgeta
              fqExponent: Q   -- order of expansion in q
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    -- index for hashtable HT
    idx(nn: P, delta: P, g: Z): Z == nn*delta + g

    properGeneralizedEtaQuotient(
      nn: P, rtilde: LLZ, m: P, lambda: N, gamma: SL2Z): % ==
        y: HT := empty()
        uexponent: Q := 0
        qexponent: Q := 0
        for l in rtilde repeat
            delta := asP l.1; g := asP l.2; rdg := l.3;
            k: Z := idx(nn, delta, g)
            etadg := generalizedEta(delta, g, m, lambda, gamma)$YGEG
            y.k := etadg
            uexponent := uexponent + rdg * unityExponent(etadg)
            qexponent := qexponent + rdg * qExponent(etadg)
        uexponent := fractionalPart(uexponent)$QETAAUX
        per [nn, rtilde, m, lambda, gamma, y, uexponent, qexponent]

    properGeneralizedEtaQuotient(nn: P, rtilde: LLZ, gamma: SL2Z): % ==
        properGeneralizedEtaQuotient(nn, rtilde, 1, 0, gamma)

    level(x: %): P == xx.flevel
    elt(x: %, delta: P, g: P): YGEG == xx.feta.idx(level x, delta, g)
    exponents(x: %): LLZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    unityExponent(x: %): Q == xx.funityExponent
    qExponent(x: %): Q == xx.fqExponent
    coerce(x: %): OutputForm == xx::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


















)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaQuotientLambdaGamma
  $g_{\bar{r},m,\lambda}(\gamma \tau)$}
\label{sec:SymbolicGeneralizedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$g_{\bar{r},m,\lambda}(\tau) = g_{r,m,\lambda}(\tau) \,
g_{\tilde{r},m,\lambda}(\tau)$ be a generalized eta-quotient of the
form \eqref{eq:g_rbar-m-lambda(tau)},
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$,
%
$\bar{r} = (r, \tilde{r})$ as defined in Definition~\ref{def:rbar}.
%
Then elements from the domain\\
\code{SymbolicGeneralizedEtaQuotientLambdaGamma} represent the tuple
$(y, \tilde{y})$ where $y$ is an element of
\code{SymbolicEtaQuotientLambdaGamma} and holds data for
$g_{r,m,\lambda}(\gamma\tau)$ and $\tilde{y}$ is an element of
\code{SymbolicProperGeneralizedEtaQuotientLambdaGamma} and holds data
for $g_{\tilde{r},m,\lambda}(\gamma\tau)$.
See \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.


)endif

-------------------------------------------------------------------
)abbrev domain YGEQLG SymbolicGeneralizedEtaQuotientLambdaGamma
++ SymbolicGeneralizedEtaQuotientLambdaGamma holds data to compute a
++ generalized eta-quotient expansion of
++ $g_{\bar{r},m,\lambda}(\gamma\tau)$. See
++ \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
++ \eqref{eq:g_rbar(gamma*tau)}.
SymbolicGeneralizedEtaQuotientLambdaGamma: Exports == Implementation where
  YEQLG ==> SymbolicEtaQuotientLambdaGamma
  YPGEQLG ==> SymbolicProperGeneralizedEtaQuotientLambdaGamma
  Exports ==> SetCategory with
    generalizedEtaQuotient: (P, LLZ, P, N, SL2Z) -> %
      ++ generalizedEtaQuotient(mm, rbar, m, lambda, gamma) represents
      ++ the expansion of $g_{\bar{r},m,\lambda}(\gamma\tau)$. see
      ++ \eqref{eq:g_rbar-m-lambda(gamma*tau)}.
    generalizedEtaQuotient: (P, LLZ, SL2Z) -> %
      ++ generalizedEtaQuotient(mm, rbar, gamma) returns
      ++ generalizedEtaQuotient(mm, rbar, 1, 0, gamma).
    pureEtaQuotient: % -> YEQLG
      ++ pureEtaQuotient(x) returns the part of x that corresponds to
      ++ the pure eta-quotient part of x.
    properGeneralizedEtaQuotient: % -> YPGEQLG
      ++ properGeneralizedEtaQuotient(x) returns the part of x that
      ++ corresponds to the proper generalized eta-quotient part of x.
    level: % -> P
      ++ If x=generalizedEtaQuotient(nn,rbar,m,lambda,gamma), then
      ++ level(x) returns nn.
    exponents: % -> LLZ
      ++ If x=generalizedEtaQuotient(nn,rbar,m,lambda,gamma), then
      ++ exponents(x) returns rbar.
    multiplier: % -> P
      ++ If x=generalizedEtaQuotient(nn,rbar,m,lambda,gamma), then
      ++ multiplier(x) returns m.
    lambda: % -> N
      ++ If x=generalizedEtaQuotient(nn,rbar,m,lambda,gamma), then
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ If x=generalizedEtaQuotient(nn,rbar,m,lambda,gamma), then
      ++ gamma(x) returns gamma.
    unityExponent: % -> Q
      ++ If x=generalizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ unityExponent(x) returns the sum of
      ++ unityExponent(pureEtaQuotient(x)) and
      ++ unityExponenbt(properGeneralizedEtaQuotient(x)).
    qExponent: % -> Q
      ++ If x=generalizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ qExponent(x) returns the sum of qExponent(pureEtaQuotient(x))
      ++ and qExponenbt(properGeneralizedEtaQuotient(x)).
  Implementation ==> add
    Rep ==> Record(
              flevel: P,      -- level \Gamma_1(lev)
              fexponents: LLZ,-- rbar
              fmultiplier: P, -- m
              flambda: N,     -- lambda
              fgamma: SL2Z,   -- gamma
              fpure: YEQLG,
              fpropergeneralized: YPGEQLG
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEtaQuotient(mm: P, rbar: LLZ, m: P, lambda: N, gamma: SL2Z): % ==
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        rrec: Record(pure: LZ, properGeneralized: LLZ) :=
            splitEtaQuotientSpecification(mm, rbar)$QETAAUX
        r: LZ := rrec.pure
        rtilde: LLZ := rrec.properGeneralized
        yeqlg := etaQuotient(mm, r, m, lambda, gamma)$YEQLG
        ypgeqlg := properGeneralizedEtaQuotient(
                     mm, rtilde, m, lambda, gamma)$YPGEQLG
        per [mm, rbar, m, lambda, gamma, yeqlg, ypgeqlg]

    generalizedEtaQuotient(nn: P, rbar: LLZ, gamma: SL2Z): % ==
        generalizedEtaQuotient(nn, rbar, 1, 0, gamma)

    pureEtaQuotient(x: %): YEQLG == xx.fpure
    properGeneralizedEtaQuotient(x: %): YPGEQLG == xx.fpropergeneralized
    level(x: %): P == xx.flevel
    exponents(x: %): LLZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    unityExponent(x: %): Q ==
        ue: Q := unityExponent pureEtaQuotient x
        ue + unityExponent properGeneralizedEtaQuotient x
    qExponent(x: %): Q ==
        qExponent pureEtaQuotient x + qExponent properGeneralizedEtaQuotient x
    coerce(x: %): OutputForm == xx::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h
    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma










)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaQuotientGamma
  $p_{\bar{r},m,t}(\gamma\tau)$}
\label{sec:SymbolicGeneralizedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for  $p_{\bar{r},m,t}(\gamma\tau)$

\begin{align*}
p_{\bar{r},m,t}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sigmainfty{\bar{r}}\Bigr)}
    g_{\bar{r},m,\lambda}(\gamma\tau)
\end{align*}

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicGeneralizedEtaQuotientGamma} represent the collection
\code{SymbolicGeneralizedEtaQuotientLambdaGamma} for each $\lambda \in
\Set{0,\ldots,m-1}$ and thus corresponds to the data from
\eqref{eq:p_rbar-m-t(gamma*tau)}, \ie, it computes the building
blocks for $p_{\bar{r},m,t}(\gamma\tau)$.

)endif
-------------------------------------------------------------------
)abbrev domain YGEQG SymbolicGeneralizedEtaQuotientGamma
++ SymbolicGeneralizedEtaQuotientGamma holds data to compute an eta
++ quotient expansion of $p_{r,m,t}(\gamma \tau)$. See
++ \eqref{eq:p_rbar-m-t(gamma*tau)}.
SymbolicGeneralizedEtaQuotientGamma: SetCategory with
    generalizedEtaQuotient: (P, LLZ, P, Z, SL2Z) -> %
      ++ etaQuotient(mm, rbar, m, t, gamma) represents the expansion
      ++ of $p_{\bar{r},m,t}(\gamma \tau)$ where rbar specifies the
      ++ exponents of the eta-quotient.
    generalizedEtaQuotient: (P, LLZ, SL2Z) -> %
      ++ generalizedEtaQuotient(mm, rbar, gamma) returns
      ++ generalizedEtaQuotient(mm, rbar, 1, 0, gamma).
    level: % -> P
      ++ If x=generalizedEtaQuotient(mm,rbar,m,t,gamma), then level(x)
      ++ returns mm.
    exponents: % -> LLZ
      ++ If x=generalizedEtaQuotient(mm,rbar,m,t,gamma), then
      ++ exponents(x) returns rbar.
    multiplier: % -> P
      ++ If x=generalizedEtaQuotient(mm,rbar,m,t,gamma), then
      ++ multiplier(x) returns m.
    offset: % -> Z
      ++ If x=generalizedtaQuotient(mm,rbar,m,t,gamma), then offset(x)
      ++ returns t.
    gamma: % -> SL2Z
      ++ If x=generalizedEtaQuotient(mm,rbar,m,t,g), then gamma(x)
      ++ returns g. gamma(x) returns the transformation corresponding
      ++ to x.
    unityExponent: % -> Q
      ++ If x=generalizedEtaQuotient(mm,rbar,m,t,g), then
      ++ unityExponent(x) returns -(24*t + \hat{\bar{r}})/(24*m).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $p_{\bar{r},m,t}(\gamma\tau)$ corresponding to
      ++ x=generalizedEtaQuotient(mm, rbar, m, t, gamma) (neglecting
      ++ the (c \tau+d)^* factor) lives in Q[w][[z]] where w is a n-th
      ++ root of unity and z a fractional q power.
    elt: (%, N) -> SymbolicGeneralizedEtaQuotientLambdaGamma
      ++ x.lambda returns the data corresponding to the respective
      ++ lambda.
 == add
    YEQLG ==> SymbolicEtaQuotientLambdaGamma
    YPGEQLG ==> SymbolicProperGeneralizedEtaQuotientLambdaGamma
    YGEQLG ==> SymbolicGeneralizedEtaQuotientLambdaGamma
    A ==> IndexedOneDimensionalArray(YGEQLG, 0)
    Rep ==> Record(
              feta: A,           -- mapping lambda to \eta_{\delta,m,lambda}
              foffset: Z,        -- the subsequence offset
              funityExponent: Q, -- (24 t + \hat{\bar{r}})/(24 m)
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep

    -- local returns the minimal root of unity needed to express a
    -- part of a summand of \eqref{eq:p_r-m-t(gamma*tau)} for the
    -- lambda stored in y.
    minRootOfUnityPure(y: YEQLG): P ==
        -- minimal root of unity needed for the expansion is
        -- determined from expressing the squareroot of the rational
        -- prefactor in roots of unity.
        rat := rationalPrefactor y
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        minroot: P := minimalSquareRootOfUnity(rr.rootOf)$QETAAUX

        -- Additionally, we have to consider the root of unity factor
        -- in $q_{\delta,m,\lambda}$, i.e., the denominator of the
        -- $v_{\delta,m,\lambda}$.
        -- minroot for the q-Pochhammer part (last product) in
        -- \eqref{eq:g_r-m-lambda(gamma*tau)}
        divs: LP := divisors y
        for delta in divs repeat minroot := lcmP(minroot, denom vdelta(y.delta))
        minroot

    -- local returns the minimal root of unity needed to express
    -- $g_{\bar{r},m.\lambda}(\gamma\tau}$ of
    -- \eqref{eq:g_rbar-m-lambda(gamma*tau)} for the lambda stored in y.
    minRootOfUnityProperGeneralized(y: YPGEQLG): P ==
        minroot: Z := 1
        -- We have to consider the root of unity factor in
        -- $q_{\delta,m,\lambda}$ and in
        -- $q_{\delta,m,\lambda}^{\left\{\frac{a' g}{\delta}\right\}}$,
        -- i.e., lcm of the denominator of
        -- $v_{\delta,m,\lambda}$ and
        -- $\frac{a' g}{\delta} v_{\delta,m,\lambda}$.
        -- (minroot for the q-Pochhammer part)
        for l in exponents y repeat
            delta := asP l.1; g := asP l.2; rdg := l.3;
            ygeg := y(delta, g)
            v := vdelta ygeg
            g1 := gamma1 ygeg
            a1 := g1(1,1); gprime := a1*g
            b1 := g1(1,2); hprime := b1*g
            z := (gprime + hprime)/delta
            minroot := lcm(minroot, lcm(denom v, denom(z*v)))
            -- Take the \alpha(a' g. b' g, delta) into account.
            if zero?(gprime rem delta) and not zero?(hprime rem delta) then
                t: Q := hprime/delta      -- for delta's root of unity
                w := 1/2*fractionalBernoulli1(t)$QETAAUX -- \alpha(g',h',delta)
                minroot := lcm(minroot, lcm(denom t, denom w))
               -- Note that we do not compute or store
               -- $\alpha(a_\delta g, b_\delta g, \delta)$ here.
        asP minroot

    generalizedEtaQuotient(mm: P, rbar: LLZ, m: P, t: Z, gamma: SL2Z): % ==
        y: YGEQLG := generalizedEtaQuotient(mm, rbar, m, 0, gamma)
        eta: A := new(m, y) -- fill with dummy values

        ypure: YEQLG := pureEtaQuotient y
        ypg: YPGEQLG := properGeneralizedEtaQuotient y
        ue: Q := unityExponent y

        minroot := lcm(denom ue, minRootOfUnityPure ypure)
        minroot := lcm(minroot, minRootOfUnityProperGeneralized ypg)

        r := exponents ypure
        rtilde := exponents ypg
        rbarhat := sigmaInfinity(mm, r, rtilde)$QETAAUX
        uexponent: Q := fractionalPart(-(24*t::Q + rbarhat)*(1/(24*m)))

        for lambda in 1..m-1 repeat -- can start with 1.
            y :=  generalizedEtaQuotient(mm, rbar, m, lambda, gamma)
            eta.lambda := y

            -- We also must take the sum of unityExponent(e) and
            -- lambda(e)*uexponent into account.
            ypure := pureEtaQuotient y
            ypg := properGeneralizedEtaQuotient y

            minroot := lcm(minroot, minRootOfUnityPure ypure)
            minroot := lcm(minroot, minRootOfUnityProperGeneralized ypg)

            ue := unityExponent y
            minroot := lcm(minroot, denom(ue + lambda * uexponent))

        per [eta, t, uexponent, asP minroot]

    generalizedEtaQuotient(mm: P, rbar: LLZ, gamma: SL2Z): % ==
        generalizedEtaQuotient(mm, rbar, 1, 0, gamma)

    elt(x: %, lambda: N): YGEQLG == rep(x).feta.lambda
    level(x: %): P == level(x.0)
    exponents(x: %): LLZ == exponents(x.0)
    multiplier(x: %): P == multiplier(x.0)
    offset(x: %): Z == rep(x).foffset
    gamma(x: %): SL2Z == gamma(x.0)
    unityExponent(x: %): Q == rep(x).funityExponent
    minimalRootOfUnity(x: %): P == rep(x).fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, x.0)
        hashUpdate!(h, offset x)
    ((x: %) = (y: %)): Boolean == x.0 = y.0 and offset x = offset y

















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma1GeneralizedEtaQuotientGamma
  $F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$}
\label{sec:SymbolicModularGamma1GeneralizedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Elements from the domain
\code{SymbolicModularGamma1GeneralizedEtaQuotientGamma} represent the
product of an eta-quotient cofactor to an element of
\code{SymbolicGeneralizedEtaQuotienttGamma} in order to make the
product a modular function for $\Gamma_1(N)$.

It corresponds to the data from \eqref{eq:F_sbar-rbar-m-t(gamma*tau)},
\ie, it computes the building blocks for
$F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM1GEQG SymbolicModularGamma1GeneralizedEtaQuotientGamma
++ SymbolicModularGamma1GeneralizedEtaQuotientGamma
++ holds data to compute an eta-quotient
++ expansions of $F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$.
++ See \eqref{eq:F_sbar-rbar-m-t(gamma*tau)}.
SymbolicModularGamma1GeneralizedEtaQuotientGamma: SetCategory with
    generalizedEtaQuotient: (P, LLZ, P, LLZ, P, N, SL2Z) -> %
      ++ generalizedEtaQuotient(nn, sbar, mm, rbar, m, t, gamma)
      ++ represents the expansion of
      ++ $F_{\bar{s},\bar{r},m,t}(\gamma\tau)$.
    cofactor: % -> SymbolicGeneralizedEtaQuotientGamma
      ++ cofactor(x) returns the cofactor part to make
      ++ $F_{\bar{s},\bar{r},m,t}$ a modular function for
      ++ $\Gamma_1(N)$.
    basefactor: % -> SymbolicGeneralizedEtaQuotientGamma
      ++ basefactor(x) returns the part of $F_{\bar{s},\bar{r},m,t}$
      ++ that is connected to the generating series of a(m*n+t).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the lcm of
      ++ minimalRootOfUnity(cofactor(x)) and
      ++ minimalRootOfUnity(basefactor(x)).
 == add
    YGEQG ==> SymbolicGeneralizedEtaQuotientGamma
    Rep ==> Record(
              fcofactor: YGEQG,   -- g_sbar
              fbasefactor: YGEQG, -- p_rbar-m-t
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEtaQuotient(nn: P, sbar: LLZ, mm: P, rbar: LLZ, m: P, t: N,
                           gamma: SL2Z): % ==
        not modularGamma1?(nn, sbar, mm, rbar, m, t)$QEtaCofactorSpace =>
            error "modular conditions are not fulfilled"
        cofactor: YGEQG := generalizedEtaQuotient(nn, sbar, 1, 0, gamma)
        basefactor: YGEQG := generalizedEtaQuotient(mm, rbar, m, t, gamma)
        minR1: P := minimalRootOfUnity cofactor
        minR2: P := minimalRootOfUnity basefactor
        per [cofactor, basefactor, lcmP(minR1, minR2)]

    cofactor(x: %): SymbolicGeneralizedEtaQuotientGamma == xx.fcofactor
    basefactor(x: %): SymbolicGeneralizedEtaQuotientGamma == xx.fbasefactor
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == xx::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fcofactor)
        h := hashUpdate!(h, xx.fbasefactor)
        h

    ((x: %) = (y: %)): Boolean ==
        (xx.fcofactor = yy.fcofactor) and (xx.fbasefactor = yy.fbasefactor)













)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaQuotient
  $(p_{\bar{r},m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicGeneralizedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $\bar{r}\in \bar{R}(N)$, elements from the domain
\code{SymbolicGeneralizedEtaQuotient} is a container of data from
\code{SymbolicGeneralizedEtaQuotientGamma} for each
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, corresponding to a cusp of $\Gamma_1(N)$ or for other given
cusps.

If \code{e = generalizedEtaQuotient(nn, rbar)}, then
for each cusp in
\code{cusps(nn)$CongruenceSubgroupGamma1(nn)}
%$
we have \code{e.cusp} is the corresponding data from
\code{SymbolicGeneralizedEtaQuotientGamma}.

)endif
-------------------------------------------------------------------
)abbrev domain YGEQ SymbolicGeneralizedEtaQuotient
++ SymbolicGeneralizedEtaQuotient holds data to compute a
++ generalized eta-quotient expansions of g_rr(\tau) at all cusps of
++ $\Gamma_1(N)$ or at the given cusps. See \eqref{g_rbar(tau)}
SymbolicGeneralizedEtaQuotient: SetCategory with
    generalizedEtaQuotient: (P, LLZ, LQ) -> %
      ++ generalizedEtaQuotient(mm,rbar,cusps) represents the
      ++ expansion of g_rbar(\tau) at the given cusps a/c of
      ++ Gamma1(mm) in terms of $x = \exp(2 \pi i \tau/w)$ where
      ++ w=width(m, c)$GAMMA1 and gamma=cuspToMatrix(m, a/c)$GAMMA1.
      ++ See \eqref{eq:g_rbar(tau)} and \eqref{eq:g_rbar(gamma*tau)}.
    generalizedEtaQuotient: (P, LLZ) -> %
      ++ generalizedEtaQuotient(mm, rbar) represents the expansion of
      ++ g_rbar(\tau) at all cusps a/c of Gamma1(mm) in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(m,c) and
      ++ gamma=cuspToMatrix(mm, a/c). It is the same as
      ++ generalizedEtaQuotient(mm,rbar,cusps(mm)$CongruenceSubgroupGamma1).
      ++ See \eqref{eq:g_rbar(tau)} and \eqref{eq:g_rbar(gamma*tau)}.
    level: % -> P
      ++ If x=generalizedEtaQuotient(nn,rbar) then level(x) returns nn.
    exponents: % -> LLZ
      ++ If x=generalizedEtaQuotient(mm, rbar) then exponents(x)
      ++ returns the list rbar.
    cusps: % -> LQ
      ++ If x=generalizedEtaQuotient(mm, rbar, spitzen), then
      ++ cusps(x)=spitzen.
    minimalRootOfUnity: % -> P
      ++ If x=generalizedEtaQuotient(nn, rbar, cusps), then
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function g_rbar(\tau) at any
      ++ cusp of cusps (neglecting the (c\tau+d)^* factor lives in
      ++ Q[w][[x]] where w is an n-th root of unity.
      ++ It is computed as the lcm of the values for the respective
      ++ expansion at the cusps.
    elt: (%, Q) -> SymbolicGeneralizedEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    qetaGrades: % -> List Z
      ++ qetaGrades(x) returns the (negated) exponents of a series
      ++ expansion of x at all the cusps in the canonical variables.
      ++ i.e. in x=q^(1/w) where w=width(level x, denom q)$GAMMA0.
      ++ Internally, the matrixEtaOrder is used.
 == add
    HT ==> XHashTable(Q, SymbolicGeneralizedEtaQuotientGamma)
    Rep ==> Record(
              flevel: P,
              fexponents: LLZ,
              fcusps: LQ,
              feta: HT,   -- mapping delta to \eta_\delta
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    xExponent(x: %, cusp: Q): Z ==
        qe: Q := qExponent(x.cusp.0)$SymbolicGeneralizedEtaQuotientLambdaGamma
        xe: Q := WIDTH1(level x, denom cusp) * qe
        not one? denom xe =>
            error "SymbolicGeneralizedEtaQuotient: fractional exponent"
        numer xe
    qetaGrades(x: %): List Z == [-xExponent(x, cusp) for cusp in cusps x]

    generalizedEtaQuotient(mm: P, rbar: LLZ, cusps: LQ): % ==
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(mm, cusp)$GAMMA1
            import from SymbolicGeneralizedEtaQuotientGamma
            y := generalizedEtaQuotient(mm, rbar, gamma)
            h.cusp := y
            minroot := lcmP(minroot, minimalRootOfUnity y)
        per [mm, rbar, cusps, h, minroot]

    generalizedEtaQuotient(nn: P, rbar: LLZ): % ==
        generalizedEtaQuotient(nn, rbar, cusps(nn)$GAMMA1)

    level(x: %): P == xx.flevel
    exponents(x: %): LLZ == xx.fexponents
    cusps(x: %): LQ == xx.fcusps
    elt(x: %, cusp: Q): SymbolicGeneralizedEtaQuotientGamma == xx.feta.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == xx::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fcusps)
        h
    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents ~= yy.fexponents => false
        xx.fcusps = yy.fcusps














)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma1GeneralizedEtaQuotient
  $(F_{\bar{s},\bar{r},m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicModularGamma1GeneralizedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $\bar{s} \in \bar{R}(N)$, $\bar{r} \in
\bar{R}(M)$, $t \in \Set{0,\ldots,m-1}$, elements from the domain
\code{SymbolicModularGamma1GeneralizedEtaQuotient} represent the
collection of elements from
\code{SymbolicModularGamma1GeneralizedEtaQuotienGamma} for all
$\gamma \in \SL2Z$ corresponding to a cusp of $\Gamma_1(N)$.

It corresponds to the data from \eqref{eq:F_sbar-rbar-m-t(gamma*tau)},
\ie, it computes the building blocks for
$F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM1GEQ SymbolicModularGamma1GeneralizedEtaQuotient
++ SymbolicModularGamma1GeneralizedEtaQuotient holds data to compute
++ an generalized eta quotient expansions of
$F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$ at all cusps
++ of $Gamma_1(N)$. See \eqref{eq:F_sbar-rbar-m-t(gamma*tau)}.
SymbolicModularGamma1GeneralizedEtaQuotient: SetCategory with
    generalizedEtaQuotient: (P, LLZ, P, LLZ, P, N, LQ) -> %
      ++ generalizedEtaQuotient(nn,sbar,mm,rbar,m,t,cusps) represents
      ++ the expansion of $F_{sbar,rbar,m,t}(\gamma \tau)$ for all gamma
      ++ corresponding to the given cusps. $rbar$ and $sbar$ are indexed by
      ++ the divisors of $mm$ and $nn$, repectively.
    generalizedEtaQuotient: (P, LLZ, P, LLZ, P, N) -> %
      ++ etaQuotient(nn,sbar,mm,rbar,m,t) represents the expansion of
      ++ $F_{rbar,sbar,m,t}(\gamma \tau)$ for all gamma corresponding
      ++ to the cusps of $\Gamma_0(nn)$. $rbar$ and $sbar$ are indexed
      ++ by the divisors of $mm$ and $nn$, repectively.
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_1(nn).
    cusps: % -> LQ
      ++ cusps(x) either returns the value that was given to
      ++ generalizedEtaQuotient at creation time or
      ++ cusps(level(x))$CongruenceSubgroupGamma1 if the cusps where
      ++ not given.
    elt: (%, Q) -> SymbolicModularGamma1GeneralizedEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in cusps x].
 == add
    YM1GEQG ==> SymbolicModularGamma1GeneralizedEtaQuotientGamma
    HT ==> XHashTable(Q, YM1GEQG)
    Rep ==> Record(
              flevel: P,  -- corresponds to Gamma_0(N)
              fcusps: LQ, -- cusps of Gamma_1(N)
              fy: HT,     -- mapping gamma to YM1GEQG
              fminroot: P -- minimal root of unity needed for the coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEtaQuotient(nn: P, sbar: LLZ, mm: P, rbar: LLZ, m: P, t: N,
                           cusps: LQ): % ==
        h: HT := empty()
        minroot: P := 1
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(nn, cusp)$GAMMA1
            e: YM1GEQG := generalizedEtaQuotient(nn, sbar, mm, rbar, m, t,gamma)
            h.cusp := e
            minroot := lcmP(minroot, minimalRootOfUnity e)
        per [nn, cusps, h, minroot]

    generalizedEtaQuotient(nn: P, sbar: LLZ, mm: P, rbar: LLZ, m: P, t: N): % ==
        generalizedEtaQuotient(nn, sbar, mm, rbar, m, t, cusps(nn)$GAMMA1)

    level(x: %): P == xx.flevel
    elt(x: %, cusp: Q): YM1GEQG == xx.fy.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot
    cusps(x: %): LQ == xx.fcusps

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, xx.fy)
    ((x: %) = (y: %)): Boolean == xx.fy = yy.fy













)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
