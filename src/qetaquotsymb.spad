-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Metadata for (sifted and generalized) Dedekind Eta Functions
  for expansion as several cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The domains in this file collect all the (meta) data that is needed
  to compute the actual Puiseux series expansion of the object in
  question, but do not itself hold the series expansion.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LSL2Z ==> List SL2Z
GAMMA0 ==> CongruenceSubgroupGamma0
GAMMA1 ==> CongruenceSubgroupGamma1
QETAAUX ==> QEtaAuxiliaryPackage
SPEC ==> QEtaSpecification

asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)
WIDTH1(nn, c) ==> asP(width(nn, c)$GAMMA1)

)if LiterateDoc
%$
In fact, we have two types of domains, namely,
\begin{enumerate}
\item domains that just collect/precompute certain data, and
\item domains that actually compute a series expansion.
\end{enumerate}
Domains in the first category are marked with the prefix
\code{Symbolic}.
%
These \emph{Symbolic} domains actually only serve the purpose to
compute an upper bound for $k$ so that the the series expansions all
live in $\setQ[\xi][x]$ where $\xi=\exp\bigl(\frac{2\pi i}{k}\bigr)$
is a $k$-th primitive root of unity and $x$ is a fractional power of
$q$.

Domains in the second category are implemented in the file
\PathName{qetaquot.spad}.











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaGamma $\eta_{\delta,m,\lambda}(\gamma\tau)$}
\label{sec:SymbolicEtaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  \delta,
  m,
  \lambda,
  \gamma,
  \gamma_1,
  \gamma_2,
  \frac{h_{\delta,m,\lambda}}{\delta},
  \kappa_{\delta,m,\lambda},
  u_{\delta,m,\lambda},
  v_{\delta,m,\lambda}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:eta_delta-m-lambda(gamma*tau)}, \ie, it computes the
building blocks for $\eta_{\delta,m,\lambda}(\gamma\tau)$.
We have $\gamma_1=\gamma_{\delta,m,\lambda}$ and $\gamma=\gamma_1\gamma_2$.

)endif

)abbrev domain YEG SymbolicEtaGamma
++ SymbolicEtaGamma collects data for the expansion of
++ eta_delta(\gamma \tau).
++ See \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
SymbolicEtaGamma: SetCategory with
    eta: (P, P, P, N, SL2Z) -> %
      ++ eta(mm, delta, m, lambda, gamma) represents the
      ++ expansion of $\eta_{\delta,m,\lambda}(\gamma \tau)$ in terms of
      ++ $q = \exp(2 \pi i \tau)$.
      ++ See \eqref{eq:eta_delta-m-lambda-gamma-tau}.
      ++ We require that c>0 in gamma=matrix[[a,b],[c,d]].
    eta: (P, P, N, SL2Z) -> %
      ++ eta(delta, m, lambda, gamma) returns
      ++ eta(delta, delta, m, lambda, gamma)
    eta: (P, P, SL2Z) -> % -- gamma=[[a,b],[c,d]], mm=level, delta
      ++ eta(mm, delta, gamma) represents the expansion of
      ++ \eta_\delta(\gamma \tau) in terms of
      ++ q = \exp(2 \pi i \tau).
      ++ It is the same as eta(mm, delta, 1, 0, gamma).
      ++ See \eqref{eq:eta_delta-m-lambda-gamma-tau} for m=1, lambda=0.
    eta: (P, SL2Z) -> %
      ++ eta(delta, gamma) returns eta(delta, delta, gamma).
    level: % -> P
      ++ level(x) returns the level corresponding to x.
    delta: % -> P
      ++ delta(x) returns the delta that was used at creation time of x.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in eta(...,gamma).
    gamma1: % -> SL2Z
      ++ gamma1(x) returns the SL2Z part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    gamma2: % -> MZ
      ++ gamma2(x) returns the triangular part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    rationalPrefactor: % -> Q -- (h_delta/delta)
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
      ++ See \ref{thm:c*tau+d}.
    upsilonExponent: % -> Z -- kappa_delta
      ++ Returns $\kappa_{\gamma_{\delta,m,\lambda}}$.
      ++ See \eqref{eq:eta_delta-m-lambda(gamma*tau)}
      ++ and \eqref{eta_delta(gamma*tau)}.
    udelta: % -> Q
      ++ Returns $u_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
      ++ See \eqref{eq:uv_delta}
    vdelta: % -> Q
      ++ Returns $v_{\delta,m,\lambda}$. See
      ++ \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
      ++ See \eqref{eq:uv_delta}.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,
              fdelta: P,
              fmultiplier: P,
              flambda: N,
              fgamma: SL2Z, -- gamma
              fgamma1: SL2Z,-- splitMatrix.red
              fgamma2: MZ,  -- splitMatrix.triang
              frat: Q,      -- square of rational prefactor
              fkappa: Z,    -- upsilonExponent(a1,b2,c1,d1)
              fudelta: Q,   -- udelta = hdelta^2/(delta*m)
                            -- \eqref{eq:uv_delta-m-lambda}}
              fvdelta: Q    -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        --assert(gamma(2, 1)>0)
        gamma(2, 1) <= 0 ==> error "QEtaSymbolicData: we want gamma(2,1)>0"
        rec: Rec := splitMatrix(gamma, delta, m, lambda)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        a2: Z := gamma2(1, 1); b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        rat: Q := a2/delta -- = hdelta/delta
        udelta: Q := a2/d2 -- = hdelta^2/delta/m
        vdelta: Q := b2/d2
        kappa: Z := upsilonExponent(gamma1)$QETAAUX
        per [mm, delta, m, lambda, gamma,
             gamma1, gamma2,rat, kappa, udelta, vdelta]

    eta(delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        eta(delta, delta, m, lambda, gamma)

    eta(mm: P, delta: P, gamma: SL2Z): % == eta(mm, delta, 1, 0, gamma)
    eta(delta: P, gamma: SL2Z): % == eta(delta, delta, gamma)

    level(x: %): P == rep(x).flevel
    delta(x: %): P == xx.fdelta
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z == xx.fkappa
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
    ((x: %) = (y: %)): Boolean ==
        delta x ~= delta y => false
        multiplier x ~= multiplier y => false
        lambda x ~= lambda y => false
        gamma x = gamma y






)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotientLambdaGamma $g_{r,m,\lambda}(\gamma\tau)$}
\label{sec:SymbolicEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $g_{r,m,\lambda}(\gamma\tau)$.

For $m, M\in\setN$, $r \in R(M)$, $\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaQuotientLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  r,
  m,
  \lambda,
  \gamma,
  y,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{M} \frac{r_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} \frac{r_\delta u_{\delta,m,\lambda}}{24}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:g_r-m-lambda(gamma*tau)}, \ie, it computes the building
blocks for $g_{r,m,\lambda}(\gamma\tau)$.

The special entry $y=(y_\delta)_{\divides{\delta}{M}}$ is a container
of the \code{SymbolicEtaGamma} values for each
divisor $\delta$ of $M$.


)endif


-------------------------------------------------------------------
)abbrev domain YEQLG SymbolicEtaQuotientLambdaGamma
++ SymbolicEtaQuotientLambdaGamma holds data to compute an eta
++ quotient expansion of g_{r,m,\lambda}(\gamma \tau).
++ See \eqref{eq:g_r-m-lambda(gamma*tau)} and
++ \eqref{eq:g_r-m---lambda(gamma*tau)}.
SymbolicEtaQuotientLambdaGamma: SetCategory with
    etaQuotient: (P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, lambda, gamma) represents the
      ++ expansion of $g_{r,m,\lambda}(\gamma \tau)$ in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(nn, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c.
      ++ $r$ is indexed by the divisors of $mm$.
    etaQuotient: (SPEC, P, N, SL2Z) -> %
      ++ etaQuotient(rspec, m, lambda, gamma) represents the
      ++ expansion of $g_{r,m,\lambda}(\gamma \tau)$ in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(nn, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c.
      ++ $r$ is given by rspec.
    definingSpecification: % -> SPEC
      ++ If x=etaQuotient(spec,...), then definingSpecification(x)
      ++ returns spec.
    level: % -> P
      ++ level(x) returns the level of the eta-quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were given
      ++ at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).

    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_r-m-lambda(gamma*tau)}.
    unityExponent: % -> Q
      ++ unityExponent(e) returns
      ++ $sum_{\delta} rdelta*(vdelta+Kappa_delta)/24$.
      ++ It corresponds to the second factor of
      ++ \eqref{eq:g_r-m-lambda(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns the order of the expansion
      ++ of e in q = \exp(2 \pi i \tau)  while neglecting the (c\tau+d) factor.
      ++ It corresponds to the exponent of the fourth product
      ++ of \eqref{eq:g_r-m-lambda(gamma*tau)}.
      ++ Compare also with \eqref{eq:modular-g_r(gamma*tau)}.
    elt: (%, P) -> SymbolicEtaGamma
      ++ x.delta returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicEtaGamma)
      -- mapping delta to \eta_{\delta,m,\lambda}
    Rep ==> Record(
              fspec: SPEC,   -- the defining specification of the eta-quotient
              fmultiplier: P,-- the multiplier m
              flambda: N,    -- lambda \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_{\delta,m,lambda}
              frat: Q,       -- square of rational prefactor
              funityExponent: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
              fqExponent: Q  -- \sum_delta rdelta*udelta/24
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    -- local
    etaquot(rspec: SPEC, m: P, lambda: N, gamma: SL2Z, eta: HT): % ==
        import from QETAAUX
        rat: Q := 1
        uexponent: Q := 0 -- unityExponent
        qexponent: Q := 0
        r: LZ := pureExponents rspec
        for delta in divisors rspec for rdelta in r | not zero? rdelta repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            rd := rdelta/24
            qexponent := qexponent + rd * udelta(e)
            kappa: Q := (upsilonExponent e)::Q
            uexponent := uexponent + rd * (vdelta e + kappa)

        -- Now make the numerator small.
        uexponent: Q := fractionalPart(uexponent)$QETAAUX
        per [rspec, m, lambda, gamma, eta, rat, uexponent, qexponent]

    etaQuotient(rspec: SPEC, m: P, lambda: N, gamma: SL2Z): % ==
        not pure? rspec => error "specification is not for a pure eta-quotient"
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        mm: P := level rspec
        for delta in divisors rspec repeat
            eta.delta := eta(mm, delta, m, lambda, gamma)$SymbolicEtaGamma
        etaquot(rspec, m, lambda, gamma, eta)

    etaQuotient(mm: P, r: LZ, m: P, lambda: N, gamma: SL2Z): % ==
        rspec: SPEC := etaQuotientSpecification(mm, r)
        etaQuotient(rspec, m, lambda, gamma)

    definingSpecification(x: %): SPEC == xx.fspec
    level(x: %): P == level definingSpecification x
    divisors(x: %): LP == divisors definingSpecification x
    elt(x: %, delta: P): SymbolicEtaGamma == xx.feta.delta
    exponents(x: %): LZ == pureExponents definingSpecification x
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityExponent(x: %): Q == xx.funityExponent
    qExponent(x: %): Q == xx.fqExponent

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fspec)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.fspec ~= yy.fspec => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotientGamma $p_{r,m,t}(\gamma\tau)$}
\label{sec:SymbolicEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for $p_{r,m,t}(\gamma\tau)$.

\begin{align*}
p_{r,m,t}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sigmainfty{r}\Bigr)}
    g_{r,m,\lambda}(\gamma\tau)
\end{align*}

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaQuotientGamma} represent the collection
\code{SymbolicEtaQuotientLambdaGamma} for each $\lambda \in
\Set{0,\ldots,m-1}$ and thus corresponds to the data from
\eqref{eq:p_r-m-t(gamma*tau)}, \ie, it computes the building
blocks for $p_{r,m,t}(\gamma\tau)$.

)endif
-------------------------------------------------------------------
)abbrev domain YEQG SymbolicEtaQuotientGamma
++ SymbolicEtaQuotientGamma holds data to compute an eta
++ quotient expansion of $p_{r,m,t}(\gamma \tau)$.
++ See \eqref{eq:p_r-m-t(gamma*tau)}.
SymbolicEtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, Z, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the
      ++ expansion of $p_{r,m,t}(\gamma \tau)$ where $r$ is indexed
      ++ by the divisors of $mm$.
    etaQuotient: (P, LZ, SL2Z) -> %
      ++ etaQuotient(mm, r, gamma) returns etaQuotient(mm,r,1,0,gamma)
      ++ and represents the expansion of $p_r(\gamma \tau)$ in terms
      ++ of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=matrix[[a,b],[c,d]] represents the cusp a/c. $r$ is
      ++ indexed by the divisors of $mm$.
    etaQuotient: (SPEC, P, Z, SL2Z) -> %
      ++ etaQuotient(rspec, m, t, gamma) represents the expansion of
      ++ $p_{r,m,t}(\gamma \tau)$ where $r$ is given by rspec.
    etaQuotient: (SPEC, SL2Z) -> %
      ++ etaQuotient(rspec, gamma) returns
      ++ etaQuotient(rspec,1,0,gamma) and represents the expansion of
      ++ $p_r(\gamma \tau)$ in terms of x = \exp(2 \pi i \tau/w) where
      ++ w=width(m, c) and gamma=matrix[[a,b],[c,d]] represents the
      ++ cusp a/c. $r$ is given by rspec.
    definingSpecification: % -> SPEC
      ++ If x=etaQuotient(spec,...), then definingSpecification(x)
      ++ returns spec.
    level: % -> P
      ++ level(x) returns the level of the eta-quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) that were
      ++ given at creation time of x.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors. Zeros at the end of the list are removed.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> Z
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaQuotient(...,gamma).
    unityExponent: % -> Q
      ++ unityExponent(x) returns -(24*t + \hat{r})/(24*m) if
      ++ x = etaQuotient(mm,r,m,t,gamma).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $p_{r,m,t}(\gamma\tau)$ corresponding to
      ++ x=etaQuotient(mm,divs,r,m,t,gamma) (neglecting the
      ++ (c*\tau+d)^* factor) lives in Q[w][[z]] where w is a n-th
      ++ root of unity and z a fractional q power.
    elt: (%, N) -> SymbolicEtaQuotientLambdaGamma
      ++ x.lambda returns the data corresponding to the respective
      ++ lambda.
    one?: % -> Boolean
      ++ one?(x) returns true if the eta-quotient corresponding to x
      ++ represents 1. This is the case if one?(specification(x)),
      ++ i.e., if the representation is trivial.
    qExponent: % -> Q
      ++ qExponent(x) returns the order of the q-expansion in terms
      ++ of the original q.
      ++ Note that this exponent is only a lower bound for the
      ++ q-expansion. The coefficient corresponding to this q-power
      ++ may be zero.
 == add
    A ==> IndexedOneDimensionalArray(SymbolicEtaQuotientLambdaGamma, 0)
    Rep ==> Record(
              feta: A,    -- mapping lambda to \eta_{\delta,m,lambda}
              foffset: Z, -- the subsequence offset
              funityExponent: Q, -- (24 t + \hat{r})/(24 m)
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep

    -- local
    -- returns the minimal root of unity needed to express a
    -- part of a summand of \eqref{eq:p_r-m-t(gamma*tau)} for the
    -- lambda stored in y.
    -- Compare with puiseuxExpansion in qetaquot.spad.
    minRootOfUnity(y: SymbolicEtaQuotientLambdaGamma, ue: Q): P ==
        -- minimal root of unity needed for the expansion is
        -- determined from expressing the squareroot of the rational
        -- prefactor in roots of unity.
        rat := rationalPrefactor y
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        minroot: Z := minimalSquareRootOfUnity(rr.rootOf)$QETAAUX
        uexp: Q := lambda(y)*ue + unityExponent y
        minroot := lcm(minroot, denom uexp)

        -- Additionally, we have to consider the root of unity factor
        -- in $q_{\delta,m,\lambda}$, i.e., the denominator of the
        -- $v_{\delta,m,\lambda}$.
        -- minroot for the q-Pochhammer part (last product) in
        -- \eqref{eq:g_r-m-lambda(gamma*tau)}
        divs: LP := divisors y
        for delta in divs repeat minroot := lcm(minroot, denom vdelta(y.delta))
        asP minroot

    etaQuotient(mm: P, r: LZ, m: P, t: Z, gamma: SL2Z): % ==
        rspec: SPEC := etaQuotientSpecification(mm, r)
        etaQuotient(rspec, m, t, gamma)

    etaQuotient(mm: P, r: LZ, gamma: SL2Z): % ==
        etaQuotient(mm, r, 1, 0, gamma)

    etaQuotient(rspec: SPEC, m: P, t: Z, gamma: SL2Z): % ==
        not pure? rspec => error "specification is not for a pure eta-quotient"
        rhat: Z := numer sigmaInfinity rspec -- know that it is integral
        uexponent: Q := fractionalPart(-(24*t + rhat)/(24*m))$QETAAUX
        y: SymbolicEtaQuotientLambdaGamma := etaQuotient(rspec, m, 0, gamma)
        minroot: Z := minRootOfUnity(y, uexponent)
        eta: A := new(m, y) -- fill with dummy values
        for lambda in 1..m-1 repeat -- can start with 1.
            eta.lambda := y := etaQuotient(rspec, m, lambda, gamma)
            minroot := lcm(minroot, minRootOfUnity(y, uexponent))
        per [eta, t, uexponent, asP minroot]

    etaQuotient(rspec: SPEC, gamma: SL2Z): % ==
        etaQuotient(rspec, 1, 0, gamma)

    elt(x: %, lambda: N): SymbolicEtaQuotientLambdaGamma ==
        rep(x).feta.lambda
    definingSpecification(x: %): SPEC == definingSpecification(x.0)
    level(x: %): P == level(x.0)
    divisors(x: %): LP == divisors(x.0)
    exponents(x: %): LZ == exponents(x.0)
    multiplier(x: %): P == multiplier(x.0)
    offset(x: %): Z == rep(x).foffset
    gamma(x: %): SL2Z == gamma(x.0)
    unityExponent(x: %): Q == rep(x).funityExponent
    minimalRootOfUnity(x: %): P == rep(x).fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, x.0)
    ((x: %) = (y: %)): Boolean == x.0 = y.0 and offset x = offset y
    one?(x): Boolean == one? definingSpecification x
    qExponent(x: %): Q ==
        m: P := multiplier x
        e: Q := qExponent(x.0)
        lambda: N := 1
        while lambda < m repeat
            e := min(e, qExponent(x.lambda))
            lambda := lambda + 1
        return e




















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotientOrbitProductGamma $P_{r, m, t}(\gamma\tau)$}
\label{sec:SymbolicEtaQuotientOrbitProductGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{align*}
  P_{r, m, t}(\gamma\tau)
  &:= \prod_{k \in \modularOrbit{r,m,t}} p_{r,m,k}(\gamma\tau)\\
\end{align*}

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicEtaQuotientOrbitProductGamma} represent the
collection \code{SymbolicEtaQuotientGamma}
for each
$t' \in \modularOrbit{r, m, t}$ and thus corresponds to the data from
\eqref{eq:P_r-m-t(gamma*tau)}, \ie, it computes the building blocks
for $P_{r,m,t}(\gamma\tau)$.


)endif

-------------------------------------------------------------------
)abbrev domain YEQOG SymbolicEtaQuotientOrbitProductGamma
++ SymbolicEtaQuotientOrbitProductGamma
++ holds data to compute an eta-quotient
++ expansions of $P_{r, m, t}(\gamma \tau)$.
++ See \eqref{eq:P_r-m-t(gamma*tau)}.}
SymbolicEtaQuotientOrbitProductGamma: SetCategory with
    etaQuotient: (P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(mm, r, m, t, gamma) represents the expansion
      ++ of $P_{r, m, t}(\gamma \tau)$.
      ++ $r$ is indexed by the divisors of $mm$.
    etaQuotient: (SPEC, P, N, SL2Z) -> %
      ++ etaQuotient(rspec, m, t, gamma) represents the expansion
      ++ of $P_{r, m, t}(\gamma \tau)$.
      ++ $r$ is given by rspec.
    definingSpecification: % -> SPEC
      ++ If x=etaQuotient(spec,...), then definingSpecification(x)
      ++ returns spec.
    level: % -> P
      ++ level(x) returns the level of the eta-quotient.
      -- Returns mm.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors. Zeros at the end of the list are removed.
      -- Returns r.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).
    orbit: % -> List N
      ++ orbit(x) returns $\modularOrbit{r, m, t}$ where
      ++ r=exponents(x), m=multiplier(x), t=offset(x).
      ++ See definition of orbit in qetacofactorspace.spad
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in orbit(x)]
      ++ where $rhat = \sum_\delta \delta r_\delta$
    elt: (%, N) -> SymbolicEtaQuotientGamma
      ++ x.u returns the data corresponding to the respective
      ++ orbit element u.
    one?: % -> Boolean
      ++ one?(x) returns true if the eta-quotient orbit product
      ++ corresponding to x represents 1. This is true if
      ++ one?(definingSpecification(x)), i.e., the representation is
      ++ trivial.
    qExponent: % -> Q
      ++ qExponent(x) returns
      ++ reduce(_+, [qExponent(x.k) for k in orbit(x)])
      ++ Note that this exponent is only a lower bound for the
      ++ q-expansion. The coefficient corresponding to this q-power
      ++ may be zero.
 == add
    YEQG ==> SymbolicEtaQuotientGamma
    HT ==> XHashTable(N, YEQG)
    Rep ==> Record(
              fspec: SPEC,   -- spec part of the eta-quotient
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              forbit: List N,-- \modularOrbit(r, m, t}
              fdata: HT,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(rspec: SPEC, m: P, t: N, gamma: SL2Z): % ==
        not pure? rspec => error "specification is not for a pure eta-quotient"
        orb: List N := modularGamma0Orbit(rspec, m, t)$QEtaCofactorConditions
        h: HT := empty()
        minroot: Z := 1
        for tt in orb repeat
            e: YEQG := etaQuotient(rspec, m, tt, gamma)
            minroot := lcm(minroot, minimalRootOfUnity e)
            h.tt := e
        per [rspec, m, t, gamma, orb, h, asP minroot]

    etaQuotient(mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        rspec: SPEC := etaQuotientSpecification(mm, r)
        etaQuotient(rspec, m, t, gamma)

    elt(x: %, tt: N): YEQG == rep(x).fdata.tt
    definingSpecification(x: %): SPEC == xx.fspec
    level(x: %): P == level definingSpecification x
    divisors(x: %): LP == divisors definingSpecification x
    exponents(x: %): LZ == pureExponents definingSpecification x
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    gamma(x: %): SL2Z == xx.fgamma
    orbit(x: %): List N == xx.forbit
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fspec)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.fspec ~= yy.fspec => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.fgamma = yy.fgamma

    one?(x: %): Boolean == one? definingSpecification x
    qExponent(x: %): Q ==
        orb := orbit x
        e: Q := qExponent(x(first orb))
        for k in rest orb repeat e := e + qExponent(x.k)
        return e



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma0EtaQuotientGamma
  $F_{s, r, m, t}(\gamma\tau)$}
\label{sec:SymbolicModularGamma0EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{align*}
  F_{s, r, m, t}(\gamma\tau)
  &:= \divisorprod{N} \eta(\delta\tau)^{s_\delta} \cdot P_{r, m, t}(\tau)
\end{align*}

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicModularGamma0EtaQuotientGamma} represent the product of
an
eta-quotient cofactor to an element of
\code{SymbolicEtaQuotientOrbitProductGamma} in order to make the
product a modular function.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie, it
computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

In order to create a common user interface, we also represent
$g_r(\gamma \tau)$ (\code{SymbolicEtaQuotientGamma}).

)endif

-------------------------------------------------------------------
)abbrev domain YM0EQG SymbolicModularGamma0EtaQuotientGamma
++ SymbolicModularGamma0EtaQuotientGamma
++ holds data to compute an eta-quotient
++ expansions of $F_{s, r, m, t}(\gamma \tau)$.
++ See \eqref{eq:F_s-r-m-t(gamma*tau)}.
SymbolicModularGamma0EtaQuotientGamma: SetCategory with
    etaQuotient: (P, LZ, P, LZ, P, N, SL2Z) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, gamma) represents the
      ++ expansion of $F_{s,r,m,t}(\gamma \tau)$. $r$ and $s$ are
      ++ indexed by the divisors of $mm$ and $nn$, repectively.
    etaQuotient: (SPEC, SPEC, P, N, SL2Z) -> %
      ++ etaQuotient(sspec, rspec, m, t, gamma) represents the
      ++ expansion of $F_{s,r,m,t}(\gamma \tau)$. $r$ and $s$ are
      ++ given by rspec and sspec, repectively.
    etaQuotient: (SPEC, SPEC, P, N) -> %
      ++ etaQuotient(sspec, rspec, m, t) returns
      ++ etaQuotient(sspec, rspec, m, t, matrix [[1,0],[0,1]]).
    etaQuotient: (SPEC, SL2Z) -> %
      ++ etaQuotient(rspec, gamma) represents the expansion of
      ++ $g_r(\gamma \tau)$. $r$ is given by rspec.
    etaQuotient: SPEC -> %
      ++ etaQuotient(rspec) returns
      ++ etaQuotient(rspec, matrix [[1,0],[0,1]]).
    coerce: SymbolicEtaQuotientGamma -> %
      ++ coerce(x) turns x into an element of this domain.
    definingSpecification: % -> SPEC
      ++ If x=generalizedEtaQuotient(sspec,rspec,...), then
      ++ definingSpecification(x) returns rspec.
    coSpecification: % -> SPEC
      ++ If x=etaQuotient(sspec,rspec,...), then
      ++ coSpecification(x) returns sspec.
    cofactor: % -> SymbolicEtaQuotientGamma
      ++ cofactor(x) returns the cofactor part to make $F_{s,r,m,t}$ a
      ++ modular function.
    orbitProduct: % -> SymbolicEtaQuotientOrbitProductGamma
      ++ orbitProduct(x) returns the orbit product part of $F_{s,r,m,t}$.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the lcm of the
      ++ minimalRootUnity(cofactor(x)) and
      ++ [minimalRootOfUnity(x.u) for u in modularGamma0Orbit(rspec,m,t)].
    one?: % -> Boolean
      ++ one?(x) returns true if the eta-quotient corresponding to x
      ++ represents 1.
    qExponent: % -> Q
      ++ qExponent(x) returns the order of the q-expansion in terms
      ++ of the original q.
      ++ Note that this exponent is only a lower bound for the
      ++ q-expansion. The coefficient corresponding to this q-power
      ++ may be zero.
    qetaGradeEstimate: % -> Q
      ++ qetaGradeEstimate(x) returns the expected pole order of the
      ++ x-expansion in terms of x=q^(1/w) where w is the widths of the
      ++ cussp of Gamma0(level(x)) corresponding to gamma(x).
      ++ Note that this is an upper bound of the pole order. The
      ++ coefficient corresponding to this grade may be zero.
      ++ Further note that due to estimation it does not necessarily
      ++ return an integer, but a rational number.
 == add
    Rep ==> Record(
              fcoetaqg: SymbolicEtaQuotientGamma,
              fyeqopg: SymbolicEtaQuotientOrbitProductGamma,
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, gamma: SL2Z): % ==
        sspec: SPEC := etaQuotientSpecification(nn, s)
        rspec: SPEC := etaQuotientSpecification(mm, r)
        etaQuotient(sspec, rspec, m, t, gamma)

    etaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N, gamma: SL2Z): % ==
        not modularGamma0?(sspec, rspec, m, t)$QEtaCofactorConditions =>
            error "modular conditions are not fulfilled"
        coetaqg: SymbolicEtaQuotientGamma := etaQuotient(sspec, 1, 0, gamma)
        yeqopg: SymbolicEtaQuotientOrbitProductGamma :=
            etaQuotient(rspec, m, t, gamma)
        minR1: P := minimalRootOfUnity coetaqg
        minR2: P := minimalRootOfUnity yeqopg
        per [coetaqg, yeqopg, asP lcm(minR1, minR2)]

    etaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N): % ==
        etaQuotient(sspec, rspec, m, t, matrix [[1,0],[0,1]])

    etaQuotient(rspec: SPEC, gamma: SL2Z): % ==
        sspec: SPEC := etaQuotientSpecification(level rspec, [])
        etaQuotient(sspec, rspec, 1, 0, gamma)

    etaQuotient(rspec: SPEC): % == etaQuotient(rspec, matrix [[1,0],[0,1]])

    coerce(x: SymbolicEtaQuotientGamma): % ==
        etaQuotient(definingSpecification x, gamma x)

    cofactor(x: %): SymbolicEtaQuotientGamma == xx.fcoetaqg
    orbitProduct(x: %): SymbolicEtaQuotientOrbitProductGamma == xx.fyeqopg
    definingSpecification(x: %): SPEC == definingSpecification orbitProduct x
    coSpecification(x: %): SPEC == definingSpecification cofactor x
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fcoetaqg)
        h := hashUpdate!(h, xx.fyeqopg)
        h

    ((x: %) = (y: %)): Boolean ==
        (xx.fcoetaqg = yy.fcoetaqg) and (xx.fyeqopg = yy.fyeqopg)

    one?(x: %): Boolean == one? cofactor x and one? orbitProduct x

    qExponent(x: %): Q == qExponent cofactor x + qExponent orbitProduct x

    qetaGradeEstimate(x: %): Q ==
        qe: Q := qExponent x
        cf: SymbolicEtaQuotientGamma := cofactor x
        g: SL2Z := gamma cf
        c: Cusp := cusp(g(1,1),g(2,1))
        - WIDTH0(level cf, c) * qe








)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicEtaQuotient $(p_{r,m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
elements from the domain \code{SymbolicEtaQuotient}
is a container of data from  \code{SymbolicEtaQuotientGamma} for each
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, corresponding to a cusp of $\Gamma_0(N)$ or other given cusps.

If \code{e = etaQuotient(nn, r)}, then
for each cusp in
\code{cusps(nn)$CongruenceSubgroupGamma0(nn)}
%$
we have \code{e.cusp} is the corresponding data from
\code{SymbolicEtaQuotientGamma}.

)endif
-------------------------------------------------------------------
)abbrev domain YEQ SymbolicEtaQuotient
++ SymbolicEtaQuotient holds data to compute an eta-quotient expansions
++ of g_r(\tau) at all cusps of $\Gamma_0(N)$ or at the given cusps.
++ See \eqref{g_r(tau)}
SymbolicEtaQuotient: SetCategory with
    etaQuotient: (P, LZ, List Cusp) -> %
      ++ etaQuotient(mm, r, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(mm, r) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(mm, r, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ is indexed by the divisors of $mm$.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: (SPEC, List Cusp) -> %
      ++ etaQuotient(rspec, cusps) represents the expansion of
      ++ g_r(\tau) at the given cusps a/c of Gamma0(mm)
      ++ in terms of x = \exp(2 \pi i \tau/w) where w=width(m, c) and
      ++ gamma=cuspToMatrix(m, a/c).
      ++ $r$ and $mm$ are given by rspec.
      ++ See \eqref{eq:g_r(tau)}.
    etaQuotient: SPEC -> %
      ++ etaQuotient(rspec) represents the expansion of g_r(\tau) at
      ++ all cusps a/c of Gamma0(mm) in terms of x = \exp(2 \pi i \tau/w)
      ++ where w=width(m, c) and gamma=cuspToMatrix(mm, a/c).
      ++ It is the same as
      ++ etaQuotient(rspec, cusps(mm)$CongruenceSubgroupGamma0).
      ++ $r$ and $mm$ are given by rspec.
      ++ See \eqref{eq:g_r(tau)}.
    definingSpecification: % -> SPEC
      ++ If  x=etaQuotient(spec,...),   then  definingSpecification(x)
      ++ returns spec.
    level: % -> P
      ++ If x=etaQuotient(mm, r) then level(x) returns the level of
      ++ the eta-quotient, i.e., level(x)=mm.
    exponents: % -> LZ
      ++ If x=etaQuotient(m, r) then exponents(x) returns the list of
      ++ exponents, i.e., exponents(x)=r.
    cusps: % -> List Cusp
      ++ If x=etaQuotient(mm, r), then
      ++ cusps(x)=cusp(mm)$CongruenceSubgroupGamma0.
    minimalRootOfUnity: % -> P
      ++ If x=etaQuotient(mm, r), then minimalRootOfUnity(x) returns the
      ++ smallest positive integer n such that the expansion of the
      ++ function g_r(\tau) at any cusp of Gamma_0(mm)
      ++ (neglecting the (c\tau+d)^* factor lives in Q[w][[x]] where w
      ++ is an n-th root of unity.
    elt: (%, Cusp) -> SymbolicEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    qetaGrades: % -> List Z
      ++ qetaGrades(x) returns the (negated) exponents of a series
      ++ expansion of x at all the cusps in the canonical variables,
      ++ i.e. in x=q^(1/w) where w=width(level x, denom cusp)$GAMMA0
      ++ Internally, the matrix of Ligozat is employed.
    one?: % -> Boolean
      ++ one?(x) returns true if the eta-quotient corresponding to x
      ++ represents 1.
 == add
    HT ==> XHashTable(Cusp, SymbolicEtaQuotientGamma)
    Rep ==> Record(
              fspec: SPEC,
              fcusps: List Cusp,
              feta: HT,      -- mapping delta to \eta_\delta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    xExponent(x: %, cusp: Cusp): Z ==
        qe: Q := qExponent(x.cusp.0)$SymbolicEtaQuotientLambdaGamma
        xe: Q := WIDTH0(level x, cusp) * qe
        not one? denom xe =>
            error "SymbolicEtaQuotient: fractional exponent"
        numer xe
    qetaGrades(x: %): List Z == [-xExponent(x, cusp) for cusp in cusps x]

    etaQuotient(rspec: SPEC, cusps: List Cusp): % ==
        h: HT := empty()
        minroot: Z := 1
        mm: P := level rspec
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(mm, cusp)$GAMMA0
            y: SymbolicEtaQuotientGamma := etaQuotient(rspec, gamma)
            h.cusp := y
            minroot := lcm(minroot, minimalRootOfUnity y)
        per [rspec, cusps, h, asP minroot]
    etaQuotient(rspec: SPEC): % == etaQuotient(rspec, cusps(level rspec)$GAMMA0)
    etaQuotient(mm: P, r: LZ, cusps: List Cusp): % ==
        etaQuotient(etaQuotientSpecification(mm, r),  cusps)
    etaQuotient(mm: P, r: LZ): % == etaQuotient(mm, r, cusps(mm)$GAMMA0)

    definingSpecification(x: %): SPEC == xx.fspec
    level(x: %): P == level definingSpecification x
    divisors(x: %): LP == divisors definingSpecification x
    exponents(x: %): LZ == pureExponents definingSpecification x
    cusps(x: %): List Cusp == xx.fcusps
    elt(x: %, cusp: Cusp): SymbolicEtaQuotientGamma == xx.feta.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fspec)
        h := hashUpdate!(h, xx.fcusps)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.fspec ~= yy.fspec => false
        xx.fcusps = yy.fcusps
    one?(x: %): Boolean == one? definingSpecification x















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma0EtaQuotient
  $(F_{s,r,m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicModularGamma0EtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $s \in R(N)$, $r \in R(M)$, $t \in
\Set{0,\ldots,m-1}$, elements from the domain
\code{SymbolicModularGamma0EtaQuotient} represent the collection of
element from \code{SymbolicModularGamma0EtaQuotienGamma} for all
$\gamma \in \SL2Z$ corresponding to a cusp of $\Gamma_0(N)$.

It corresponds to the data from \eqref{eq:F_s-r-m-t(gamma*tau)}, \ie,
it computes the building blocks for $F_{s, r, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM0EQ SymbolicModularGamma0EtaQuotient
++ SymbolicModularGamma0EtaQuotient holds data to compute an eta
++ quotient expansions of $F_{s, r, m, t}(\gamma \tau)$ at all cusps
++ of $Gamma_0(N)$. See \eqref{eq:F_s-r-m-t(gamma*tau)}.
SymbolicModularGamma0EtaQuotient: SetCategory with
    etaQuotient: (SPEC, SPEC, P, N, List Cusp) -> %
      ++ etaQuotient(sspec, rspec, m, t, cusps) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$ for all gamma corresponding to
      ++ the given cusps.
      ++ $r$ and $s$ are given by rspec and sspec, repectively.
    etaQuotient: (SPEC, SPEC, P, N) -> %
      ++ etaQuotient(sspec, rspec, m, t) represents the expansion of
      ++ $F_{r,s,m,t}(\gamma \tau)$ for all gamma corresponding to the
      ++ cusps of $\Gamma_0(nn)$.
      ++ $r$ and $s$ are given by rspec and sspec, repectively.
    etaQuotient: (SPEC, List Cusp) -> %
      ++ etaQuotient(rspec, cusps) represents the expansion of
      ++ $g_r(\gamma \tau)$ for all gamma corresponding to the given
      ++ cusps. $r$ is given by rspec.
    etaQuotient: SPEC -> %
      ++ etaQuotient(rspec) represents the expansion of $g_r(\gamma
      ++ \tau)$ for all gamma corresponding to the cusps of
      ++ $\Gamma_0(nn)$. $r$ is given by rspec.
    etaQuotient: (P, LZ, P, LZ, P, N, List Cusp) -> %
      ++ etaQuotient(nn, s, mm, r, m, t, cusps) represents the expansion
      ++ of $F_{s,r,m,t}(\gamma \tau)$ for all gamma corresponding to
      ++ the given cusps.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    etaQuotient: (P, LZ, P, LZ, P, N) -> %
      ++ etaQuotient(nn, s, mm, r, m, t) represents the expansion of
      ++ $F_{r,s,m,t}(\gamma \tau)$ for all gamma corresponding to the
      ++ cusps of $\Gamma_0(nn)$.
      ++ $r$ and $s$ are indexed by the divisors of $mm$ and $nn$, repectively.
    coerce: SymbolicEtaQuotient -> %
      ++ coerce(x) turns x into an element of this domain.
    definingSpecification: % -> SPEC
      ++ If x=generalizedEtaQuotient(sspec,rspec,...), then
      ++ definingSpecification(x) returns rspec.
    coSpecification: % -> SPEC
      ++ If x=etaQuotient(sspec,rspec,...), then
      ++ coSpecification(x) returns sspec.
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_0(nn).
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    cusps: % -> List Cusp
      ++ cusps(x) either returns the value that was given to
      ++ etaQuotient at creation time or
      ++ cusps(level(x))$CongruenceSubgroupGamma0 if the cusps where
      ++ not given.
    elt: (%, Cusp) -> SymbolicModularGamma0EtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in cusps x].
    one?: % -> Boolean
      ++ one?(x) returns true if the eta-quotient corresponding to x
      ++ represents 1.
    qetaGradesEstimate: % -> List Q
      ++ qetaGradesEstimate(x) returns an estimate for the grades at
      ++ all cusps without computing the explicit series expansion at
      ++ any cusp.
      ++ Note that due to estimation it does not necessarily
      ++ return an integer, but a rational number.
      ++ The result is [qetaGradeEstimate(x.c) for c in cusps x].

 == add
    YM0EQG ==> SymbolicModularGamma0EtaQuotientGamma
    HT ==> XHashTable(Cusp, YM0EQG)
    Rep ==> Record(
              fsspec: SPEC,
              frspec: SPEC,
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              fcusps: List Cusp, -- cusps of Gamma_0(N)
              fy: HT,     -- mapping gamma to YM0EQG
              fminroot: P -- minimal root of unity needed for the coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    etaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N, cusps: List Cusp): % ==
        h: HT := empty()
        minroot: Z := 1
        nn: P := level sspec
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(nn, cusp)$GAMMA0
            e: YM0EQG := etaQuotient(sspec, rspec, m, t, gamma)
            h.cusp := e
            minroot := lcm(minroot, minimalRootOfUnity e)
        per [sspec, rspec, m, t, cusps, h, asP minroot]

    etaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N): % ==
        etaQuotient(sspec, rspec, m, t, cusps(level sspec)$GAMMA0)

    etaQuotient(rspec: SPEC, cusps: List Cusp): % ==
        sspec: SPEC := etaQuotientSpecification(level rspec, [])
        etaQuotient(sspec, rspec, 1, 0, cusps)

    etaQuotient(rspec: SPEC): % == etaQuotient(rspec, cusps(level rspec)$GAMMA0)

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N, cusps: List Cusp): % ==
        sspec: SPEC := etaQuotientSpecification(nn, s)
        rspec: SPEC := etaQuotientSpecification(mm, r)
        etaQuotient(sspec, rspec, m, t, cusps)

    etaQuotient(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): % ==
        etaQuotient(nn, s, mm, r, m, t, cusps(nn)$GAMMA0)

    coerce(x: SymbolicEtaQuotient): % ==
        etaQuotient(definingSpecification x, cusps x)

    definingSpecification(x: %): SPEC == xx.frspec
    coSpecification(x: %): SPEC == xx.fsspec
    level(x: %): P == level coSpecification x
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    elt(x: %, cusp: Cusp): YM0EQG == xx.fy.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot
    cusps(x: %): List Cusp == xx.fcusps

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, coSpecification x)
        h := hashUpdate!(h, definingSpecification x)
        h := hashUpdate!(h, multiplier x)
        h := hashUpdate!(h, offset x)
        h := hashUpdate!(h, cusps x)
        h

    ((x: %) = (y: %)): Boolean ==
        coSpecification x ~= coSpecification y => false
        definingSpecification x ~= definingSpecification y => false
        multiplier x ~= multiplier y => false
        offset x ~= offset y => false
        cusps x = cusps y

    one?(x: %): Boolean ==
        one? definingSpecification x and one? coSpecification x

    qetaGradesEstimate(x: %): List Q ==
        [qetaGradeEstimate(x.c) for c in cusps x]









)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaGamma
  $\eta_{\delta,g,m,\lambda}^{[R]}(\gamma \tau)$}
\label{sec:SymbolicGeneralizedEtaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain domain
\code{SymbolicGeneralizedEtaGamma} represent data for the expansion of
$\eta_{\delta,g}^{[R]} \left( \left(\begin{smallmatrix}
      1 & \lambda\\
      0 & m
  \end{smallmatrix}\right)
  \gamma \tau \right)$
as given implicitly in equation
\eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.


)endif
-------------------------------------------------------------------
)abbrev domain YGEG SymbolicGeneralizedEtaGamma
++ SymbolicGeneralizedEtaGamma holds data to compute a generalized
++ eta-function expansion of
++ \eta_{\delta.g,m,\lambda}^{[R]}(\gamma\tau). See
++ \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.
SymbolicGeneralizedEtaGamma: SetCategory with
    generalizedEta: (P, P, P, N, SL2Z) -> %
      ++ generalizedEta(delta, g, m, lambda, gamma) represents the
      ++ expansion of $\eta_{\delta.g,m,\lambda}^{[R]}(\gamma\tau)$.
      ++ See \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.
    generalizedEta: (P, P, SL2Z) -> %
      ++ generalizedEta(delta, g, gamma) returns
      ++ generalizedEta(delta,g,1,0,gamma).
    level: % -> P
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ level(x) returns delta.
    general: % -> P
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ general(x) returns g.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ gamma(x) returns gamma.
    gamma1: % -> SL2Z
      ++ gamma1(x) returns the SL2Z part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    gamma2: % -> MZ
      ++ gamma2(x) returns the triangular part of
      ++ splitMatrix(gamma,delta,m,lambda)).
    kappaSchoeneberg: % -> Q
      ++ kappaSchoeneberg(x) returns the respective exponent that
      ++ corresponds to the transformation of the generalized
      ++ eta-function.
    udelta: % -> Q            -- gcd(delta,c)^2/delta
      ++ See \eqref{eq:uv_delta-m-lamnbda}.
    vdelta: % -> Q            -- b2/d2
      ++ See \eqref{eq:uv_delta-m-lamnbda}.
    unityExponent: % -> Q
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ unityExponent(x) returns the argument of the first product of
      ++ \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}.
    qExponent: % -> Q
      ++ If x = generalizedEta(delta, g, m, lambda, gamma), then
      ++ qExponent(x) returns the argument of the third product of
      ++ \eqref{eq:eta_delta-g-m-lambda^[R](gamma*tau)}, i.e.,
      ++ $\frac{u_{\delta,m,\lambda}}{2} P_2\left(\frac{a'g}{\delta}\right)$.
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              fdelta: P,     -- delta
              fgeneral: P,   -- g
              fmultiplier: P,-- m
              flambda: N,    -- lambda
              fgamma: SL2Z,  -- gamma
              fgamma1: SL2Z, -- $gamma_{\delta,m,\lambda}$
              fgamma2: MZ,   -- triangular matrix
              fkappa: Q,     -- kappaSchoeneberg
              fudelta: Q,    -- u_{\delta,m,\lambda} {eq:uv_delta-m-lambda}
              fvdelta: Q,    -- v_{\delta,m,\lambda} {eq:uv_delta-m-lambda}
                             -- =b2.d2, 0<=b2<d2, 0<d2
              funityExponent: Q,-- kappa_{g,0,d,gamma_d}
                             --   + vdelta/2*P_2(adelta*g/delta)
              fqExponent: Q  -- order of expansion in q
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEta(delta: P, g: P, m: P, lambda: N, gamma: SL2Z): % ==
        gamma(2,1) < 0 =>
            error "generalizedEta: expect gamma(2,1) to be positive"
        rec: Rec := splitMatrix(gamma, delta, m, lambda)$QETAAUX
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        kappa: Q := kappaSchoeneberg(delta, g, 0, gamma1)$QETAAUX
        udelta: Q := gamma2(1,1) / gamma2(2,2)
        vdelta: Q := gamma2(1,2) / gamma2(2,2)
        gprime: Z := gamma1(1,1)*g -- $a' g$
        hprime: Z := gamma1(1,2)*g -- $b' g$
        p2: Q := (1/2)*fractionalBernoulli2(gprime/delta)
        uexponent: Q := fractionalPart(kappa + vdelta * p2)
        qexponent: Q := udelta * p2
        per [delta, g, m, lambda, gamma, gamma1, gamma2, kappa,
             udelta, vdelta, uexponent, qexponent]

    generalizedEta(delta: P, g: P, gamma: SL2Z): % ==
        generalizedEta(delta, g, 1, 0, gamma)

    level(x: %): P == xx.fdelta
    general(x: %): P == xx.fgeneral
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    gamma1(x: %): SL2Z == xx.fgamma1
    gamma2(x: %): MZ == xx.fgamma2
    kappaSchoeneberg(x: %): Q == xx.fkappa
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    unityExponent(x: %): Q == xx.funityExponent
    qExponent(x: %): Q == xx.fqExponent

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fdelta)
        h := hashUpdate!(h, xx.fgeneral)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.fdelta ~= yy.fdelta => false
        xx.fgeneral ~= yy.fgeneral => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


















)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicProperGeneralizedEtaQuotientLambdaGamma
  $g_{\tilde{r},m,\lambda}(\gamma \tau)$}
\label{sec:SymbolicProperGeneralizedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$g_{\bar{r},m,\lambda}(\tau) = g_{r,m,\lambda}(\tau) \,
g_{\tilde{r},m,\lambda}(\tau)$ be a generalized eta-quotient of the
form \eqref{eq:g_rbar-m-lambda(tau)},
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$,
%
$\bar{r} = (r, \tilde{r})$ as defined in Definition~\ref{def:rbar}.
%
Then elements from the domain\\
\code{SymbolicProperGeneralizedEtaQuotientLambdaGamma} represent
$g_{\tilde{r},m,\lambda}(\gamma\tau)$ through the tuple
\begin{gather*}
  \left(
  M
  ,
  \tilde{r}
  ,
  m
  ,
  \lambda
  ,
  \gamma
  ,
  \underbrace{\gensum
  r_{\delta,g}
  \left(
    \kappa_{g,0,\delta,\gamma_\delta}^{[S]}
    +
    \frac{v_\delta}{2} P_2\left(\frac{a_\delta g}{\delta}\right)
  \right)
  }_{\texttt{unityExponent}}
  ,
  \underbrace{
  \gensum[M]
  \frac{r_{\delta,g} u_\delta}{2} P_2\left(\frac{a_\delta g}{\delta}\right)
  }_{\texttt{qExponent}}
  ,
  \tilde{y}
\right)
\end{gather*}
according to \eqref{eq:g_rtilde-m-lambda(gamma*tau)} where
$\tilde{y}=(y_{\delta,g})_{\substack{\divides{\delta}{N}\\0<g<\frac{\delta}{2}}}$
and $y_{\delta,g} = \text{\code{generalizedEta(delta,g,gamma)}}$ is an
element of \code{SymbolicGeneralizedEtaGamma}.



)endif

-------------------------------------------------------------------
)abbrev domain YPGEQLG SymbolicProperGeneralizedEtaQuotientLambdaGamma
++ SymbolicProperGeneralizedEtaQuotientLambdaGamma holds data to
++ compute a proper generalized eta-quotient expansion of
++ $g_{\tilde{r},m,\lambda}(\gamma\tau)$. See
++ \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
SymbolicProperGeneralizedEtaQuotientLambdaGamma: SetCategory with
    properGeneralizedEtaQuotient: (P, LLZ, P, N, SL2Z) -> %
      ++ properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma)
      ++ represents the
      ++ expansion of $g_{\tilde{r},m,\lambda}(\gamma\tau)$. see
      ++ \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
    properGeneralizedEtaQuotient: (P, LLZ, SL2Z) -> %
      ++ properGeneralizedEtaQuotient(nn,rtilde,gamma) returns
      ++ properGeneralizedEtaQuotient(nn,rtilde,1,0,gamma).
    level: % -> P
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ level(x) returns nn.
    exponents: % -> LLZ
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ exponents(x) returns rtilde.
    multiplier: % -> P
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ multiplier(x) returns m.
    lambda: % -> N
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ gamma(x) returns gamma.
    unityExponent: % -> Q
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ unityExponent(x) returns the argument of the first product of
      ++ \eqref{eq:g_rtilde(gamma*tau)}.
    qExponent: % -> Q
      ++ If x=properGeneralizedEtaQuotient(nn,rtilde,m,lambda,gamma), then
      ++ qExponent(x) returns the argument of the third product of
      ++ \eqref{eq:g_rtilde(gamma*tau)}, i.e.,
      ++ $\gensum
      ++   \frac{r_{\delta,g} u_\delta}{2}
      ++   P_2\left(\frac{a_\delta g}{\delta}\right)$.
    elt: (%, P, P) -> SymbolicGeneralizedEtaGamma
      ++ elt(x, delta, g) returns the data corresponding to the
      ++ respective (delta, g) pair.
 == add
    YGEG ==> SymbolicGeneralizedEtaGamma
    HT ==> XHashTable(Z, YGEG)
            -- mapping (delta, g) to $\eta_{\delta, g}^{[R]}$ where
            -- (delta, g) is encoded by n=level*delta+g
    Rep ==> Record(
              flevel: P,      -- level \Gamma_1(lev)
              fexponents: LLZ,-- rtilde
              fmultiplier: P, -- m
              flambda: N,     -- lambda
              fgamma: SL2Z,   -- gamma
              feta: HT,       -- mapping (delta,g) to $\eta_{\delta,g}^{[R]}$
              funityExponent: Q, -- sum of unityExponent of elements in fdgeta
              fqExponent: Q   -- order of expansion in q
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    -- index for hashtable HT
    idx(nn: P, delta: P, g: Z): Z == nn*delta + g

    properGeneralizedEtaQuotient(
      nn: P, rtilde: LLZ, m: P, lambda: N, gamma: SL2Z): % ==
        y: HT := empty()
        uexponent: Q := 0
        qexponent: Q := 0
        for l in rtilde repeat
            delta := asP l.1; g := asP l.2; rdg := l.3;
            k: Z := idx(nn, delta, g)
            etadg := generalizedEta(delta, g, m, lambda, gamma)$YGEG
            y.k := etadg
            uexponent := uexponent + rdg * unityExponent(etadg)
            qexponent := qexponent + rdg * qExponent(etadg)
        uexponent := fractionalPart(uexponent)$QETAAUX
        per [nn, rtilde, m, lambda, gamma, y, uexponent, qexponent]

    properGeneralizedEtaQuotient(nn: P, rtilde: LLZ, gamma: SL2Z): % ==
        properGeneralizedEtaQuotient(nn, rtilde, 1, 0, gamma)

    level(x: %): P == xx.flevel
    elt(x: %, delta: P, g: P): YGEG == xx.feta.idx(level x, delta, g)
    exponents(x: %): LLZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    unityExponent(x: %): Q == xx.funityExponent
    qExponent(x: %): Q == xx.fqExponent
    coerce(x: %): OutputForm == xx::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma


















)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaQuotientLambdaGamma
  $g_{\bar{r},m,\lambda}(\gamma \tau)$}
\label{sec:SymbolicGeneralizedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$g_{\bar{r},m,\lambda}(\tau) = g_{r,m,\lambda}(\tau) \,
g_{\tilde{r},m,\lambda}(\tau)$ be a generalized eta-quotient of the
form \eqref{eq:g_rbar-m-lambda(tau)},
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$,
%
$\bar{r} = (r, \tilde{r})$ as defined in Definition~\ref{def:rbar}.
%
Then elements from the domain\\
\code{SymbolicGeneralizedEtaQuotientLambdaGamma} represent the tuple
$(y, \tilde{y})$ where $y$ is an element of
\code{SymbolicEtaQuotientLambdaGamma} and holds data for
$g_{r,m,\lambda}(\gamma\tau)$ and $\tilde{y}$ is an element of
\code{SymbolicProperGeneralizedEtaQuotientLambdaGamma} and holds data
for $g_{\tilde{r},m,\lambda}(\gamma\tau)$.
See \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.


)endif

-------------------------------------------------------------------
)abbrev domain YGEQLG SymbolicGeneralizedEtaQuotientLambdaGamma
++ SymbolicGeneralizedEtaQuotientLambdaGamma holds data to compute a
++ generalized eta-quotient expansion of
++ $g_{\bar{r},m,\lambda}(\gamma\tau)$. See
++ \eqref{eq:g_rtilde-m-lambda(gamma*tau)}.
++ \eqref{eq:g_rbar(gamma*tau)}.
SymbolicGeneralizedEtaQuotientLambdaGamma: Exports == Implementation where
  YEQLG ==> SymbolicEtaQuotientLambdaGamma
  YPGEQLG ==> SymbolicProperGeneralizedEtaQuotientLambdaGamma
  Exports ==> SetCategory with
    generalizedEtaQuotient: (SPEC, P, N, SL2Z) -> %
      ++ generalizedEtaQuotient(rspec, m, lambda, gamma) represents
      ++ the expansion of $g_{\bar{r},m,\lambda}(\gamma\tau)$. see
      ++ \eqref{eq:g_rbar-m-lambda(gamma*tau)} where rbar is given by
      ++ rspec.
    generalizedEtaQuotient: (SPEC, SL2Z) -> %
      ++ generalizedEtaQuotient(rspec, gamma) returns
      ++ generalizedEtaQuotient(rspec, 1, 0, gamma).
    generalizedEtaQuotient: (P, LLZ, P, N, SL2Z) -> %
      ++ generalizedEtaQuotient(mm, rbar, m, lambda, gamma) represents
      ++ the expansion of $g_{\bar{r},m,\lambda}(\gamma\tau)$. see
      ++ \eqref{eq:g_rbar-m-lambda(gamma*tau)}.
    generalizedEtaQuotient: (P, LLZ, SL2Z) -> %
      ++ generalizedEtaQuotient(mm, rbar, gamma) returns
      ++ generalizedEtaQuotient(mm, rbar, 1, 0, gamma).
    pureEtaQuotient: % -> YEQLG
      ++ pureEtaQuotient(x) returns the part of x that corresponds to
      ++ the pure eta-quotient part of x.
    properGeneralizedEtaQuotient: % -> YPGEQLG
      ++ properGeneralizedEtaQuotient(x) returns the part of x that
      ++ corresponds to the proper generalized eta-quotient part of x.
    definingSpecification: % -> SPEC
      ++ If x=generalizedEtaQuotient(spec,...), then
      ++ definingSpecification(x) returns spec.
    level: % -> P
      ++ If x=generalizedEtaQuotient(rspec,m,lambda,gamma), then
      ++ level(x) returns level(rspec).
    multiplier: % -> P
      ++ If x=generalizedEtaQuotient(rspec,m,lambda,gamma), then
      ++ multiplier(x) returns m.
    lambda: % -> N
      ++ If x=generalizedEtaQuotient(rspec,m,lambda,gamma), then
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ If x=generalizedEtaQuotient(rspec,m,lambda,gamma), then
      ++ gamma(x) returns gamma.
    unityExponent: % -> Q
      ++ If x=generalizedEtaQuotient(rspec,m,lambda,gamma), then
      ++ unityExponent(x) returns the sum of
      ++ unityExponent(pureEtaQuotient(x)) and
      ++ unityExponent(properGeneralizedEtaQuotient(x)).
    qExponent: % -> Q
      ++ If x=generalizedEtaQuotient(rspec,m,lambda,gamma), then
      ++ qExponent(x) returns the sum of qExponent(pureEtaQuotient(x))
      ++ and qExponenbt(properGeneralizedEtaQuotient(x)).
  Implementation ==> add
    Rep ==> Record(
              fspec: SPEC,
              fmultiplier: P, -- m
              flambda: N,     -- lambda
              fgamma: SL2Z,   -- gamma
              fpure: YEQLG,
              fpropergeneralized: YPGEQLG
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEtaQuotient(rspec: SPEC, m: P, lambda: N, gamma: SL2Z): % ==
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        r: LZ := pureExponents rspec
        rtilde: LLZ := properGeneralizedPart rspec
        mm: P := level rspec
        yeqlg := etaQuotient(mm, r, m, lambda, gamma)$YEQLG
        ypgeqlg := properGeneralizedEtaQuotient(
                     mm, rtilde, m, lambda, gamma)$YPGEQLG
        per [rspec, m, lambda, gamma, yeqlg, ypgeqlg]

    generalizedEtaQuotient(rspec: SPEC, gamma: SL2Z): % ==
        generalizedEtaQuotient(rspec, 1, 0, gamma)

    generalizedEtaQuotient(mm: P, rbar: LLZ, m: P, lambda: N, gamma: SL2Z): % ==
        rspec: SPEC := generalizedEtaQuotientSpecification(mm, rbar)
        generalizedEtaQuotient(rspec, m, lambda, gamma)

    generalizedEtaQuotient(nn: P, rbar: LLZ, gamma: SL2Z): % ==
        generalizedEtaQuotient(nn, rbar, 1, 0, gamma)

    pureEtaQuotient(x: %): YEQLG == xx.fpure
    properGeneralizedEtaQuotient(x: %): YPGEQLG == xx.fpropergeneralized
    definingSpecification(x: %): SPEC == xx.fspec
    level(x: %): P == level definingSpecification x
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    unityExponent(x: %): Q ==
        ue: Q := unityExponent pureEtaQuotient x
        ue + unityExponent properGeneralizedEtaQuotient x
    qExponent(x: %): Q ==
        qExponent pureEtaQuotient x + qExponent properGeneralizedEtaQuotient x
    coerce(x: %): OutputForm == xx::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fspec)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h
    ((x: %) = (y: %)): Boolean ==
        xx.fspec ~= yy.fspec => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma










)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaQuotientGamma
  $p_{\bar{r},m,t}(\gamma\tau)$}
\label{sec:SymbolicGeneralizedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This domain represents data for  $p_{\bar{r},m,t}(\gamma\tau)$

\begin{align*}
p_{\bar{r},m,t}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sigmainfty{\bar{r}}\Bigr)}
    g_{\bar{r},m,\lambda}(\gamma\tau)
\end{align*}

For $m, M\in\setN$, $r \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, elements from the domain
\code{SymbolicGeneralizedEtaQuotientGamma} represent the collection
\code{SymbolicGeneralizedEtaQuotientLambdaGamma} for each $\lambda \in
\Set{0,\ldots,m-1}$ and thus corresponds to the data from
\eqref{eq:p_rbar-m-t(gamma*tau)}, \ie, it computes the building
blocks for $p_{\bar{r},m,t}(\gamma\tau)$.

)endif
-------------------------------------------------------------------
)abbrev domain YGEQG SymbolicGeneralizedEtaQuotientGamma
++ SymbolicGeneralizedEtaQuotientGamma holds data to compute an eta
++ quotient expansion of $p_{r,m,t}(\gamma \tau)$. See
++ \eqref{eq:p_rbar-m-t(gamma*tau)}.
SymbolicGeneralizedEtaQuotientGamma: SetCategory with
    generalizedEtaQuotient: (SPEC, P, Z, SL2Z) -> %
      ++ etaQuotient(rspec, m, t, gamma) represents the expansion of
      ++ $p_{\bar{r},m,t}(\gamma \tau)$ where rbar is given by rspec
      ++ and specifies the exponents of the eta-quotient.
    generalizedEtaQuotient: (SPEC, SL2Z) -> %
      ++ generalizedEtaQuotient(rspec, gamma) returns
      ++ generalizedEtaQuotient(rspec, 1, 0, gamma).
    generalizedEtaQuotient: (P, LLZ, P, Z, SL2Z) -> %
      ++ etaQuotient(mm, rbar, m, t, gamma) represents the expansion
      ++ of $p_{\bar{r},m,t}(\gamma \tau)$ where rbar specifies the
      ++ exponents of the eta-quotient.
    generalizedEtaQuotient: (P, LLZ, SL2Z) -> %
      ++ generalizedEtaQuotient(mm, rbar, gamma) returns
      ++ generalizedEtaQuotient(mm, rbar, 1, 0, gamma).
    level: % -> P
      ++ If x=generalizedEtaQuotient(rspec,m,t,gamma), then level(x)
      ++ returns level(rspec).
    definingSpecification: % -> SPEC
      ++ If x=generalizedEtaQuotient(rspec,m,t,gamma), then
      ++ definingSpecification(x) returns rspec.
    multiplier: % -> P
      ++ If x=generalizedEtaQuotient(rspec,m,t,gamma), then
      ++ multiplier(x) returns m.
    offset: % -> Z
      ++ If x=generalizedtaQuotient(rspec,m,t,gamma), then offset(x)
      ++ returns t.
    gamma: % -> SL2Z
      ++ If x=generalizedEtaQuotient(rspec,m,t,g), then gamma(x)
      ++ returns g. gamma(x) returns the transformation corresponding
      ++ to x.
    unityExponent: % -> Q
      ++ If x=generalizedEtaQuotient(rspec,m,t,g), then
      ++ unityExponent(x) returns -(24*t + \hat{\bar{r}})/(24*m) where
      ++ $\bar{r}$ is given through rspec.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function
      ++ $p_{\bar{r},m,t}(\gamma\tau)$ corresponding to
      ++ x=generalizedEtaQuotient(rspec, m, t, gamma) (neglecting the
      ++ (c \tau+d)^* factor) lives in Q[w][[z]] where w is a n-th
      ++ root of unity and z a fractional q power and rbar is given
      ++ through rspec.
    elt: (%, N) -> SymbolicGeneralizedEtaQuotientLambdaGamma
      ++ x.lambda returns the data corresponding to the respective
      ++ lambda.
    one?: % -> Boolean
      ++ one?(x) returns true if the generalized eta-quotient
      ++ corresponding to x represents 1. Note that if this function
      ++ returns false, due to redundancy it may still be the case
      ++ that the actual expansion of x into a q-series is 1.
    qExponent: % -> Q
      ++ qExponent(x) returns the order of the q-expansion in terms
      ++ of the original q.
      ++ Note that this exponent is only a lower bound for the
      ++ q-expansion. The coefficient corresponding to this q-power
      ++ may be zero.
 == add
    YEQLG ==> SymbolicEtaQuotientLambdaGamma
    YPGEQLG ==> SymbolicProperGeneralizedEtaQuotientLambdaGamma
    YGEQLG ==> SymbolicGeneralizedEtaQuotientLambdaGamma
    A ==> IndexedOneDimensionalArray(YGEQLG, 0)
    Rep ==> Record(
              feta: A,           -- mapping lambda to \eta_{\delta,m,lambda}
              foffset: Z,        -- the subsequence offset
              funityExponent: Q, -- (24 t + \hat{\bar{r}})/(24 m)
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep

    -- local
    minRootOfUnityAlphaSchoenebergProperGeneralized(_
      y: SymbolicProperGeneralizedEtaQuotientLambdaGamma): P ==
        mr: Z := 1
        for l in exponents y repeat
            delta := asP l.1; g := asP l.2;
            ygeg := y(delta, g)
            g1 := gamma1 ygeg
            h: Z := g1(1,2)*g
            if zero?((g1(1,1)*g) rem delta) and not zero?(h rem delta) then
                hd: Q := h/delta
                mr := lcm(mr, denom hd)
                mr := lcm(mr, denom((1/2)*fractionalBernoulli1(hd)$QETAAUX))
        asP mr

    -- local
    -- returns the minimal root of unity needed to express a
    -- part of a summand of \eqref{eq:p_rbar-m-t(gamma*tau)} for the
    -- lambda stored in y.
    -- Compare with puiseuxExpansion in qetaquot.spad.
    minRootOfUnity(y: YGEQLG, ue: Q): P ==
        ypure: SymbolicEtaQuotientLambdaGamma := pureEtaQuotient y
        -- minimal root of unity needed for the expansion is
        -- determined from expressing the squareroot of the rational
        -- prefactor in roots of unity.
        rat := rationalPrefactor ypure
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QETAAUX
        -- second factor of the summand of \eqref{eq:p_rbar-m-t(gamma*tau)}
        minroot: Z := minimalSquareRootOfUnity(rr.rootOf)$QETAAUX

        -- first factor of summand of \eqref{eq:p_rbar-m-t(gamma*tau)}
        uexp: Q := lambda(y)*ue + unityExponent y
        minroot := lcm(minroot, denom uexp)

        -- third factor of summand of \eqref{eq:p_rbar-m-t(gamma*tau)}
        -- See function alphaSchoenebergContribution in qetaquot.spad.
        ypg: SymbolicProperGeneralizedEtaQuotientLambdaGamma :=
            properGeneralizedEtaQuotient y
        mr: P := minRootOfUnityAlphaSchoenebergProperGeneralized ypg
        minroot := lcm(minroot, mr)

        -- fourth factor of summand of \eqref{eq:p_rbar-m-t(gamma*tau)}
        -- See qPochhammerPure in qetaquot.spad.
        divs: LP := divisors ypure
        for delta in divs repeat
            minroot := lcm(minroot, denom vdelta(ypure.delta))

        -- fifth factor of summand of \eqref{eq:p_rbar-m-t(gamma*tau)}
        -- See qPochhammerProperGeneralized in qetaquot.spad.
        for l in exponents ypg repeat
            delta := asP l.1; g := asP l.2;
            ygeg := ypg(delta, g)
            g1 := gamma1 ygeg
            beta := denom(g1(1,1)*g/delta)
            minroot := lcm(minroot, denom(vdelta(ygeg) * (1/beta)))
            minroot := lcm(minroot, denom(g1(1,2)*g/delta))

        asP minroot

    generalizedEtaQuotient(rspec: SPEC, m: P, t: Z, gamma: SL2Z): % ==
        y: YGEQLG := generalizedEtaQuotient(rspec, m, 0, gamma)
        eta: A := new(m, y) -- fill with dummy values
        rbarhat: Q := sigmaInfinity rspec
        uexponent: Q := fractionalPart(-(24*t::Q + rbarhat)*(1/(24*m)))$QETAAUX
        minroot: Z := minRootOfUnity(y, uexponent)
        for lambda in 0..m-1 repeat -- can start with 1.
            y :=  generalizedEtaQuotient(rspec, m, lambda, gamma)
            eta.lambda := y
            minroot := lcm(minroot, minRootOfUnity(y, uexponent))
        per [eta, t, uexponent, asP minroot]

    generalizedEtaQuotient(mm: P, rbar: LLZ, m: P, t: Z, gamma: SL2Z): % ==
        rspec: SPEC := generalizedEtaQuotientSpecification(mm, rbar)
        generalizedEtaQuotient(rspec, m, t, gamma)

    generalizedEtaQuotient(rspec: SPEC, gamma: SL2Z): % ==
        generalizedEtaQuotient(rspec, 1, 0, gamma)

    generalizedEtaQuotient(mm: P, rbar: LLZ, gamma: SL2Z): % ==
        generalizedEtaQuotient(mm, rbar, 1, 0, gamma)

    elt(x: %, lambda: N): YGEQLG == rep(x).feta.lambda
    level(x: %): P == level(x.0)
    definingSpecification(x: %): SPEC == definingSpecification(x.0)
    multiplier(x: %): P == multiplier(x.0)
    offset(x: %): Z == rep(x).foffset
    gamma(x: %): SL2Z == gamma(x.0)
    unityExponent(x: %): Q == rep(x).funityExponent
    minimalRootOfUnity(x: %): P == rep(x).fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, x.0)
        hashUpdate!(h, offset x)
    ((x: %) = (y: %)): Boolean == x.0 = y.0 and offset x = offset y
    one?(x: %): Boolean == one? definingSpecification x
    qExponent(x: %): Q ==
        m: P := multiplier x
        e: Q := qExponent(x.0)
        lambda: N := 1
        while lambda < m repeat
            e := min(e, qExponent(x.lambda))
            lambda := lambda + 1
        return e

















)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma1GeneralizedEtaQuotientGamma
  $F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$}
\label{sec:SymbolicModularGamma1GeneralizedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Elements from the domain
\code{SymbolicModularGamma1GeneralizedEtaQuotientGamma} represent the
product of an eta-quotient cofactor to an element of
\code{SymbolicGeneralizedEtaQuotienttGamma} in order to make the
product a modular function for $\Gamma_1(N)$.

It corresponds to the data from \eqref{eq:F_sbar-rbar-m-t(gamma*tau)},
\ie, it computes the building blocks for
$F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM1GEQG SymbolicModularGamma1GeneralizedEtaQuotientGamma
++ SymbolicModularGamma1GeneralizedEtaQuotientGamma
++ holds data to compute an eta-quotient
++ expansions of $F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$.
++ See \eqref{eq:F_sbar-rbar-m-t(gamma*tau)}.
SymbolicModularGamma1GeneralizedEtaQuotientGamma: SetCategory with
    generalizedEtaQuotient: (P, LLZ, P, LLZ, P, N, SL2Z) -> %
      ++ generalizedEtaQuotient(nn, sbar, mm, rbar, m, t, gamma)
      ++ represents the expansion of
      ++ $F_{\bar{s},\bar{r},m,t}(\gamma\tau)$.
    generalizedEtaQuotient: (SPEC, SPEC, P, N, SL2Z) -> %
      ++ generalizedEtaQuotient(sspec, rspec, m, t, gamma) represents
      ++ the expansion of $F_{\bar{s},\bar{r},m,t}(\gamma\tau)$ where
      ++ \bar{s} and \bar{r} are given through sspec and rspec.
    generalizedEtaQuotient: (SPEC, SL2Z) -> %
      ++ generalizedEtaQuotient(rspec, gamma) represents
      ++ the expansion of $g_{\bar{r}}(\gamma\tau)$ where
      ++ \bar{r} is given through rspec.
    generalizedEtaQuotient: SPEC -> %
      ++ generalizedEtaQuotient(rspec) represents the expansion of
      ++ $g_{\bar{r}}(\tau)$ where \bar{r} is given through rspec. It
      ++ is the same as
      ++ generalizedEtaQuotient(rspec,matrix[[1,0],[0,1]]).
    coerce: SymbolicGeneralizedEtaQuotientGamma -> %
      ++ coerce(x) turns x into an element of this domain.
    cofactor: % -> SymbolicGeneralizedEtaQuotientGamma
      ++ cofactor(x) returns the cofactor part to make
      ++ $F_{\bar{s},\bar{r},m,t}$ a modular function for
      ++ $\Gamma_1(N)$.
    basefactor: % -> SymbolicGeneralizedEtaQuotientGamma
      ++ basefactor(x) returns the part of $F_{\bar{s},\bar{r},m,t}$
      ++ that is connected to the generating series of a(m*n+t).
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns the lcm of
      ++ minimalRootOfUnity(cofactor(x)) and
      ++ minimalRootOfUnity(basefactor(x)).
    one?: % -> Boolean
      ++ one?(x) returns true if the generalized eta-quotient
      ++ corresponding to x represents 1. This is the case if
      ++ one?(basefactor(x)) and one?(cofactor(x)).
    qExponent: % -> Q
      ++ qExponent(x) returns the order of the q-expansion in terms
      ++ of the original q.
      ++ Note that this exponent is only a lower bound for the
      ++ q-expansion. The coefficient corresponding to this q-power
      ++ may be zero.
    qetaGradeEstimate: % -> Q
      ++ qetaGradeEstimate(x) returns the expected pole order of the
      ++ x-expansion in terms of x=q^(1/w) where w is the widths of the
      ++ cussp of Gamma0(level(x)) corresponding to gamma(x).
      ++ Note that this is an upper bound of the pole order. The
      ++ coefficient corresponding to this grade may be zero.
      ++ Further note that due to estimation it does not necessarily
      ++ return an integer, but a rational number.
 == add
    YGEQG ==> SymbolicGeneralizedEtaQuotientGamma
    Rep ==> Record(
              fcofactor: YGEQG,   -- g_sbar
              fbasefactor: YGEQG, -- p_rbar-m-t
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEtaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N,
                           gamma: SL2Z): % ==
        not modularGamma1?(sspec, rspec, m, t)$QEtaCofactorConditions =>
            error "modular conditions are not fulfilled"
        cofactor: YGEQG := generalizedEtaQuotient(sspec, 1, 0, gamma)
        basefactor: YGEQG := generalizedEtaQuotient(rspec, m, t, gamma)
        minR1: P := minimalRootOfUnity cofactor
        minR2: P := minimalRootOfUnity basefactor
        per [cofactor, basefactor, asP lcm(minR1, minR2)]

    generalizedEtaQuotient(rspec: SPEC, gamma: SL2Z): % ==
        sspec: SPEC := generalizedEtaQuotientSpecification(level rspec, [])
        generalizedEtaQuotient(sspec, rspec, 1, 0, gamma)

    generalizedEtaQuotient(rspec: SPEC): % ==
        generalizedEtaQuotient(rspec, matrix [[1,0],[0,1]])

    generalizedEtaQuotient(nn: P, sbar: LLZ, mm: P, rbar: LLZ, m: P, t: N,
                           gamma: SL2Z): % ==
        sspec: SPEC := generalizedEtaQuotientSpecification(nn, sbar)
        rspec: SPEC := generalizedEtaQuotientSpecification(mm, rbar)
        generalizedEtaQuotient(sspec, rspec, m, t, gamma)

    coerce(x: SymbolicGeneralizedEtaQuotientGamma): % ==
        generalizedEtaQuotient(definingSpecification x, gamma x)

    cofactor(x: %): SymbolicGeneralizedEtaQuotientGamma == xx.fcofactor
    basefactor(x: %): SymbolicGeneralizedEtaQuotientGamma == xx.fbasefactor
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == xx::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fcofactor)
        h := hashUpdate!(h, xx.fbasefactor)
        h

    ((x: %) = (y: %)): Boolean ==
        (xx.fcofactor = yy.fcofactor) and (xx.fbasefactor = yy.fbasefactor)

    one?(x: %): Boolean == one? basefactor x and one? cofactor x

    qExponent(x: %): Q == qExponent cofactor x + qExponent basefactor x

    qetaGradeEstimate(x: %): Q ==
        qe: Q := qExponent x
        cf: SymbolicGeneralizedEtaQuotientGamma := cofactor x
        g: SL2Z := gamma cf
        c: Cusp := cusp(g(1,1),g(2,1))
        - WIDTH1(level cf, c) * qe











)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicGeneralizedEtaQuotient
  $(p_{\bar{r},m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicGeneralizedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $\bar{r}\in \bar{R}(N)$, elements from the domain
\code{SymbolicGeneralizedEtaQuotient} is a container of data from
\code{SymbolicGeneralizedEtaQuotientGamma} for each
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\SL2Z$, corresponding to a cusp of $\Gamma_1(N)$ or for other given
cusps.

If \code{e = generalizedEtaQuotient(nn, rbar)}, then
for each cusp in
\code{cusps(nn)$CongruenceSubgroupGamma1(nn)}
%$
we have \code{e.cusp} is the corresponding data from
\code{SymbolicGeneralizedEtaQuotientGamma}.

)endif
-------------------------------------------------------------------
)abbrev domain YGEQ SymbolicGeneralizedEtaQuotient
++ SymbolicGeneralizedEtaQuotient holds data to compute a
++ generalized eta-quotient expansions of g_rr(\tau) at all cusps of
++ $\Gamma_1(N)$ or at the given cusps. See \eqref{g_rbar(tau)}
SymbolicGeneralizedEtaQuotient: SetCategory with
    generalizedEtaQuotient: (SPEC, List Cusp) -> %
      ++ generalizedEtaQuotient(rspec,cusps) represents the
      ++ expansion of g_rbar(\tau) at the given cusps of
      ++ Gamma1(mm) in terms of $x = \exp(2 \pi i \tau/w)$ where
      ++ w=width(mm,cusp)$GAMMA1 and gamma=cuspToMatrix(mm,cusp)$GAMMA1.
      ++ mm and rbar are given through rspec, see QEtaSpecification.
      ++ See \eqref{eq:g_rbar(tau)} and \eqref{eq:g_rbar(gamma*tau)}.
    generalizedEtaQuotient: SPEC -> %
      ++ generalizedEtaQuotient(rspec) represents the expansion of
      ++ g_rbar(\tau) at all cusps of Gamma1(mm) in terms of
      ++ $x = \exp(2 \pi i \tau/w)$ where w=width(mm,cusp) and
      ++ gamma=cuspToMatrix(mm,cusp). It is the same as
      ++ generalizedEtaQuotient(rspec,cusps(mm)$CongruenceSubgroupGamma1).
      ++ mm and rbar are given through rspec, see QEtaSpecification.
      ++ See \eqref{eq:g_rbar(tau)} and \eqref{eq:g_rbar(gamma*tau)}.
    level: % -> P
      ++ If x=generalizedEtaQuotient(rspec) then level(x) returns nn.
    definingSpecification: % -> SPEC
      ++ If x=generalizedEtaQuotient(rspec) then
      ++ definingSpecification(x) returns rspec.
    cusps: % -> List Cusp
      ++ If x=generalizedEtaQuotient(rspec, spitzen), then
      ++ cusps(x)=spitzen.
    minimalRootOfUnity: % -> P
      ++ If x=generalizedEtaQuotient(rspec, cusps), then
      ++ minimalRootOfUnity(x) returns the smallest positive integer n
      ++ such that the expansion of the function g_rbar(\tau) at any
      ++ cusp of cusps (neglecting the (c\tau+d)^* factor lives in
      ++ Q[w][[x]] where w is an n-th root of unity.
      ++ It is computed as the lcm of the values for the respective
      ++ expansion at the cusps.
    elt: (%, Cusp) -> SymbolicGeneralizedEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    qetaGrades: % -> List Z
      ++ qetaGrades(x) returns the (negated) exponents of a series
      ++ expansion of x at all the cusps in the canonical variables.
      ++ i.e. in x=q^(1/w) where w=width(level x, denom q)$GAMMA1.
      ++ Internally, the matrixEtaOrder is used.
    one?: % -> Boolean
      ++ one?(x) returns true if the generalized eta-quotient
      ++ corresponding to x represents 1. This is the case if
      ++ one?(definingSpecification(x)).
 == add
    HT ==> XHashTable(Cusp, SymbolicGeneralizedEtaQuotientGamma)
    Rep ==> Record(
              fspec: SPEC,
              fcusps: List Cusp,
              feta: HT,   -- mapping delta to \eta_\delta
              fminroot: P -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    xExponent(x: %, cusp: Cusp): Z ==
        qe: Q := qExponent(x.cusp.0)$SymbolicGeneralizedEtaQuotientLambdaGamma
        xe: Q := WIDTH1(level x, cusp) * qe
        not one? denom xe =>
            error "SymbolicGeneralizedEtaQuotient: fractional exponent"
        numer xe
    qetaGrades(x: %): List Z == [-xExponent(x, cusp) for cusp in cusps x]

    generalizedEtaQuotient(rspec: SPEC, cusps: List Cusp): % ==
        h: HT := empty()
        minroot: Z := 1
        mm: P := level rspec
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(mm, cusp)$GAMMA1
            import from SymbolicGeneralizedEtaQuotientGamma
            y := generalizedEtaQuotient(rspec, gamma)
            h.cusp := y
            minroot := lcm(minroot, minimalRootOfUnity y)
        per [rspec, cusps, h, asP minroot]

    generalizedEtaQuotient(rspec: SPEC): % ==
        generalizedEtaQuotient(rspec, cusps(level rspec)$GAMMA1)

    definingSpecification(x: %): SPEC == xx.fspec
    level(x: %): P == level definingSpecification x
    cusps(x: %): List Cusp == xx.fcusps
    elt(x: %, cusp: Cusp): SymbolicGeneralizedEtaQuotientGamma == xx.feta.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == xx::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fspec)
        h := hashUpdate!(h, xx.fcusps)
        h
    ((x: %) = (y: %)): Boolean ==
        xx.fspec ~= yy.fspec => false
        xx.fcusps = yy.fcusps
    one?(x: %): Boolean == one? definingSpecification x













)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D SymbolicModularGamma1GeneralizedEtaQuotient
  $(F_{\bar{s},\bar{r},m,t}(\gamma\tau))_\gamma$}
\label{sec:SymbolicModularGamma1GeneralizedEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $m, M, N\in\setN$, $\bar{s} \in \bar{R}(N)$, $\bar{r} \in
\bar{R}(M)$, $t \in \Set{0,\ldots,m-1}$, elements from the domain
\code{SymbolicModularGamma1GeneralizedEtaQuotient} represent the
collection of elements from
\code{SymbolicModularGamma1GeneralizedEtaQuotienGamma} for all
$\gamma \in \SL2Z$ corresponding to a cusp of $\Gamma_1(N)$.

It corresponds to the data from \eqref{eq:F_sbar-rbar-m-t(gamma*tau)},
\ie, it computes the building blocks for
$F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$.

)endif

-------------------------------------------------------------------
)abbrev domain YM1GEQ SymbolicModularGamma1GeneralizedEtaQuotient
++ SymbolicModularGamma1GeneralizedEtaQuotient holds data to compute
++ an generalized eta quotient expansions of
$F_{\bar{s}, \bar{r}, m, t}(\gamma\tau)$ at all cusps
++ of $Gamma_1(N)$. See \eqref{eq:F_sbar-rbar-m-t(gamma*tau)}.
SymbolicModularGamma1GeneralizedEtaQuotient: SetCategory with
    generalizedEtaQuotient: (SPEC, SPEC, P, N, List Cusp) -> %
      ++ generalizedEtaQuotient(sspec,rspec,m,t,cusps) represents the
      ++ expansion of $F_{sbar,rbar,m,t}(\gamma \tau)$ for all gamma
      ++ corresponding to the given cusps. $rbar$ and $sbar$ are given
      ++ by rspec and sspec, repectively.
    generalizedEtaQuotient: (SPEC, SPEC, P, N) -> %
      ++ etaQuotient(sspec,rspec,m,t) represents the expansion of
      ++ $F_{rbar,sbar,m,t}(\gamma \tau)$ for all gamma corresponding
      ++ to the cusps of $\Gamma_0(nn)$. $rbar$ and $sbar$ are given
      ++ by rspec and sspec, respectively.
    generalizedEtaQuotient: (SPEC, List Cusp) -> %
      ++ generalizedEtaQuotient(rspec,cusps) represents the expansion
      ++ of $g_{rbar}(\gamma \tau)$ for all gamma corresponding to the
      ++ given cusps. $rbar$ is given by rspec.
    generalizedEtaQuotient: SPEC -> %
      ++ etaQuotient(rspec) represents the expansion of
      ++ $g_{rbar}(\gamma \tau)$ for all gamma corresponding to the
      ++ cusps of $\Gamma_0(nn)$. $rbar$ is given by rspec.
    coerce: SymbolicGeneralizedEtaQuotient -> %
      ++ coerce(x) turns x into an element of this domain.
    level: % -> P
      ++ level(x) returns nn such that x corresponds to a modular
      ++ function for Gamma_1(nn).
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    cusps: % -> List Cusp
      ++ cusps(x) either returns the value that was given to
      ++ generalizedEtaQuotient at creation time or
      ++ cusps(level(x))$CongruenceSubgroupGamma1 if the cusps where
      ++ not given.
    elt: (%, Cusp) -> SymbolicModularGamma1GeneralizedEtaQuotientGamma
      ++ x.cusp returns the data corresponding to the respective
      ++ cusp.
    minimalRootOfUnity: % -> P
      ++ minimalRootOfUnity(x) returns
      ++ lcm [minimalRootOfUnity(x.u) for u in cusps x].
 == add
    YM1GEQG ==> SymbolicModularGamma1GeneralizedEtaQuotientGamma
    HT ==> XHashTable(Cusp, YM1GEQG)
    Rep ==> Record(
              fsspec: SPEC,
              frspec: SPEC,
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              fcusps: List Cusp, -- cusps of Gamma_1(N) or given cusps
              fy: HT,     -- mapping gamma to YM1GEQG
              fminroot: P -- minimal root of unity needed for the coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    generalizedEtaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N,
                           cusps: List Cusp): % ==
        h: HT := empty()
        minroot: Z := 1
        nn: P := level sspec
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(nn, cusp)$GAMMA1
            e: YM1GEQG := generalizedEtaQuotient(sspec, rspec, m, t,gamma)
            h.cusp := e
            minroot := lcm(minroot, minimalRootOfUnity e)
        per [sspec, rspec, m, t, cusps, h, asP minroot]

    generalizedEtaQuotient(sspec: SPEC, rspec: SPEC, m: P, t: N): % ==
        generalizedEtaQuotient(sspec, rspec, m, t, cusps(level sspec)$GAMMA1)

    generalizedEtaQuotient(rspec: SPEC, cusps: List Cusp): % ==
        sspec: SPEC := generalizedEtaQuotientSpecification(level rspec, [])
        generalizedEtaQuotient(sspec, rspec, 1, 0, cusps)

    generalizedEtaQuotient(rspec: SPEC): % ==
        generalizedEtaQuotient(rspec, cusps(level rspec)$GAMMA1)

    coerce(x: SymbolicGeneralizedEtaQuotient): % ==
        generalizedEtaQuotient(definingSpecification x, cusps x)

    level(x: %): P == level(xx.fsspec)
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    elt(x: %, cusp: Cusp): YM1GEQG == xx.fy.cusp
    minimalRootOfUnity(x: %): P == xx.fminroot
    cusps(x: %): List Cusp == xx.fcusps

    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.fsspec)
        h := hashUpdate!(h, xx.frspec)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.fcusps)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.fsspec ~= yy.fsspec => false
        xx.frspec ~= yy.frspec => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.fcusps = yy.fcusps

    one?(x: %): Boolean == one? xx.fsspec and one? xx.frspec

    qetaGradesEstimate(x: %): List Q ==
        [qetaGradeEstimate(x.c) for c in cusps x]













)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
