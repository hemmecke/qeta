-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Finding co-factors for dissected Eta-Quotients with cusps only at infinity}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals the computation of a cofactor to a
  sifted (generalized) eta-quotient such that the result is a modular
  function with a cusp at most at infinity.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
VZ ==> Vector Z
MZ ==> Matrix Z -- consider only 2x2 matricies
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
INDICES ==> LLZ
QETAAUX ==> QEtaAuxiliaryPackage
SPEC ==> QEtaSpecification
SPECS ==> List SPEC
CUSPS ==> List Cusp

asP x ==> x pretend P

LVZ ==> List VZ
ECS ==> Record(indices: INDICES, particular: Union(VZ,"failed"), basis: LVZ)
ECSS ==> Record(comatrix: MZ, rhs: VZ)
SOL ==> Record(particular: Union(VZ, "failed"), basis: LVZ)
ZRESULT ==> Record(zinhom: LVZ, zhom: LVZ, zfree: LVZ) -- zsolve$X4ti2


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGammaPackage}
\label{sec:QEtaModularGammaPackage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta-quotient
in order to make it a modular function for
$\Gamma_0(N)$ having a pole only at infinity or to make the (positive)
orders at all cusps (\code{qetaGrades}) small in total sum.

)endif

)abbrev package QETAMGP QEtaModularGammaPackage
QEtaModularGammaPackage(MOD): Exports == Implementation where
  MOD: QEtaConditionsModularCategory
  YMEQ ==> SymbolicModularEtaQuotient MOD
  Exports ==> with
    etaCofactorInfinitySpaceSystem: (SPECS, LZ, CUSPS) -> ECSS
      ++ etaCofactorInfinitySpaceSystem(bspecs,grds,spitzen) returns a
      ++ matrix A and a right-hand side v for a system A*x>=v where
      ++ the right-hand side is grds (which is the expansion
      ++ poleorders ath the cusps spitzen and A is the expansion
      ++ poleorders of the basis elements given by bspecs. The rows
      ++ are indexed by the cusps.
    reduceSystem: ECSS -> ECSS
      ++ reduceSystem([A,v]) returns a matrix A' and a right-hand side
      ++ v' such that A*x>=v and A'*x>=v' have the same solutions, but
      ++ A' has duplicate rows removed.
    qetaGrades: YMEQ -> LZ
      ++ qetaGrads(y) returns the poleorders of the modular function
      ++ corresponding to y. In the special case when e is the
      ++ expansion and qetaGrade(e.c) is less than 0 for every cusp c
      ++ in cusps(y), the function returns a value of -1 for each cusp
      ++ although this might not be the true poleorder of the
      ++ expansion, it rather is the value for the case that y
      ++ represents zero. This special treatment avoids running into
      ++ an infinite loop if y represents the zero function.
    qetaGrades: (SPEC, SPEC, P, N, CUSPS) -> LZ
      ++ qetaGrades(sspec,rspec,m,t,spitzen) returns qetaGrades(y)
      ++ where y=etaQuotient(sspec,rspec,m,t,spitzen) from
      ++ SymbolicModularEtaQuotient(MOD).
    qetaGrades: (SPEC, SPEC, P, N) -> LZ
      ++ qetaGrades(sspec,rspec,m,t) returns qetaGrades(y) where
      ++ y=etaQuotient(sspec,rspec,m,t)$SymbolicModularEtaQuotient(MOD).
    etaCofactorInfinity: (P, SPEC, P, N, INDICES) -> SPEC
      ++ etaCofactorInfinity(nn,rspec,m,t,idxs) returns a
      ++ specification sspec such that sspec has only indices from
      ++ idxs, modular?(sspec,rspec,m,t)$MOD and
      ++ etaQuotient(sspec,rspec,m,t)$SymbolicModularEtaQuotient(MOD)
      ++ corresponds to a modular function with poles only at infinity
      ++ and with smallest pole order.
  Implementation ==> add
    C ==> Q
    lift2C x ==> map(coerce, x)$SparseUnivariatePolynomialFunctions2(Z, C)
    SUPC ==> SparseUnivariatePolynomial C
    CX ==> SimpleAlgebraicExtension(C, SUPC, supc)
    TX ==> QEtaTaylorSeries CX
    LX ==> QEtaLaurentSeries CX
    QLX ==> XHashTable(Cusp, LX)
    specMODA1 C ==> modularEtaQuotientInfinity $ QEtaModularInfinity(C, MOD)
    -- local
    -- We assume that sspec(y)=1, multiplier(basefactor y)=1, modular?(y).
    -- Then orderMin gives the true order of the expansion in terms of
    -- the canonical variables and the denominators are all 1.
    orderMod(y: YMEQ): LZ ==
        ords: List Q := ordersMin y
        not one? lcm [denom x for x in ords] =>
            error "orderMod: fractional order" -- should never happen
        [numer x for x in ords]

    etaCofactorInfinitySpaceSystem(
      bspecs: SPECS, ords: LZ, spitzen: CUSPS): ECSS ==
        -- For bspecs (modular functions) we can use the
        -- matrixEtaOrder to compute the order vectors.
        ybas: List YMEQ := [etaQuotient(bspec, spitzen) for bspec in bspecs]
        bas: LLZ := [orderMod y for y in ybas]
        mat: MZ := transpose matrix bas
        [mat, - vector ords]  -- switch from orders to grades

    reduceSystem(ecss: ECSS): ECSS ==
        -- We have to solve ecss.comatrix * x >= ecss.rhs and are
        -- satisfied with a solution for "=" instead of ">=". The rows
        -- of ecss.comatrix and ecss.rhs are indexed by cusps. Since
        -- it might happen that some rows are identical, we remove
        -- them. From the rhs we collect the corresponding entries and
        -- take their maximum grade (pole order), see
        -- \eqref{eq:remove-non-infinity-poles}.
        mat: MZ := ecss.comatrix
        u: VZ := ecss.rhs
        hrows: XHashTable(VZ, Z) := empty()
        for i in 1..nrows(mat) repeat
            hrow: VZ := row(mat, i)
            g: Union(Z, "failed") := search(hrow, hrows)
            if g case "failed" or u.i > (g::Z) then hrows.hrow := u.i
        ll: LLZ := empty()
        v: LZ := empty()
        for hrow in keys hrows repeat
            ll := cons(members hrow, ll)
            v := cons(hrows.hrow, v)
        [matrix ll, vector v]

    qetaGrades(y: YMEQ): LZ ==
        xiord: P := minimalRootOfUnity y
        supc: SUPC := lift2C(cyclotomic(xiord)$CyclotomicPolynomialPackage);
        xi := generator()$CX;
        xsym: Symbol := "x"::Symbol;
        e: QLX := laurentExpansions(y)$QEtaSeriesExpansion(C,xiord,CX,xi,MOD)
        spitzen: CUSPS := cusps y
        qetaGrades(e :: ModularFunctionExpansionsAtCusps(CX, spitzen))
    qetaGrades(sspec: SPEC, rspec: SPEC, m: P, t: N, spitzen: CUSPS): LZ ==
        qetaGrades etaQuotient(sspec, rspec, m, t, spitzen)$YMEQ
    qetaGrades(sspec: SPEC, rspec: SPEC, m: P, t: N): LZ ==
        qetaGrades etaQuotient(sspec, rspec, m, t)$YMEQ

    etaCofactorInfinity(nn: P, rspec: SPEC, m: P, t: N, idxs: INDICES): SPEC ==
        ecs: ECS := etaCofactorSpace(nn, rspec, m, t, idxs)
        ecs.particular case "failed" =>
            error "etaCofactorInfinity: cannot make modular"
        idxs := ecs.indices -- because idxs can be empty initially
        hbasis: LVZ := ecs.basis -- a basis for the homogeneous solutions
        rinitial: VZ := (ecs.particular)::VZ
        sinitial: VZ := minimizeVector(rinitial, hbasis)$QETAAUX

        -- If it can be shown that multiplication with sspec leads
        -- to a constant series expansion (without computing this series),
        -- then we can return sspec.
        sspec: SPEC := etaQuotientSpecification(nn, idxs, members sinitial)
        spitzen: List Cusp := cusps(nn)$MOD
        yall: YMEQ := etaQuotient(sspec, rspec, m, t, spitzen)
        constant? yall => sspec

        -- y can still represent a constant function.
        -- We only make an actual test at the cusp infinity for all others
        -- the poleorder estimate must suffice.
        spitzen := remove!(infinity(), spitzen)
        y: YMEQ := etaQuotient(sspec, rspec, m, t, spitzen)
        if constant? y then -- note that infinity is not involved
            -- Coming here, we definitely have no pole at non-infinity cusps.
            -- The implementation for order in A1(C) takes care of not
            -- running indefinityly of the series is zero.
            if qetaGrade(specMODA1(C)(sspec, rspec, m, t))<=0 then return sspec

        -- Coming here, it is still possible that (sspec, rspec, m, t)
        -- represents a constant function, since the "constant?"
        -- function above only estimates the grades/orders.

        -- Make sure that yall does not by chance have only a pole at
        -- infinity.
        ords: LZ := [-g for g in qetaGrades y]
        hasPole?: Boolean := false
        for o in ords repeat hasPole? := hasPole? or o < 0
        if not hasPole? then return sspec -- only possible pole is at infinity
        -- There is a pole at a non-infinity cusp.
        bspecs := [etaQuotientSpecification(nn, idxs, members x)
                   for x in hbasis]
        --- See \eqref{eq:remove-non-infinity-poles}.
        ecss := etaCofactorInfinitySpaceSystem(bspecs, ords, spitzen)
        -- Now we have a system (mat, b) and look for a solution v such
        -- that mat*v>=b, where >= means "in each component".
        ecss := reduceSystem ecss -- remove identical rows
        mat: MZ := ecss.comatrix -- corresponds to O'
        u: VZ := ecss.rhs -- corresponds to -v in eq:remove-non-infinity-poles

        -- We first solve mat*x=u for x.
        sol: SOL := diophantineSystem(mat, u)$SmithNormalForm(Z, VZ, VZ, MZ)
        hmat: MZ := transpose matrix [members x for x in hbasis]
        not sol.particular case "failed" =>
            s := sinitial + (hmat * ((sol.particular)::VZ))
            return etaQuotientSpecification(nn, idxs, members s)

        -- If there is no solution, we try the more involved mat*x>=u.
        rels: VZ := vector [1 for x in 1..#u]
        zresult: ZRESULT := zsolve(mat, rels, u)$X4ti2
        -- We are interested in the inhomogeneous solutions, since
        -- they yield an adjustment such that the resulting cofactor
        -- vector sbar leads to an element in M^\infty(nn) for the
        -- etaQuotient(sspec,rspec,m,t).
        --
        -- There can be several inhomogeneous solutions. Any of them
        -- is fine, but we want the resulting series to be of a small
        -- qetaGrade (= small poleorder = big order) at infinity. So we
        -- compute the series expansion at infinity for each of the
        -- inhomogeneous solutions and take the minimal qetaGrade.
        adjustments := zresult.zinhom
        empty? adjustments => error "cannot find cofactor"
        s := sinitial + hmat * first(adjustments)
        -- The order of the expansion at infinity of the modular
        -- function given by (sspec, rspec, m, t) can be approximated
        -- by alphaInfinity. See its definition in QEtaCofactorSpace.
        -- Even though it might not be the correct order since
        -- a(m*n+t) can be zero for an initial segment of natural
        -- numbers n, alphaInfinity can be used to determine which of
        -- the possible inhomogeneous candidates gives a minimal
        -- grade. Note that grade = -order.
        -- Since in the computation of alphaInfinity (see
        -- QEtaSpecification) only the cofactor part changes, it is
        -- sufficient if we try to maximize sigmaInfinity(sspec) where
        -- sspec is given through s via
        -- sbar:=etaQuotientSpecification(nn,idxs,s)
        sspec := etaQuotientSpecification(nn, idxs, members s)
        sigmainf: Q := sigmaInfinity sspec
        while not empty?(adjustments := rest adjustments) repeat
            s := sinitial + hmat * first(adjustments)
            tspec := etaQuotientSpecification(nn, idxs, members s)
            si: Q := sigmaInfinity tspec
            if si > sigmainf then
                sspec := tspec
                sigmainf := si
        return sspec










)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
