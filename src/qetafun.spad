-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
--dbgPrint(x,y) ==> display(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 770)
xdbgPrint(x,y) ==> rhx:="42"

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}
% Euler totient function
\newcommand{\eulerphi}{\varphi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding Dedekind Eta Functions into $q$-series}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}

We expand quotients of Dedekind $\eta$-functions that are modular
functions for $\Gamma_0(N)$ at all cusps into $q$-series.

\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{gather}
  GL_2^+(\setZ)
  :=
  \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix}}{a,b,c,d\in\setZ \land ad-bc>0}
\end{gather}

\begin{gather}
  SL_2(\setZ) := \SetDef{\gamma\in GL_2^+(\setZ)}{\det(\gamma)=1}
\end{gather}

Let $N$ be a positive natural number and define a $\Gamma_0(N)$ as a
subgroup of the special linear group $SL_2(\setZ)$ as follows.
\begin{gather*}
\Gamma_0(N) := \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix} \in SL_2(\setZ)}{\divides{N}{c}}
\end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:epsilon}
  Let $\unityPowerSymbol: \setC \to \setC$ be defined by
  \begin{gather*}
    \unityPower{x} := \exp(2\pi i x).
  \end{gather*}
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\setH=\SetDef{c\in \setC}{\Im(c)>0}$ denote the upper complex
half-plane.

Let
\begin{gather}\label{eq:eta-expansion}
  \eta: \setH \to \setC, \quad
  \tau \mapsto \unityPower{\frac{\tau}{24}}
  \prod_{n=1}^{\infty}(1-q^n)
\end{gather}
with $q = \unityPower{\tau}$
denote the Dedekind eta function.

In the following $N$ denotes a positive integer and
$1=\delta_1<\delta_2\dots<\delta_n=N$ the positive divisors of $N$.
Let $\Delta:=\Set{\delta_1,\ldots,\delta_n}$. For convenience, we
allow to index $n$-dimensional vectors by the divisors of $N$,
instead of the usual index set $\Set{1,\ldots,n}$.
%
For $\delta\in\Delta$ we consider the functions
\begin{gather*}
 \eta_\delta: \setH \to \setC,\quad \tau \mapsto  \eta(\delta\tau)
\end{gather*}
None of these functions is identically zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We define $R(N)$ to be the set of integer tuples
$r = (r_{\delta_1}, \ldots,
r_{\delta_n})\in \setZ^n$.

By $R^*(N)$ we denote the subset of all tuples
$r=(r_\delta)_{\delta\in\Delta}$ of $R(N)$ that fulfil the following
conditions.
\begin{align}
 \sum_{\delta\in\Delta} r_\delta &= 0\label{eq:sum=0}\\
 \sum_{\delta\in\Delta} \delta r_\delta &\equiv 0\pmod{24}\label{eq:sigmainfinity}\\
 \sum_{\delta\in\Delta} (N/\delta)r_\delta &\equiv 0\pmod{24}\label{eq:sigma0}\\
 \sqrt{\prod_{\delta\in\Delta}\delta^{r_\delta}} &\in \setQ\label{eq:productsquare}
\end{align}

Note that $R^*(N)$ is an additive monoid. It even is an additive group.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

According to
\cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016},
there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
$\Gamma_0(N)$ that correspond to a divisor $c$ of $N$.

In the following we always deal with quotients of $\eta$-functions of
level $N$ that are modular functions for $\Gamma_0(N)$.

We implement a domain that deals with such quotients and their
$q$-expansion at all cusps ($q=e^{2\pi i \tau})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transformations of the Dedekind $\eta$-function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's look at the transformation of the $\eta$-function (see
\cite[Lemma~2.27]{Radu:PhD:2010}).

Let $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, then
\begin{gather}
\eta(\gamma\tau) =
\eta\left(\frac{a\tau+b}{c\tau+d}\right) =
(c\tau+d)^{1/2}\,\upsilon_\eta(\gamma)\,\eta(\tau)
\label{eq:eta-transformation}
\end{gather}
where $\upsilon(\gamma) := \upsilon_\eta(a,b,c,d)$ as defined as in
\cite[Lemma~2.27]{Radu:PhD:2010}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta$ under $GL_2^+(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$W=\left(\begin{smallmatrix}A&B\\C&D\end{smallmatrix}\right) \in
GL_2^+(\setZ)$.
%
Then for $h=\gcd(A, C)>0$, $a':=\frac{A}{h}$, $c':=\frac{C}{h}$ we
have $\gcd(a', c')=1$ and thus can find $b'$ and $d'$ such that
$a'd'-b'c'=1$.


\ie,
$W'=\left(\begin{smallmatrix}a'&b'\\c'&d'\end{smallmatrix}\right)\in
SL_2(\setZ)$.
%
Let
\begin{gather*}
  W':=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  \qquad
  W''
  :=
  \begin{pmatrix}
    h &B d'-D b'\\
    0 & \det(W) / h
  \end{pmatrix}.
\end{gather*}
Then $W\in SL_2(\setZ)$ and $W = W' W''$.


Note that for any integer $s$ whe have:
\begin{align}
W = \begin{pmatrix}A&B\\C&D\end{pmatrix}
&=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}h &B d'- D b'\\0 &\det(W) / h\end{pmatrix}
  \\
&=
  \begin{pmatrix} a'&b' + a' s\\ c'&d' + c' s \end{pmatrix}
  \begin{pmatrix}
    h &B d'- D b'- s \det(W) / h\\
    0 &\det(W) / h\end{pmatrix}.
\end{align}
Therefore, we can choose $b'$ and $d'$ in such a way that
$0 \le B d'-D b' < \det(W)/h$.

Let $\tau' := W''\tau = \frac{h}{\det(W)}(h\tau + B d'- D b')$, then
$\tau'\in\setH$ and
\begin{gather}
\eta(W\tau) =
\eta(W'\tau') =
(c'\tau+d')^{1/2}\,\upsilon_\eta(W')\,\eta(\tau')
\label{eq:eta-W-transformation}
\end{gather}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_{\delta,m,t}$ under $\Gamma_0(N)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Given a positive integer $m$ and $t\in\Set{0,\ldots,m-1}$, a positive
integer $M$, and $r \in R(M)$ such that
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\divides{\delta}{M}}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
  =
  \prod_{\delta|M}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
\end{gather*}
is the generating function for the sequence $(a(n))_{n\in\setN}$.

In order to algorithmically find a Ramanujan-Kolberg relation for
$\sum_{n=0}^\infty a(m n + t)$ we restrict the choice of $N$ in such a
way, that
\begin{gather}
  \text{for every prime $p$ with $\divides{p}{m}$ follows $\divides{p}{N}$,}
  \label{eq:p|m=>p|N}\\
  \text{and, if $\divides{\delta}{M}$ and $r_\delta\ne0$, then
    $\divides{\delta}{mN}$.}
  \label{eq:delta|M=>delta|mN}
\end{gather}

For the above conditions see (13) and (14) in
\cite{Radu:AlgorithmicApproachRamanujanCongruences:2009} or
Section~4.2 in \cite{Radu:PhD:2010}.

Let $m$ and $N$ be a positive integers,
$t \in \Set{0,\ldots,m-1}$, and $\divides{\delta}{M}$.
%
We define
\begin{gather}
\eta_{\delta,m,t}(\tau) := \eta
\left(
  \begin{pmatrix}\delta& \delta t\\0&m\end{pmatrix} \tau
\right).
\end{gather}

Let $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\Gamma_0(N)$.
%
Then
\begin{align}
  \eta_{\delta,m,t}(\gamma \tau)
  &:= \eta
\left(
  \begin{pmatrix}\delta& \delta t\\0&m\end{pmatrix}
  \gamma
  \tau
\right)
=
\eta(W \tau)
\end{align}
where
\begin{align}
  W &:=
  \begin{pmatrix}
    \delta (a + c t) & \delta (b + d t)\\
    c m                   & d m
  \end{pmatrix}.
\end{align}

Let's apply the splitting of $W=W'W''$ into a matrix
$W'\in SL_2(\setZ)$ and an upper triangular matrix $W''$ as in the
previous section and compare with the proof of Lemma~2.2 of
\cite{Radu:AlgorithmicApproachRamanujanCongruences:2009}.

We get
%
$\det(W) = \delta m$, because $\det(\gamma)=1$.

Furthermore,
$h = \gcd(\delta(a + c t), \delta \frac{cm}{\delta})=\delta$,
%
$a' = a + c t$, and
%
$c' = \frac{cm}{\delta}$.
%
From \eqref{eq:delta|M=>delta|mN} and $\divides{N}{c}$ follows
$\divides{\delta}{mc}$ and $c'\in \setZ$.

Note that $\gcd(a,c)=1$. Thus $\gcd(a + c t, c)=1$ and because of
$\divides{N}{c}$,
% ($\gamma \in \Gamma_0(N)$)
it follows $\gcd(a + c t, N)=1$.
%
Then \eqref{eq:p|m=>p|N} implies $\gcd(a + c t, m)=1$.
%
Therefore $\gcd(a + c t, cm)=1$ and we can find $b^*$ and $d'$ such
that $(a + c t) d' - b^* cm =1$. It also holds $\gcd(a', c')=1$ and we
can choose $b'=\delta b^*$ such that $\det(W')=1$ for
\begin{gather*}
  W'= \begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  = \begin{pmatrix}a+ct& \delta b^*\\cm/\delta&d'\end{pmatrix}.
\end{gather*}

For the matrix $W''$ we obtain
\begin{gather}
  W''
  =
  \begin{pmatrix}
    \delta & \delta ((b + d t) d' - d m b^*)\\
    0      & m
  \end{pmatrix}
  =
  \begin{pmatrix}
    \delta & \delta t_\gamma\\
    0      & m
  \end{pmatrix}.
\end{gather}
where $t_\gamma := (b + d t) d' - d m b^*$.

Note that
\begin{align*}
  W = W'\cdot W''
  &=
    \begin{pmatrix}a'& b'\\c'&d'\end{pmatrix}
    \cdot
    \begin{pmatrix}1& \delta s\\0&1\end{pmatrix}
    \begin{pmatrix}1&-\delta s\\0&1\end{pmatrix}
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&t_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& b' + a'\delta s\\c'&d' + c' \delta s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&-s\\0&1\end{pmatrix}
    \begin{pmatrix}1&t_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& \delta(b^* + (a+ct)s)\\c'&d' + c m s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&t_\gamma-sm\\0&m\end{pmatrix}
\end{align*}


Clearly, we can choose $s\in\setZ$ such that
$0 \le t_\gamma - sm < m$.
%
In the following, we assume that already in the first place we have
chosen $b^*$ and $d'$ in such a way that $0\le t_\gamma < m$.

Note that $t_\gamma$ does depend on $\gamma$, $t$, and $m$, but it
does not depend on $\delta$.

With $\tau':=W''\tau$ we have
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\delta\tau+\delta(b + d t) d' - d m b'}{m}
    \right) + d'\\
  &=
    \frac{cm}{\delta}
    \left(
    \frac{\delta\tau+\delta(b + d t) d'}{m}
    \right)  - d b' c' + d'\\
  &=
    c\tau + c(b + d t) d' - d (a' d' -1) + d'\\
  &=
    c\tau + d + c(b + d t) d' - d a' d' + d'\\
  &=
    c\tau + d + [c(b + d t) - d (a + c t) + 1]d'\\
  &=
    c\tau + d
\end{align*}
and thus
\begin{align*}
  \eta_{\delta,m,t}(\gamma \tau)
  &= \eta(W \tau) = \eta(W'W''\tau) = \eta(W'\tau')\\
  &= (c'\tau'+d')^{1/2} \, \upsilon(W') \, \eta(\tau')\\
  &= K \, \eta(\tau') = K \, \eta(W''\tau)
   = K \, \eta
    \left(
    \begin{pmatrix}
      \delta & \delta t_\gamma\\
      0      & m
    \end{pmatrix}
    \tau
    \right)\\
  &= K \, \eta_{\delta,m,t_\gamma}(\tau)
\end{align*}
where $K = (c\tau+d)^{1/2}\, \upsilon(W')$ and
$t_\gamma:=(b + d t) d' - d m b^*$.

We want to emphasize that $0\le t_\gamma$ does only depend on $\gamma$ and $t$.

CONTINUE HERE






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_\delta$ under $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\delta \in \setN\setminus\Set{0}$.

\begin{gather*}
\eta_\delta(\gamma\tau)
=
\eta_\delta\left(\frac{a\tau+b}{c\tau+d}\right) =
\eta\left(\frac{a\delta\tau+b\delta}{c\tau+d}\right)
=
\eta\left(\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
  \tau\right).
\end{gather*}

Let
%
$h_\delta:=\gcd(\delta a,c)$,
%
$a_\delta:=\frac{\delta a}{h_\delta}$,
%
$c_\delta:=\frac{c}{h_\delta}$,
%
and $b_\delta$ and $d_\delta$ are chosen in such a way that
$a_\delta d_\delta - b_\delta c_\delta = 1$.
%
Because of $\gcd(a_\delta, c_\delta)=1$, such $b_\delta$ and $d_\delta$
can be found.
%
Therefore
  $\gamma_\delta := \left(
  \begin{smallmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{smallmatrix}
\right)\in SL_2(\setZ)$.

Note that $h_\delta=\gcd(\delta, c)$, because $\gcd(a,c)=1$ and,
furthermore,

\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\label{eq:naive-matrix-split}
\end{align}
Note that for any integer $s$ whe have:
\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}
    h_\delta&\delta b d_\delta-d b_\delta\\
    0      &\delta / h_\delta\end{pmatrix}
  \\
&=
  \begin{pmatrix}
    a_\delta&b_\delta + a_\delta s\\
    c_\delta&d_\delta + c_\delta s
  \end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta-s \delta / h_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\end{align}
Therefore, we can choose $b_\delta$ and $d_\delta$ in such a way that
$0 \le \delta b d_\delta-d b_\delta < \delta/h_\delta$.

If we set
\begin{gather}
  \tau_\delta:=\begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\0&\delta
    / h_\delta\end{pmatrix} \tau
  = \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta},
  \label{eq:tau_delta}
\end{gather}
then
\begin{gather*}
  \eta_\delta(\gamma\tau)
  =
  \eta(\gamma_\delta \tau_\delta)
  =
  (c_\delta\tau_\delta+d_\delta)^{1/2}
  \,
  \upsilon(\gamma_\delta)
  \,
  \eta(\tau_\delta).
\end{gather*}


Furthermore,
\begin{align*}
  c_\delta\tau_\delta+d_\delta
  &=
  c_\delta
    \left(
    \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta}
    \right) + d_\delta\\
  &=
  \frac{c_\delta h_\delta}{\delta}
    (
    h_\delta\tau + b \delta d_\delta-d b_\delta
    ) + d_\delta\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + c b \delta d_\delta - c d b_\delta + \delta d_\delta)\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + (ad-1) \delta d_\delta - c d b_\delta + \delta d_\delta)\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + ad \delta d_\delta - c d b_\delta)\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + d h_\delta (a_\delta d_\delta - c_\delta b_\delta)\\
  &=
  \frac{h_\delta}{\delta}(c \tau + d).
\end{align*}

Thus, we have
\begin{gather}
\eta_\delta(\gamma\tau)
=
\left(\frac{h_\delta}{\delta}(c \tau+d)\right)^{\!1/2}
\unityPower{\frac{\kappa_\delta}{24}}
\,
\eta(\tau_\delta).
\label{eq:eta_delta(gamma*tau)}
\end{gather}
where $\kappa_\delta \in \Set{0,\ldots,23}$ is defined by
$\unityPower{\frac{\kappa_\delta}{24}}
:= \upsilon(\gamma_\delta)$.



For the following definition see \cite[Lemma~2.37]{Radu:PhD:2010} and
\cite[Definition~2.9]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:width}
  Let
  $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)
  \in SL_2(\setZ)$ and $N$ be a positive integer. Then
  \begin{gather}
    w_\gamma = \frac{N}{\gcd(c^2, N)}
  \end{gather}
  is called the \emph{width of $\gamma$ with respect to $\Gamma_0(N)$}.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For
$\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ we want to expand $\eta(\tau_\delta)$ in
$x:=q^{1/w_\gamma}=\unityPower{\frac{\tau}{w_\gamma}}$ with
coefficients from $\setQ(\xi)$ where
$\xi := \unityPower{\frac{c}{24N}}$.

Since we are only interested in expansions at the cusps, we can assume
$0<c\in\Delta$.

In the following let $\delta \in \Delta$.
Because of \eqref{eq:tau_delta}, we have
\begin{align}
  q_\delta = \unityPower{\tau_\delta}
  &= x^{u_\delta} \, \unityPower{v_\delta}
\label{eq:q_delta}
\end{align}
for $u_\delta := \frac{w_\gamma h_\delta^2}{\delta}$ and
$v_\delta := \frac{\delta b d_\delta-d b_\delta}{\delta/h_\delta}$.
%
Note that $\unityPower{\frac{v_\delta}{24}} = \xi^k$ for
$k = (\delta b d_\delta - d b_\delta) \frac{N}{\lcm(\delta,c)}\in \setZ$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  $u_\delta \in \setZ$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
If $p$ is a prime that divides $N$, \ie, $N=N'p^\alpha$ for some
$\alpha>0$, and $\delta = \delta' p^m$, $c=c' p^k$ with
$\gcd(p,N')=\gcd(p,\delta')=\gcd(p,c')=1$, then
\begin{align*}
  u_\delta
  &=
  \frac{N}{\gcd(c^2,N)} \frac{\gcd(\delta,c)^2}{\delta}\\
  &=
  \frac{p^\alpha N' \gcd(p^m \delta', p^k c')^2}{\gcd(p^{2k}
    c'^2,p^\alpha N') p^m \delta'}\\
  &=
  p^{\alpha + 2 \min(m,k) - m - \min(2k, \alpha)}
  \frac{N' \gcd(\delta', c')^2}{\gcd(c'^2, N') \delta'}
\end{align*}
If we can show that $e:=\alpha + 2 \min(m,k) - m - \min(2k,
\alpha)\ge0$ then $u_\delta\in\setN$ follows by repeating the above
process for every prime divisor of $N$.

There are several cases to consider:
\begin{itemize}
\item $0\le m\le k \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2m-m-2k=(\alpha-2k)+m\ge0$.
\item $0\le m\le k \le \alpha < 2k$. Then
  $e=\alpha+2m-m-\alpha=m\ge0$.

\item $0\le k\le m \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2k-m-2k=\alpha-m\ge0$.
\item $0\le k\le m \le \alpha < 2k$. Then
  $e=\alpha+2k-m-\alpha=2k-m\ge0$.
\end{itemize}
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We can expand $\eta(\tau_\delta)$ in terms of $x$ as follows.
\begin{gather*}
  \eta(\tau_\delta)
  =
    \unityPower{{\frac{\tau_\delta}{24}}}
    \prod_{n=1}^{\infty}(1-q_\delta^n)
  =
  \unityPower{\frac{v_\delta}{24}} x^{u_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n)
\end{gather*}

Then \eqref{eq:eta_delta(gamma*tau)} turns into
\begin{align}
\eta_\delta(\gamma\tau)
&=
(c \tau+d)^{1/2}
\,
\left(\frac{h_\delta}{\delta}\right)^{\!\frac{1}{2}}
\,
  \unityPower {\frac{v_\delta + \kappa_\delta}{24}}
  x^{u_\delta/24} \cdot \prod_{n=1}^{\infty}(1-q_\delta^n).
\label{eq:eta_delta(gamma*tau)-expansion}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  For any $c, \delta \in\Delta$, $r\in R(N)$ let us define
  \begin{align}
    a_N(c, \delta) &:= \frac{N}{\gcd(N, c^2)}
                       \frac{\gcd(c,\delta)^2}{\delta},\notag\\
    \ord_c^N(r) &:= \frac{1}{24}\sum_{\delta\in\Delta} a_N(c, \delta) \, r_\delta,
    \label{eq:order-r}
    \intertext{and}
    g_r(\tau) &:= \prod_{\delta\in\Delta} \eta(\delta\tau)^{r_\delta}.
    \label{eq:g_r(tau)}
  \end{align}
\end{Definition}

With $\ord_\gamma^N$ as defined in \cite{Radu:RamanujanKolberg:2015},
Theorem~23 of \cite{Radu:RamanujanKolberg:2015} turns into
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\label{thm:order}
  Let $\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c\in\Delta$.
  If $r \in R^*(N)$, then
  $\ord_\gamma^N(g_r) = \ord_c^N(r)$.
\end{Theorem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For a proof we refer to
\cite[Proposition~3.2.8]{Ligozat:CourbesModulaires:1975}.

In the following let us fix $r \in R^*(N)$ and
$\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c \in \Delta$.

From \eqref{eq:eta_delta(gamma*tau)-expansion} follows
\begin{align}
  g_r(\gamma \tau)
  &=
  \prod_{\delta\in\Delta}
  (c \tau+d)^{r_\delta/2}
  \,
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \,
  \unityPower{\frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{r_\delta u_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  %
  \intertext{and because of \eqref{eq:sum=0}, $u_\delta=a_N(c,
  \delta)$, and \eqref{eq:order-r},  we can write}
  g_r(\gamma \tau)
  &=
  \prod_{\delta\in\Delta}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\ord^N_c(r)}
  \cdot
  \prod_{\delta\in\Delta}
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  \label{eq:g_r(gamma*tau)}
\end{align}
Thus, we can expand $g_r(\gamma\tau)$ as a Laurent series in
$x:=q^{1/w_\gamma}$ with coefficients from $\setQ(\xi)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Root of unity reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that any modular function (in particular $g_r$) can be expressed
as a rational function $f$ in $j$ and $j_N$ where
$j_N(\tau):=j(N\tau)$ and $j$ is Klein's $j$-invariant, \ie,
$g_r(\tau)=f(j, j_N)(\tau) := f(j(\tau), j(N\tau))$.

Let $\frac{a}{c}$ be a cusp of $\Gamma_0(N)$.
%
We can choose $b$ and $d$ such that
%
$\gamma := \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ and $\gamma\infty=\frac{a}{c}$.
%
Klein's $j$-function is invariant under any modular transformation.
%
Let us consider the transformation of $j_N$ by $\gamma$.
%
According to \eqref{eq:tau_delta} for $\delta=N$, $j_N(\gamma\tau)$
can be expanded into a Laurent series in
$x=q^{1/w_\gamma}=\unityPower{\tau/w_\gamma}$ with
coefficients from $\setQ(\xi)$ where $\xi$ is a $\frac{N}{c}$-th root
of unity.
%
Since there is some freedom to choose such $b$ and $d$, we show in the
following, how we can obtain an expansion of $j_N(\gamma\tau)$ and
therefore (via $f$) an expansion $g_r(\gamma\tau)$ into a Laurent
series in $x$ with coefficients in $\setQ(\xi)$ where $\xi$ is a
$v$-th root of unity and $1 \leq v \le N/c$ and $v<N/c$ if $c<N$.

Let
$\gamma' = \bigl(
\begin{smallmatrix}
  a & b'\\
  c & d'
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$, then also
\begin{align*}
  \gamma
  &:=
    \begin{pmatrix}
      a & b' + as\\
      c & d' + cs
    \end{pmatrix}
  =
    \begin{pmatrix}
      a & b'\\
      c & d'
    \end{pmatrix}
    \begin{pmatrix}
      1 & s\\
      0 & 1
    \end{pmatrix}
    \in SL_2(\setZ)
\end{align*}
for any $s\in\setZ$.

For the transformation of $j_N$, we split the matrix as in
\eqref{eq:naive-matrix-split} with $\delta=N$.
\begin{align*}
  \begin{pmatrix}
    N a & N(b' + as)\\
    c & d' + cs
  \end{pmatrix}
      &=
  \begin{pmatrix}
    N a/c & -1\\
    1     &  0
  \end{pmatrix}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix}
\end{align*}
into an element of $SL_2(Z)$ and a triangular matrix.
%
Then we determine natural numbers $u$ and $v$ such that $u v = N/c$
and $\gcd(c, u)=1$. Thus, we can find $s \in \setZ$ such that
$s \equiv -d'c^{-1} \pmod{u}$, \ie, $cs + d' = tu$ for some integer
$t$ with $0\le t<c$.
%
Thus,
\begin{gather*}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix} \tau
  =
  \begin{pmatrix}
    c & u t\\
    0 & u v
  \end{pmatrix} \tau
  =
  \frac{c^2}{N} \tau + \frac{t}{v}
  =
 \frac{w_\gamma c^2}{N} \frac{\tau}{w_\gamma} + \frac{t}{v}
  =
 \frac{c}{\gcd(c,N/c)} \frac{\tau}{w_\gamma} + \frac{t}{v}
  .
\end{gather*}
Note that $u=N/c$ and $v=1$, if $N$ is squarefree.

With the particular $s$ from above, we define $b:=b'+as$, $d:=d'+cs$
and take
%
$\gamma = \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr)$ as the transformation matrix that belongs to the cusp
$\frac{a}{c}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Z24 ==> IntegerMod 24
Q ==> Fraction Z
MZ ==> Matrix Z -- considere only 2x2 matricies
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LQ ==> List Q
LMZ ==> List MZ
OF ==> OutputForm
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage

)abbrev domain SYMBEDC SymbolicEtaDeltaAtCusp
++ SymbolicEtaDeltaAtCusp collects data for the expansion of
++ eta_delta at a specific cusp.
SymbolicEtaDeltaAtCusp: SetCategory with
    eta: (P, MZ, P) -> % -- gamma=[[a,b],[c,d]], m=level, delta, r_delta
      ++ eta(m, gamma, delta, rdelta) represents the expansion of
      ++ \eta_\delta(\gamma\tau)^{r_\delta} in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/) for  some cusp a/c.
    rationalPrefactor: % -> Q -- (h_delta/delta)
    upsilonExponent: % -> Z24 -- kappa_delta
    udelta: % -> P         -- width*gcd(delta,c)^2/delta
    vdelta: % -> Q         -- b2/d2
    unityPower: % -> Q     -- (kappa_delta + vdelta)/24
 == add
    Rep ==> Record(
              flevel: P,  -- level \Gamma_0(lev)
              frat: Q,    -- rational prefactor
              fkappa: Z24,-- upsilonExponent(a1,b2,c1,d1)
              fudelta: P, -- udelta = width*hdelta^2/delta \eqref{eq:q_delta}}
              fvdelta: Q, -- b2/d2, reduced form of roots of unity
                          -- 0<=b2<d2, 0<d2
              funityPower: Q -- (kappa_delta + vdelta)/24
            )
    Rec ==> Record(red: MZ, triang: MZ)
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(m: P, gamma: MZ, delta: P): % ==
        c: Z := gamma(2, 1)
        --assert(c>0)
        hdelta: Z := gcd(c, delta)
        rat: Q := hdelta/delta
        rec: Rec := splitMatrix(gamma, delta)$QAuxMEQ
        gamma1: MZ := rec.red
        gamma2: MZ := rec.triang
        kappa: Z24 := upsilonExponent(gamma1)$QAuxMEQ
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        udelta: P := qcoerce(aLigozat(m, c, delta)$QAuxMEQ)@P
        a2: Z := gamma2(1, 1); wgamma: Z := width(m, c)
        --assert(udelta = ((a2*wgamma exquo d2) :: Z))
        if not (udelta = ((a2*wgamma) exquo d2) :: Z) then
            error "udelta does not match"
        vdelta: Q := b2/d2
        r: Q := (vdelta + (convert(kappa)@Z)::Q) / (24::Q)
          -- eq:eta_delta(gamma*tau)-expansion)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den
        per [m, rat, kappa, udelta, vdelta, r]

    import from MZ
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    udelta(x: %): P == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    unityPower(x: %): Q == xx.funityPower
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
        h := hashUpdate!(h, xx.funityPower)
    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.frat ~= yy.frat => false
        xx.fkappa ~= yy.fkappa => false
        xx.fudelta ~= yy.fudelta => false
        xx.fvdelta ~= yy.fvdelta => false
        xx.funityPower = yy.funityPower

-------------------------------------------------------------------
)abbrev domain SYMBEDP SymbolicEtaDeltaPower
++ SymbolicEtaDeltaPower collects data for the expansion of eta_delta^rdelta
++ at all cusps of Gamma_0(level).
SymbolicEtaDeltaPower: SetCategory with
    etaPower: (P, LQ, LMZ, P, Z) -> %
    rationalPrefactor: (%, Q) -> Q -- (h_delta/delta)^(r_delta)
    udelta: (%, Q) -> Z     -- rdelta * width*gcd(delta,c)^2/delta
    unityPower: (%, Q) -> Q -- rdelta * (b2/d2+kappa_delta)/24
    rdelta: % -> Z          -- rdelta
    _*: (%, %) -> %
      ++ This is a partial multiplication. x*y is only applicable
      ++ if both eta powers belong to the same level, gamma, and delta.
      ++ If x=eta(m, gamma, delta, rx), y=eta(m, gamma, delta, ry), then
      ++ z=x*y is the same as eta(m, gamma, delta, rx + ry).
    xrat: (%, Q) -> Q
    xkappa: (%, Q) -> Z24
    xudelta: (%, Q) -> P
    xvdelta: (%, Q) -> Q
    xunityPower: (%, Q) -> Q

 == add
    HT ==> XHashTable(Q, SymbolicEtaDeltaAtCusp)
    Rep ==> Record(
              flevel: P,  -- level \Gamma_0(lev)
              fdelta: Z,  -- we expand \eta_\delta(\gamma\tau)
              frdelta: Z, -- the respective divisor of level
              fht: HT     -- cusp to eta_delta at cusp mapping
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y
    hh ==> xx.fht

    etaPower(m: P, cusps: LQ, gammas: LMZ, delta: P, rdelta: Z): % ==
        ht: HT := empty()
        for cusp in cusps for gamma in gammas repeat
            ht.cusp := eta(m, gamma, delta)$SymbolicEtaDeltaAtCusp
        per [m, delta, rdelta, ht]

    import from MZ
    rdelta(x: %): Z == xx.frdelta
    rationalPrefactor(x: %, cusp: Q): Q == rationalPrefactor(hh.cusp)^rdelta(x)
    udelta(x: %, cusp: Q): Z ==  udelta(hh.cusp) * rdelta(x)
    unityPower(x: %, cusp: Q): Q == rdelta(x) * unityPower(hh.cusp)
    coerce(x: %): OutputForm == rep(x)::OutputForm

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdelta ~= yy.fdelta => false
        xx.frdelta ~= yy.frdelta => false
        xx.fht = yy.fht

    ((x: %) * (y: %)): % ==
        xx.flevel ~= yy.flevel => error "SymbolicEtaDeltaAtCusp: not same level"
        xx.fdelta ~= yy.fdelta => error "SymbolicEtaDeltaAtCusp: not same delta"
        per [xx.flevel, xx.fdelta, rdelta(x)+rdelta(y), hh]

    xrat(x: %, cusp: Q): Q == rationalPrefactor(hh.cusp)
    xkappa(x: %, cusp: Q): Z24 == upsilonExponent(hh.cusp)
    xudelta(x: %, cusp: Q): P == udelta(hh.cusp)
    xvdelta(x: %, cusp: Q): Q == vdelta(hh.cusp)
    xunityPower(x: %, cusp: Q): Q == unityPower(hh.cusp)
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdelta)
        h := hashUpdate!(h, xx.frdelta)
        for cusp in sort keys(xx.fht) repeat h := hashUpdate!(h, xx.fht)
        h

-------------------------------------------------------------------
)abbrev domain SYMBETAQ SymbolicEtaQuotient
SymbolicEtaQuotient:
  Join(SemiGroup, CoercibleTo OutputForm) with
    etaQuotient: (P, LP, LZ) -> %
      ++ etaQuotient(m, divs, r) represents the collection
      ++ (over all cusps) of the expansion of
      ++ g_r(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/c) for a cusp a/c.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
    cusps: % -> LQ
      ++ cusps(x) returns the (precomputed) cusps of Gamma0(m)
      ++ where m=level(x).
      ++ cusps(x) = cuspsOfGamma0(leval x)
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) such that
      ++ the exponent of the eta_delta for such a divisor delta
      ++ is non-zero.
    order: (%, Q) -> Z
      ++ order(x) returns the order of the expansion in terms of
      ++ x = \exp(2\pi i\tau/w) where w is the width of the cusp.
      ++ It corresponds to the fourth product of eq:g_r(gamma*tau).
    rationalPrefactor: (%, Q) -> Q
      ++ rationalPrefactor(x) returns the first product in
      ++ eq:g_r(gamma*tau)
    unityPower: (%, Q) -> Q --sum_\delta rdelta*(vdelta+Kappa_delta)/24
    order: % -> XHashTable(Q, Z)
      ++ order(x) returns the order of the expansion in terms of
      ++ x = \exp(2\pi i\tau/w) where w is the width of the cusp.
      ++ It corresponds to the fourth product of eq:g_r(gamma*tau).
    rationalPrefactor: % -> XHashTable(Q, Q)
      ++ rationalPrefactor(x) returns the first product in
      ++ eq:g_r(gamma*tau)
    unityPower: % -> XHashTable(Q, Q)
      ++ sum_\delta rdelta*(vdelta+Kappa_delta)/24
    rootOfUnity: % -> P
      ++ rootOfUnity(x) returns the minimal n such that the n-th
      ++ root of unity in the coefficient ring would be enough
      ++ to express the Laurent series expansions at all cusps of
      ++ Gamma0(level x).
    rdelta: (%, P) -> Z
    xrat: (%, Q, P) -> Q
    xkappa: (%, Q, P) -> Z24
    xudelta: (%, Q, P) -> P
    xvdelta: (%, Q, P) -> Q
    xunityPower: (%, Q, P) -> Q
 == add
    HT ==> XHashTable(P, SymbolicEtaDeltaPower)
    Rep ==> Record(
              flevel: P,  -- level \Gamma_0(level)
              fcusps: LQ, -- all cusps of \Gamma_0(level)
              fdivs: LP,  -- all divisors of level that are given at creation
              fht: HT     -- delta to eta_delta^rdelta mapping
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    level(x: %): P == xx.flevel
    cusps(x: %): LQ == xx.fcusps
    divisors(x: %): LP == xx.fdivs

    -- divs must be ALL divisors of m sorted ascendingly
    etaQuotient(m: P, divs: LP, r: LZ): % ==
        cusps: LQ := cuspsOfGamma0(m)$QAuxMEQ
        gammas: LMZ := [cuspToMatrix(m, cusp)$QAuxMEQ for cusp in cusps]
        ht: HT := empty()
        for delta in divs for rdelta in r repeat
            deltaP: P := qcoerce(delta)@P
            ht.delta := etaPower(m, cusps, gammas, deltaP, rdelta)
        per [m, cusps, divs, ht]

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fcusps)
        ht: HT := xx.fht
        for delta in xx.fdivs repeat
            h := hashUpdate!(hashUpdate!(h, delta), ht.delta)
        h

    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        cusps x ~= cusps y => false
        xx.fht = yy.fht

    ((x: %) * (y: %)): % ==
        xm: P := level x
        ym: P := level y
        xm ~= ym => error "SymbolicEtaQuotient: different levels"
        divs: LP := xx.fdivs
        divs ~= yy.fdivs =>
            error "SymbolicEtaQuotient: different divisors"
        xht := xx.fht
        yht := yy.fht
        ht: HT := empty()
        for delta in divs repeat ht.delta := xht.delta * yht.delta
        per [xm, cusps x, divs, ht]$Rep

    order(x: %, cusp: Q): Z ==
        z: Z := 0
        ht: HT := xx.fht
        for delta in keys ht repeat z := z + udelta(ht.delta, cusp)
        (z exquo 24) :: Z

    rationalPrefactor(x: %, cusp: Q): Q ==
        z: Q := 1
        ht: HT := xx.fht
        for delta in keys ht repeat z := z * rationalPrefactor(ht.delta, cusp)
        z

    unityPower(x: %, cusp: Q): Q ==
        -- exponent for (24*level/c)-th root of unity
        r: Q := 0
        ht: HT := xx.fht
        for delta in keys ht repeat r := r + unityPower(ht.delta, cusp)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den

-------------------------------------------------------------------
    order(x: %): XHashTable(Q, Z) ==
        h: XHashTable(Q, Z) := empty()
        for cusp in xx.fcusps repeat h.cusp := order(x, cusp)
        h

    rationalPrefactor(x: %): XHashTable(Q, Q) ==
        h: XHashTable(Q, Q) := empty()
        for cusp in xx.fcusps repeat h.cusp := rationalPrefactor(x, cusp)
        h

    unityPower(x: %): XHashTable(Q, Q) ==
        -- exponent for (24*level/c)-th root of unity
        h: XHashTable(Q, Q) := empty()
        for cusp in xx.fcusps repeat h.cusp := unityPower(x, cusp)
        h

    rdelta(x: %, delta: P): Z == rdelta(xx.fht.delta)
    xrat(x: %, cusp: Q, delta: P): Q == xrat(xx.fht.delta, cusp)
    xkappa(x: %, cusp: Q, delta: P): Z24 == xkappa(xx.fht.delta, cusp)
    xudelta(x: %, cusp: Q, delta: P): P == xudelta(xx.fht.delta, cusp)
    xvdelta(x: %, cusp: Q, delta: P): Q == xvdelta(xx.fht.delta, cusp)
    xunityPower(x: %, cusp: Q, delta: P): Q == xunityPower(xx.fht.delta, cusp)
    rootOfUnity(x: %): P ==
        lcmP(a, b) ==> qcoerce(lcm(a::Integer, b::Integer))@P
        p: P := 1
        ht: HT := xx.fht
        for delta in keys ht repeat
            h := ht.delta
            for cusp in xx.fcusps repeat p := lcmP(p, denom xvdelta(h, cusp))
        for cusp in xx.fcusps repeat
            p := lcmP(p, denom(unityPower(x, cusp)))
        return p

-------------------------------------------------------------------
)abbrev domain ETAQX EtaQuotientX
EtaQuotientX(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain)
  mx: P
  CX: Algebra C
  xi: CX
  LX: UnivariateLaurentSeriesCategory CX
  LC ==> SparseUnivariateLaurentSeries(C, q, 0)
  Exports ==> SemiGroup with
    --assert(one? xi^mx)
    etaQuotientExpansion: (SymbolicEtaQuotient, Q) -> LX
    etaQuotient: SymbolicEtaQuotient -> %
      ++ etaQuotient(s) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2\pi i\tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(level s).
    order: (%, Q) -> Z
      ++ order(x) returns the order of the expansion in terms of
      ++ x = \exp(2\pi i\tau/w) where w is the width of the cusp.
      ++ It corresponds to the fourth product of eq:g_r(gamma*tau).
    symbolicEtaQuotient: % -> SymbolicEtaQuotient
    expansion: (%, Q) -> LX
    expansions: % -> XHashTable(Q, LX)
  Implementation ==> add
    HT ==> XHashTable(Q, LX)
    Rep ==> Record(fsymetaquo: SymbolicEtaQuotient, fexpansions: HT)
    xx ==> rep x

    q: Symbol := "q"::Symbol
    ef: LC := eulerFunction(1)$QFunctions(C, LC)
    ef1: C := coefficient(ef, 1)
    cache: XHashTable(Z, LC) := getCache()$CachedPower(LC, ef)

    ((x: %) = (y: %)): Boolean == symbolicEtaQuotient x = symbolicEtaQuotient y
    ((x: %) * (y: %)): % ==
        seqx: SymbolicEtaQuotient := symbolicEtaQuotient x
        symetaquo := seqx * symbolicEtaQuotient y
        expansions: HT := empty()
        for cusp in cusps seqx repeat
            expansions.cusp := expansion(x, cusp) * expansion(y, cusp)
        per [symetaquo, expansions]

    coerce(x: %): OutputForm == rep(x)::OutputForm

    RecC ==> Record(k: Z, c: C)
    RecX ==> Record(k: Z, c: CX)
    SFCX ==> StreamFunctions2(RecC, RecX)

    f(u: P, v: N): RecC -> RecX == (x: RecC): RecX +->
        xiPower: N := qcoerce(positiveRemainder(v*x.k, mx))@N
        cc: C := x.c
        cx: CX := xi^xiPower
        cx := cc * cx
        [u*x.k, cx]

    substitute(s: LC, u: P, v: N): LX ==
        stc: Stream RecC := terms s
        stx: Stream RecX := map(f(u, v), stc)$SFCX
        series(stx)$LX

    etaQuotientExpansion(e: SymbolicEtaQuotient, cusp: Q): LX ==
        m: P := level e
        divs: LP := divisors e
        s: LX := 1
        for delta in divs | not zero? (rd: Z := rdelta(e, delta)) repeat
            pow: P := qcoerce(abs rd)@P
            es := power(pow)$CachedPower(LC, ef)
            if rd < 0 then es := recip(es)::LC
            u: P := xudelta(e, cusp, delta)
            v: N := qcoerce(numer(mx * xvdelta(e, cusp, delta)))@N
            s := s * substitute(es, u, v)
        fq: Q := rationalPrefactor(e, cusp)
        import from QAuxiliaryModularEtaQuotientPackage
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)
        q: Q := rr.rat
        p: P := rr.rootOf
        pf: CX := (q::C::CX) * squareRoot(p)$GaussRoot(CX, xi, mx)
        q := mx*unityPower(e, cusp)
        ord: Z := order(e, cusp)
        n: N := qcoerce(positiveRemainder(numer q, mx))@N
        pf := xi^n*pf
        monomial(pf, ord)$LX * s

    etaQuotient(e: SymbolicEtaQuotient): % ==
        h:  XHashTable(Q, LX) := empty()
        for cusp in cusps e repeat h.cusp := etaQuotientExpansion(e, cusp)
        per [e, h]

    order(x: %, cusp: Q): Z == order(xx.fexpansions.cusp)
    expansion(x: %, cusp: Q): LX == xx.fexpansions.cusp
    expansions(x: %): XHashTable(Q, LX) == xx.fexpansions
    symbolicEtaQuotient(x: %): SymbolicEtaQuotient == xx.fsymetaquo

-------------------------------------------------------------------
)abbrev domain ADD2MUL AddToMul
++ AddToMul turns an additive monoid into a multiplicative Monoid
AddToMul(A: AbelianMonoid): Exports == Implementation where
  Exports ==> Monoid with
    coerce: A -> %
    coerce: % -> A
    if A has OrderedAbelianMonoid then OrderedMonoid
  Implementation ==> add
    Rep ==> A
    import from A
    coerce(a: A): % == per a
    coerce(x: %): A == rep x
    1: % == per 0
    ((x: %) * (y: %)): % == per(rep x + rep y)
    ((x: %) ^ (n: N)): % == per(n * rep x)
    ((x: %) = (y: %)): Boolean == rep x = rep y
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState == hashUpdate!(h, rep x)
    rightRecip(x: %): Union(%, "failed") == if one? x then 1 else "failed"
    leftRecip(x: %): Union(%, "failed") == if one? x then 1 else "failed"
    if A has OrderedAbelianMonoid then
        ((x: %) < (y: %)): Boolean == rep x < rep y

-------------------------------------------------------------------
)abbrev domain ETAQXA EtaQuotientExpansionAlgebra
EtaQuotientExpansionAlgebra(C, L, m): Exports == Implementation where
  C: IntegralDomain
  L: UnivariateLaurentSeriesCategory C
  m: P -- level
  Exports ==> XEtaAlgebra C with
    etaQuotient: (LZ, XHashTable(Q, L)) -> %
      ++ etaQuotient(r, t) creates an element that corresponds to
      ++ the eta quotient with exponent vector r and whose
      ++ expansions at all the cusps or Gamma_0(m) is given by t.
    orders: % -> LZ
      ++ orders(x) returns the order at each cusp. If the order at a cusp
      ++ is positive, then 1 is returned.
    leadingCoefficient: (%, P) -> C
    series: (%, P) -> L
  Implementation ==> add
    divs: LP := [qcoerce(d)@P for d in divisors(m)$IntegerNumberTheoryFunctions]
    ndivs: N := # divs
    cusps: LQ := cuspsOfGamma0(m)$QAuxiliaryModularEtaQuotientPackage
    ncusps: P := qcoerce(#cusps)@P
    RVector ==> DirectProduct(ndivs, Z)
    MRVector ==> AddToMul RVector
    EQR ==> MonoidRing(C, MRVector) -- EtaQuotientRepresentation
    Expansions ==> DirectProduct(ncusps, L)
    Rep ==> Record(eqr: EQR, fexpansions: Expansions)
    xx ==> rep x
    yy ==> rep y

    etaQuotient(r: LZ, t: XHashTable(Q, L)): % ==
        rv: Vector Z := vector r
        mrv: MRVector := directProduct(rv)$RVector::MRVector
        e: Expansions := directProduct vector [t.c for c in cusps]
        per [mrv::EQR, e]

    coerce(x: %): OutputForm == xx::OutputForm
    0: % == per [0, 0]
    1: % ==
        r: MRVector := 1
        e: Expansions := 1
        per [r::EQR, e]

    zero?(x: %): Boolean ==
        e := xx.fexpansions
        for i in 1..ncusps repeat
            order(e.i, 0) < 0 => return false
            not zero? e.i.0 => return false
        return true

    ((x: %) + (y: %)): % ==
        per [xx.eqr + yy.eqr, xx.fexpansions + yy.fexpansions]

    ((x: %) * (y: %)): % ==
        per [xx.eqr * yy.eqr, xx.fexpansions * yy.fexpansions]

    ((c: C) * (x: %)): % ==
        r: EQR := c * xx.eqr
        e: Expansions := map((l:L):L +-> c*l, xx.fexpansions)
        per [r, e]

    ((x: %) ^ (n: N)): % == per [xx.eqr ^ n, xx.fexpansions ^ n]

    maxIndex(): P == ncusps
    qetaIndex(x: %): P ==
        --assert(not zero? x)
        maxGrade := -1 -- dummy value
        idx: N := 0
        for kn in ncusps .. 1 by -1 repeat
            k: P := qcoerce(kn)@P
            if (mx := qetaGrade(x, k)) > maxGrade then
                maxGrade := mx
                idx := k
        return qcoerce(idx)@P
    qetaGrade(x: %, k: P): Z == - order(xx.fexpansions.k)
    qetaGrade(x: %, k: P, mn: Z): Z == - order(xx.fexpansions.k, -mn)
    leadingCoefficient(x: %, k: P): C == leadingCoefficient(xx.fexpansions.k)
    qetaLeadingCoefficient(x: %, k: P): C == leadingCoefficient(x, k)
    series(x: %, k: P): L == xx.fexpansions.k
    qetaGrades(x: %): LZ ==
        zero? x => [0 for i in 1..ncusps]
        d: Expansions := xx.fexpansions
        [- order(d.i) for i in 1..ncusps]

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
