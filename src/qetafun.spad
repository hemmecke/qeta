-------------------------------------------------------------------
---
--- FriCAS QEtaa
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
--dbgPrint(x,y) ==> display(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 770)
xdbgPrint(x,y) ==> rhx:="42"

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}
% Euler totient function
\newcommand{\eulerphi}{\varphi}

% Abbreviation for \sum_{\divides{\delta}{#1}}\delta {#2}_\delta
\newcommand{\sumdelta}[2][M]{\hat{#2}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding Dedekind Eta Functions into $q$-series}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}

We expand quotients of Dedekind $\eta$-functions that are modular
functions for $\Gamma_0(N)$ at all cusps into $q$-series.

\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{gather}
  GL_2^+(\setZ)
  :=
  \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix}}{a,b,c,d\in\setZ \land ad-bc>0}
\end{gather}

\begin{gather}
  SL_2(\setZ) := \SetDef{\gamma\in GL_2^+(\setZ)}{\det(\gamma)=1}
\end{gather}

Let $N$ be a positive natural number and define a $\Gamma_0(N)$ as a
subgroup of the special linear group $SL_2(\setZ)$ as follows.
\begin{gather*}
\Gamma_0(N) := \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix} \in SL_2(\setZ)}{\divides{N}{c}}
\end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:epsilon}
  Let $\unityPowerSymbol: \setC \to \setC$ be defined by
  \begin{gather*}
    \unityPower{x} := \exp(2\pi i x).
  \end{gather*}
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\setH=\SetDef{c\in \setC}{\Im(c)>0}$ denote the upper complex
half-plane.

Let
\begin{gather}\label{eq:eta-expansion}
  \eta: \setH \to \setC, \quad
  \tau \mapsto \unityPower{\frac{\tau}{24}}
  \prod_{n=1}^{\infty}(1-q^n)
\end{gather}
with $q = \unityPower{\tau}$
denote the Dedekind eta function.

In the following $N$ denotes a positive integer and
$1=\delta_1<\delta_2\dots<\delta_n=N$ the positive divisors of $N$.
Let $\Delta:=\Set{\delta_1,\ldots,\delta_n}$. For convenience, we
allow to index $n$-dimensional vectors by the divisors of $N$,
instead of the usual index set $\Set{1,\ldots,n}$.
%
For $\delta\in\Delta$ we consider the functions
\begin{gather*}
 \eta_\delta: \setH \to \setC,\quad \tau \mapsto  \eta(\delta\tau)
\end{gather*}
None of these functions is identically zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We define $R(N)$ to be the set of integer tuples
$r = (r_{\delta_1}, \ldots,
r_{\delta_n})\in \setZ^n$.
%
For $r\in R(N)$ let
\begin{align}
  g_r(\tau) &:= \prod_{\delta\in\Delta} \eta(\delta\tau)^{r_\delta}.
  \label{eq:etaquotient}
\end{align}

By $R^*(N)$ we denote the subset of all tuples
$r=(r_\delta)_{\delta\in\Delta}$ of $R(N)$ that fulfil the following
conditions.
\begin{align}
 \sum_{\delta\in\Delta} r_\delta &= 0\label{eq:sum=0}\\
 \sum_{\delta\in\Delta} \delta r_\delta &\equiv 0\pmod{24}\label{eq:sigmainfinity}\\
 \sum_{\delta\in\Delta} (N/\delta)r_\delta &\equiv 0\pmod{24}\label{eq:sigma0}\\
 \sqrt{\prod_{\delta\in\Delta}\delta^{r_\delta}} &\in \setQ\label{eq:productsquare}
\end{align}

Note that $R^*(N)$ is an additive monoid. It even is an additive group.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

According to
\cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016},
there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
$\Gamma_0(N)$ that correspond to a divisor $c$ of $N$.

In the following we always deal with quotients of $\eta$-functions of
level $N$ that are modular functions for $\Gamma_0(N)$.

We implement a domain that deals with such quotients and their
$q$-expansion at all cusps ($q=e^{2\pi i \tau})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transformations of the Dedekind $\eta$-function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's look at the transformation of the $\eta$-function (see
\cite[Lemma~2.27]{Radu:PhD:2010}).

Let $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, then
\begin{gather}
\eta(\gamma\tau) =
\eta\left(\frac{a\tau+b}{c\tau+d}\right) =
(c\tau+d)^{1/2}\,\upsilon(\gamma)\,\eta(\tau)
\label{eq:eta-transformation}
\end{gather}
where $\upsilon(\gamma) := \upsilon_\eta(a,b,c,d)$ as defined as in
\cite[Lemma~2.27]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
Let $\gamma',\gamma''\in SL_2(\setZ)$.
%
Then $\upsilon(\gamma'\gamma'')^2 = \upsilon(\gamma')^2 \upsilon(\gamma'')^2$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
  Let
  $\gamma'=\left(\begin{smallmatrix}a'&b'\\c'&d'\end{smallmatrix}\right)$
  and
  $\gamma''=\left(\begin{smallmatrix}a''&b''\\c''&d''\end{smallmatrix}\right)$
  be in $SL_2(\setZ)$.
  %
  Then
  $\gamma'\gamma'' =
  \left(\begin{smallmatrix}a'a''+b'c''&a'b''+b'd''\\c'a''+d'c''&c'b''+d'd''\end{smallmatrix}\right)$.
  We set $c:=c'a''+d'c''$ and $d:=c'b''+d'd''$.
%
  If $\tau'=\gamma''\tau$, we derive for any $\tau \in \setH$:
  \begin{gather*}
    c' \tau' + d'
    =
      \left(c' \frac{a''\tau + b''}{c''\tau + d''} +d'\right)
    =
      \left(\frac{c'a''\tau + c'b''+ d'c''\tau + d'd''}{c''\tau + d''}\right)
    =
    \left(\frac{c\tau + d}{c''\tau + d''}\right).
  \end{gather*}
%
  \begin{align*}
    (c \tau + d)^{1/2}\,\upsilon(\gamma)\,\eta(\tau)
    &=
    \eta((\gamma'\gamma'')\tau) =
    \eta(\gamma'\tau')
    =
      (c'\tau'+d')^{1/2}\,\upsilon(\gamma')\,\eta(\tau')\\
    &=
      \left(\frac{c\tau + d}{c''\tau + d''}\right)^{1/2} \,(c''\tau+d'')^{1/2}
      \,\upsilon(\gamma')\,\,\upsilon(\gamma'')\eta(\tau).
  \end{align*}
  After squaring both sides and cancelling equal terms, the statement
  of the Lemma can be concluded.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta$ under $GL_2^+(\setZ)$}
\label{sec:eta-transformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$W=\left(\begin{smallmatrix}A&B\\C&D\end{smallmatrix}\right) \in
GL_2^+(\setZ)$.
%
Then for $h=\gcd(A, C)>0$, $a':=\frac{A}{h}$, $c':=\frac{C}{h}$ we
have $\gcd(a', c')=1$ and thus can find $b'$ and $d'$ such that
$a'd'-b'c'=1$.
%
Let
\begin{gather*}
  W':=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix},
  \qquad
  W''
  :=
  \begin{pmatrix}
    h &B d'-D b'\\
    0 & \det(W) / h
  \end{pmatrix}.
\end{gather*}
Then $W'\in SL_2(\setZ)$ and $W = W' W''$.


Note that for any integer $s$ whe have:
\begin{align}
W = \begin{pmatrix}A&B\\C&D\end{pmatrix}
&=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}h &B d'- D b'\\0 &\det(W) / h\end{pmatrix}
  \\
&=
  \begin{pmatrix} a'&b' + a' s\\ c'&d' + c' s \end{pmatrix}
  \begin{pmatrix}
    h &B d'- D b'- s \det(W) / h\\
    0 &\det(W) / h\end{pmatrix}.
\end{align}
Therefore, we can choose $b'$ and $d'$ in such a way that
$0 \le B d'-D b' < \det(W)/h$.

Let $\tau' := W''\tau = \frac{h}{\det(W)}(h\tau + B d'- D b')$, then
$\tau'\in\setH$ and
\begin{gather}
\eta(W\tau) =
\eta(W'\tau') =
(c'\tau+d')^{1/2}\,\upsilon_\eta(W')\,\eta(\tau')
\label{eq:eta-W-transformation}
\end{gather}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}\label{thm:c*tau+d}
  Let $\gamma := \left(
    \begin{smallmatrix}a&b\\c&d\end{smallmatrix} \right)\in
  SL_2(\setZ)$, $\delta>0$, $m>0$, $z\ge0$, and
  \begin{gather*}
    W=
    \begin{pmatrix}
      \delta & z\\
      0      & m
    \end{pmatrix}
    \gamma
    = \begin{pmatrix}
        \delta a + c z & \delta b + d z\\
        c m & d m
      \end{pmatrix}
    \in GL_2^+(\setZ).
  \end{gather*}
  Then $\det(W)=\det(H)=\delta m$.
  %
  If
  $h:=\gcd(\delta a + c z, cm)$,
  $a':=\frac{\delta a + c z}{h}$,
  $c':=\frac{c m}{h}$, and
  $b'$ and $d'$ are such that $a'd'-b'c'=1$ and
  $0 \le (\delta b + d z) d' - d m b' < cm/h$, \ie,
  \begin{gather*}
    W':=\begin{pmatrix}
      (\delta a + c z) / h & b'\\
      c m / h                    & d'
    \end{pmatrix},
    \qquad
    W''
    :=
    \begin{pmatrix}
      h & (\delta b + d z) d' - d m b'\\
      0 & \delta m / h
    \end{pmatrix}.
  \end{gather*}
  according to the splitting above.

  Then with $\tau':=W''\tau$ we have
  $c'\tau'+d' = \frac{h}{\delta} (c\tau + d)$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}

\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{h}{\delta m}(h\tau + (\delta b + d z) d' - d m b')
    \right) + d'\\
  &=
    \frac{c m}{h}
    \left(
    \frac{h}{\delta m}(h\tau + (\delta b + d z) d' - d m b')
    \right) + d'\\
  &=
    \frac{1}{\delta}
    \left(
    h c \tau + b c \delta d' + c d d' z - c d m b'
    \right) + d'\\
  &=
    \frac{1}{\delta}
    \left(
    h c \tau + (a d - 1) \delta d' + c d d' z - c d m b'
    + \delta d'
    \right)\\
  &=
    \frac{1}{\delta}
    \left(
    h c \tau + a d \delta d' + c d d' z - c d m b'
    \right)\\
  &=
    \frac{1}{\delta}
    \left(
    h c \tau + h d (a' d' - c' b')
    \right)\\
  &=
    \frac{h}{\delta} (c\tau + d)
\end{align*}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_\delta$ under $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\delta \in \setN\setminus\Set{0}$.

\begin{gather*}
\eta_\delta(\gamma\tau)
=
\eta_\delta\left(\frac{a\tau+b}{c\tau+d}\right) =
\eta\left(\frac{a\delta\tau+b\delta}{c\tau+d}\right)
=
\eta\left(\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
  \tau\right).
\end{gather*}

Let
%
\begin{gather}
  h_\delta:=\gcd(\delta a,c), \label{eq:h_delta}
\end{gather}
%
$a_\delta:=\frac{\delta a}{h_\delta}$,
%
$c_\delta:=\frac{c}{h_\delta}$,
%
and $b_\delta$ and $d_\delta$ are chosen in such a way that
$a_\delta d_\delta - b_\delta c_\delta = 1$.
%
Because of $\gcd(a_\delta, c_\delta)=1$, such $b_\delta$ and $d_\delta$
can be found.
%
Therefore
  $\gamma_\delta := \left(
  \begin{smallmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{smallmatrix}
\right)\in SL_2(\setZ)$.

Note that $h_\delta=\gcd(\delta, c)$, because $\gcd(a,c)=1$ and,
furthermore,

\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\label{eq:naive-matrix-split}
\end{align}
Note that for any integer $s$ whe have:
\begin{align*}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}
    h_\delta&\delta b d_\delta-d b_\delta\\
    0      &\delta / h_\delta\end{pmatrix}
  \\
&=
  \begin{pmatrix}
    a_\delta&b_\delta + a_\delta s\\
    c_\delta&d_\delta + c_\delta s
  \end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta-s \delta / h_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\end{align*}
Therefore, we can choose $b_\delta$ and $d_\delta$ in such a way that
$0 \le \delta b d_\delta-d b_\delta < \delta/h_\delta$.

If $c=0$, then $a=d=1$, $h_\delta=\delta$. We can choose $d_\delta=1$
and $b_\delta= \delta b  d_\delta$ and get
\begin{align}
\begin{pmatrix}\delta&b\delta\\0&1\end{pmatrix}
&=\begin{pmatrix}1&b \delta\\0&1\end{pmatrix}
  \begin{pmatrix}\delta&0\\
                 0      &1\end{pmatrix}.
\end{align}

If we set
\begin{gather}
  \tau_\delta:=\begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\0&\delta
    / h_\delta\end{pmatrix} \tau
  = \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta},
  \label{eq:tau_delta}
\end{gather}
then
\begin{gather*}
  \eta_\delta(\gamma\tau)
  =
  \eta(\gamma_\delta \tau_\delta)
  =
  (c_\delta\tau_\delta+d_\delta)^{1/2}
  \,
  \upsilon(\gamma_\delta)
  \,
  \eta(\tau_\delta).
\end{gather*}


From Lemma~\ref{thm:c*tau+d} we get
\begin{align*}
  c_\delta\tau_\delta+d_\delta
  &=
  \frac{h_\delta}{\delta}(c \tau + d).
\end{align*}

Thus, we have
\begin{gather}
\eta_\delta(\gamma\tau)
=
\left(\frac{h_\delta}{\delta}(c \tau+d)\right)^{\!1/2}
\unityPower{\frac{\kappa_\delta}{24}}
\,
\eta(\tau_\delta).
\label{eq:eta_delta(gamma*tau)}
\end{gather}
where $\kappa_\delta \in \Set{0,\ldots,23}$ is defined by
$\unityPower{\frac{\kappa_\delta}{24}}
:= \upsilon(\gamma_\delta)$.



For the following definition see \cite[Lemma~2.37]{Radu:PhD:2010} and
\cite[Definition~2.9]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:width}
  Let
  $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)
  \in SL_2(\setZ)$ and $N$ be a positive integer. Then
  \begin{gather}
    w_\gamma = \frac{N}{\gcd(c^2, N)}
    \label{eq:width}
  \end{gather}
  is called the \emph{width of $\gamma$ with respect to $\Gamma_0(N)$}.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For
$\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ we want to expand $\eta(\tau_\delta)$ in
$x:=q^{1/w_\gamma}=\unityPower{\frac{\tau}{w_\gamma}}$ with
coefficients from $\setQ(\xi)$ where
$\xi := \unityPower{\frac{c}{24N}}$.

Since we are only interested in expansions at the cusps, we can assume
$0<c\in\Delta$.

In the following let $\delta \in \Delta$. Because of
$x=q^{1/w_\gamma}$, \eqref{eq:tau_delta} and \eqref{eq:width}, we
have
\begin{align}
  q_\delta = \unityPower{\tau_\delta}
  &= x^{u_\delta} \, \unityPower{v_\delta}
\label{eq:q_delta}
\end{align}
for
\begin{gather}
  u_\delta := \frac{w_\gamma h_\delta^2}{\delta},
  \qquad
  v_\delta := \frac{\delta b d_\delta-d b_\delta}{\delta/h_\delta}.
  \label{eq:uv_delta}
\end{gather}
In particular, if $c=0$, then $a=d=1$, $w_\gamma=1$,
$h_\delta=\delta$, $u_\delta=\delta$, $v_\delta=0$.

%
Note that $\unityPower{\frac{v_\delta}{24}} = \xi^k$ for
$k = (\delta b d_\delta - d b_\delta) \frac{N}{\lcm(\delta,c)}\in \setZ$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  If $\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$, $N > 0$, $\delta \in \Delta$, then
$u_\delta \in \setZ$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
If $c=0$, then $u_\delta=\delta\in\setZ$. Without loss of generality,
we can assume $c>0$.
If $p$ is a prime that divides $N$, \ie, $N=N'p^\alpha$ for some
$\alpha>0$, and $\delta = \delta' p^m$, $c=c' p^k$ with
$\gcd(p,N')=\gcd(p,\delta')=\gcd(p,c')=1$, then
\begin{align*}
  u_\delta
  &=
  \frac{N}{\gcd(c^2,N)} \frac{\gcd(\delta,c)^2}{\delta}\\
  &=
  \frac{p^\alpha N' \gcd(p^m \delta', p^k c')^2}{\gcd(p^{2k}
    c'^2,p^\alpha N') p^m \delta'}\\
  &=
  p^{\alpha + 2 \min(m,k) - m - \min(2k, \alpha)}
  \frac{N' \gcd(\delta', c')^2}{\gcd(c'^2, N') \delta'}
\end{align*}
If we can show that $e:=\alpha + 2 \min(m,k) - m - \min(2k,
\alpha)\ge0$ then $u_\delta\in\setN$ follows by repeating the above
process for every prime divisor of $N$.

There are several cases to consider:
\begin{itemize}
\item $0\le m\le k \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2m-m-2k=(\alpha-2k)+m\ge0$.
\item $0\le m\le k \le \alpha < 2k$. Then
  $e=\alpha+2m-m-\alpha=m\ge0$.

\item $0\le k\le m \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2k-m-2k=\alpha-m\ge0$.
\item $0\le k\le m \le \alpha < 2k$. Then
  $e=\alpha+2k-m-\alpha=2k-m\ge0$.
\end{itemize}
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We can expand $\eta(\tau_\delta)$ in terms of $x$ as follows.
\begin{gather*}
  \eta(\tau_\delta)
  =
    \unityPower{{\frac{\tau_\delta}{24}}}
    \prod_{n=1}^{\infty}(1-q_\delta^n)
  =
  \unityPower{\frac{v_\delta}{24}} x^{u_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n)
\end{gather*}

Then \eqref{eq:eta_delta(gamma*tau)} turns into
\begin{align}
\eta_\delta(\gamma\tau)
&=
(c \tau+d)^{1/2}
\,
\left(\frac{h_\delta}{\delta}\right)^{\!\frac{1}{2}}
\,
  \unityPower {\frac{v_\delta + \kappa_\delta}{24}}
  x^{u_\delta/24} \cdot \prod_{n=1}^{\infty}(1-q_\delta^n).
\label{eq:eta_delta(gamma*tau)-expansion}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  For any $c, \delta \in\Delta$, $r\in R(N)$ let us define
  \begin{align}
    a_N(c, \delta) &:= \frac{N}{\gcd(N, c^2)}
                       \frac{\gcd(c,\delta)^2}{\delta},\notag\\
    \ord_c^N(r) &:= \frac{1}{24}\sum_{\delta\in\Delta} a_N(c, \delta) \, r_\delta,
    \label{eq:order-r}
    \intertext{and}
    g_r(\tau) &:= \prod_{\delta\in\Delta} \eta(\delta\tau)^{r_\delta}.
    \label{eq:g_r(tau)}
  \end{align}
\end{Definition}

With $\ord_\gamma^N$ as defined in \cite{Radu:RamanujanKolberg:2015},
Theorem~23 of \cite{Radu:RamanujanKolberg:2015} turns into
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\label{thm:order}
  Let $\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c\in\Delta$.
  If $r \in R^*(N)$, then
  $\ord_\gamma^N(g_r) = \ord_c^N(r)$.
\end{Theorem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For a proof we refer to
\cite[Proposition~3.2.8]{Ligozat:CourbesModulaires:1975}.

In the following let us fix $r \in R(N)$ and
$\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c \in \Delta$.

From \eqref{eq:eta_delta(gamma*tau)-expansion} follows
\begin{align}
  g_r(\gamma \tau)
  &=
  \prod_{\delta\in\Delta}
  (c \tau+d)^{r_\delta/2}
  \,
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \,
  \unityPower{\frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{r_\delta u_\delta/24}
  \cdot
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}
  \notag
  \\
  %
  &=
  (c \tau+d)^{\sum_{\delta\in\Delta} \frac{r_\delta}{2}}
  \cdot
  \prod_{\delta\in\Delta}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\sum_{\delta\in\Delta} \frac{r_\delta u_\delta}{24}}
  \cdot
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}.
  \label{eq:g_r(gamma*tau)}
\end{align}
%
If $r\in R^*(N)$, then because of \eqref{eq:sum=0},
$u_\delta=a_N(c, \delta)$, and \eqref{eq:order-r}, we can write
\begin{align}
  g_r(\gamma \tau)
  &=
  \prod_{\delta\in\Delta}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\ord^N_c(r)}
  \cdot
  \prod_{\delta\in\Delta}
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  \label{eq:modular-g_r(gamma*tau)}
\end{align}
Thus, we can expand $g_r(\gamma\tau)$ as a Laurent series in
$x:=q^{1/w_\gamma}$ with coefficients from $\setQ(\xi)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Root of unity reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that any modular function (in particular $g_r$) can be expressed
as a rational function $f$ in $j$ and $j_N$ where
$j_N(\tau):=j(N\tau)$ and $j$ is Klein's $j$-invariant, \ie,
$g_r(\tau)=f(j, j_N)(\tau) := f(j(\tau), j(N\tau))$.

Let $\frac{a}{c}$ be a cusp of $\Gamma_0(N)$.
%
We can choose $b$ and $d$ such that
%
$\gamma := \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ and $\gamma\infty=\frac{a}{c}$.
%
Klein's $j$-function is invariant under any modular transformation.
%
Let us consider the transformation of $j_N$ by $\gamma$.
%
According to \eqref{eq:tau_delta} for $\delta=N$, $j_N(\gamma\tau)$
can be expanded into a Laurent series in
$x=q^{1/w_\gamma}=\unityPower{\tau/w_\gamma}$ with
coefficients from $\setQ(\xi)$ where $\xi$ is a $\frac{N}{c}$-th root
of unity.
%
Since there is some freedom to choose such $b$ and $d$, we show in the
following, how we can obtain an expansion of $j_N(\gamma\tau)$ and
therefore (via $f$) an expansion $g_r(\gamma\tau)$ into a Laurent
series in $x$ with coefficients in $\setQ(\xi)$ where $\xi$ is a
$v$-th root of unity and $1 \leq v \le N/c$ and $v<N/c$ if $c<N$.

Let
$\gamma' = \bigl(
\begin{smallmatrix}
  a & b'\\
  c & d'
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$, then also
\begin{align*}
  \gamma
  &:=
    \begin{pmatrix}
      a & b' + as\\
      c & d' + cs
    \end{pmatrix}
  =
    \begin{pmatrix}
      a & b'\\
      c & d'
    \end{pmatrix}
    \begin{pmatrix}
      1 & s\\
      0 & 1
    \end{pmatrix}
    \in SL_2(\setZ)
\end{align*}
for any $s\in\setZ$.

For the transformation of $j_N$, we split the matrix as in
\eqref{eq:naive-matrix-split} with $\delta=N$.
\begin{align*}
  \begin{pmatrix}
    N a & N(b' + as)\\
    c & d' + cs
  \end{pmatrix}
      &=
  \begin{pmatrix}
    N a/c & -1\\
    1     &  0
  \end{pmatrix}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix}
\end{align*}
into an element of $SL_2(Z)$ and a triangular matrix.
%
Then we determine natural numbers $u$ and $v$ such that $u v = N/c$
and $\gcd(c, u)=1$. Thus, we can find $s \in \setZ$ such that
$s \equiv -d'c^{-1} \pmod{u}$, \ie, $cs + d' = tu$ for some integer
$t$ with $0\le t<c$.
%
Thus,
\begin{gather*}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix} \tau
  =
  \begin{pmatrix}
    c & u t\\
    0 & u v
  \end{pmatrix} \tau
  =
  \frac{c^2}{N} \tau + \frac{t}{v}
  =
 \frac{w_\gamma c^2}{N} \frac{\tau}{w_\gamma} + \frac{t}{v}
  =
 \frac{c}{\gcd(c,N/c)} \frac{\tau}{w_\gamma} + \frac{t}{v}
  .
\end{gather*}
Note that $u=N/c$ and $v=1$, if $N$ is squarefree.

With the particular $s$ from above, we define $b:=b'+as$, $d:=d'+cs$
and take
%
$\gamma = \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr)$ as the transformation matrix that belongs to the cusp
$\frac{a}{c}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The function $h_{r,m,t}$ and its transformations under
  $SL_2(\setZ)$ and $\Gamma_0(N)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Given a positive integer $m$ and $t\in\Set{0,\ldots,m-1}$, a positive
integer $M$, and $r \in R(M)$ such that
\begin{gather*}
  f(\tau)
  =
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\divides{\delta}{M}}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
  =
  \unityPower{-\frac{\tau \, \sumdelta{r}}{24}} g_r(\tau)
\end{gather*}
is the generating function for the sequence $(a(n))_{n\in\setN}$
where we have abbreviated
\begin{gather}
  \sumdelta{r} := \sum_{\delta|M}\delta r_\delta.
\end{gather}

Let $U_m$ be an operation on functions $\setH\to\setC$ so that
\begin{gather*}
  (U_m\phi)(\tau) := \frac{1}{m}\sum_{\lambda=0}^{m-1}
  \phi\left(\frac{\tau+\lambda}{m}\right).
\end{gather*}
Let $f_t(\tau):=\unityPower{-t\tau}f(\tau)$, then
\begin{align*}
  (U_mf_t)(\tau)
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}f_t\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{t\tau+t\lambda}{m}}
  \sum_{k=0}^\infty a(k) \unityPower{\frac{k\tau+n\lambda}{m}}
  \\
  &=
  \frac{1}{m}
  \sum_{k=0}^\infty
  a(k)
  \sum_{\lambda=0}^{m-1}
  \unityPower{\frac{(k-t)(\tau+\lambda)}{m}}
  \\
  &=
  \frac{1}{m}
  \sum_{k=0}^\infty
  a(k)\,
  \unityPower{\frac{(k-t)\tau}{m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{\frac{(k-t)\lambda}{m}}
  \\
  &=
    \sum_{n=0}^\infty
    \sum_{l=0}^{m-1}
  a(mn+l)\,
  \unityPower{\frac{(mn+l-t)\tau}{m}}
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}\unityPower{\frac{(mn+l-t)\lambda}{m}}\\
  &=
    \sum_{n=0}^\infty a(mn+t) q^n
\end{align*}

Note that
$\sum_{\lambda=0}^{m-1}\unityPower{\frac{(mn+l-t)\lambda}{m}}$ is
equal to $m$ for $l=t$ and vanishes in all other cases.

We can also evaluate $(U_mf_t)(\tau)$ in another way.

\begin{align*}
  (U_mf_t)(\tau)
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}f_t\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{t\tau+t\lambda}{m} - \frac{\tau+\lambda}{24m} \sumdelta{r}}
  g_r\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m}
  \unityPower{-\frac{\tau (24t+\sumdelta{r})}{24m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda (24t+\sumdelta{r})}{24m}}
  \prod_{\divides{\delta}{M}}
    \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}\\
\end{align*}

In the following we consider the function

\begin{align}
  h_{r,m,t}(\tau)
  &:= \unityPower{\frac{\tau (24t+\sumdelta{r})}{24m} } (U_mf_t)(\tau)=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
  \prod_{\divides{\delta}{M}}
  \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{r_\delta}
  \label{eq:def-h-r-m-t}
\end{align}
and its transformations under $SL_2(\setZ)$ and $\Gamma_0(N)$.

In order to algorithmically find a Ramanujan-Kolberg relation for
$\sum_{n=0}^\infty a(m n + t)$ we restrict the choice of
$N\in\setN\setminus\Set{0}$ in such a way, that
\begin{gather}
  \text{for every prime $p$ with $\divides{p}{m}$ follows $\divides{p}{N}$,}
  \label{eq:p|m=>p|N}\\
  \text{and, if $\divides{\delta}{M}$ and $r_\delta\ne0$, then
    $\divides{\delta}{mN}$.}
  \label{eq:delta|M=>delta|mN}
\end{gather}

For the above conditions see (13) and (14) in
\cite{Radu:AlgorithmicApproachRamanujanCongruences:2009} or
Section~4.2 in \cite{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_{\delta,m,\lambda}$ under
  $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $m$ and $N$ be a positive integers,
$\lambda \in \Set{0,\ldots,m-1}$, and $\divides{\delta}{M}$.
%
We define
\begin{gather}
\eta_{\delta,m,\lambda}(\tau) := \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix} \tau
\right).
\label{eq:eta_delta-m-lambda}
\end{gather}

Let
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$.
%
Then
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &:= \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix}
  \gamma
  \tau
\right)
=
\eta(W \tau)
\end{align}
where
\begin{align}
  W &:=
  \begin{pmatrix}
    \delta (a + c \lambda) & \delta (b + d \lambda)\\
    c m                   & d m
  \end{pmatrix}.
  \label{eq:W_delta-m-lambda}
\end{align}

Let us apply the splitting of $W=W'W''$ into a matrix
$W'\in SL_2(\setZ)$ and an upper triangular matrix $W''$ as in the
Section~\ref{sec:eta-transformation}.

We get
%
$\det(W) = \delta m$, because $\det(\gamma)=1$.
%
Furthermore,
$h = \gcd(\delta(a + c \lambda), cm)$,
%
$a' = \frac{a + c \lambda}{h}$, and
%
$c' = \frac{cm}{h}$.
%

We find $b'$ and $d'$ according to
Section~\ref{sec:eta-transformation} such that
$a' d' - b' c' =1$, \ie, $\det(W')=1$ for
\begin{gather}
  W'= \begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  = \begin{pmatrix}
      \delta(a+c \lambda)/h & b'\\
      cm/h                  & d'
    \end{pmatrix}.
  \label{eq:W'_delta-m-lambda}
\end{gather}

For the matrix $W''$ we obtain
\begin{gather}
  W''
  =
  \begin{pmatrix}
    h & \delta ((b + d \lambda) d')\\
    0      & \delta m / h
  \end{pmatrix}
  \label{eq:W''_delta-m-lambda}
\end{gather}
where $b'$ and $d'$ have been chosen in such a way that
$0\le  \delta (b + d \lambda) d' < \delta m / h$.

Note that
\begin{align*}
  W = W'\cdot W''
  &=
    \begin{pmatrix}a'& b'\\c'&d'\end{pmatrix}
    \cdot
    \begin{pmatrix}1& \delta s\\0&1\end{pmatrix}
    \begin{pmatrix}1&-\delta s\\0&1\end{pmatrix}
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& b' + a'\delta s\\c'&d' + c' \delta s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&-s\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& \delta(b^* + (a+c \lambda)s)\\c'&d' + c m s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma-sm\\0&m\end{pmatrix}
\end{align*}


Clearly, we can choose $s\in\setZ$ such that
$0 \le \lambda_\gamma - sm < m$.
%
In the following, we assume that already in the first place we have
chosen $b^*$ and $d'$ in such a way that $0\le \lambda_\gamma < m$. In
other words, we assume functions $(\gamma,\delta,m,\lambda)\mapsto W'$
and $(\gamma,m,\lambda)\mapsto \lambda_\gamma$.

Note that $\lambda_\gamma$ does depend on $\gamma$, $\lambda$, and
$m$, but it does not depend on $\delta$.

With $\tau':=W''\tau$ we have
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d' - d m b'}{m}
    \right) + d'\\
  &=
    \frac{cm}{\delta}
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d'}{m}
    \right)  - d b' c' + d'\\
  &=
    c\tau + c(b + d \lambda) d' - d (a' d' -1) + d'\\
  &=
    c\tau + d + c(b + d \lambda) d' - d a' d' + d'\\
  &=
    c\tau + d + [c(b + d \lambda) - d (a + c \lambda) + 1]d'\\
  &=
    c\tau + d
\end{align*}
and thus
\begin{align*}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &= \eta(W \tau) = \eta(W'W''\tau) = \eta(W'\tau')\\
  &= (c'\tau'+d')^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \,\eta(\tau')\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta(W''\tau)\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta
    \left(
    \begin{pmatrix}
      \delta & \delta \lambda_\gamma\\
      0      & m
    \end{pmatrix}
    \tau
    \right)\\
  &= (c\tau+d)^{1/2} \upsilon_{\gamma,\delta,m,\lambda} \, \eta_{\delta,m,\lambda_\gamma}(\tau)
\end{align*}
where $\upsilon_{\gamma,\delta,m,\lambda} := \upsilon(W')$ and
$\lambda_\gamma = d d' \lambda + b d' - d m b^*$, see \eqref{eq:lambda_gamma}.

Note that $d$ and $d'$ are invertible modulo $m$, \ie, given
$\lambda_\gamma$, we can find $\lambda$ such that
$\lambda\in\Set{0,\ldots,m-1}$ and
$\lambda_\gamma= d d' \lambda +  b d' - d m b^*$ holds.
%
We have $\gcd(d',m)=1$ by choice of $d'$. Because $\det(\gamma)=1$ and
$\divides{N}{c}$, it follows $\gcd(N, d)=1$. From \eqref{eq:p|m=>p|N}
follows invertibility of $d$ modulo $m$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $h_{r,m,t}$ under
  $\Gamma_0(N) \subset SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Hemmecke}
  Cannot use this section for expansion, since it only describes
  formulas for $\Gamma_0(N)$.
\end{Hemmecke}

From the previous section, we can easily find a formula for the
transformation of $h_{r,m,t}$ under $SL_2(\setZ)$.

\begin{align*}
  h_{r,m,t}(\gamma\tau)
  &:=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
  \prod_{\divides{\delta}{M}}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{r_\delta}
  \\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
    (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
    \prod_{\divides{\delta}{M}}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
    \prod_{\divides{\delta}{M}} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}
\end{align*}

Let us compare this with \eqref{eq:def-h-r-m-t} where we have replaced
$t$ by $t'$ with $t' = t x + \frac{x-1}{24}s+km$ for some
$x\in\setN$ and $k\in\setZ$ such that $0\le t' < m$.
\begin{align}
  h_{r,m,t'}(\tau)
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}
    \Bigl(24\bigl(t x + \frac{x-1}{24}s+km\bigr)+\sumdelta{r}\Bigr)}
  \prod_{\divides{\delta}{M}}
  \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24 t + \sumdelta{r}) x}
  \prod_{\divides{\delta}{M}} \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
  \prod_{\divides{\delta}{M}} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}.
\end{align}

If we can find some $x\in\setZ$ and $\kappa(r,t)\in\setC$ such that
for every $0\le \lambda<m$
\begin{gather}
  \unityPower{-\frac{\lambda}{24m} (24t + \sumdelta{r})}
    \prod_{\divides{\delta}{M}}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
  = \kappa(r, t) \cdot
    \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
\end{gather}

According to
\cite[Thm.~2.14]{Radu:AlgorithmicApproachRamanujanCongruences:2009},
we choose $x=a^2$ and

\begin{gather*}
  \kappa(r,t)
  =
  \beta(\gamma,0) \, \unityPower{\frac{24t+\sumdelta{r}}{24m} ab(1-m^2)}
\end{gather*}

\begin{align*}
  \kappa(r, t)
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m} (\lambda - \lambda_\gamma x)}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda - ((b + d \lambda) d' - d m b^*) x)}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda(1 - dd'x) - (b d' - d m b^*) x}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expansion of $\eta_{\delta,m,\lambda}(\tau)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

If we set
\begin{gather}
  \tau_{\delta,m,\lambda}
  :=
    \begin{pmatrix}
      \delta & \delta \lambda\\
      0      & m
    \end{pmatrix}
    \tau
  = \frac{\delta \tau + \delta \lambda}{m},
  \label{eq:tau_delta_m_lambda}
\end{gather}
then we can write
\begin{align*}
  \eta_{\delta,m,\lambda}(\tau)
  &= \eta(\tau_{\delta,m,\lambda})
  = \unityPower{\frac{\delta}{24 m} \tau + \frac{\delta
    \lambda}{24m}}
    \prod_{n=1}^\infty(1-q_{m,\lambda}^{\delta n})
  = \xi_m^{\delta \lambda} q_{m,\lambda}^{\delta/24}
    \prod_{n=1}^\infty(1-q_{m,\lambda}^{\delta n})
\end{align*}
where $q_{m,\lambda}=\xi_m^{\lambda} x_m$,
$x_m = \unityPower{\frac{\tau}{m}}$,
$\xi_m= \unityPower{\frac{1}{24m}}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expansion of $h_{r,m,t}(\gamma \tau)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For $h_{r,m,t}(\gamma \tau)$ we then have
\begin{align*}
  h_{r,m,t}(\gamma\tau)
  &=
  (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
    \xi_m^{-\lambda(24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
    \prod_{\divides{\delta}{M}} \left(\xi_m^{\delta \lambda_\gamma}
    q_{m,\lambda_\gamma}^{\delta/24}
    \prod_{n=1}^\infty(1-q_{m,\lambda_\gamma}^{\delta n})\right)^{r_\delta}\\
  &=
  (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
    \xi_m^{-\lambda(24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
    \cdot
    \xi_m^{\lambda_\gamma \sumdelta{r}}
    q_{m,\lambda_\gamma}^{\sumdelta{r}/24}
    \prod_{\divides{\delta}{M}} \left(
    \prod_{n=1}^\infty(1-q_{m,\lambda_\gamma}^{\delta n})\right)^{r_\delta}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find ``modular'' cofactor for $h_{r,m,t}(\tau)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
According to \cite[Thm.~45]{Radu:RamanujanKolberg:2015}


\subsection{Transformation of $\eta_{\delta,m,\lambda}$ under
  $\Gamma_0(N)\subset SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $m$ and $N$ be a positive integers,
$\lambda \in \Set{0,\ldots,m-1}$, and $\divides{\delta}{M}$.
%
We define
\begin{gather}
\eta_{\delta,m,\lambda}(\tau) := \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix} \tau
\right).
\end{gather}

Let $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\Gamma_0(N)$.
%
Then
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &:= \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix}
  \gamma
  \tau
\right)
=
\eta(W \tau)
\end{align}
where
\begin{align}
  W &:=
  \begin{pmatrix}
    \delta (a + c \lambda) & \delta (b + d \lambda)\\
    c m                   & d m
  \end{pmatrix}.
  \label{eq:W_delta-m-lambda}
\end{align}

Let's apply the splitting of $W=W'W''$ into a matrix
$W'\in SL_2(\setZ)$ and an upper triangular matrix $W''$ as in the
Section~\ref{sec:eta-transformation} and compare with the proof of
Lemma~2.2 of \cite{Radu:AlgorithmicApproachRamanujanCongruences:2009}.

We get
%
$\det(W) = \delta m$, because $\det(\gamma)=1$.

Furthermore,
$h = \gcd(\delta(a + c \lambda), \delta \frac{cm}{\delta})=\delta$,
%
$a' = a + c \lambda$, and
%
$c' = \frac{cm}{\delta}$.
%
From \eqref{eq:delta|M=>delta|mN} and $\divides{N}{c}$ (because
$\gamma \in \Gamma_0(N)$) follows $\divides{\delta}{mc}$ and
$c'\in \setZ$.

Note that $\gcd(a,c)=1$. Thus $\gcd(a + c \lambda, c)=1$ and because of
$\divides{N}{c}$,
% ($\gamma \in \Gamma_0(N)$)
it follows $\gcd(a + c \lambda, N)=1$.
%
Then \eqref{eq:p|m=>p|N} implies $\gcd(a + c \lambda, m)=1$.
%
Therefore $\gcd(a + c \lambda, cm)=1$ and we can find $b^*$ and $d'$ such
that $(a + c \lambda) d' - b^* cm =1$. It also holds $\gcd(a', c')=1$ and we
can choose $b'=\delta b^*$ such that $\det(W')=1$ for
\begin{gather}
  W'= \begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  = \begin{pmatrix}a+c \lambda& \delta b^*\\cm/\delta&d'\end{pmatrix}.
  \label{eq:W'_delta-m-lambda}
\end{gather}

For the matrix $W''$ we obtain
\begin{gather}
  W''
  =
  \begin{pmatrix}
    \delta & \delta ((b + d \lambda) d' - d m b^*)\\
    0      & m
  \end{pmatrix}
  =
  \begin{pmatrix}
    \delta & \delta \lambda_\gamma\\
    0      & m
  \end{pmatrix}.
  \label{eq:W''_delta-m-lambda}
\end{gather}
where
\begin{gather}
  \lambda_\gamma := (b + d \lambda) d' - d m b^*.
  \label{eq:lambda_gamma}
\end{gather}

Note that
\begin{align*}
  W = W'\cdot W''
  &=
    \begin{pmatrix}a'& b'\\c'&d'\end{pmatrix}
    \cdot
    \begin{pmatrix}1& \delta s\\0&1\end{pmatrix}
    \begin{pmatrix}1&-\delta s\\0&1\end{pmatrix}
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& b' + a'\delta s\\c'&d' + c' \delta s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&-s\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& \delta(b^* + (a+c \lambda)s)\\c'&d' + c m s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma-sm\\0&m\end{pmatrix}
\end{align*}


Clearly, we can choose $s\in\setZ$ such that
$0 \le \lambda_\gamma - sm < m$.
%
In the following, we assume that already in the first place we have
chosen $b^*$ and $d'$ in such a way that $0\le \lambda_\gamma < m$. In
other words, we assume functions $(\gamma,\delta,m,\lambda)\mapsto W'$
and $(\gamma,m,\lambda)\mapsto \lambda_\gamma$.

Note that $\lambda_\gamma$ does depend on $\gamma$, $\lambda$, and
$m$, but it does not depend on $\delta$.

With $\tau':=W''\tau$ we have
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d' - d m b'}{m}
    \right) + d'\\
  &=
    \frac{cm}{\delta}
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d'}{m}
    \right)  - d b' c' + d'\\
  &=
    c\tau + c(b + d \lambda) d' - d (a' d' -1) + d'\\
  &=
    c\tau + d + c(b + d \lambda) d' - d a' d' + d'\\
  &=
    c\tau + d + [c(b + d \lambda) - d (a + c \lambda) + 1]d'\\
  &=
    c\tau + d
\end{align*}
and thus
\begin{align*}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &= \eta(W \tau) = \eta(W'W''\tau) = \eta(W'\tau')\\
  &= (c'\tau'+d')^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \,\eta(\tau')\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta(W''\tau)\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta
    \left(
    \begin{pmatrix}
      \delta & \delta \lambda_\gamma\\
      0      & m
    \end{pmatrix}
    \tau
    \right)\\
  &= (c\tau+d)^{1/2} \upsilon_{\gamma,\delta,m,\lambda} \, \eta_{\delta,m,\lambda_\gamma}(\tau)
\end{align*}
where $\upsilon_{\gamma,\delta,m,\lambda} := \upsilon(W')$ and
$\lambda_\gamma = d d' \lambda + b d' - d m b^*$, see \eqref{eq:lambda_gamma}.

Note that $d$ and $d'$ are invertible modulo $m$, \ie, given
$\lambda_\gamma$, we can find $\lambda$ such that
$\lambda\in\Set{0,\ldots,m-1}$ and
$\lambda_\gamma= d d' \lambda +  b d' - d m b^*$ holds.
%
We have $\gcd(d',m)=1$ by choice of $d'$. Because $\det(\gamma)=1$ and
$\divides{N}{c}$, it follows $\gcd(N, d)=1$. From \eqref{eq:p|m=>p|N}
follows invertibility of $d$ modulo $m$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $h_{r,m,t}$ under
  $\Gamma_0(N) \subset SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Hemmecke}
  Cannot use this section for expansion, since it only describes
  formulas for $\Gamma_0(N)$.
\end{Hemmecke}

From the previous section, we can easily find a formula for the
transformation of $h_{r,m,t}$ under $SL_2(\setZ)$.

\begin{align*}
  h_{r,m,t}(\gamma\tau)
  &:=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
  \prod_{\divides{\delta}{M}}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{r_\delta}
  \\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
    (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
    \prod_{\divides{\delta}{M}}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\sum_{\divides{\delta}{M}} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
    \prod_{\divides{\delta}{M}} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}
\end{align*}

Let us compare this with \eqref{eq:def-h-r-m-t} where we have replaced
$t$ by $t'$ with $t' = t x + \frac{x-1}{24}s+km$ for some
$x\in\setN$ and $k\in\setZ$ such that $0\le t' < m$.
\begin{align}
  h_{r,m,t'}(\tau)
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}
    \Bigl(24\bigl(t x + \frac{x-1}{24}s+km\bigr)+s\Bigr)}
  \prod_{\divides{\delta}{M}}
  \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24 t + \sumdelta{r}) x}
  \prod_{\divides{\delta}{M}} \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
  \prod_{\divides{\delta}{M}} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}.
\end{align}

If we can find some $x\in\setZ$ and $\kappa(r,t)\in\setC$ such that
for every $0\le \lambda<m$
\begin{gather}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \prod_{\divides{\delta}{M}}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
  = \kappa(r, t) \cdot
    \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
\end{gather}

According to
\cite[Thm.~2.14]{Radu:AlgorithmicApproachRamanujanCongruences:2009},
we choose $x=a^2$ and

\begin{gather*}
  \kappa(r,t)
  =
  \beta(\gamma,0) \, \unityPower{\frac{24t+\sumdelta{r}}{24m} ab(1-m^2)}
\end{gather*}

\begin{align*}
  \kappa(r, t)
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m} (\lambda - \lambda_\gamma x)}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda - ((b + d \lambda) d' - d m b^*) x)}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda(1 - dd'x) - (b d' - d m b^*) x}
    \prod_{\divides{\delta}{M}} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Z24 ==> IntegerMod 24
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LQ ==> List Q
LSL2Z ==> List SL2Z
OF ==> OutputForm
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SymbolicEtaDeltaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $\divides{\delta}{N}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain \code{SymbolicEtaDelta}
represent the tuple
\begin{gather*}
  \left(\frac{h_\delta}{\delta}, u_\delta, v_\delta, \kappa_\delta,
  \frac{v_\delta+\kappa_\delta}{24}\right)
\end{gather*}
from \eqref{eq:eta_delta(gamma*tau)-expansion} where the values are
given through \eqref{eq:h_delta}, \eqref{eq:width},
\eqref{eq:q_delta}, \eqref{eq:uv_delta}, and
$x=\unityPower{\frac{\tau}{w_\gamma}}$.

If \code{e = eta(m, delta, gamma)}, then we have the following
correspondence.
\code{rationalPrefactor(e)} $= \frac{h_\delta}{\delta}$,
\code{udelta(e)}            $= u_\delta$,
\code{vdelta(e)}            $= v_\delta$,
\code{upsilonExponent(e)}   $= \kappa_\delta$,
\code{unityPower(e)}        $= \frac{v_\delta+\kappa_\delta}{24}$.
)endif

)abbrev domain SYMBEDG SymbolicEtaDeltaGamma
++ SymbolicEtaDeltaGamma collects data for the expansion of
++ eta_delta(\gamma \tau).
SymbolicEtaDeltaGamma: SetCategory with
    eta: (P, P, SL2Z) -> % -- gamma=[[a,b],[c,d]], m=level, delta, r_delta
      ++ eta(m, delta, gamma) represents the expansion of
      ++ \eta_\delta(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/) for  some cusp a/c.
    level: % -> P
      ++ level(x) returns the level corresponding to x.
    delta: % -> P
      ++ delta(x) returns the delta that was used at creation time of x.
    gamma: % -> SL2Z
      ++ gamma(x) returns the gamma as given at creation time of x.
    rationalPrefactor: % -> Q -- (h_delta/delta)
    upsilonExponent: % -> Z24 -- kappa_delta
    udelta: % -> P            -- width*gcd(delta,c)^2/delta
    vdelta: % -> Q            -- b2/d2
    unityPower: % -> Q        -- (kappa_delta + vdelta)/24
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,    -- level \Gamma_0(lev)
              fdelta: P,    -- the divisor used at creation
              fgamma: SL2Z, -- the gamma used at creation
              frat: Q,      -- h_delta/delta
              fkappa: Z24,  -- upsilonExponent(a1,b2,c1,d1)
              fudelta: P,   -- udelta = width*hdelta^2/delta \eqref{eq:q_delta}}
              fvdelta: Q,   -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
              funityPower: Q-- (kappa_delta + vdelta)/24
             )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(m: P, delta: P, gamma: SL2Z): % ==
        c: Z := gamma(2, 1)
        --assert(c>0)
        hdelta: Z := gcd(c, delta)
        rat: Q := hdelta/delta
        rec: Rec := splitMatrix(gamma, delta)$QAuxMEQ
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        a2: Z := gamma2(1, 1); wgamma: Z := width(m, c)
        udelta: P := qcoerce(((wgamma*gcd(c,delta)^2) exquo delta)::Z)@P
        --assert(udelta = ((a2*wgamma exquo d2) :: Z))
        if not (udelta = ((a2*wgamma) exquo d2) :: Z) then
            error "udelta does not match"
        vdelta: Q := b2/d2
        kappa: Z24 := upsilonExponent(gamma1)$QAuxMEQ
        r: Q := (vdelta + (convert(kappa)@Z)::Q) / (24::Q)
          -- eq:eta_delta(gamma*tau)-expansion)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den
        per [m, delta, gamma, rat, kappa, udelta, vdelta, r]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    udelta(x: %): P == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    unityPower(x: %): Q == xx.funityPower
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
        h := hashUpdate!(h, xx.funityPower)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        gamma x = gamma y




)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SymbolicEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain \code{SymbolicEtaQuotientGamma}
represent the tuple
\begin{gather}
  \left(
  N
  ,
  r
  ,
  \gamma
  ,
  \prod_{\delta\in\Delta}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}
  ,
  \sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}
  ,
  \sum_{\delta\in\Delta} r_\delta u_\delta
  \right)
\end{gather}
and thus corresponds to the data from \eqref{eq:g_r(gamma*tau)}.

If \code{e = etaQuotient(m, divs, r, gamma)}, then we have the
following correspondence.
\code{rationalPrefactor(e)} $=
  \prod_{\delta\in\Delta} \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}$,
\code{unityPower(e)}        $=
  \sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}$,
\code{xExponent(e)}         $= \sum_{\delta\in\Delta} r_\delta u_\delta$.

)endif
-------------------------------------------------------------------
)abbrev domain SYMBETAQ SymbolicEtaQuotientGamma
++ SymbolicEtaQuotientGamma holds data to compute an eta quotient expansion
++ of g_r(\gamma\tau).
SymbolicEtaQuotientGamma:
  Join(SemiGroup, CoercibleTo OutputForm) with
    etaQuotient: (P, LP, LZ, SL2Z) -> %
      ++ etaQuotient(m, divs, r, gamma) represents the expansion of
      ++ g_r(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/c) for a cusp a/c.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) such that
      ++ the exponent of the eta_delta for such a divisor delta
      ++ is non-zero.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in eq:g_r(gamma*tau)
    unityPower: % -> Q
      ++ unityPower(e) returns sum_\delta rdelta*(vdelta+Kappa_delta)/24
      ++ It corresponds to the third product of eq:g_r(gamma*tau).
    xExponent: % -> Z
      ++ xExponent(e) returns the 24 times the order of the expansion
      ++ of e in x = \exp(2\pi i\tau/w) where w is the width of the cusp
      ++ while neglecting the (c\tau+d) factor.
      ++ It corresponds to 24 times the exponent of the fourth product
      ++ of eq:g_r(gamma*tau).
    minRootOfUnity: % -> P
      ++ minRootOfUnity(e) returns the smallest positive integer n such that
      ++ the expansion of the function g_r(\gamma\tau) corresponding to
      ++ e=etaQuotient(m, divs, r, gamma) (neglecting the (c\tau+d)^* factor
      ++ lives in Q[w][[x]] where w is a n-th root of unity.
    eta: (%, P) -> SymbolicEtaDeltaGamma
      ++ eta(x, delta) returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicEtaDeltaGamma) -- mapping delta to \eta_\delta
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              feta: HT,      -- mapping delta to \eta_\delta
              fexponents: LZ,-- the r vector
              fgamma: SL2Z,  -- gamma
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
              fxExponent: Z, -- \sum_delta rdelta*udelta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y
    lcmP(a, b) ==> qcoerce(lcm(a::Integer, b::Integer))@P

    -- divs must be ALL divisors of m sorted ascendingly
    etaquot(m: P, divs: LP, r: LZ, gamma: SL2Z, eta: HT): % ==
        rat: Q := 1
        upower: Q := 0
        xexponent: Z := 0
        for delta in divs for rdelta in r repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            upower := upower + rdelta * unityPower(e)
            xexponent := xexponent + rdelta * udelta(e)
        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QAuxMEQ
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minSquareRootOfUnity(p)$QAuxMEQ)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [m, divs, eta, r, gamma, rat, upower, xexponent, minroot]

    etaQuotient(m: P, divs: LP, r: LZ, gamma: SL2Z): % ==
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in divs repeat
            eta.delta := eta(m, delta, gamma)$SymbolicEtaDeltaGamma
        etaquot(m, divs, r, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    eta(x: %, delta: P): SymbolicEtaDeltaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    xExponent(x: %): Z == xx.fxExponent
    minRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fgamma = yy.fgamma

    ((x: %) * (y: %)): % ==
        (xm: P := level x) ~= level y =>
            error "SymbolicEtaQuotientGamma: different levels"
        (divs: LP := divisors x) ~= divisors y =>
            error "SymbolicEtaQuotientGamma: different divisors"
        (g: SL2Z := gamma x) ~= gamma y =>
            error "SymbolicEtaQuotientGamma: different gammas"
        sumr: LZ := [rx+ry for rx in exponents x for ry in exponents y]
        etaquot(xm, divs, sumr, g, xx.feta)


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, and \code{y = etaQuotient(N, divs, r, gamma)} and
\code{e = etaQuotient(y)}, then $e$ represents the tuple
\begin{gather}
  \left(
  \underbrace{y}_{\texttt{symbolicEtaQuotient}}
  ,
  \underbrace{\prod_{\delta\in\Delta}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \unityPower{\sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  }_{\texttt{leadingCoefficient}}
  ,
  \underbrace{\prod_{\delta\in\Delta}\prod_{n=1}^{\infty}
    (1-\unityPower{n v_\delta} x^{n u_\delta})^{r_\delta}
  }_{\texttt{series}}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:modular-g_r(gamma*tau)} with
$x=\unityPower{\frac{\tau}{w_\gamma}}$ where $w_\gamma$ is given by
\eqref{eq:width}.


)endif
-------------------------------------------------------------------
)abbrev domain ETAQG EtaQuotientGamma
++ EtaQuotientGamma(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotient expansions at gamma.
EtaQuotientGamma(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX: UnivariateLaurentSeriesCategory CX -- domain for the series expansions
  Exports ==> SemiGroup with
    --assert(one? xi^mx)
    etaQuotient: SymbolicEtaQuotientGamma -> %
      ++ etaQuotient(s) represents the expansion of
      ++ g_r(\gamma\tau) in terms of x = \exp(2\pi i\tau/w) where
      ++ w=width(m, c).
    eulerFunctionPower: (P, N, Z) -> LX
      ++ etaPower(u, v, p) computes eulerFunction(1)^p and replaces
      ++ q=monomial(1,1)$LC by monomial(xi^v, u)$LX
    symbolicEtaQuotient: % -> SymbolicEtaQuotientGamma
      ++ symbolicEtaQuotient(x) returns meta-data corresponding to x.
    expansion: % -> LX
      ++ expansion(x) returns the series expansion of x without any prefactor.
    leadingCoefficient: % -> CX
      ++ leadingCoefficient(x) returns the
  Implementation ==> add
    Rep ==> Record(fsymetaquo: SymbolicEtaQuotientGamma, lc: CX, ser: LX)
    -- The true series expansion of e is given by c * x^p * s where
    -- c = leadingCoefficient e
    -- x = \exp(2\pi i\tau/w) where w=width(m, c)
    -- p = xExponent symbolicEtaQuotient e
    -- s = expansion e
    xx ==> rep x
    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol
    LC ==> SparseUnivariateLaurentSeries(C, q, 0)
    ef: LC := eulerFunction(1)$QFunctions(C, LC)
    ef1: C := coefficient(ef, 1) -- avoid null pointer by expansion
    -- We intend to also store negative powers of the eulerFunction.
    cache: XHashTable(Z, LC) := getCache()$CachedPower(LC, ef)

    RecC ==> Record(k: Z, c: C)
    RecX ==> Record(k: Z, c: CX)
    SFCX ==> StreamFunctions2(RecC, RecX)

    substituteVariable(u: P, v: N): RecC -> RecX == (x: RecC): RecX +->
        -- replace variable q by xi^v * x^u
        xiPower: N := qcoerce(positiveRemainder(v*x.k, mx))@N
        cx: CX := xi^xiPower
        cx := x.c * cx
        [u*x.k, cx]

    -- In the series s(q) replace q by q^u*xi^v.
    substitute(s: LC, u: P, v: N): LX ==
        stc: Stream RecC := terms s
        stx: Stream RecX := map(substituteVariable(u, v), stc)$SFCX
        series(stx)$LX

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        if key?(rd, cache) then
            es := cache.rd
        else
            pow: P := qcoerce(abs rd)@P
            es := power(pow)$CachedPower(LC, ef)
            if rd < 0 then
                es := recip(es)::LC
                cache.rd := es -- cache for negative exponents
        substitute(es, u, v)

    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QAuxMEQ
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    etaQuotient(e: SymbolicEtaQuotientGamma): % ==
        m: P := level e
        divs: LP := divisors e
        s: LX := 1
        for delta in divs for rd in exponents e | not zero? rd repeat
            edelta: SymbolicEtaDeltaGamma := eta(e, delta)
            u: P := udelta(edelta)
            v: N := qcoerce(numer(mx * vdelta(edelta)))@N
            s := s * eulerFunctionPower(u, v, rd)
        q: Q := mx * unityPower e
        if not one? denom q then
            error "EtaQuotientGamma: denominator does not vanish"
        n: N := qcoerce(positiveRemainder(numer q, mx))@N
        cx: CX := xi^n * squareRoot rationalPrefactor e -- leading coefficient
        per [e, cx, s]

    symbolicEtaQuotient(x: %): SymbolicEtaQuotientGamma == xx.fsymetaquo
    leadingCoefficient(x: %): CX == xx.lc
    expansion(x: %): LX == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean == symbolicEtaQuotient x = symbolicEtaQuotient y
    ((x: %) * (y: %)): % ==
        -- The following multiplication does the compatibility check.
        e := symbolicEtaQuotient x * symbolicEtaQuotient y
        c: CX := leadingCoefficient x * leadingCoefficient y
        s: LX := expansion x * expansion y
        per [e, c, s]

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ModularEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$, and \code{e = etaQuotient(N, r)}, then
$e$ represents the information given in
\eqref{eq:modular-g_r(gamma*tau)}
for each cusp $\frac{a}{c}$ of $\Gamma_0(N)$.


)endif
)abbrev domain METAQ ModularEtaQuotient
++ ModularEtaQuotient(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
++ Only modular functions of the same level can be multiplied.
ModularEtaQuotient(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX: UnivariateLaurentSeriesCategory CX -- domain for the series expansions
  LC ==> SparseUnivariateLaurentSeries(C, q, 0)
  SEQG ==> SymbolicEtaQuotientGamma
  Exports ==> SemiGroup with
    --assert(one? xi^mx)
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(m, r) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2\pi i\tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(m).
    level: % -> P
      ++ level(x) gives the m such that x corresponds to a modular
      ++ function for Gamma_0(m).
    symbolicEtaQuotients: % -> XHashTable(Q, SEQG)
      ++ symbolicEtaQuotients(x) returns the meta data corresponding to x.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of $g_r(tau)$
      ++ at all cusps of Gamma_0(N).
  Implementation ==> add
    Rep ==> Record(flevel: P, meta: XHashTable(Q, SEQG), ser: XHashTable(Q, LX))
    xx ==> rep x

    etaQuotient(m: P, r: LZ): % ==
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function, i.e., rStarConditions must be fulfilled.
        not zero? rStarConditions(m, r)$QAuxMEQ =>
            error "etaQuotient: not a modular function"
        hmeta: XHashTable(Q, SEQG) := empty()
        hser: XHashTable(Q, LX) := empty()
        divs: LP := [qcoerce(d)@P for d in
                       divisors(m)$IntegerNumberTheoryFunctions]
        cusps: LQ := cuspsOfGamma0(m)$QAuxMEQ
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(m, cusp)$QAuxMEQ
            se: SEQG := etaQuotient(m, divs, r, gamma)
            e: EtaQuotientGamma(C, mx, CX, xi, LX) := etaQuotient se
            s: LX := expansion e
            lc: CX := leadingCoefficient e
            ord: Z := (xExponent(se) exquo 24)::Z -- order of series
            hmeta.cusp := se
            hser.cusp := monomial(lc, ord)$LX * s
        per [m, hmeta, hser]

    level(x: %): P == xx.flevel
    symbolicEtaQuotients(x: %): XHashTable(Q, SEQG) == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the level and the rdeltas
        m: P := level x
        m ~= level y => false
        -- note that 1/m is always a cusp of Gamma_0(m), but we choose any
        ex: XHashTable(Q, SEQG) := symbolicEtaQuotients x
        ey: XHashTable(Q, SEQG) := symbolicEtaQuotients y
        cusp: Q := first keys ex
        exponents(ex.cusp) = exponents(ey.cusp)

    ((x: %) * (y: %)): % ==
        m: P := level x
        m ~= level y =>
            error "ModularEtaQuotient: cannot multiply elements with different level"
        ex: XHashTable(Q, SEQG) := symbolicEtaQuotients x
        ey: XHashTable(Q, SEQG) := symbolicEtaQuotients y
        sx: XHashTable(Q, LX) := expansions x
        sy: XHashTable(Q, LX) := expansions y
        hmeta: XHashTable(Q, SEQG) := empty()
        hser: XHashTable(Q, LX) := empty()
        cusps: LQ := keys ex
        for cusp in cusps repeat
            hmeta.cusp := ex.cusp * ey.cusp
            hser.cusp := sx.cusp * sy.cusp
        per [m, hmeta, hser]
    coerce(x: %): OutputForm == rep(x)::OutputForm


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ModularEtaQuotientExpansions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$, and \code{e = etaQuotient(N, r)}, \code{v
  = coerce(expansions e)} then $v$ represents the vector of Laurent
expansions of an eta quotient (corresponding to $r$) at each cusp of
$\Gamma_0(N)$. These vectors form an algebra that similar to
\code{Finite0Series} have a finite zero test. A vector $v$ is zero, if
\code{qetaGrade(v, k)} is smaller than 0 for all indices $k$ from 1 to
$n$ where $n$ is the number of cusps of $\Gamma_0(N)$.

)endif
)abbrev domain METAQX ModularEtaQuotientExpansions
++ ModularEtaQuotientExpansions(C, L, m) represents the algebra of
++ eta quotients that are modular functions for Gamma_0(m).
ModularEtaQuotientExpansions(C, L, m): Exports == Implementation where
  C: IntegralDomain
  L: UnivariateLaurentSeriesCategory C
  m: P -- level
  Exports ==> XEtaAlgebra C with
    coerce: XHashTable(Q, L) -> %
      ++ If t is a hashtable containing (for each cusp of Gamma_0(m)
      ++ the series expansions at the cusps, then etaQuotient(t) creates
      ++ a data structure that can be used for computations.
    series: (%, P) -> L
      ++ series(x, n) returns the series corresponding to the n-th index.
      ++ Indices can run from 1 to maxIndex().
  Implementation ==> add
    divs: LP := [qcoerce(d)@P for d in divisors(m)$IntegerNumberTheoryFunctions]
    ndivs: N := # divs
    cusps: LQ := cuspsOfGamma0(m)$QAuxiliaryModularEtaQuotientPackage
    ncusps: P := qcoerce(#cusps)@P
    RVector ==> DirectProduct(ndivs, Z)
    Rep ==> DirectProduct(ncusps, L)
    xx ==> rep x
    yy ==> rep y

    coerce(t: XHashTable(Q, L)): % ==
        -- sanity check
        # (cs := keys t) ~= ncusps or sort cs ~= sort cusps =>
            error "keys do not agree with cusps of Gamma0(m)"
        per directProduct vector [t.c for c in cusps]

    coerce(x: %): OutputForm == xx::OutputForm
    0: % == per(0$Rep)
    1: % == per(1$Rep)
    zero?(x: %): Boolean ==
        for kn in 1..ncusps repeat
            k: P := qcoerce(kn)@P
            qetaGrade(x, k, 0) > 0 => return false
            not zero? xx.k.0 => return false
        return true

    ((x: %) + (y: %)): % == per(xx + yy)
    ((x: %) * (y: %)): % == per(xx * yy)
    ((c: C) * (x: %)): % == per map((s: L): L +-> c * s, xx)
    ((x: %) ^ (n: N)): % == per map((s: L): L +-> s^n, xx)
    maxIndex(): P == ncusps
    qetaIndex(x: %): P ==
        --assert(not zero? x) -- therefore for one k qetaGrade(x,k)>=0
        maxGrade := -1 -- dummy value
        idx: N := 0
        for kn in 1 .. ncusps repeat
            k: P := qcoerce(kn)@P
            if (mx := qetaGrade(x, k)) > maxGrade then
                maxGrade := mx

                idx: P := k
        return idx
    qetaGrade(x: %, k: P): Z == - order(xx.k)
    qetaGrade(x: %, k: P, mn: Z): Z == - order(xx.k, -mn)
    qetaLeadingCoefficient(x: %, k: P): C == leadingCoefficient(xx.k)
    series(x: %, k: P): L == xx.k
    qetaGrades(x: %): LZ ==
        zero? x => [0 for k in 1..ncusps]
        [qetaGrade(x, qcoerce(k)@P) for k in 1..ncusps]

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
