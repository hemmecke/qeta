-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}
% Euler totient function
\newcommand{\eulerphi}{\varphi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding Dedekind Eta Functions into $q$-series}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}

We expand quotients of Dedekind $\eta$-functions that are modular
functions for $\Gamma_0(N)$ at all cusps into $q$-series.

\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $N$ be a positive natural number and define a $\Gamma_0(N)$ as a
subgroup of the special linear group $SL_2(\setZ)$ as follows.
\begin{gather*}
\Gamma_0(N) := \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix} \in SL_2(\setZ)}{N|c}
\end{gather*}

According to
\cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016},
there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
$\Gamma_0(N)$ that correspond to a divisor $c$ of $N$.

In the following we always deal with quotients of $\eta$-functions of
level $N$ that are modular functions for $\Gamma_0(N)$.

We implement a domain that deals with such quotients and their
$q$-expansion at all cusps ($q=e^{2\pi i \tau})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dedekind $\eta$-function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:epsilon}
  Let $\unityPowerSymbol: \setC \to \setC$ be defined by
  \begin{gather*}
    \unityPower{x} := \exp(2\pi i x).
  \end{gather*}
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\setH=\SetDef{c\in \setC}{\Im(c)>0}$ denote the upper complex
half-plane.

Let
\begin{gather}\label{eq:eta-expansion}
  \eta: \setH \to \setC, \quad
  \tau \mapsto \unityPower{\frac{\tau}{24}}
  \prod_{n=1}^{\infty}(1-q^n)
\end{gather}
with $q = \unityPower{\tau}$
denote the Dedekind eta function.

In the following $N$ denotes a positive integer and
$1=\delta_1<\delta_2\dots<\delta_n=N$ the positive divisors of $N$.
Let $\Delta:=\Set{\delta_1,\ldots,\delta_n}$. For convenience, we
allow to index $n$-dimensional vectors by the divisors of $N$,
instead of the usual index set $\Set{1,\ldots,n}$.
%
For $\delta\in\Delta$ we consider the functions
\begin{gather*}
 \eta_\delta: \setH \to \setC,\quad \tau \mapsto  \eta(\delta\tau)
\end{gather*}
None of these functions is identically zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We define $R(N)$ to be the set of integer tuples
$r = (r_{\delta_1}, \ldots,
r_{\delta_n})\in \setZ^n$.

By $R^*(N)$ we denote the subset of all tuples
$r=(r_\delta)_{\delta\in\Delta}$ of $R(N)$ that fulfil the following
conditions.
\begin{align}
 \sum_{\delta\in\Delta} r_\delta &= 0\label{eq:sum=0}\\
 \sum_{\delta\in\Delta} \delta r_\delta &\equiv 0\pmod{24}\label{eq:sigmainfinity}\\
 \sum_{\delta\in\Delta} (N/\delta)r_\delta &\equiv 0\pmod{24}\label{eq:sigma0}\\
 \sqrt{\prod_{\delta\in\Delta}\delta^{r_\delta}} &\in \setQ\label{eq:productsquare}
\end{align}

Note that $R^*(N)$ is an additive monoid. It even is an additive group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's look at the transformation of the $\eta$-function (see
\cite[Lemma~2.27]{Radu:PhD:2010}.

Let $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, then
\begin{gather*}
\eta(\gamma\tau) =
\eta\left(\frac{a\tau+b}{c\tau+d}\right) =
(c\tau+d)^{1/2}\,\upsilon_\eta(a,b,c,d)\,\eta(\tau)
\end{gather*}

Let $\delta \in \setN\setminus\Set{0}$.

\begin{gather*}
\eta_\delta(\gamma\tau)
=
\eta_\delta\left(\frac{a\tau+b}{c\tau+d}\right) =
\eta\left(\frac{a\delta\tau+b\delta}{c\tau+d}\right)
=
\eta\left(\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
  \tau\right).
\end{gather*}

Let
%
$h_\delta:=\gcd(\delta a,c)$,
%
$a_\delta:=\frac{\delta a}{h_\delta}$,
%
$c_\delta:=\frac{c}{h_\delta}$,
%
and $b_\delta$ and $d_\delta$ are chosen in such a way that
$a_\delta d_\delta - b_\delta c_\delta = 1$.
%
Because of $\gcd(a_\delta, c_\delta)=1$, such $b_\delta$ and $d_\delta$
can be found.
%
Therefore
  $\gamma_\delta := \left(
  \begin{smallmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{smallmatrix}
\right)\in SL_2(\setZ)$.

Note that $h_\delta=\gcd(\delta, c)$, because $\gcd(a,c)=1$ and,
furthermore,

\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\label{eq:naive-matrix-split}
\end{align}
Note that for any integer $s$ whe have:
\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}
    h_\delta&\delta b d_\delta-d b_\delta\\
    0      &\delta / h_\delta\end{pmatrix}
  \\
&=
  \begin{pmatrix}
    a_\delta&b_\delta + a_\delta s\\
    c_\delta&d_\delta + c_\delta s
  \end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta-s \delta / h_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\end{align}
Therefore, we can choose $b_\delta$ and $d_\delta$ in such a way that
$0 \le \delta b d_\delta-d b_\delta < \delta/h_\delta$.

If we set
\begin{gather}
  \tau_\delta:=\begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\0&\delta
    / h_\delta\end{pmatrix} \tau
  = \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta},
  \label{eq:tau_delta}
\end{gather}
then
\begin{gather*}
  \eta_\delta(\gamma\tau)
  =
  \eta(\gamma_\delta \tau_\delta)
  =
  (c_\delta\tau_\delta+d_\delta)^{1/2}
  \,
  \upsilon_\eta(a_\delta,b_\delta,c_\delta,d_\delta)
  \,
  \eta(\tau_\delta).
\end{gather*}


Furthermore,
\begin{align*}
  c_\delta\tau_\delta+d_\delta
  &=
  c_\delta
    \left(
    \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta}
    \right) + d_\delta\\
  &=
  \frac{c_\delta h_\delta}{\delta}
    (
    h_\delta\tau + b \delta d_\delta-d b_\delta
    ) + d_\delta\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + c b \delta d_\delta - c d b_\delta + \delta d_\delta)\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + (ad-1) \delta d_\delta - c d b_\delta + \delta d_\delta)\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + ad \delta d_\delta - c d b_\delta)\\
  &=
  \frac{1}{\delta}
    (c h_\delta\tau + d h_\delta (a_\delta d_\delta - c_\delta b_\delta)\\
  &=
  \frac{h_\delta}{\delta}(c \tau + d).
\end{align*}

Thus, we have
\begin{gather}
\eta_\delta(\gamma\tau)
=
\left(\frac{h_\delta}{\delta}(c \tau+d)\right)^{\!1/2}
\unityPower{\frac{\kappa_\delta}{24}}
\,
\eta(\tau_\delta).
\label{eq:eta_delta(gamma*tau)}
\end{gather}
where $\kappa_\delta \in \Set{0,\ldots,23}$ is defined by
$\unityPower{\frac{\kappa_\delta}{24}}
:= \upsilon_\eta(a_\delta,b_\delta,c_\delta,d_\delta)$.



For the following definition see \cite[Lemma~2.37]{Radu:PhD:2010} and
\cite[Definition~2.9]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:width}
  Let
  $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)
  \in SL_2(\setZ)$ and $N$ be a positive integer. Then
  \begin{gather}
    w_\gamma = \frac{N}{\gcd(c^2, N)}
  \end{gather}
  is called the \emph{width of $\gamma$ with respect to $\Gamma_0(N)$}.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For
$\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ we want to expand $\eta(\tau_\delta)$ in
$x:=q^{1/w_\gamma}=\unityPower{\frac{\tau}{w_\gamma}}$ with
coefficients from $\setQ(\xi)$ where
$\xi := \unityPower{\frac{c}{24N}}$.

Since we are only interested in expansions at the cusps, we can assume
$0<c\in\Delta$.

In the following let $\delta \in \Delta$.
Because of \eqref{eq:tau_delta}, we have
\begin{align}
  q_\delta = \unityPower{\tau_\delta}
  &= x^{u_\delta} \, \unityPower{v_\delta}
\label{eq:q_delta}
\end{align}
for $u_\delta := \frac{w_\gamma h_\delta^2}{\delta}$ and
$v_\delta := \frac{\delta b d_\delta-d b_\delta}{\delta/h_\delta}$.
%
Note that $\unityPower{\frac{v_\delta}{24}} = \xi^k$ for
$k = (\delta b d_\delta - d b_\delta) \frac{N}{\lcm(\delta,c)}\in \setZ$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  $u_\delta \in \setZ$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
If $p$ is a prime that divides $N$, \ie, $N=N'p^\alpha$ for some
$\alpha>0$, and $\delta = \delta' p^m$, $c=c' p^k$ with
$\gcd(p,N')=\gcd(p,\delta')=\gcd(p,c')=1$, then
\begin{align*}
  u_\delta
  &=
  \frac{N}{\gcd(c^2,N)} \frac{\gcd(\delta,c)^2}{\delta}\\
  &=
  \frac{p^\alpha N' \gcd(p^m \delta', p^k c')^2}{\gcd(p^{2k}
    c'^2,p^\alpha N') p^m \delta'}\\
  &=
  p^{\alpha + 2 \min(m,k) - m - \min(2k, \alpha)}
  \frac{N' \gcd(\delta', c')^2}{\gcd(c'^2, N') \delta'}
\end{align*}
If we can show that $e:=\alpha + 2 \min(m,k) - m - \min(2k,
\alpha)\ge0$ then $u_\delta\in\setN$ follows by repeating the above
process for every prime divisor of $N$.

There are several cases to consider:
\begin{itemize}
\item $0\le m\le k \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2m-m-2k=(\alpha-2k)+m\ge0$.
\item $0\le m\le k \le \alpha < 2k$. Then
  $e=\alpha+2m-m-\alpha=m\ge0$.

\item $0\le k\le m \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2k-m-2k=\alpha-m\ge0$.
\item $0\le k\le m \le \alpha < 2k$. Then
  $e=\alpha+2k-m-\alpha=2k-m\ge0$.
\end{itemize}
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We can expand $\eta(\tau_\delta)$ in terms of $x$ as follows.
\begin{gather*}
  \eta(\tau_\delta)
  =
    \unityPower{{\frac{\tau_\delta}{24}}}
    \prod_{n=1}^{\infty}(1-q_\delta^n)
  =
  \unityPower{\frac{v_\delta}{24}} x^{u_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n)
\end{gather*}

Then \eqref{eq:eta_delta(gamma*tau)} turns into
\begin{align}
\eta_\delta(\gamma\tau)
&=
(c \tau+d)^{1/2}
\,
\left(\frac{h_\delta}{\delta}\right)^{\!\frac{1}{2}}
\,
  \unityPower {\frac{v_\delta + \kappa_\delta}{24}}
  x^{u_\delta/24} \cdot \prod_{n=1}^{\infty}(1-q_\delta^n).
\label{eq:eta_delta(gamma*tau)-expansion}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  For any $c, \delta \in\Delta$, $r\in R(N)$ let us define
  \begin{align}
    a_N(c, \delta) &:= \frac{N}{\gcd(N, c^2)}
                       \frac{\gcd(c,\delta)^2}{\delta},\notag\\
    \ord_c^N(r) &:= \frac{1}{24}\sum_{\delta\in\Delta} a_N(c, \delta) \, r_\delta,
    \label{eq:order-r}
    \intertext{and}
    g_r(\tau) &:= \prod_{\delta\in\Delta} \eta(\delta\tau)^{r_\delta}.
    \label{eq:g_r(tau)}
  \end{align}
\end{Definition}

With $\ord_\gamma^N$ as defined in \cite{Radu:RamanujanKolberg:2015},
Theorem~23 of \cite{Radu:RamanujanKolberg:2015} turns into
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\label{thm:order}
  Let $\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c\in\Delta$.
  If $r \in R^*(N)$, then
  $\ord_\gamma^N(g_r) = \ord_c^N(r)$.
\end{Theorem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For a proof we refer to
\cite[Proposition~3.2.8]{Ligozat:CourbesModulaires:1975}.

In the following let us fix $r \in R^*(N)$ and
$\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c \in \Delta$.

From \eqref{eq:eta_delta(gamma*tau)-expansion} follows
\begin{align}
  g_r(\gamma \tau)
  &=
  \prod_{\delta\in\Delta}
  (c \tau+d)^{r_\delta/2}
  \,
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \,
  \unityPower{\frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{r_\delta u_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  %
  \intertext{and because of \eqref{eq:sum=0}, $u_\delta=a_N(c,
  \delta)$, and \eqref{eq:order-r},  we can write}
  g_r(\gamma \tau)
  &=
  \prod_{\delta\in\Delta}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\sum_{\delta\in\Delta} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\ord^N_c(r)}
  \cdot
  \prod_{\delta\in\Delta}
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  \label{eq:g_r(gamma*tau)}
\end{align}
Thus, we can expand $g_r(\gamma\tau)$ as a Laurent series in
$x:=q^{1/w_\gamma}$ with coefficients from $\setQ(\xi)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Root of unity reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that any modular function (in particular $g_r$) can be expressed
as a rational function $f$ in $j$ and $j_N$ where
$j_N(\tau):=j(N\tau)$ and $j$ is Klein's $j$-invariant, \ie,
$g_r(\tau)=f(j, j_N)(\tau) := f(j(\tau), j(N\tau))$.

Let $\frac{a}{c}$ be a cusp of $\Gamma_0(N)$.
%
We can choose $b$ and $d$ such that
%
$\gamma := \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ and $\gamma\infty=\frac{a}{c}$.
%
Klein's $j$-function is invariant under any modular transformation.
%
Let us consider the transformation of $j_N$ by $\gamma$.
%
According to \eqref{eq:tau_delta} for $\delta=N$, $j_N(\gamma\tau)$
can be expanded into a Laurent series in
$x=q^{1/w_\gamma}=\unityPower{\tau/w_\gamma}$ with
coefficients from $\setQ(\xi)$ where $\xi$ is a $\frac{N}{c}$-th root
of unity.
%
Since there is some freedom to choose such $b$ and $d$, we show in the
following, how we can obtain an expansion of $j_N(\gamma\tau)$ and
therefore (via $f$) an expansion $g_r(\gamma\tau)$ into a Laurent
series in $x$ with coefficients in $\setQ(\xi)$ where $\xi$ is a
$v$-th root of unity and $1 \leq v \le N/c$ and $v<N/c$ if $c<N$.

Let
$\gamma' = \bigl(
\begin{smallmatrix}
  a & b'\\
  c & d'
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$, then also
\begin{align*}
  \gamma
  &:=
    \begin{pmatrix}
      a & b' + as\\
      c & d' + cs
    \end{pmatrix}
  =
    \begin{pmatrix}
      a & b'\\
      c & d'
    \end{pmatrix}
    \begin{pmatrix}
      1 & s\\
      0 & 1
    \end{pmatrix}
    \in SL_2(\setZ)
\end{align*}
for any $s\in\setZ$.

For the transformation of $j_N$, we split the matrix as in
\eqref{eq:naive-matrix-split} with $\delta=N$.
\begin{align*}
  \begin{pmatrix}
    N a & N(b' + as)\\
    c & d' + cs
  \end{pmatrix}
      &=
  \begin{pmatrix}
    N a/c & -1\\
    1     &  0
  \end{pmatrix}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix}
\end{align*}
into an element of $SL_2(Z)$ and a triangular matrix.
%
Then we determine natural numbers $u$ and $v$ such that $u v = N/c$
and $\gcd(c, u)=1$. Thus, we can find $s \in \setZ$ such that
$s \equiv -d'c^{-1} \pmod{u}$, \ie, $cs + d' = tu$ for some integer
$t$ with $0\le t<c$.
%
Thus,
\begin{gather*}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix} \tau
  =
  \begin{pmatrix}
    c & u t\\
    0 & u v
  \end{pmatrix} \tau
  =
  \frac{c^2}{N} \tau + \frac{t}{v}
  =
 \frac{w_\gamma c^2}{N} \frac{\tau}{w_\gamma} + \frac{t}{v}
  =
 \frac{c}{\gcd(c,N/c)} \frac{\tau}{w_\gamma} + \frac{t}{v}
  .
\end{gather*}
Note that $u=N/c$ and $v=1$, if $N$ is squarefree.

With the particular $s$ from above, we define $b:=b'+as$, $d:=d'+cs$
and take
%
$\gamma = \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr)$ as the transformation matrix that belongs to the cusp
$\frac{a}{c}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Z24 ==> IntegerMod 24
Q ==> Fraction Z
MZ ==> Matrix Z -- considere only 2x2 matricies
LSym ==> List Symbol
LZ ==> List Z
LQ ==> List Q
LMZ ==> List MZ
OF ==> OutputForm
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage

)abbrev domain SYMBETA SymbolicEta
SymbolicEta: _
  Join(CoercibleTo OutputForm) with
    eta: (P, MZ, P) -> % -- gamma=[[a,b],[c,d]], m=level, delta, r_delta
      ++ eta(m, gamma, delta, rdelta) represents the expansion of
      ++ \eta_\delta(\gamma\tau)^{r_\delta} in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/) for  some cusp a/c.
    rationalPrefactor: % -> Q -- (h_delta/delta)
    upsilonExponent: % -> Z24 -- kappa_delta
    udelta: % -> Z         -- width*gcd(delta,c)^2/delta
    vdelta: % -> Q         -- b2/d2
    unityPower: % -> Q     -- (kappa_delta + vdelta)/24
 == add
    Rep ==> Record(
              flevel: P,  -- level \Gamma_0(lev)
              frat: Q,  -- rational prefactor
              fkappa: Z24,-- upsilonExponent(a1,b2,c1,d1)
              fudelta: Z, -- udelta = width*hdelta^2/delta \eqref{eq:q_delta}}
              fvdelta: Q, -- b2/d2, reduced form of roots of unity
                          -- 0<=b2<d2, 0<d2
              funityPower: Q -- (kappa_delta + vdelta)/24
            )
    Rec ==> Record(red: MZ, triang: MZ)
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(m: P, gamma: MZ, delta: P): % ==
        c: Z := gamma(2, 1)
        --assert(c>0)
        hdelta: Z := gcd(c, delta)
        rat: Q := hdelta/delta
        rec: Rec := splitMatrix(gamma, delta)$QAuxMEQ
        gamma1: MZ := rec.red
        gamma2: MZ := rec.triang
        kappa: Z24 := upsilonExponent(gamma1)$QAuxMEQ
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        udelta: Z := aLigozat(m, c, delta)$QAuxMEQ
        a2: Z := gamma2(1, 1); wgamma: Z := width(m, c)
        --assert(udelta = ((a2*wgamma exquo d2) :: Z))
        if not (udelta = (((a2*wgamma) exquo d2) :: Z)) then
            error "udelta does not match"
        vdelta: Q := b2/d2
        r: Q := vdelta + (convert(kappa)@Z)::Q / (24::Q)
          -- eq:eta_delta(gamma*tau)-expansion)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den
        per [m, rat, kappa, udelta, vdelta, r]

    import from MZ
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    udelta(x: %): Z == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    unityPower(x: %): Q == xx.funityPower
    coerce(x: %): OutputForm == rep(x)::OutputForm

-------------------------------------------------------------------
)abbrev domain SYMBETAP SymbolicEtaPower
SymbolicEtaPower: _
  Join(CoercibleTo OutputForm) with
    etaPower: (P, LQ, LMZ, P, Z) -> %
    rationalPrefactor: (%, Q) -> Q -- (h_delta/delta)^(r_delta)
    udelta: (%, Q) -> Z     -- rdelta * width*gcd(delta,c)^2/delta
    unityPower: (%, Q) -> Q -- rdelta * (b2/d2+kappa_delta)/24
    rdelta: % -> Z         -- rdelta
    _*: (%, %) -> %
      ++ This is a partial multiplication. x*y is only applicable
      ++ if both eta powers belong to the same level, gamma, and delta.
      ++ If x=eta(m, gamma, delta, rx), y=eta(m, gamma, delta, ry), then
      ++ z=x*y is the same as eta(m, gamma, delta, rx + ry).
 == add
    HT ==> XHashTable(Q, SymbolicEta)
    Rep ==> Record(
              flevel: P,  -- level \Gamma_0(lev)
              fdelta: Z,  -- we expand \eta_\delta(\gamma\tau)
              frdelta: Z,  -- the respective divisor of level
              fht: HT
                -- mapping from cusp to SumbolicEtaPowerAtCusp
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y
    hh ==> xx.fht

    etaPower(m: P, cusps: LQ, gammas: LMZ, delta: P, rdelta: Z): % ==
        ht: HT := empty()
        for cusp in cusps for gamma in gammas repeat
            ht.cusp := eta(m, gamma, qcoerce(delta)@P)$SymbolicEta
        per [m, delta, rdelta, ht]

    import from MZ
    rdelta(x: %): Z == xx.frdelta
    rationalPrefactor(x: %, cusp: Q): Q == rationalPrefactor(hh.cusp)^rdelta(x)
    udelta(x: %, cusp: Q): Z == rdelta(x) * udelta(hh.cusp)
    unityPower(x: %, cusp: Q): Q == rdelta(x) * unityPower(hh.cusp)
    coerce(x: %): OutputForm == rep(x)::OutputForm

    ((x: %) * (y: %)): % ==
        xx.flevel ~= yy.flevel => error "SymbolicEtaPower: not same level"
        xx.fdelta ~= yy.fdelta => error "SymbolicEtaPower: not same delta"
        per [xx.flevel, xx.fdelta, rdelta(x)+rdelta(y), hh]

-------------------------------------------------------------------
)abbrev domain SYMBETAQ SymbolicEtaQuotient
SymbolicEtaQuotient:
  Join(Group, CoercibleTo OutputForm) with
    etaQuotient: (P, List Z, List Z) -> %
      ++ etaQuotient(m, gamma, divs, r) represents the expansion of
      ++ g_r(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/) for  some cusp a/c.
    order: (%, Q) -> Z
      ++ order(x) returns the order of the expansion in terms of
      ++ x = \exp(2\pi i\tau/w) where w is the width of the cusp.
      ++ It corresponds to the fourth product of eq:g_r(gamma*tau).
    rationalPrefactor: (%, Q) -> Q
      ++ rationalPrefactor(x) returns the first product in
      ++ eq:g_r(gamma*tau)
    unityPower: (%, Q) -> Q --sum_\delta rdelta*(vdelta+Kappa_delta)/24
    order: % -> XHashTable(Q, Z)
      ++ order(x) returns the order of the expansion in terms of
      ++ x = \exp(2\pi i\tau/w) where w is the width of the cusp.
      ++ It corresponds to the fourth product of eq:g_r(gamma*tau).
    rationalPrefactor: % -> XHashTable(Q, Q)
      ++ rationalPrefactor(x) returns the first product in
      ++ eq:g_r(gamma*tau)
    unityPower: % -> XHashTable(Q, Q)
      ++ sum_\delta rdelta*(vdelta+Kappa_delta)/24
 == add
    HT ==> XHashTable(Z, SymbolicEtaPower)
    Rep ==> Record(
              flevel: P,  -- level \Gamma_0(level)
              fcusps: LQ, -- all cusps of \Gamma_0(level)
              fht: HT -- delta to eta power mapping
            )
    import from Rep
    xx ==> rep x

    etaQuotient(m: P, divs: LZ, r: LZ): % ==
        cusps: LQ := cuspsOfGamma0(m)$QAuxMEQ
        gammas: LMZ := [cuspToMatrix(m, cusp)$QAuxMEQ for cusp in cusps]
        ht: HT := empty()
        for delta in divs for rdelta in r repeat
            deltaP: P := qcoerce(delta)@P
            ht.delta := etaPower(m, cusps, gammas, deltaP, rdelta)
        per [m, cusps, ht]

    coerce(x: %): OutputForm == rep(x)::OutputForm
    order(x: %, cusp: Q): Z ==
        z: Z := 0
        ht: HT := xx.fht
        for delta in keys ht repeat z := z + udelta(ht.delta, cusp)
        (z exquo 24) :: Z

    rationalPrefactor(x: %, cusp: Q): Q ==
        z: Q := 1
        ht: HT := xx.fht
        for delta in keys ht repeat z := z * rationalPrefactor(ht.delta, cusp)
        z

    unityPower(x: %, cusp: Q): Q ==
        -- exponent for (24*level/c)-th root of unity
        r: Q := 0
        ht: HT := xx.fht
        for delta in keys ht repeat r := r + unityPower(ht.delta, cusp)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den

-------------------------------------------------------------------
    order(x: %): XHashTable(Q, Z) ==
        h: XHashTable(Q, Z) := empty()
        for cusp in xx.fcusps repeat h.cusp := order(x, cusp)
        h

    rationalPrefactor(x: %): XHashTable(Q, Q) ==
        h: XHashTable(Q, Q) := empty()
        for cusp in xx.fcusps repeat h.cusp := rationalPrefactor(x, cusp)
        h

    unityPower(x: %): XHashTable(Q, Q) ==
        -- exponent for (24*level/c)-th root of unity
        h: XHashTable(Q, Q) := empty()
        for cusp in xx.fcusps repeat h.cusp := unityPower(x, cusp)
        h


)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
