-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
--dbgPrint(x,y) ==> display(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 770)
xdbgPrint(x,y) ==> rhx:="42"

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}
% Euler totient function
\newcommand{\eulerphi}{\varphi}

% Abbreviation for \sum_{\divides{\delta}{#1}}\delta {#2}_\delta
\newcommand{\sumdelta}[2][M]{\hat{#2}}

\newcommand{\divisorsum}[2][\delta]{\sum_{\divides{#1}{#2}}}
\newcommand{\divisorprod}[2][\delta]{\prod_{\divides{#1}{#2}}}

\newcommand{\setS}{\mathbb{S}}

\usepackage{makeidx}
\makeindex

\newcommand{\defineNotation}[2][$$]{%
  \ensuremath{#2}\index{#1@\ensuremath{#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding Dedekind Eta Functions into $q$-series}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}

We expand quotients of Dedekind $\eta$-functions that are modular
functions for $\Gamma_0(N)$ at all cusps into $q$-series.

\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{gather}
  \defineNotation[GL2+Z]{GL_2^+(\setZ)}
  :=
  \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix}}{a,b,c,d\in\setZ \land ad-bc>0}
\end{gather}

\begin{gather}
  \defineNotation[SL2Z]{SL_2(\setZ)} := \SetDef{\gamma\in
    GL_2^+(\setZ)}{\det(\gamma)=1}
\end{gather}

Let $N$ be a positive natural number and define a $\Gamma_0(N)$ as a
subgroup of the special linear group $SL_2(\setZ)$ as follows.
\begin{gather*}
\defineNotation[Gamma0N]{\Gamma_0(N)} := \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix} \in SL_2(\setZ)}{\divides{N}{c}}
\end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:epsilon}
  Let $\defineNotation[epsilon]{\unityPowerSymbol}: \setC \to \setC$
  be defined by
  \begin{gather*}
    \unityPower{x} := \exp(2\pi i x).
  \end{gather*}
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\defineNotation[H]{\setH}=\SetDef{c\in \setC}{\Im(c)>0}$ denote
the complex upper half-plane.

Let
\begin{gather}\label{eq:eta-expansion}
  \defineNotation[eta]{\eta}: \setH \to \setC, \quad
  \tau \mapsto \unityPower{\frac{\tau}{24}}
  \prod_{n=1}^{\infty}(1-q^n)
\end{gather}
with $\defineNotation[q]{q} = \unityPower{\tau}$
denote the Dedekind eta function.

In the following $\defineNotation[N]{N}$ denotes a positive integer
and $1=\delta_1<\delta_2\dots<\delta_{\defineNotation[n]{n}}=N$ the
positive divisors of $N$. Let
$\defineNotation[Delta]{\Delta}:=\Set{\delta_1,\ldots,\delta_n}$. For
convenience, we allow to index $n$-dimensional vectors by the divisors
of $N$, instead of the usual index set $\Set{1,\ldots,n}$.
%
For $\delta\in\Delta$ we consider the functions
\begin{gather*}
  \defineNotation[eta-delta]{\eta_\delta}: \setH \to \setC,\quad \tau
  \mapsto \eta(\delta\tau)
\end{gather*}
None of these functions is identically zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
When we write $\divisorsum{N}$ and $\divisorprod{N}$ we mean the sum
and product over all \emph{positive} divisors of $N$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We define $\defineNotation[RN]{R(N)}$ to be the set of integer tuples
$\defineNotation[r]{r} = (r_{\delta_1}, \ldots,
r_{\delta_n})\in \setZ^n$.
%
For $r\in R(N)$ let
\begin{align}
  \defineNotation[g-r-tau]{g_r(\tau)}
  &:=
  \divisorprod{N} \eta(\delta\tau)^{r_\delta}.
  \label{eq:g_r(tau)}
\end{align}

By $\defineNotation[R*N]{R^*(N)}$ we denote the subset of all tuples
$r=(r_\delta)_{\delta\in\Delta}$ of $R(N)$ that fulfil the following
conditions.
\begin{align}
 \divisorsum{N} r_\delta &= 0\label{eq:sum=0}\\
 \divisorsum{N} \delta r_\delta &\equiv 0\pmod{24}\label{eq:sigmainfinity}\\
 \divisorsum{N} (N/\delta)r_\delta &\equiv 0\pmod{24}\label{eq:sigma0}\\
 \sqrt{\divisorprod{N}\delta^{r_\delta}} &\in \setQ\label{eq:productsquare}
\end{align}

Note that $R^*(N)$ is an additive monoid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

According to
\cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016},
there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
$\Gamma_0(N)$ that correspond to a divisor $c$ of $N$ where
$\defineNotation[phi]{\eulerphi}$ denotes the Euler totient function.

In the following we always deal with quotients of $\eta$-functions of
level $N$ that are modular functions for $\Gamma_0(N)$.

We implement a domain that deals with such quotients and their
$q$-expansion at all cusps ($q=e^{2\pi i \tau})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transformations of the Dedekind $\eta$-function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's look at the transformation of the $\eta$-function (see
\cite[Lemma~2.27]{Radu:PhD:2010}).

Let
$\defineNotation[gamma]{\gamma} =
\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, then
\begin{gather}
\eta(\gamma\tau) =
\eta\left(\frac{a\tau+b}{c\tau+d}\right) =
(c\tau+d)^{1/2}\,\upsilon(\gamma)\,\eta(\tau)
\label{eq:eta-transformation}
\end{gather}
where
$\defineNotation[upsilon-gamma]{\upsilon(\gamma)} :=
\upsilon_\eta(a,b,c,d)$ as defined as in
\cite[Lemma~2.27]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
\label{thm:matix-splitting}
Let $\gamma',\gamma''\in SL_2(\setZ)$.
%
Then $\upsilon(\gamma'\gamma'')^2 = \upsilon(\gamma')^2 \upsilon(\gamma'')^2$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
  Let
  $\gamma'=\left(\begin{smallmatrix}a'&b'\\c'&d'\end{smallmatrix}\right)$
  and
  $\gamma''=\left(\begin{smallmatrix}a''&b''\\c''&d''\end{smallmatrix}\right)$
  be in $SL_2(\setZ)$.
  %
  Then
  $\gamma'\gamma'' =
  \left(\begin{smallmatrix}a'a''+b'c''&a'b''+b'd''\\c'a''+d'c''&c'b''+d'd''\end{smallmatrix}\right)$.
  We set $c:=c'a''+d'c''$ and $d:=c'b''+d'd''$.
%
  If $\tau'=\gamma''\tau$, we derive for any $\tau \in \setH$:
  \begin{gather*}
    c' \tau' + d'
    =
      \left(c' \frac{a''\tau + b''}{c''\tau + d''} +d'\right)
    =
      \left(\frac{c'a''\tau + c'b''+ d'c''\tau + d'd''}{c''\tau + d''}\right)
    =
    \left(\frac{c\tau + d}{c''\tau + d''}\right).
  \end{gather*}
%
  \begin{align*}
    (c \tau + d)^{1/2}\,\upsilon(\gamma)\,\eta(\tau)
    &=
    \eta((\gamma'\gamma'')\tau) =
    \eta(\gamma'\tau')
    =
      (c'\tau'+d')^{1/2}\,\upsilon(\gamma')\,\eta(\tau')\\
    &=
      \left(\frac{c\tau + d}{c''\tau + d''}\right)^{1/2} \,(c''\tau+d'')^{1/2}
      \,\upsilon(\gamma')\,\,\upsilon(\gamma'')\eta(\tau).
  \end{align*}
  After squaring both sides and cancelling equal terms, the statement
  of the Lemma can be concluded.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta$ under $GL_2^+(\setZ)$}
\label{sec:eta-transformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
$W=\left(\begin{smallmatrix}A&B\\C&D\end{smallmatrix}\right) \in
GL_2^+(\setZ)$.
%
Then for $h=\gcd(A, C)>0$, $a':=\frac{A}{h}$, $c':=\frac{C}{h}$ we
have $\gcd(a', c')=1$ and thus can find $b'$ and $d'$ such that
$a'd'-b'c'=1$.
%
Let
\begin{gather*}
  W':=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix},
  \qquad
  W''
  :=
  \begin{pmatrix}
    h &B d'-D b'\\
    0 & \det(W) / h
  \end{pmatrix}.
\end{gather*}
Then $W'\in SL_2(\setZ)$ and $W = W' W''$.


Note that for any integer $s$ whe have:
\begin{align}
W = \begin{pmatrix}A&B\\C&D\end{pmatrix}
&=\begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}h &B d'- D b'\\0 &\det(W) / h\end{pmatrix}
  \\
&=
  \begin{pmatrix} a'&b' + a' s\\ c'&d' + c' s \end{pmatrix}
  \begin{pmatrix}
    h &B d'- D b'- s \det(W) / h\\
    0 &\det(W) / h\end{pmatrix}.
\end{align}
Therefore, we can choose $b'$ and $d'$ in such a way that
$0 \le B d'-D b' < \det(W)/h$.

Let $\tau' := W''\tau = \frac{h}{\det(W)}(h\tau + B d'- D b')$, then
$\tau'\in\setH$ and
\begin{gather}
\eta(W\tau) =
\eta(W'\tau') =
(c'\tau+d')^{1/2}\,\upsilon_\eta(W')\,\eta(\tau')
\label{eq:eta-W-transformation}
\end{gather}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begingroup
\newcommand{\h}{h}
\begin{Lemma}\label{thm:c*tau+d}
  Let $\gamma := \left(
    \begin{smallmatrix}a&b\\c&d\end{smallmatrix} \right)\in
  SL_2(\setZ)$, $\delta>0$, $m>0$, $z\ge0$, and
  \begin{gather*}
    W=
    \begin{pmatrix}
      \delta & z\\
      0      & m
    \end{pmatrix}
    \gamma
    = \begin{pmatrix}
        \delta a + c z & \delta b + d z\\
        c m & d m
      \end{pmatrix}
    \in GL_2^+(\setZ).
  \end{gather*}
  Then $\det(W)=\delta m$.
  %
  If
  $\h:=\gcd(\delta a + c z, cm)$,
  $a':=\frac{\delta a + c z}{\h}$,
  $c':=\frac{c m}{\h}$, and
  $b'$ and $d'$ are such that $a'd'-b'c'=1$ and
  $0 \le (\delta b + d z) d' - d m b' < cm / \h$, \ie,
  \begin{gather*}
    W':=\begin{pmatrix}
      (\delta a + c z) / \h & b'\\
      c m / \h              & d'
    \end{pmatrix},
    \qquad
    W''
    :=
    \begin{pmatrix}
      \h & (\delta b + d z) d' - d m b'\\
      0  & \delta m / \h
    \end{pmatrix}.
  \end{gather*}
  according to the splitting above,
  %
  then with $\tau':=W''\tau$ we have
  $c'\tau'+d' = \frac{\h}{\delta} (c\tau + d)$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\h}{\delta m}(h\tau + (\delta b + d z) d' - d m b')
    \right) + d'\\
  &=
    \frac{c m}{\h}
    \left(
    \frac{\h}{\delta m}(\h \tau + (\delta b + d z) d' - d m b')
    \right) + d'\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + b c \delta d' + c d d' z - c d m b'
    \right) + d'\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + (a d - 1) \delta d' + c d d' z - c d m b'
    + \delta d'
    \right)\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + a d \delta d' + c d d' z - c d m b'
    \right)\\
  &=
    \frac{1}{\delta}
    \left(
    \h c \tau + \h d (a' d' - c' b')
    \right)\\
  &=
    \frac{\h}{\delta} (c\tau + d)
\end{align*}
\end{proof}
\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_\delta$ under $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\delta \in \setN\setminus\Set{0}$.

\begin{gather*}
\eta_\delta(\gamma\tau)
=
\eta_\delta\left(\frac{a\tau+b}{c\tau+d}\right) =
\eta\left(\frac{a\delta\tau+b\delta}{c\tau+d}\right)
=
\eta\left(\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
  \tau\right).
\end{gather*}

Let
%
\begin{gather}
  \defineNotation[h-delta]{h_\delta}
  :=
  \gcd(\delta a,c), \label{eq:h_delta}
\end{gather}
%
$\defineNotation[a-delta]{a_\delta}:=\frac{\delta a}{h_\delta}$,
%
$\defineNotation[c-delta]{c_\delta}:=\frac{c}{h_\delta}$,
%
and $\defineNotation[b=delta]{b_\delta}$ and
$\defineNotation[d-delta]{d_\delta}$ are chosen in such a way that
$a_\delta d_\delta - b_\delta c_\delta = 1$.
%
Because of $\gcd(a_\delta, c_\delta)=1$, such $b_\delta$ and $d_\delta$
can be found.
%
Therefore
  $\defineNotation[gamma-delta]{\gamma_\delta} := \left(
  \begin{smallmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{smallmatrix}
\right)\in SL_2(\setZ)$.

Note that $h_\delta=\gcd(\delta, c)$, because $\gcd(a,c)=1$ and,
furthermore,
\begin{align}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\label{eq:naive-matrix-split}
\end{align}
Note that for any integer $s$ whe have:
\begin{align*}
\begin{pmatrix}a\delta&b\delta\\c&d\end{pmatrix}
&=\begin{pmatrix}a_\delta&b_\delta\\c_\delta&d_\delta\end{pmatrix}
  \begin{pmatrix}1& s\\0&1\end{pmatrix}
  \begin{pmatrix}1&-s\\0&1\end{pmatrix}
  \begin{pmatrix}
    h_\delta&\delta b d_\delta-d b_\delta\\
    0      &\delta / h_\delta\end{pmatrix}
  \\
&=
  \begin{pmatrix}
    a_\delta&b_\delta + a_\delta s\\
    c_\delta&d_\delta + c_\delta s
  \end{pmatrix}
  \begin{pmatrix}h_\delta&\delta b d_\delta-d b_\delta-s \delta / h_\delta\\
                 0      &\delta / h_\delta\end{pmatrix}.
\end{align*}
Therefore, we can choose $b_\delta$ and $d_\delta$ in such a way that
$0 \le \delta b d_\delta-d b_\delta < \delta/h_\delta$.

If $c=0$, then $a=d=1$, $h_\delta=\delta$. We can choose $d_\delta=1$
and $b_\delta= \delta b  d_\delta$ and get
\begin{align}
\begin{pmatrix}\delta&b\delta\\0&1\end{pmatrix}
&=\begin{pmatrix}1&b \delta\\0&1\end{pmatrix}
  \begin{pmatrix}\delta&0\\
                 0      &1\end{pmatrix}.
\end{align}

If we set
\begin{gather}
  \defineNotation[tau-delta]{\tau_\delta}
  :=
  \begin{pmatrix}
    h_\delta & \delta b d_\delta-d b_\delta\\
    0       & \delta / h_\delta
  \end{pmatrix} \tau
  =
  \frac{h_\delta\tau+\delta b d_\delta-d b_\delta}{\delta/h_\delta},
  \label{eq:tau_delta}
\end{gather}
then
\begin{gather*}
  \eta_\delta(\gamma\tau)
  =
  \eta(\gamma_\delta \tau_\delta)
  =
  (c_\delta\tau_\delta+d_\delta)^{1/2}
  \,
  \upsilon(\gamma_\delta)
  \,
  \eta(\tau_\delta).
\end{gather*}


From Lemma~\ref{thm:c*tau+d} we get
\begin{align*}
  c_\delta\tau_\delta+d_\delta
  &=
  \frac{h_\delta}{\delta}(c \tau + d).
\end{align*}

Thus, we have
\begin{gather}
\eta_\delta(\gamma\tau)
=
\left(\frac{h_\delta}{\delta}(c \tau+d)\right)^{\!1/2}
\unityPower{\frac{\kappa_\delta}{24}}
\,
\eta(\tau_\delta).
\label{eq:eta_delta(gamma*tau)}
\end{gather}
where
$\defineNotation[kappa-delta]{\kappa_\delta} \in \Set{0,\ldots,23}$ is
defined by
$\unityPower{\frac{\kappa_\delta}{24}} := \upsilon(\gamma_\delta)$.



For the following definition see \cite[Lemma~2.37]{Radu:PhD:2010} and
\cite[Definition~2.9]{Radu:PhD:2010}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\label{def:width}
  Let
  $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)
  \in SL_2(\setZ)$ and $N$ be a positive integer. Then
  \begin{gather}
    \defineNotation[w-gamma]{w_\gamma} = \frac{N}{\gcd(c^2, N)}
    \label{eq:width}
  \end{gather}
  is called the \emph{width of $\gamma$ with respect to $\Gamma_0(N)$}.
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For
$\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ we want to expand $\eta(\tau_\delta)$ in
$\defineNotation[x]{x}:=q^{1/w_\gamma}=\unityPower{\frac{\tau}{w_\gamma}}$
with coefficients from $\setQ(\xi)$ where
$\defineNotation[xi]{\xi} := \unityPower{\frac{c}{24N}}$.

Since we are only interested in expansions at the cusps, we can assume
$0<c\in\Delta$.

In the following let $\delta \in \Delta$. Because of
$x=q^{1/w_\gamma}$, \eqref{eq:tau_delta} and \eqref{eq:width}, we
have
\begin{align}
  \defineNotation[q-delta]{q_\delta} = \unityPower{\tau_\delta}
  &= x^{e_\delta} \, \unityPower{v_\delta}
\label{eq:q_delta}
\end{align}
for
\begin{gather}
  \defineNotation[e-delta]{e_\delta} :=
  \frac{w_\gamma h_\delta^2}{\delta},
  \qquad
  \defineNotation[v-delta]{v_\delta} :=
  \frac{\delta b d_\delta-d b_\delta}{\delta/h_\delta}.
  \label{eq:uv_delta}
\end{gather}
In particular, if $c=0$, then $a=d=1$, $w_\gamma=1$,
$h_\delta=\delta$, $e_\delta=\delta$, $v_\delta=0$.

%
Note that $\unityPower{\frac{v_\delta}{24}} = \xi^k$ for
$k = (\delta b d_\delta - d b_\delta) \frac{N}{\lcm(\delta,c)}\in \setZ$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  If $\gamma =
\bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$, $N > 0$, $\delta \in \Delta$, then
$e_\delta \in \setZ$.
\end{Lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
If $c=0$, then $e_\delta=\delta\in\setZ$. Without loss of generality,
we can assume $c>0$.
If $p$ is a prime that divides $N$, \ie, $N=N'p^\alpha$ for some
$\alpha>0$, and $\delta = \delta' p^m$, $c=c' p^k$ with
$\gcd(p,N')=\gcd(p,\delta')=\gcd(p,c')=1$, then
\begin{align*}
  e_\delta
  &=
  \frac{N}{\gcd(c^2,N)} \frac{\gcd(\delta,c)^2}{\delta}\\
  &=
  \frac{p^\alpha N' \gcd(p^m \delta', p^k c')^2}{\gcd(p^{2k}
    c'^2,p^\alpha N') p^m \delta'}\\
  &=
  p^{\alpha + 2 \min(m,k) - m - \min(2k, \alpha)}
  \frac{N' \gcd(\delta', c')^2}{\gcd(c'^2, N') \delta'}
\end{align*}
If we can show that $e:=\alpha + 2 \min(m,k) - m - \min(2k,
\alpha)\ge0$ then $e_\delta\in\setN$ follows by repeating the above
process for every prime divisor of $N$.

There are several cases to consider:
\begin{itemize}
\item $0\le m\le k \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2m-m-2k=(\alpha-2k)+m\ge0$.
\item $0\le m\le k \le \alpha < 2k$. Then
  $e=\alpha+2m-m-\alpha=m\ge0$.

\item $0\le k\le m \le \alpha$, $2k \le \alpha$. Then
  $e=\alpha+2k-m-2k=\alpha-m\ge0$.
\item $0\le k\le m \le \alpha < 2k$. Then
  $e=\alpha+2k-m-\alpha=2k-m\ge0$.
\end{itemize}
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We can expand $\eta(\tau_\delta)$ in terms of $x$ as follows.
\begin{gather*}
  \eta(\tau_\delta)
  =
    \unityPower{{\frac{\tau_\delta}{24}}}
    \prod_{n=1}^{\infty}(1-q_\delta^n)
  =
  \unityPower{\frac{v_\delta}{24}} x^{e_\delta/24}
  \cdot
  \prod_{n=1}^{\infty}(1-q_\delta^n).
\end{gather*}

Then \eqref{eq:eta_delta(gamma*tau)} turns into
\begin{align}
\eta_\delta(\gamma\tau)
&=
(c \tau+d)^{1/2}
\,
\left(\frac{h_\delta}{\delta}\right)^{\!\frac{1}{2}}
\,
  \unityPower {\frac{v_\delta + \kappa_\delta}{24}}
  x^{e_\delta/24} \cdot \prod_{n=1}^{\infty}(1-q_\delta^n).
\label{eq:eta_delta(gamma*tau)-expansion}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  For any $c, \delta \in\Delta$, $r\in R(N)$ let us define
  \begin{align}
    \defineNotation[a-N]{a_N}(c, \delta)
    &:= \frac{N}{\gcd(N, c^2)} \frac{\gcd(c,\delta)^2}{\delta},
      \notag\\
    \defineNotation[ord-c-N]{\ord_c^N}(r)
    &:= \frac{1}{24}\divisorsum{N} a_N(c, \delta) \, r_\delta.
    \label{eq:order-r}
  \end{align}
\end{Definition}

With $\defineNotation[ord-gamma-N]{\ord_\gamma^N}$ as defined in
\cite{Radu:RamanujanKolberg:2015}, Theorem~23 of
\cite{Radu:RamanujanKolberg:2015} turns into
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\label{thm:order}
  Let $\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c\in\Delta$.
  If $r \in R^*(N)$, then
  $\ord_\gamma^N(g_r) = \ord_c^N(r)$.
\end{Theorem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For a proof we refer to
\cite[Proposition~3.2.8]{Ligozat:CourbesModulaires:1975}.

In the following let us fix $r \in R(N)$ and
$\gamma =
  \bigl(
  \begin{smallmatrix}
    a & b\\
    c & d
  \end{smallmatrix}
  \bigr)
  \in SL_2(\setZ)$ with $c \in \Delta$.

From \eqref{eq:eta_delta(gamma*tau)-expansion} follows
\begin{align}
  g_r(\gamma \tau)
  &=
  \divisorprod{N}
  (c \tau+d)^{r_\delta/2}
  \,
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \,
  \unityPower{\frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{r_\delta e_\delta/24}
  \cdot
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}
  \notag
  \\
  %
  &=
  (c \tau+d)^{\divisorsum{N} \frac{r_\delta}{2}}
  \cdot
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\divisorsum{N} \frac{r_\delta e_\delta}{24}}
  \cdot
    \divisorprod{N} \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}.
  \label{eq:g_r(gamma*tau)}
\end{align}
%
If $r\in R^*(N)$, then $g_r$ is a modular function on $\Gamma_0(N)$.
Because of \eqref{eq:sum=0}, $e_\delta=a_N(c, \delta)$, and
\eqref{eq:order-r}, we can write
\begin{align}
  g_r(\gamma \tau)
  &=
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \cdot
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  x^{\ord^N_c(r)}
  \cdot
  \divisorprod{N}
    \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta}\notag\\
  \label{eq:modular-g_r(gamma*tau)}
\end{align}
Thus, we can expand $g_r(\gamma\tau)$ as a Laurent series in
$x:=q^{1/w_\gamma}$ with coefficients from $\setQ(\xi)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Root of unity reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that any modular function (in particular $g_r$) can be expressed
as a rational function $f$ in $j$ and $j_N$ where
$j_N(\tau):=j(N\tau)$ and $j$ is Klein's $j$-invariant, \ie,
$g_r(\tau)=f(j, j_N)(\tau) := f(j(\tau), j(N\tau))$.

Let $\frac{a}{c}$ be a cusp of $\Gamma_0(N)$.
%
We can choose $b$ and $d$ such that
%
$\gamma := \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$ and $\gamma\infty=\frac{a}{c}$.
%
Klein's $j$-function is invariant under any modular transformation.
%
Let us consider the transformation of $j_N$ by $\gamma$.
%
According to \eqref{eq:tau_delta} for $\delta=N$, $j_N(\gamma\tau)$
can be expanded into a Laurent series in
$x=q^{1/w_\gamma}=\unityPower{\tau/w_\gamma}$ with
coefficients from $\setQ(\xi)$ where $\xi$ is a $\frac{N}{c}$-th root
of unity.
%
Since there is some freedom to choose such $b$ and $d$, we show in the
following, how we can obtain an expansion of $j_N(\gamma\tau)$ and
therefore (via $f$) an expansion $g_r(\gamma\tau)$ into a Laurent
series in $x$ with coefficients in $\setQ(\xi)$ where $\xi$ is a
$v$-th root of unity and $1 \leq v \le N/c$ and $v<N/c$ if $c<N$.

Let
$\gamma' = \bigl(
\begin{smallmatrix}
  a & b'\\
  c & d'
\end{smallmatrix}
\bigr) \in SL_2(\setZ)$, then also
\begin{align*}
  \gamma
  &:=
    \begin{pmatrix}
      a & b' + as\\
      c & d' + cs
    \end{pmatrix}
  =
    \begin{pmatrix}
      a & b'\\
      c & d'
    \end{pmatrix}
    \begin{pmatrix}
      1 & s\\
      0 & 1
    \end{pmatrix}
    \in SL_2(\setZ)
\end{align*}
for any $s\in\setZ$.

For the transformation of $j_N$, we split the matrix as in
\eqref{eq:naive-matrix-split} with $\delta=N$.
\begin{align*}
  \begin{pmatrix}
    N a & N(b' + as)\\
    c & d' + cs
  \end{pmatrix}
      &=
  \begin{pmatrix}
    N a/c & -1\\
    1     &  0
  \end{pmatrix}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix}
\end{align*}
into an element of $SL_2(Z)$ and a triangular matrix.
%
Then we determine natural numbers $u$ and $v$ such that $u v = N/c$
and $\gcd(c, u)=1$. Thus, we can find $s \in \setZ$ such that
$s \equiv -d'c^{-1} \pmod{u}$, \ie, $cs + d' = tu$ for some integer
$t$ with $0\le t<c$.
%
Thus,
\begin{gather*}
  \begin{pmatrix}
    c & cs+d'\\
    0 & N/c
  \end{pmatrix} \tau
  =
  \begin{pmatrix}
    c & u t\\
    0 & u v
  \end{pmatrix} \tau
  =
  \frac{c^2}{N} \tau + \frac{t}{v}
  =
 \frac{w_\gamma c^2}{N} \frac{\tau}{w_\gamma} + \frac{t}{v}
  =
 \frac{c}{\gcd(c,N/c)} \frac{\tau}{w_\gamma} + \frac{t}{v}
  .
\end{gather*}
Note that $u=N/c$ and $v=1$, if $N$ is squarefree.

With the particular $s$ from above, we define $b:=b'+as$, $d:=d'+cs$
and take
%
$\gamma = \bigl(
\begin{smallmatrix}
  a & b\\
  c & d
\end{smallmatrix}
\bigr)$ as the transformation matrix that belongs to the cusp
$\frac{a}{c}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The function $g_{s,m,t}$ and its transformations under
  $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the following let
$\defineNotation[m]{m},
\defineNotation[M]{M},
N \in \setN \setminus \Set{0}$, and
$s \in R(M)$
be subject to the following conditions
\begin{gather}
  \text{for every prime $p$ with $\divides{p}{m}$ follows $\divides{p}{N}$,}
  \label{eq:p|m=>p|N}\\
  \text{and, if $\divides{\delta}{M}$ and $s_\delta\ne0$, then
    $\divides{\delta}{mN}$.}
  \label{eq:delta|M=>delta|mN}
\end{gather}

For the above conditions see (13) and (14) in
\cite{Radu:AlgorithmicApproachRamanujanCongruences:2009} or
Section~4.2 in \cite{Radu:PhD:2010}.

Furthermore, we fix $t\in\Set{0,\ldots,m-1}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let
\begin{gather*}
  f(\tau)
  =
  \sum_{n=0}^\infty a(n) q^n
  =
  \divisorprod{M}\prod_{n=0}^\infty(1-q^{\delta n})^{s_\delta}
  =
  \unityPower{-\frac{\tau \, \sumdelta{s}}{24}} g_s(\tau)
\end{gather*}
be the generating function for the sequence $(a(n))_{n\in\setN}$
where we have abbreviated
\begin{gather}
  \defineNotation[s^{}]{\sumdelta{s}} := \divisorsum{M} \delta s_\delta.
  \label{eq:sumdelta}
\end{gather}

Let $\defineNotation[U-m]{U_m}$ be an operation on functions
$\setH\to\setC$ so that
\begin{gather*}
  (U_m\phi)(\tau) := \frac{1}{m}\sum_{\lambda=0}^{m-1}
  \phi\left(\frac{\tau+\lambda}{m}\right).
\end{gather*}
Let $f_t(\tau):=\unityPower{-t\tau}f(\tau)$, then
\begin{align*}
  (U_mf_t)(\tau)
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}f_t\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{t\tau+t\lambda}{m}}
  \sum_{k=0}^\infty a(k) \unityPower{\frac{k\tau+n\lambda}{m}}
  \\
  &=
  \frac{1}{m}
  \sum_{k=0}^\infty
  a(k)
  \sum_{\lambda=0}^{m-1}
  \unityPower{\frac{(k-t)(\tau+\lambda)}{m}}
  \\
  &=
  \frac{1}{m}
  \sum_{k=0}^\infty
  a(k)\,
  \unityPower{\frac{(k-t)\tau}{m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{\frac{(k-t)\lambda}{m}}
  \\
  &=
    \sum_{n=0}^\infty
    \sum_{l=0}^{m-1}
  a(mn+l)\,
  \unityPower{\frac{(mn+l-t)\tau}{m}}
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}\unityPower{\frac{(mn+l-t)\lambda}{m}}\\
  &=
    \sum_{n=0}^\infty a(mn+t) q^n
\end{align*}
is the generating function for the series
$(a(mn+t))_{n\in\setN}$.


Note that
$\sum_{\lambda=0}^{m-1}\unityPower{\frac{(mn+l-t)\lambda}{m}}$ is
equal to $m$ for $l=t$ and vanishes in all other cases.

We can also evaluate $(U_mf_t)(\tau)$ in another way.
%
\begin{align*}
  (U_mf_t)(\tau)
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}f_t\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m} \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{t\tau+t\lambda}{m} - \frac{\tau+\lambda}{24m} \sumdelta{s}}
  g_s\left(\frac{\tau+\lambda}{m}\right)\\
  &=
  \frac{1}{m}
  \unityPower{-\frac{\tau (24t+\sumdelta{s})}{24m}}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda (24t+\sumdelta{s})}{24m}}
  \divisorprod{M}
    \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{s_\delta}
\end{align*}

As abbreviation, we define the function
\begin{align}
  \defineNotation[g-s-m-t-lambda]{g_{s,m,t,\lambda}(\tau)}
  &:=
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{s})}
  \divisorprod{M}
  \eta\left(\frac{\delta(\tau+\lambda)}{m}\right)^{s_\delta}
  \label{eq:g_s-m-t-lambda(tau)}
\end{align}

In the following we consider the function
\begin{align}
  \defineNotation[g-s-m-t]{g_{s,m,t}(\tau)}
  &:= \unityPower{\frac{\tau (24t+\sumdelta{s})}{24m} } (U_mf_t)(\tau)
  =
  \frac{1}{m} \sum_{\lambda=0}^{m-1} g_{s,m,t,\lambda}(\tau)
  \label{eq:g_s-m-t(tau)}
\end{align}
and its transformations under $SL_2(\setZ)$.

Note that $g_s = g_{s, 1, 0}$.

We aim at the expansion of $g_{s,m,t}(\tau)$ at all cusps
$\gamma = \left(
  \begin{smallmatrix}a&b\\c&d\end{smallmatrix} \right)\in SL_2(\setZ)$
of $\Gamma_0(N)$ into Puiseux series in $x=q^{1/w_\gamma}$ or rather
into Laurent series in
$\defineNotation[z]{z} := q^{\frac{1}{24 w_\gamma}}$. Temporarily (for
the expansion of $\eta_{\delta,m,\lambda}$) we will expand into
Laurent series in
$\defineNotation[z-m]{z_m} := q^{\frac{1}{24 m w_\gamma}}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $\eta_{\delta,m,\lambda}$ under
  $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\defineNotation[lambda]{\lambda} \in \Set{0,\ldots,m-1}$, and
$\divides{\delta}{M}$.
%
We define
\begin{gather}
  \defineNotation[eta-delta-m-lambda]{\eta_{\delta,m,\lambda}}(\tau)
  := \eta \left(
    \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix} \tau
  \right).
\label{eq:eta_delta-m-lambda}
\end{gather}

Let
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$.
%
Then
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &:= \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix}
  \gamma
  \tau
\right)
=
\eta(W \tau)
\end{align}
where
\begin{align}
  W &:=
  \begin{pmatrix}
    \delta (a + c \lambda) & \delta (b + d \lambda)\\
    c m                   & d m
  \end{pmatrix}.
  \label{eq:W_delta-m-lambda}
\end{align}

Setting $z = \delta \lambda$ in Lemma~\ref{thm:c*tau+d}, we get the
splitting of $W = W' W''$ as
%
\begin{gather}
  W' =
  \begin{pmatrix}
    a' & b'\\
    c' & d'
  \end{pmatrix}
  = \begin{pmatrix}
      \delta(a+c \lambda)/h_{\delta,m,\lambda} & b'\\
      cm/h_{\delta,m,\lambda}                  & d'
    \end{pmatrix},
  \qquad
  W''
  =
  \begin{pmatrix}
    h_{\delta,m,\lambda} & \delta (b + d \lambda) d' - d m b'\\
    0               & \delta m / h_{\delta,m,\lambda}
  \end{pmatrix}
  \label{eq:split-W_delta-m-lambd}
\end{gather}
where $b'$ and $d'$ have been chosen in such a way that
$0\le  \delta (b + d \lambda) d' < \delta m / h_{\delta,m,\lambda}$.
and
\begin{gather}
  \defineNotation[h-delta-m-lambda]{h_{\delta,m,\lambda}} :=
  \gcd(\delta (a + c \lambda), cm).
\end{gather}

Let us define
\begin{gather}
  \defineNotation[u-delta-m-lambda]{u_{\delta,m,\lambda}}
  :=
  \frac{h_{\delta,m,\lambda}^2}{\delta m},
  \qquad
  \defineNotation[v-delta-m-lambda]{v_{\delta,m,\lambda}}
  :=
  \frac{h_{\delta,m,\lambda}(\delta (b + d \lambda) d' - d m b')}{\delta m}.
\end{gather}

And further,
\begin{align*}
  \defineNotation[tau-delta-m-lambda]{\tau_{\delta,m,\lambda}}
  &:=
    W''\tau
    = \frac{h_{\delta,m,\lambda}^2 \tau}{\delta m} +
    \frac{h_{\delta,m,\lambda}(\delta (b + d \lambda) d' - d m
    b')}{\delta m}\\
    &= u_{\delta,m,\lambda} \tau + v_{\delta,m,\lambda}.
\end{align*}
Then
$\defineNotation[q-delta-m-lambda]{q_{\delta,m,\lambda}} :=
\unityPower{\tau_{\delta,m,\lambda}} =
q^{u_{\delta,m,\lambda}}\,\unityPower{v_{\delta,m,\lambda}}$.


Lemma~\ref{thm:c*tau+d} tells us
$c'\tau_{\delta,m,\lambda}+d' = \frac{h_{\delta,m,\lambda}}{\delta} (c \tau + d)$.
%
Therefore,
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &= \eta(W \tau)
    = (c'\tau'+d')^{1/2} \, \upsilon(W')
    \,\eta(\tau_{\delta,m,\lambda})\notag\\
  &=
    (c\tau+d)^{1/2}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{1/2}
    \unityPower{\frac{\kappa_{\gamma,\delta,m,\lambda}}{24}} \,
    q_{\delta,m,\lambda}^{1/24}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)\notag\\
  &=
    (c\tau+d)^{1/2}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{1/2}
    \unityPower{\frac{ v_{\delta,m\lambda} + \kappa_{\gamma,\delta,m,\lambda}}{24}}
    q^{u_{\delta,m,\lambda}/24}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)
    \label{eq:eta_delta-m-lambda(gamma*tau)}
\end{align}
where
$\defineNotation[kappa-gamma-delta-m-lambda]{\kappa_{\gamma,\delta,m,\lambda}}
\in \Set{0,\ldots,23}$ is defined by
$\unityPower{\frac{\kappa_{\gamma,\delta,m,\lambda}}{24}} = \upsilon(W')$.

We expand $\eta_{\delta,m,\lambda}(\gamma \tau)$ into a Laurent series
in $z_m$ with coefficients from $\setQ(\xi_m)$ where
$\xi_m := \unityPower{\frac{1}{24 m N}}$. Note that
$\unityPower{\frac{v_{\delta,m,\lambda}}{24}}=\xi_m^k$ for
$k=\frac{N}{\delta} h_{\delta,m,\lambda}(\delta (b + d \lambda) d' - d
m b') \in \setZ$.
\begin{Hemmecke}
  $\xi_m$ is not yet what we want.
\end{Hemmecke}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $g_{s,m,t,\lambda}$ under $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

From its definition~\eqref{eq:g_s-m-t-lambda(tau)} and
\eqref{eq:eta_delta-m-lambda(gamma*tau)}, we can easily find a formula
for the transformation of $g_{s,m,t,\lambda}$ under $SL_2(\setZ)$.

\begin{align}
  g_{s,m,t,\lambda}(\gamma\tau)
  &=
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{s}\Bigr)}
    \divisorprod{M}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{s_\delta}\notag\\
  \begin{split}
  &=
    (c\tau+d)^{\divisorsum{M} \frac{s_\delta}{2}} \cdot
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{s}\Bigr)
    + \divisorsum{M}\frac{s_\delta(v_{\delta,m,\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\\
  & \qquad\times
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{s_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} s_\delta u_{\delta,m,\lambda}}{24} \tau}
    \cdot
    \divisorprod{M}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{s_\delta}
  \end{split}
  \label{eq:g_s-m-t-lambda(gamma*tau)}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $g_{s,m,t}$ under $SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

From its definition~\eqref{eq:g_s-m-t(tau)}
and \ref{eq:g_s-m-t-lambda(gamma*tau)}, we can easily find a formula
for the transformation of $g_{s,m,t}$ under $SL_2(\setZ)$.

\begin{align}
  g_{s,m,t}(\gamma\tau)
  &:=\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{s,m,t,\lambda}(\gamma\tau)\notag\\
  \begin{split}
  &=
    \frac{(c\tau+d)^{\divisorsum{M} \frac{s_\delta}{2}}}{m}
    \sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{s}\Bigr)
    + \divisorsum{M}\frac{s_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\\
  & \qquad\times
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{s_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} s_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M}
    \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{s_\delta}
  \end{split}
  \label{eq:g_s-m-t(gamma*tau)}
\end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find ``modular'' cofactor for $g_{s,m,t}(\tau)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~35]{Radu:RamanujanKolberg:2015}
  Let $\Delta^*$ be the set of all tuples $(m, M, N, t, s)$ such that
  $m, M, N \in \setN\setminus\Set{0}$,
  %
  $t \in \Set{0,\ldots,m-1}$,
  %
  $s \in R(M)$
  %
  fulfil conditions \eqref{eq:p|m=>p|N} and \eqref{eq:delta|M=>delta|mN}
  and for
  %
  $\kappa:=\gcd(1-m^2, 24)\ge1$,
  %
  $w' := \gcd(\kappa(24t + \sumdelta{s}),24m)$,
  %
  $w := \frac{24m}{w'}$
  %
  the following conditions hold:
  \begin{gather}
  \kappa \frac{m N^2}{M} \divisorsum{M} \frac{M}{\delta}
    s_\delta \equiv_{24} 0,\\
  \kappa N \divisorsum{M} s_\delta \equiv_8 0,\\
  \divides{w}{N},\\
  \divides{2}{m} \implies (\kappa N \equiv_4 0 \land \divides{8}{N e})
  \lor
  (\divides{2}{e} \land \divides{8}{N(u-1)})
\end{gather}
where $e, u\in\setZ$ are such that $u$ is odd and
$\divisorprod{M} \delta^{\abs{r_\delta}}=2^e u$.
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}\label{thm:y^2-1}
  Let $y\in \setZ$ be such that $gcd(y, 6)=1$ then
  $y^2 \equiv_{24} 1$, \ie, $ \frac{y^2-1}{24} \in \setZ$.
\end{Lemma}
\begin{proof}
  Let $y = 6k + l$ with $l \in \Set{0,\ldots,5}$. Then
  $\gcd(y, 6)=\gcd(l,6)=1$ only holds for $l=1$ or $l=5$.
  %
  Since $36 k^2 + 12 k l + l^2 = 12k(3k+l) + l^2$, and $12k(3k+l)$ is
  divisible by 24 for $l=1$ or $l=5$, the statement of the Lemma
  follows from the fact that $1^2\equiv_{24} 5^2 \equiv_{24} 1$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~40]{Radu:RamanujanKolberg:2015}
  Let $n \in \setN$, $n>1$. For $x \in \setZ$ we denote by
  $[x]_n\in \setZ_n$ the residue class of $x$ modulo $n$ and define
  \begin{gather*}
    \setS_{n} := \SetDef{[y^2]_n}{y \in \setZ \land \gcd(y, n)=1}
    \subseteq
    \setZ_n.
  \end{gather*}
\end{Definition}

Let $x \in \setZ$ be such that $[x]_{24_m} \in \setS_{24m}$. Then
there exists $y \in \setZ$ with $\gcd(y, 24m)=1$ and
$[x]_{24m}=[y^2]_{24m}$, \ie, $x = y^2 + k (24m)$ for some $k\in
\setZ$. From Lemma~\ref{thm:y^2-1} follows that
$\frac{x-1}{24}=\frac{y^2-1}{24} + km \in\setZ$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~41]{Radu:RamanujanKolberg:2015}
  Let $s \in R(M)$.
  %
  The mapping
  \begin{align*}
    \bar{\odot}_s &: \setS_{24m} \times \Set{0,\ldots,m-1} \to
    \Set{0,\ldots,m-1},
    \qquad
    ([x]_{24m}, t) \mapsto [x]_{24m}  \mathbin{\bar{\odot}_s} t
  \end{align*}
  is uniquely given by
  \begin{gather}
    [x]_{24m} \mathbin{\bar{\odot}_s} t
    :=
    \left( t x + \frac{x-1}{24} \sumdelta{s} \right) \bmod{m}
  \end{gather}
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}
  (Definition 42 and Lemma 43 of \cite{Radu:RamanujanKolberg:2015})
  For $t\in\Set{0,\ldots,m-1}$, $s \in R(M)$ we define
  %
  \begin{align}
    \defineNotation[P-s-m-t]{P_{s,m,t}}
    &:=
      \setS_{24m}  \mathbin{\bar{\odot}_s} t
      =
      \SetDef{x \mathbin{\bar{\odot}_s} t}{x \in \setS_{24m}},
    \\
    %
    \defineNotation[chi-s-m-t]{\chi_{s,m,t}}
    &:=
      \prod_{t' \in P_{s,m,t}}
        \unityPower{\frac{(1-m^2)(24 t'+ \sumdelta{s})}{24 m}}.
  \end{align}
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Lemma}
  \label{thm:stable-P-s-m-t}
  \label{thm:chi-exponent}
  \cite[Lemma~43]{Radu:RamanujanKolberg:2015}
  Let $t\in\Set{0,\ldots,m-1}$, $s \in R(M)$. Then
  \begin{enumerate}
  \item for any $x \in \setS_{24m}$ we have
    $P_{s,m,t}
    = x \mathbin{\bar{\odot}_s} P_{s,m,t}
    = \SetDef{x \mathbin{\bar{\odot}_s} t'}{t'\in P_{s,m,t}}$,
  \item $\chi_{s,m,t}=\unityPower{\frac{\nu}{24}}$ for some
    $\nu \in \Set{0,\ldots,23}$.
  \end{enumerate}
\end{Lemma}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~44]{Radu:RamanujanKolberg:2015}
  Given $t\in\Set{0,\ldots,m-1}$, $s \in R(M)$, $r \in R(N)$, we
  define
  \begin{gather}
    F_{r, s, m, t}(\tau) := \divisorprod{N} \eta(\delta
    \tau)^{r_\delta} \prod_{t' \in P_{s,m,t}} g_{s,m,t'}(\tau)
  \end{gather}
\end{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Theorem}\cite[Thm.~45]{Radu:RamanujanKolberg:2015}
  \label{thm:RaduConditions}
  Let $(m, M, N, t, s) \in \Delta^*$, $r\in R(N)$, $\nu$ and $\mu$ be
  integers such that $\chi_{s,m,t}=\unityPower{\frac{\nu}{24}}$, and
  $\mu=\sizeOfSet{P_{s,m,t}}$, then $F_{r,s,m,t}(\tau)$ is a modular
  function on $\Gamma_0(N)$ iff the following conditions hold:
  \begin{align}
    \divisorsum{N} r_\delta + \mu \divisorsum{M} s_\delta
    &=
      0,
    \label{eq:Radu-sum=0}\\
    \divisorsum{M} \delta r_\delta + \mu m \divisorsum{N} \delta s_\delta + \nu
    &\equiv
      0 \pmod{24},
    \label{eq:Radu-sigmainfinity}\\
    \divisorsum{N} \frac{N}{\delta} r_\delta
    + \frac{\mu m N}{M} \divisorsum{M} \frac{M}{\delta} s_\delta
    &\equiv
      0 \pmod{24},
    \label{eq:Radu-sigma0}\\
    \sqrt{
    \divisorprod{N}\delta^{r_\delta}
    \divisorprod{M} (m \delta)^{\mu s_\delta}
    } &\in \setQ\label{eq:Radu-productsquare}
  \end{align}
\end{Theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $m, M, N, t, r, s, \nu, \mu$ fulfil all the conditions of
Theorem~\ref{thm:RaduConditions}. Then the exponent of the factor
$c\tau+d$ is zero, \ie, this factor vanishes.

\begin{align*}
  F_{r,s,m,t}(\gamma\tau)
  &=
  (c\tau+d)^{\divisorsum{N} \frac{r_\delta}{2}}
  \cdot
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!\frac{r_\delta}{2}}
  \cdot
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  q^{\divisorsum{N} \frac{r_\delta u_\delta}{24}}
  \cdot
    \divisorprod{N} \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta} \times\\
  &\qquad\times
    \prod_{t'\in P_{s,m,t}}
    \frac{(c\tau+d)^{\divisorsum{M} \frac{s_\delta}{2}}}{m}
    \left[\sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t'+\sumdelta{s}\Bigr)
    + \divisorsum{M}\frac{s_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\right.\\
  &\qquad\times
    \left.
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{s_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} s_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M} \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{s_\delta}
    \right]
  \\
  &=
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!\frac{r_\delta}{2}}
  \cdot
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  \cdot
  q^{\divisorsum{N} \frac{r_\delta u_\delta}{24}}
    \cdot
    \divisorprod{N} \prod_{n=1}^{\infty}(1-q_\delta^n)^{r_\delta} \times\\
  &\qquad\times
    \frac{1}{m^\mu}
    \prod_{t'\in P_{s,m,t}}
    \left[\sum_{\lambda=0}^{m-1}
    \unityPower{-\frac{\lambda}{24m}\Bigl(24t'+\sumdelta{s}\Bigr)
    + \divisorsum{M}\frac{s_\delta(v_{\delta,m\lambda} +
    \kappa_{\gamma,\delta,m,\lambda})}{24}} \times\right.\\
  &\qquad\times
    \left.
    \divisorprod{M}
    \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!\frac{s_\delta}{2}}
    \cdot
    \unityPower{\frac{\divisorsum{M} s_\delta u_{\delta,m,\lambda}}{24}\tau}
    \cdot
    \divisorprod{M} \prod_{n=1}^\infty (1-q_{\delta,m,\lambda}^n)^{s_\delta}
    \right]
\end{align*}










For all $\lambda \in\Set{0,\ldots,m-1}$:
\begin{gather*}
  \mu \cdot \frac{\divisorsum{M} s_\delta u_{\delta,m,\lambda}}{24}\\
  \divisorsum{N} \frac{r_\delta e_\delta}{w_\gamma}
  + \mu \cdot \frac{\divisorsum{M} s_\delta h_{\delta,m,\lambda}^2}{24 \delta m}\\
\end{gather*}
































\begin{Hemmecke}
  Continue here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\end{Hemmecke}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Stuff for later}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Definition}\cite[Def.~36+41]{Radu:RamanujanKolberg:2015}
  Let $t\in\Set{0,\ldots,m-1}$, $r \in R(M)$.
  %
  We define two mappings
  \begin{align*}
    \odot_r &: \Gamma_0(N) \times \Set{0,\ldots,m-1} \to
    \Set{0,\ldots,m-1},
    \qquad
    (\gamma, t) \mapsto \gamma \odot_r t\\
    %
    \bar{\odot}_r &: \setS_{24m} \times \Set{0,\ldots,m-1} \to
    \Set{0,\ldots,m-1},
    \qquad
    ([s]_{24m}, t) \mapsto [s]_{24m} \bar{\odot}_r t
  \end{align*}
  where for
  $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)$
  the images $\gamma \odot_r t$ and $[s]_{24m} \bar{\odot}_r t$ are
  uniquely defined by the relations
  \begin{align*}
    \gamma \odot_r t &\equiv_m t a^2 + \frac{a^2-1}{24} \divisorsum{M}
    \delta r_\delta\\
    [s]_{24m} \bar{\odot}_r t &\equiv_m t s + \frac{s-1}{24}
    \divisorsum{M} \delta r_\delta
  \end{align*}
\end{Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



Let us compare this with \eqref{eq:def-g_s-m-t(tau)} where we have replaced
$t$ by $t'$ with $t' = t x + \frac{x-1}{24}s+km$ for some
$x\in\setN$ and $k\in\setZ$ such that $0\le t' < m$.
\begin{align}
  g_{s,m,t'}(\tau)
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}
    \Bigl(24\bigl(t x + \frac{x-1}{24}s+km\bigr)+\sumdelta{r}\Bigr)}
  \divisorprod{M}
  \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}.
\end{align}

If we can find some $x\in\setZ$ and $\kappa(r,t)\in\setC$ such that
for every $0\le \lambda<m$
\begin{gather}
  \unityPower{-\frac{\lambda}{24m} (24t + \sumdelta{r})}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
  = \kappa(r, t) \cdot
    \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
\end{gather}

According to
\cite[Thm.~2.14]{Radu:AlgorithmicApproachRamanujanCongruences:2009},
we choose $x=a^2$ and

\begin{gather*}
  \kappa(r,t)
  =
  \beta(\gamma,0) \, \unityPower{\frac{24t+\sumdelta{r}}{24m} ab(1-m^2)}
\end{gather*}

\begin{align*}
  \kappa(r, t)
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m} (\lambda - \lambda_\gamma x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda - ((b + d \lambda) d' - d m b^*) x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda(1 - dd'x) - (b d' - d m b^*) x}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
\end{align*}

\subsection{Transformation of $\eta_{\delta,m,\lambda}$ under
  $\Gamma_0(N)\subset SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $m$ and $N$ be a positive integers,
$\lambda \in \Set{0,\ldots,m-1}$, and $\divides{\delta}{M}$.
%
We define
\begin{gather}
\eta_{\delta,m,\lambda}(\tau) := \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix} \tau
\right).
\end{gather}

Let $\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
\Gamma_0(N)$.
%
Then
\begin{align}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &:= \eta
\left(
  \begin{pmatrix}\delta& \delta \lambda\\0&m\end{pmatrix}
  \gamma
  \tau
\right)
=
\eta(W \tau)
\end{align}
where
\begin{align}
  W &:=
  \begin{pmatrix}
    \delta (a + c \lambda) & \delta (b + d \lambda)\\
    c m                   & d m
  \end{pmatrix}.
  \label{eq:W_delta-m-lambda}
\end{align}

Let's apply the splitting of $W=W'W''$ into a matrix
$W'\in SL_2(\setZ)$ and an upper triangular matrix $W''$ as in the
Section~\ref{sec:eta-transformation} and compare with the proof of
Lemma~2.2 of \cite{Radu:AlgorithmicApproachRamanujanCongruences:2009}.

We get
%
$\det(W) = \delta m$, because $\det(\gamma)=1$.

Furthermore,
$h = \gcd(\delta(a + c \lambda), \delta \frac{cm}{\delta})=\delta$,
%
$a' = a + c \lambda$, and
%
$c' = \frac{cm}{\delta}$.
%
From \eqref{eq:delta|M=>delta|mN} and $\divides{N}{c}$ (because
$\gamma \in \Gamma_0(N)$) follows $\divides{\delta}{mc}$ and
$c'\in \setZ$.

Note that $\gcd(a,c)=1$. Thus $\gcd(a + c \lambda, c)=1$ and because of
$\divides{N}{c}$,
% ($\gamma \in \Gamma_0(N)$)
it follows $\gcd(a + c \lambda, N)=1$.
%
Then \eqref{eq:p|m=>p|N} implies $\gcd(a + c \lambda, m)=1$.
%
Therefore $\gcd(a + c \lambda, cm)=1$ and we can find $b^*$ and $d'$ such
that $(a + c \lambda) d' - b^* cm =1$. It also holds $\gcd(a', c')=1$ and we
can choose $b'=\delta b^*$ such that $\det(W')=1$ for
\begin{gather}
  W'= \begin{pmatrix}a'&b'\\c'&d'\end{pmatrix}
  = \begin{pmatrix}a+c \lambda& \delta b^*\\cm/\delta&d'\end{pmatrix}.
  \label{eq:W'_delta-m-lambda}
\end{gather}

For the matrix $W''$ we obtain
\begin{gather}
  W''
  =
  \begin{pmatrix}
    \delta & \delta ((b + d \lambda) d' - d m b^*)\\
    0      & m
  \end{pmatrix}
  =
  \begin{pmatrix}
    \delta & \delta \lambda_\gamma\\
    0      & m
  \end{pmatrix}.
  \label{eq:W''_delta-m-lambda}
\end{gather}
where
\begin{gather}
  \lambda_\gamma := (b + d \lambda) d' - d m b^*.
  \label{eq:lambda_gamma}
\end{gather}

Note that
\begin{align*}
  W = W'\cdot W''
  &=
    \begin{pmatrix}a'& b'\\c'&d'\end{pmatrix}
    \cdot
    \begin{pmatrix}1& \delta s\\0&1\end{pmatrix}
    \begin{pmatrix}1&-\delta s\\0&1\end{pmatrix}
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& b' + a'\delta s\\c'&d' + c' \delta s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&-s\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma\\0&m\end{pmatrix}\\
  &=
    \begin{pmatrix}a'& \delta(b^* + (a+c \lambda)s)\\c'&d' + c m s\end{pmatrix}
    \cdot
    \begin{pmatrix}\delta&0\\0&1\end{pmatrix}
    \begin{pmatrix}1&\lambda_\gamma-sm\\0&m\end{pmatrix}
\end{align*}


Clearly, we can choose $s\in\setZ$ such that
$0 \le \lambda_\gamma - sm < m$.
%
In the following, we assume that already in the first place we have
chosen $b^*$ and $d'$ in such a way that $0\le \lambda_\gamma < m$. In
other words, we assume functions $(\gamma,\delta,m,\lambda)\mapsto W'$
and $(\gamma,m,\lambda)\mapsto \lambda_\gamma$.

Note that $\lambda_\gamma$ does depend on $\gamma$, $\lambda$, and
$m$, but it does not depend on $\delta$.

With $\tau':=W''\tau$ we have
\begin{align*}
  c'\tau'+d'
  &=
  c'
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d' - d m b'}{m}
    \right) + d'\\
  &=
    \frac{cm}{\delta}
    \left(
    \frac{\delta\tau+\delta(b + d \lambda) d'}{m}
    \right)  - d b' c' + d'\\
  &=
    c\tau + c(b + d \lambda) d' - d (a' d' -1) + d'\\
  &=
    c\tau + d + c(b + d \lambda) d' - d a' d' + d'\\
  &=
    c\tau + d + [c(b + d \lambda) - d (a + c \lambda) + 1]d'\\
  &=
    c\tau + d
\end{align*}
and thus
\begin{align*}
  \eta_{\delta,m,\lambda}(\gamma \tau)
  &= \eta(W \tau) = \eta(W'W''\tau) = \eta(W'\tau')\\
  &= (c'\tau'+d')^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \,\eta(\tau')\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta(W''\tau)\\
  &= (c\tau+d)^{1/2} \,\upsilon_{\gamma,\delta,m,\lambda} \, \eta
    \left(
    \begin{pmatrix}
      \delta & \delta \lambda_\gamma\\
      0      & m
    \end{pmatrix}
    \tau
    \right)\\
  &= (c\tau+d)^{1/2} \upsilon_{\gamma,\delta,m,\lambda} \, \eta_{\delta,m,\lambda_\gamma}(\tau)
\end{align*}
where $\upsilon_{\gamma,\delta,m,\lambda} := \upsilon(W')$ and
$\lambda_\gamma = d d' \lambda + b d' - d m b^*$, see \eqref{eq:lambda_gamma}.

Note that $d$ and $d'$ are invertible modulo $m$, \ie, given
$\lambda_\gamma$, we can find $\lambda$ such that
$\lambda\in\Set{0,\ldots,m-1}$ and
$\lambda_\gamma= d d' \lambda +  b d' - d m b^*$ holds.
%
We have $\gcd(d',m)=1$ by choice of $d'$. Because $\det(\gamma)=1$ and
$\divides{N}{c}$, it follows $\gcd(N, d)=1$. From \eqref{eq:p|m=>p|N}
follows invertibility of $d$ modulo $m$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation of $g_{r,m,t}$ under
  $\Gamma_0(N) \subset SL_2(\setZ)$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Hemmecke}
  Cannot use this section for expansion, since it only describes
  formulas for $\Gamma_0(N)$.
\end{Hemmecke}

From the previous section, we can easily find a formula for the
transformation of $g_{r,m,t}$ under $SL_2(\setZ)$.

\begin{align*}
  g_{r,m,t}(\gamma\tau)
  &:=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
  \divisorprod{M}
    \eta_{\delta,m,\lambda}(\gamma\tau)^{r_\delta}
  \\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{r}\Bigr)}
    (c\tau+d)^{\divisorsum{M} r_\delta/2}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\divisorsum{M} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}\\
  &=
  (c\tau+d)^{\divisorsum{M} r_\delta/2}
  \cdot
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
    \divisorprod{M} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}
\end{align*}

Let us compare this with \eqref{eq:g_s-m-t(tau)} where we have replaced
$t$ by $t'$ with $t' = t x + \frac{x-1}{24}s+km$ for some
$x\in\setN$ and $k\in\setZ$ such that $0\le t' < m$.
\begin{align}
  g_{r,m,t'}(\tau)
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m}
    \Bigl(24\bigl(t x + \frac{x-1}{24}s+km\bigr)+s\Bigr)}
  \divisorprod{M}
  \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda}(\tau)^{r_\delta}\\
  &=
  \frac{1}{m}
  \sum_{\lambda=0}^{m-1}
  \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
  \divisorprod{M} \eta_{\delta,m,\lambda_\gamma}(\tau)^{r_\delta}.
\end{align}

If we can find some $x\in\setZ$ and $\kappa(r,t)\in\setC$ such that
for every $0\le \lambda<m$
\begin{gather}
  \unityPower{-\frac{\lambda}{24m} (24t+\sumdelta{r})}
    \divisorprod{M}
    \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}
  = \kappa(r, t) \cdot
    \unityPower{-\frac{\lambda_\gamma}{24m} (24 t + \sumdelta{r}) x}
\end{gather}

According to
\cite[Thm.~2.14]{Radu:AlgorithmicApproachRamanujanCongruences:2009},
we choose $x=a^2$ and

\begin{gather*}
  \kappa(r,t)
  =
  \beta(\gamma,0) \, \unityPower{\frac{24t+\sumdelta{r}}{24m} ab(1-m^2)}
\end{gather*}

\begin{align*}
  \kappa(r, t)
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m} (\lambda - \lambda_\gamma x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda - ((b + d \lambda) d' - d m b^*) x)}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
  &=
    \unityPower{\frac{24 t + \sumdelta{r}}{24m}
      (\lambda(1 - dd'x) - (b d' - d m b^*) x}
    \divisorprod{M} \upsilon_{\gamma,\delta,m,\lambda}^{r_\delta}\\
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Z24 ==> IntegerMod 24
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LSym ==> List Symbol
LP ==> List P
LZ ==> List Z
LQ ==> List Q
LSL2Z ==> List SL2Z
OF ==> OutputForm
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage

)if LiterateDoc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SymbolicEtaDeltaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$,
$\divides{\delta}{N}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain \code{SymbolicEtaDelta}
represent the tuple
\begin{gather*}
  \left(\frac{h_{\delta}}{\delta}, e_\delta, v_\delta, \kappa_\delta,
  \frac{v_\delta+\kappa_\delta}{24}\right)
\end{gather*}
from \eqref{eq:eta_delta(gamma*tau)-expansion} where the values are
given through \eqref{eq:h_delta}, \eqref{eq:width},
\eqref{eq:q_delta}, \eqref{eq:uv_delta}, and
$x=\unityPower{\frac{\tau}{w_\gamma}}$.

If \code{e = eta(m, delta, gamma)}, then we have the following
correspondence.
\code{rationalPrefactor(e)} $= \frac{h_\delta}{\delta}$,
\code{edelta(e)}            $= e_\delta$,
\code{vdelta(e)}            $= v_\delta$,
\code{upsilonExponent(e)}   $= \kappa_\delta$,
\code{unityPower(e)}        $= \frac{v_\delta+\kappa_\delta}{24}$.
)endif

)abbrev domain YEDG SymbolicEtaDeltaGamma
++ SymbolicEtaDeltaGamma collects data for the expansion of
++ eta_delta(\gamma \tau).
SymbolicEtaDeltaGamma: SetCategory with
    eta: (P, P, SL2Z) -> % -- gamma=[[a,b],[c,d]], m=level, delta, r_delta
      ++ eta(m, delta, gamma) represents the expansion of
      ++ \eta_\delta(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/) for  some cusp a/c.
    level: % -> P
      ++ level(x) returns the level corresponding to x.
    delta: % -> P
      ++ delta(x) returns the delta that was used at creation time of x.
    gamma: % -> SL2Z
      ++ gamma(x) returns the gamma as given at creation time of x.
    rationalPrefactor: % -> Q -- (h_delta/delta)
    upsilonExponent: % -> Z24 -- kappa_delta
    edelta: % -> P            -- width*gcd(delta,c)^2/delta
    vdelta: % -> Q            -- b2/d2
    unityPower: % -> Q        -- (kappa_delta + vdelta)/24
 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,    -- level \Gamma_0(lev)
              fdelta: P,    -- the divisor used at creation
              fgamma: SL2Z, -- the gamma used at creation
              frat: Q,      -- h_delta/delta
              fkappa: Z24,  -- upsilonExponent(a1,b2,c1,d1)
              fedelta: P,   -- edelta = width*hdelta^2/delta \eqref{eq:q_delta}}
              fvdelta: Q,   -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
              funityPower: Q-- (kappa_delta + vdelta)/24
             )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(m: P, delta: P, gamma: SL2Z): % ==
        c: Z := gamma(2, 1)
        --assert(c>0)
        hdelta: Z := gcd(c, delta)
        rat: Q := hdelta/delta
        rec: Rec := splitMatrix(gamma, delta)$QAuxMEQ
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        a2: Z := gamma2(1, 1); wgamma: Z := width(m, c)
        edelta: P := qcoerce(((wgamma*gcd(c,delta)^2) exquo delta)::Z)@P
        --assert(edelta = ((a2*wgamma exquo d2) :: Z))
        if not (edelta = ((a2*wgamma) exquo d2) :: Z) then
            error "edelta does not match"
        vdelta: Q := b2/d2
        kappa: Z24 := upsilonExponent(gamma1)$QAuxMEQ
        r: Q := (vdelta + (convert(kappa)@Z)::Q) / (24::Q)
          -- eq:eta_delta(gamma*tau)-expansion)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den
        per [m, delta, gamma, rat, kappa, edelta, vdelta, r]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    edelta(x: %): P == xx.fedelta
    vdelta(x: %): Q == xx.fvdelta
    unityPower(x: %): Q == xx.funityPower
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fedelta)
        h := hashUpdate!(h, xx.fvdelta)
        h := hashUpdate!(h, xx.funityPower)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        gamma x = gamma y




)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SymbolicEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain \code{SymbolicEtaQuotientGamma}
represent the tuple
\begin{gather}
  \left(
  N
  ,
  r
  ,
  \gamma
  ,
  \divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}
  ,
  \divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}
  ,
  \divisorsum{N} r_\delta e_\delta
  \right)
\end{gather}
and thus corresponds to the data from \eqref{eq:g_r(gamma*tau)}.

If \code{e = etaQuotient(m, divs, r, gamma)}, then we have the
following correspondence.
\code{rationalPrefactor(e)} $=
  \divisorprod{N} \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}$,
\code{unityPower(e)}        $=
  \divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}$,
\code{xExponent(e)}         $= \divisorsum{N} r_\delta e_\delta$.

)endif
-------------------------------------------------------------------
)abbrev domain YEQG SymbolicEtaQuotientGamma
++ SymbolicEtaQuotientGamma holds data to compute an eta quotient expansion
++ of g_r(\gamma\tau).
SymbolicEtaQuotientGamma: SemiGroup with
    etaQuotient: (P, LP, LZ, SL2Z) -> %
      ++ etaQuotient(m, divs, r, gamma) represents the expansion of
      ++ g_r(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(m, c) and
      ++ gamma=cupsToMatrix(m, a/c) for a cusp a/c.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) such that
      ++ the exponent of the eta_delta for such a divisor delta
      ++ is non-zero.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in eq:g_r(gamma*tau)
    unityPower: % -> Q
      ++ unityPower(e) returns sum_\delta rdelta*(vdelta+Kappa_delta)/24
      ++ It corresponds to the third product of eq:g_r(gamma*tau).
    xExponent: % -> Z
      ++ xExponent(e) returns the 24 times the order of the expansion
      ++ of e in x = \exp(2\pi i\tau/w) where w is the width of the cusp
      ++ while neglecting the (c\tau+d) factor.
      ++ It corresponds to 24 times the exponent of the fourth product
      ++ of eq:g_r(gamma*tau).
    minRootOfUnity: % -> P
      ++ minRootOfUnity(e) returns the smallest positive integer n such that
      ++ the expansion of the function g_r(\gamma\tau) corresponding to
      ++ e=etaQuotient(m, divs, r, gamma) (neglecting the (c\tau+d)^* factor
      ++ lives in Q[w][[x]] where w is a n-th root of unity.
    eta: (%, P) -> SymbolicEtaDeltaGamma
      ++ eta(x, delta) returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicEtaDeltaGamma) -- mapping delta to \eta_\delta
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the r vector
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_\delta
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta rdelta*(vdelta+kappa_delta)/24
              fxExponent: Z, -- \sum_delta rdelta*edelta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y
    lcmP(a, b) ==> qcoerce(lcm(a::Integer, b::Integer))@P

    -- divs must be ALL divisors of m sorted ascendingly
    etaquot(m: P, divs: LP, r: LZ, gamma: SL2Z, eta: HT): % ==
        rat: Q := 1
        upower: Q := 0
        xexponent: Z := 0
        for delta in divs for rdelta in r repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^rdelta
            upower := upower + rdelta * unityPower(e)
            xexponent := xexponent + rdelta * edelta(e)
        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QAuxMEQ
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minSquareRootOfUnity(p)$QAuxMEQ)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [m, divs, r, gamma, eta, rat, upower, xexponent, minroot]

    etaQuotient(m: P, divs: LP, r: LZ, gamma: SL2Z): % ==
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in divs repeat
            eta.delta := eta(m, delta, gamma)$SymbolicEtaDeltaGamma --$
        etaquot(m, divs, r, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    eta(x: %, delta: P): SymbolicEtaDeltaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    xExponent(x: %): Z == xx.fxExponent
    minRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fgamma = yy.fgamma

    ((x: %) * (y: %)): % ==
        (xm: P := level x) ~= level y =>
            error "SymbolicEtaQuotientGamma: different levels"
        (divs: LP := divisors x) ~= divisors y =>
            error "SymbolicEtaQuotientGamma: different divisors"
        (g: SL2Z := gamma x) ~= gamma y =>
            error "SymbolicEtaQuotientGamma: different gammas"
        sumr: LZ := [rx+ry for rx in exponents x for ry in exponents y]
        etaquot(xm, divs, sumr, g, xx.feta)


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{EtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, and \code{y = etaQuotient(N, divs, r, gamma)} and
\code{e = etaQuotient(y)}, then $e$ represents the tuple
\begin{gather}
  \left(
  \underbrace{y}_{\texttt{symbolicEtaQuotient}}
  ,
  \underbrace{\divisorprod{N}
  \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta/2}
  \unityPower{\divisorsum{N} \frac{r_\delta(v_\delta + \kappa_\delta)}{24}}
  }_{\texttt{leadingCoefficient}}
  ,
  \underbrace{\divisorprod{N}\prod_{n=1}^{\infty}
    (1-\unityPower{n v_\delta} x^{n e_\delta})^{r_\delta}
  }_{\texttt{series}}
  \right)
\end{gather}
and thus corresponds to the data from
\eqref{eq:modular-g_r(gamma*tau)} with
$x=\unityPower{\frac{\tau}{w_\gamma}}$ where $w_\gamma$ is given by
\eqref{eq:width}.


)endif
-------------------------------------------------------------------
)abbrev domain ETAQG EtaQuotientGamma
++ EtaQuotientGamma(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotient expansions at gamma.
EtaQuotientGamma(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX: UnivariateLaurentSeriesCategory CX -- domain for the series expansions
  Exports ==> SemiGroup with
    --assert(one? xi^mx)
    etaQuotient: SymbolicEtaQuotientGamma -> %
      ++ etaQuotient(s) represents the expansion of
      ++ g_r(\gamma\tau) in terms of x = \exp(2\pi i\tau/w) where
      ++ w=width(m, c).
    eulerFunctionPower: (P, N, Z) -> LX
      ++ etaPower(u, v, p) computes eulerFunction(1)^p and replaces
      ++ q=monomial(1,1)$LC by monomial(xi^v, u)$LX
    symbolicEtaQuotient: % -> SymbolicEtaQuotientGamma
      ++ symbolicEtaQuotient(x) returns meta-data corresponding to x.
    expansion: % -> LX
      ++ expansion(x) returns the series expansion of x without any prefactor.
    leadingCoefficient: % -> CX
      ++ leadingCoefficient(x) returns the
  Implementation ==> add
    Rep ==> Record(fsymetaquo: SymbolicEtaQuotientGamma, lc: CX, ser: LX)
    -- The true series expansion of e is given by c * x^p * s where
    -- c = leadingCoefficient e
    -- x = \exp(2\pi i\tau/w) where w=width(m, c)
    -- p = xExponent symbolicEtaQuotient e
    -- s = expansion e
    xx ==> rep x
    -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol
    LC ==> SparseUnivariateLaurentSeries(C, q, 0)
    ef: LC := eulerFunction(1)$QFunctions(C, LC)
    ef1: C := coefficient(ef, 1) -- avoid null pointer by expansion
    -- We intend to also store negative powers of the eulerFunction.
    cache: XHashTable(Z, LC) := getCache()$CachedPower(LC, ef)

    RecC ==> Record(k: Z, c: C)
    RecX ==> Record(k: Z, c: CX)
    SFCX ==> StreamFunctions2(RecC, RecX)

    substituteVariable(u: P, v: N): RecC -> RecX == (x: RecC): RecX +->
        -- replace variable q by xi^v * x^u
        xiPower: N := qcoerce(positiveRemainder(v*x.k, mx))@N
        cx: CX := xi^xiPower
        cx := x.c * cx
        [u*x.k, cx]

    -- In the series s(q) replace q by q^u*xi^v.
    substitute(s: LC, u: P, v: N): LX ==
        stc: Stream RecC := terms s
        stx: Stream RecX := map(substituteVariable(u, v), stc)$SFCX
        series(stx)$LX

    eulerFunctionPower(u: P, v: N, rd: Z): LX ==
        if key?(rd, cache) then
            es := cache.rd
        else
            pow: P := qcoerce(abs rd)@P
            es := power(pow)$CachedPower(LC, ef)
            if rd < 0 then
                es := recip(es)::LC
                cache.rd := es -- cache for negative exponents
        substitute(es, u, v)

    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QAuxMEQ --$
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    etaQuotient(e: SymbolicEtaQuotientGamma): % ==
        m: P := level e
        divs: LP := divisors e
        s: LX := 1
        for delta in divs for rd in exponents e | not zero? rd repeat
            etadelta: SymbolicEtaDeltaGamma := eta(e, delta)
            u: P := edelta(etadelta)
            v: N := qcoerce(numer(mx * vdelta(etadelta)))@N
            s := s * eulerFunctionPower(u, v, rd)
        q: Q := mx * unityPower e
        if not one? denom q then
            error "EtaQuotientGamma: denominator does not vanish"
        n: N := qcoerce(positiveRemainder(numer q, mx))@N
        cx: CX := xi^n * squareRoot rationalPrefactor e -- leading coefficient
        per [e, cx, s]

    symbolicEtaQuotient(x: %): SymbolicEtaQuotientGamma == xx.fsymetaquo
    leadingCoefficient(x: %): CX == xx.lc
    expansion(x: %): LX == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean == symbolicEtaQuotient x = symbolicEtaQuotient y
    ((x: %) * (y: %)): % ==
        -- The following multiplication does the compatibility check.
        e := symbolicEtaQuotient x * symbolicEtaQuotient y
        c: CX := leadingCoefficient x * leadingCoefficient y
        s: LX := expansion x * expansion y
        per [e, c, s]

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ModularEtaQuotient}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$, and \code{e = etaQuotient(N, r)}, then
$e$ represents the information given in
\eqref{eq:modular-g_r(gamma*tau)}
for each cusp $\frac{a}{c}$ of $\Gamma_0(N)$.


)endif
)abbrev domain METAQ ModularEtaQuotient
++ ModularEtaQuotient(C, mx, CX, xi, LX) represents the semigroup
++ of eta-quotients that are modular functions for Gamma_0(N).
++ In fact, this domain is meant to do computation for a specific N,
++ but is actually implementing the union over all N.
++ Only modular functions of the same level can be multiplied.
ModularEtaQuotient(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX: UnivariateLaurentSeriesCategory CX -- domain for the series expansions
  LC ==> SparseUnivariateLaurentSeries(C, q, 0)
  YEQG ==> SymbolicEtaQuotientGamma
  Exports ==> SemiGroup with
    --assert(one? xi^mx)
    etaQuotient: (P, LZ) -> %
      ++ etaQuotient(m, r) represents the expansion of
      ++ g_r(\tau) in terms of x = \exp(2\pi i\tau/w) where
      ++ w=width(m, c) at all cusps of Gamma0(m).
    level: % -> P
      ++ level(x) gives the m such that x corresponds to a modular
      ++ function for Gamma_0(m).
    symbolicEtaQuotients: % -> XHashTable(Q, YEQG)
      ++ symbolicEtaQuotients(x) returns the meta data corresponding to x.
    expansions: % -> XHashTable(Q, LX)
      ++ expansions(x) returns the Laurent series expansions of $g_r(tau)$
      ++ at all cusps of Gamma_0(N).
  Implementation ==> add
    Rep ==> Record(flevel: P, meta: XHashTable(Q, YEQG), ser: XHashTable(Q, LX))
    xx ==> rep x

    etaQuotient(m: P, r: LZ): % ==
        -- check whether the exponent vectors (rdelta) lead to a
        -- modular function, i.e., rStarConditions must be fulfilled.
        not zero? rStarConditions(m, r)$QAuxMEQ =>
            error "etaQuotient: not a modular function"
        hmeta: XHashTable(Q, YEQG) := empty()
        hser: XHashTable(Q, LX) := empty()
        divs: LP := [qcoerce(d)@P for d in
                       divisors(m)$IntegerNumberTheoryFunctions]
        cusps: LQ := cuspsOfGamma0(m)$QAuxMEQ
        for cusp in cusps repeat
            gamma: SL2Z := cuspToMatrix(m, cusp)$QAuxMEQ
            se: YEQG := etaQuotient(m, divs, r, gamma)
            e: EtaQuotientGamma(C, mx, CX, xi, LX) := etaQuotient se
            s: LX := expansion e
            lc: CX := leadingCoefficient e
            ord: Z := (xExponent(se) exquo 24)::Z -- order of series
            hmeta.cusp := se
            hser.cusp := monomial(lc, ord)$LX * s
        per [m, hmeta, hser]

    level(x: %): P == xx.flevel
    symbolicEtaQuotients(x: %): XHashTable(Q, YEQG) == xx.meta
    expansions(x: %): XHashTable(Q, LX) == xx.ser

    coerce(x: %): OutputForm == rep(x)::OutputForm
    ((x: %) = (y: %)): Boolean ==
        -- it is enough if we compare the level and the rdeltas
        m: P := level x
        m ~= level y => false
        -- note that 1/m is always a cusp of Gamma_0(m), but we choose any
        ex: XHashTable(Q, YEQG) := symbolicEtaQuotients x
        ey: XHashTable(Q, YEQG) := symbolicEtaQuotients y
        cusp: Q := first keys ex
        exponents(ex.cusp) = exponents(ey.cusp)

    ((x: %) * (y: %)): % ==
        m: P := level x
        m ~= level y =>
            error "ModularEtaQuotient: cannot multiply elements with different level"
        ex: XHashTable(Q, YEQG) := symbolicEtaQuotients x
        ey: XHashTable(Q, YEQG) := symbolicEtaQuotients y
        sx: XHashTable(Q, LX) := expansions x
        sy: XHashTable(Q, LX) := expansions y
        hmeta: XHashTable(Q, YEQG) := empty()
        hser: XHashTable(Q, LX) := empty()
        cusps: LQ := keys ex
        for cusp in cusps repeat
            hmeta.cusp := ex.cusp * ey.cusp
            hser.cusp := sx.cusp * sy.cusp
        per [m, hmeta, hser]
    coerce(x: %): OutputForm == rep(x)::OutputForm


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ModularEtaQuotientExpansions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If $N\in\setN$, $r\in R(N)$, and \code{e = etaQuotient(N, r)}, \code{v
  = coerce(expansions e)} then $v$ represents the vector of Laurent
expansions of an eta quotient (corresponding to $r$) at each cusp of
$\Gamma_0(N)$. These vectors form an algebra that similar to
\code{Finite0Series} have a finite zero test. A vector $v$ is zero, if
\code{qetaGrade(v, k)} is smaller than 0 for all indices $k$ from 1 to
$n$ where $n$ is the number of cusps of $\Gamma_0(N)$.

)endif
)abbrev domain METAQX ModularEtaQuotientExpansions
++ ModularEtaQuotientExpansions(C, L, m) represents the algebra of
++ eta quotients that are modular functions for Gamma_0(m).
ModularEtaQuotientExpansions(C, L, m): Exports == Implementation where
  C: IntegralDomain
  L: UnivariateLaurentSeriesCategory C
  m: P -- level
  Exports ==> XEtaAlgebra C with
    coerce: XHashTable(Q, L) -> %
      ++ If t is a hashtable containing (for each cusp of Gamma_0(m)
      ++ the series expansions at the cusps, then etaQuotient(t) creates
      ++ a data structure that can be used for computations.
    series: (%, P) -> L
      ++ series(x, n) returns the series corresponding to the n-th index.
      ++ Indices can run from 1 to maxIndex().
  Implementation ==> add
    divs: LP := [qcoerce(d)@P for d in divisors(m)$IntegerNumberTheoryFunctions]
    ndivs: N := # divs
    cusps: LQ := cuspsOfGamma0(m)$QAuxiliaryModularEtaQuotientPackage
    ncusps: P := qcoerce(#cusps)@P
    RVector ==> DirectProduct(ndivs, Z)
    Rep ==> DirectProduct(ncusps, L)
    xx ==> rep x
    yy ==> rep y

    coerce(t: XHashTable(Q, L)): % ==
        -- sanity check
        # (cs := keys t) ~= ncusps or sort cs ~= sort cusps =>
            error "keys do not agree with cusps of Gamma0(m)"
        per directProduct vector [t.c for c in cusps]

    coerce(x: %): OutputForm == xx::OutputForm
    0: % == per(0$Rep)
    1: % == per(1$Rep)
    zero?(x: %): Boolean ==
        for kn in 1..ncusps repeat
            k: P := qcoerce(kn)@P
            qetaGrade(x, k, 0) > 0 => return false
            not zero? xx.k.0 => return false
        return true

    ((x: %) + (y: %)): % == per(xx + yy)
    ((x: %) * (y: %)): % == per(xx * yy)
    ((c: C) * (x: %)): % == per map((s: L): L +-> c * s, xx)
    ((x: %) ^ (n: N)): % == per map((s: L): L +-> s^n, xx)
    maxIndex(): P == ncusps
    qetaIndex(x: %): P ==
        --assert(not zero? x) -- therefore for one k qetaGrade(x,k)>=0
        maxGrade := -1 -- dummy value
        idx: N := 0
        for kn in 1 .. ncusps repeat
            k: P := qcoerce(kn)@P
            if (mx := qetaGrade(x, k)) > maxGrade then
                maxGrade := mx

                idx: P := k
        return idx
    qetaGrade(x: %, k: P): Z == - order(xx.k)
    qetaGrade(x: %, k: P, mn: Z): Z == - order(xx.k, -mn)
    qetaLeadingCoefficient(x: %, k: P): C == leadingCoefficient(xx.k)
    series(x: %, k: P): L == xx.k
    qetaGrades(x: %): LZ ==
        zero? x => [0 for k in 1..ncusps]
        [qetaGrade(x, qcoerce(k)@P) for k in 1..ncusps]




)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SymbolicSiftedEtaDeltaLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $\divides{\delta}{M}$,
$\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain
\code{SymbolicSiftedEtaDeltaLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  \delta,
  m,
  \lambda,
  \gamma,
  \frac{h_{\delta,m,\lambda}}{\delta}
  ,
  u_{\delta,m,\lambda},
  v_{\delta,m,\lambda},
  \kappa_{\delta,m,\lambda},
  \frac{v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda}}{24}
  \right)
\end{gather}
and thus corresponds to the data from \eqref{eq:eta_delta-m-lambda(gamma*tau)}.

If \code{e = eta(mm, delta, m, lambda, gamma)}, then we
have the following correspondence:
%
\code{rationalPrefactor(e)} $= \frac{h_{\delta,m,\lambda}}{\delta}$,
\code{udelta(e)}            $= u_{\delta,m,\lambda}$,
\code{vdelta(e)}            $= v_{\delta,m,\lambda}$,
\code{upsilonExponent(e)}   $= \kappa_{\delta,m,\lambda}$,
\code{unityPower(e)}        $= \frac{v_{\delta,m,\lambda}+\kappa_{\delta,m,\lambda}}{24}$.

)endif
-------------------------------------------------------------------
)abbrev domain YSEDLG SymbolicSiftedEtaDeltaLambdaGamma
++ SymbolicSiftedEtaDeltaLambdaGamma is a generalization of
++ SymbolicEtaDeltaGamma. It holds data to compute an eta
++ expansion of \eta_{delta.m,\lambda}(\gamma\tau).
++ See \eqref{eq:eta_delta-m-lambda(gamma*tau)}.
SymbolicSiftedEtaDeltaLambdaGamma: SetCategory with
    eta: (P, P, P, N, SL2Z) -> %
      ++ eta(mm, delta, m, lambda, gamma) represents the
      ++ expansion of \eta_{\delta,m,\lambda}(\gamma\tau) in terms of
      ++ q = \exp(2\pi i\tau).
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    delta: % -> P
      ++ delta(x) returns the corresponding delta.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    lambda: % -> N
      ++ lambda(x) returns lambda.
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in eta(...,gamma).

    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in eq:g_r(gamma*tau)

    upsilonExponent: % -> Z24
      ++ kappa_delta
    udelta: % -> Q
      ++ udelta
    vdelta: % -> Q
      ++ vdelta
    unityPower: % -> Q        -- (kappa_delta + vdelta)/24

 == add
    Rec ==> Record(red: SL2Z, triang: MZ)
    Rep ==> Record(
              flevel: P,
              fdelta: P,
              fmultiplier: P,
              flambda: N,
              fgamma: SL2Z, -- gamma
              frat: Q,      -- square of rational prefactor
              fkappa: Z24,  -- upsilonExponent(a1,b2,c1,d1)
              fudelta: Q,   -- udelta = hdelta^2/(delta*m)
                            -- \eqref{eq:uv_delta-m-lambda}}
              fvdelta: Q,   -- b2/d2, reduced form of roots of unity
                            -- 0<=b2<d2, 0<d2
              funityPower: Q-- (kappa + vdelta)/24
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y

    eta(mm: P, delta: P, m: P, lambda: N, gamma: SL2Z): % ==
        --assert(gamma(2, 1)>0)
        rec: Rec := splitMatrix(gamma, delta, m, lambda)$QAuxMEQ
        gamma1: SL2Z := rec.red
        gamma2: MZ := rec.triang
        b2: Z := gamma2(1, 2); d2: Z := gamma2(2, 2)
        a2: Z := gamma2(1, 1); -- hdelta
        rat: Q := a2/delta
        udelta: Q := a2/d2 -- = hdelta^2/delta/m
        vdelta: Q := b2/d2
        kappa: Z24 := upsilonExponent(gamma1)$QAuxMEQ
        r: Q := (vdelta + (convert(kappa)@Z)::Q) / (24::Q)
          -- eq:eta_delta-m-lambda(gamma*tau)-expansion)
        num: Z := numer r; den: Z := denom r -- denom(r)-th root of unity
        r := positiveRemainder(num, den)/den
        per [mm, delta, m, lambda, gamma, rat, kappa, udelta, vdelta, r]

    level(x: %): P == xx.flevel
    delta(x: %): P == xx.fdelta
    multiplier(x: %): P == xx.fmultiplier
    lambda(x: %): N == xx.flambda
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    upsilonExponent(x: %): Z24 == xx.fkappa
    udelta(x: %): Q == xx.fudelta
    vdelta(x: %): Q == xx.fvdelta
    unityPower(x: %): Q == xx.funityPower
    coerce(x: %): OutputForm == rep(x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frat)
        h := hashUpdate!(h, xx.fkappa)
        h := hashUpdate!(h, xx.fudelta)
        h := hashUpdate!(h, xx.fvdelta)
        h := hashUpdate!(h, xx.funityPower)
    ((x: %) = (y: %)): Boolean ==
        level x ~= level y => false
        delta x ~= delta y => false
        multiplier x ~= multiplier y => false
        lambda x ~= lambda y => false
        gamma x = gamma y


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SymbolicSiftedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $s \in R(M)$, $t,\lambda \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain
\code{SymbolicSiftedEtaLambdaGamma} represent the tuple
\begin{gather}
  \left(
  M,
  s,
  m,
  t,
  \lambda,
  \gamma,
  \divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!s_\delta}
  ,
  -\frac{\lambda}{24m}\Bigl(24t+\sumdelta{s}\Bigr) +
  \divisorsum{M} \frac{s_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}
  ,
  \divisorsum{M} s_\delta u_{\delta,m,\lambda}
  \right)
\end{gather}
and thus corresponds to the data from \eqref{eq:g_s-m-t-lambda(gamma*tau)},
\ie,  it computes the building blocks for $g_{s,m,t,\lambda}(\gamma\tau)$.

If \code{e = etaQuotient(mm, divs, s, m, t, lambda, gamma)}, then we
have the following correspondence:
%
\code{rationalPrefactor(e)}
$= \divisorprod{N} \left(\frac{h_\delta}{\delta}\right)^{\!r_\delta}$,
%
\code{unityPower(e)}
$= -\frac{\lambda}{24m}\Bigl(24t+\sumdelta{s}\Bigr) +
  \divisorsum{M} \frac{s_\delta(v_{\delta,m,\lambda} +
  \kappa_{\delta,m,\lambda})}{24}$,
%
\code{qExponent(e)} $= \divisorsum{M} s_\delta u_{\delta,m,\lambda}$.

)endif
-------------------------------------------------------------------
)abbrev domain YSEQLG SymbolicSiftedEtaQuotientLambdaGamma
++ SymbolicSiftedEtaQuotientLambdaGamma is a generalization of
++ SymbolicEtaQuotientGamma. It holds data to compute an eta
++ quotient expansion of g_{s,m,t,\lambda}(\gamma\tau).
++ See \eqref{eq:g_s-m-t-lambda(gamma*tau)}.}
SymbolicSiftedEtaQuotientLambdaGamma: SetCategory with
    etaQuotient: (P, LP, LZ, P, N, N, SL2Z) -> %
      ++ etaQuotient(mm, divs, s, m, t, lambda, gamma) represents the
      ++ expansion of g_{s,m,t,\lambda}(\gamma\tau) in terms of
      ++ x = \exp(2\pi i\tau/w) where w=width(nn, c) and
      ++ gamma=cupsToMatrix(nn, a/c) for a cusp a/c.
    level: % -> P
      ++ level(x) returns the level of the eta quotient.
      -- Returns mm.
    divisors: % -> LP
      ++ divisors(x) returns the divisors of level(x) such that
      ++ the exponent of the eta_delta for such a divisor delta
      ++ is non-zero.
      -- Returns divs.
    exponents: % -> LZ
      ++ exponents(x) returns the list of exponents corresponding to all
      ++ divisors.
      -- Returns s.
    multiplier: % -> P
      ++ multiplier(x) returns the subsequence multiplier.
      ++ Returns m.
    offset: % -> N
      ++ offset(x) returns the subsequence offset.
      ++ Returns t.
    lambda: % -> P
      ++ lambda(x) returns lambda
    gamma: % -> SL2Z
      ++ gamma(x) returns the transformation corresponding to x.
      -- Returns gamma as given in etaSequence(...,gamma).

    rationalPrefactor: % -> Q
      ++ rationalPrefactor(x) returns the square of the second product
      ++ in \eqref{eq:g_s-m-t-lambda(gamma*tau)}.
    unityPower: % -> Q
      ++ unityPower(e) returns - lambda*(24*t+\sumdelta{s})/(24*m) +
      ++ sum_\delta sdelta*(vdelta+Kappa_delta)/24. It corresponds to
      ++ the second factor of \eqref{eq:g_s-m-t-lambda(gamma*tau)}.
    qExponent: % -> Q
      ++ qExponent(e) returns the 24 times the order of the expansion
      ++ of e in q = \exp(2\pi i\tau)  while neglecting the (c\tau+d) factor.
      ++ It corresponds to 24 times the exponent of the fourth product
      ++ of \eqref{eq:g_s-m-t-lambda(gamma*tau)}.
    minRootOfUnity: % -> P
      ++ minRootOfUnity(e) returns the smallest positive integer n such that
      ++ the expansion of the function g_{s,m,t,\lambda}(\gamma\tau)
      ++ corresponding to e=etaQuotient(mm, divs, s, m, t, lambda, gamma)
      ++ (neglecting the (c\tau+d)^* factor lives in Q[w][[z]] where w
      ++ is a n-th root of unity and z a fractional q power.
    eta: (%, P) -> SymbolicSiftedEtaDeltaLambdaGamma
      ++ eta(x, delta) returns the data corresponding to the respective
      ++ delta.
 == add
    HT ==> XHashTable(P, SymbolicSiftedEtaDeltaLambdaGamma)
      -- mapping delta to \eta_{\delta,m,\lambda}
    Rep ==> Record(
              flevel: P,     -- level \Gamma_0(lev)
              fdivs: LP,     -- all divisors of level that are given at creation
              fexponents: LZ,-- the s vector
              fmultiplier: P,-- the multiplier m
              foffset: N,    -- the offset t \in 0..(m-1)
              flambda: N,    -- lambda \in 0..(m-1)
              fgamma: SL2Z,  -- gamma
              feta: HT,      -- mapping delta to \eta_{\delta,m,lambda}
              frat: Q,       -- square of rational prefactor
              funityPower: Q,-- \sum_\delta sdelta*(vdelta+kappa_delta)/24
                             -- - lambda*(24*t+\sumdelta{s})/(24*m)
              fqExponent: Q, -- \sum_delta sdelta*udelta
              fminroot: P    -- minimal root of unity needed for coefficients
            )
    import from Rep
    xx ==> rep x
    yy ==> rep y
    lcmP(a, b) ==> qcoerce(lcm(a::Integer, b::Integer))@P

    -- divs must be ALL divisors of m sorted ascendingly
    etaquot(mm: P, divs: LP, s: LZ,
            m: P, t: N, lambda: N, gamma: SL2Z, eta: HT): % ==
        rat: Q := 1
        upower: Q := 0
        qexponent: Q := 0
        sigmaInfty: Z := 0
        for delta in divs for sdelta in s repeat
            e := eta(delta)
            rat := rat * rationalPrefactor(e)^sdelta
            upower := upower + sdelta * unityPower(e)
            qexponent := qexponent + sdelta * udelta(e)
            sigmaInfty := sigmaInfty + delta * sdelta
        upower := upower - lambda/m * (24*t + sigmaInfty)
        -- minimal root of unity needed for the expansion is determined from
        -- expressing the squareroot of the rational prefactor in roots of unity
        -- and from the unityPower.
        -- Additionally, we have to consider the root of unity factor in
        -- q_\delta, i.e., the denominator of the v_\delta.
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(rat)$QAuxMEQ
        p: P := rr.rootOf
        minroot: P := lcmP(denom upower, minSquareRootOfUnity(p)$QAuxMEQ)
        minroot := lcmP(minroot, lcm [denom vdelta eta delta for delta in divs])
        per [mm, divs, s, m, t, lambda, gamma, eta, rat, upower, qexponent, minroot]

    etaQuotient(mm: P, divs: LP, s: LZ,
                m: P, t: N, lambda: N, gamma: SL2Z): % ==
        eta: HT := empty()
        -- Make sure gamma(2,1) >= 0. Corresponds to the same transformation.
        if gamma(2,1) < 0 then gamma := -gamma
        for delta in divs repeat
            YSEDLG ==> SymbolicSiftedEtaDeltaLambdaGamma
            eta.delta := eta(m, delta, m, lambda, gamma)$YSEDLG --$
        etaquot(mm, divs, s, m, t, lambda, gamma, eta)

    level(x: %): P == xx.flevel
    divisors(x: %): LP == xx.fdivs
    eta(x: %, delta: P): SymbolicSiftedEtaDeltaLambdaGamma == xx.feta.delta
    exponents(x: %): LZ == xx.fexponents
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    gamma(x: %): SL2Z == xx.fgamma
    rationalPrefactor(x: %): Q == xx.frat
    unityPower(x: %): Q == xx.funityPower
    qExponent(x: %): Q == xx.fqExponent
    minRootOfUnity(x: %): P == xx.fminroot

    coerce(x: %): OutputForm == rep(x)::OutputForm

    hashUpdate!(h: HashState, x: %): HashState ==
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.fdivs)
        h := hashUpdate!(h, xx.fexponents)
        h := hashUpdate!(h, xx.fmultiplier)
        h := hashUpdate!(h, xx.foffset)
        h := hashUpdate!(h, xx.flambda)
        h := hashUpdate!(h, xx.fgamma)
        h

    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.fdivs ~= yy.fdivs => false
        xx.fexponents ~= yy.fexponents => false
        xx.fmultiplier ~= yy.fmultiplier => false
        xx.foffset ~= yy.foffset => false
        xx.flambda ~= yy.flambda => false
        xx.fgamma = yy.fgamma

)if LiterateDoc
% $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SiftedEtaQuotientLambdaGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $s \in R(M)$, $t,\lambda \in
\Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain \code{SiftedEtaQuotientLambdaGamma}
represents the series expansion of
$g_{s,m,t,\lambda}(\gamma\tau)$, \ie, an element from
\code{SymbolicSiftedEtaQuotientLambdaGamma} in terms of $q^{1/(24 m w)}$ where
$w$ must be a multiple of the the $\lcm$ the denominator of
\begin{gather*}
  p := \frac{\divisorsum{M} s_\delta u_{\delta,m,\lambda}}{24}
\end{gather*}
and of all denominators of $u_{\delta,m,\lambda}$ over all
$\divides{\delta}{M}$ with
$s_\delta\ne0$, \ie, it represents the tuple
\begin{gather}
  \left(
  y
  ,
  \underbrace{\divisorprod{M}
  \left(\frac{h_{\delta,m,\lambda}}{\delta}\right)^{\!s_\delta/2}
  \unityPower{-\frac{\lambda}{24m}\Bigl(24t+\sumdelta{s}\Bigr) +
  \divisorsum{M} \frac{s_\delta(v_{\delta,m,\lambda} + \kappa_{\delta,m,\lambda})}{24}}
  }_{\texttt{leadingCoefficient}}
  \cdot
  q^p \divisorprod{M}\prod_{n=1}^{\infty}
    (1-\unityPower{n v_\delta} q^{n u_\delta})^{s_\delta}
  \right)
\end{gather}
where $y$ is the corrresponding element of
\code{SymbolicSiftedEtaQuotientLambdaGamma} and, thus, the series from
\eqref{eq:g_s-m-t-lambda(gamma*tau)} without the
$(c\tau+d)$-part.

)endif


-------------------------------------------------------------------
)abbrev domain SEQLG SiftedEtaQuotientLambdaGamma
++ SiftedEtaQuotientLambdaGamma is a generalization of
++ SymbolicSiftedEtaQuotientLambdaGamma. It holds data to compute an eta
++ quotient expansion of g_{s,m,t,\lambda}(\gamma\tau).
++ See \eqref{eq:g_s-m-t-lambda(gamma*tau)}.}
SiftedEtaQuotientLambdaGamma(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX: UnivariateLaurentSeriesCategory CX -- building block for series expansions
  Exports ==> SetCategory with
    etaQuotient: (SymbolicSiftedEtaQuotientLambdaGamma, P) -> %
      ++ etaQuotient(e, w) represents the
      ++ q-expansion of g_{s,m,t,\lambda}(\gamma\tau) at \tau=i\infity.
    rationalPowerDenominator: % -> P
      ++ rationalPowerDenominator(x) returns d such that x is a Laurent series
      ++ in q^d.
    expansion: % -> LX
      ++ expansion(x) returns the Laurent series representation of x
      ++ without the prefactor corresponding to (c\tau+d) in z=q^(1/d)
      ++ where d=rationalPowerDenominator(x).
  Implementation ==> add
    Rep ==> Record(den: P, ser: LX)
    xx ==> rep x
     -- We maintain a cache of expansions of powers of the Euler function.
    q: Symbol := "q"::Symbol
    LC ==> SparseUnivariateLaurentSeries(C, q, 0)
    ef: LC := eulerFunction(1)$QFunctions(C, LC)
    ef1: C := coefficient(ef, 1) -- avoid null pointer by expansion
    -- We intend to also store negative powers of the eulerFunction.
    cache: XHashTable(Z, LC) := getCache()$CachedPower(LC, ef)

    RecC ==> Record(k: Z, c: C)
    RecX ==> Record(k: Z, c: CX)
    SFCX ==> StreamFunctions2(RecC, RecX)

    eulerFunctionPower(p: Z): LC ==
        key?(p, cache) => cache.p
        zero? p => 1
        pow: P := qcoerce(abs p)@P
        es := power(pow)$CachedPower(LC, ef) --$
        p > 0 => es
        cache.p := recip(es)::LC -- cache for negative exponents and return

    substituteVariable(u: P, v: N): RecC -> RecX == (x: RecC): RecX +->
        -- replace variable q by xi^v * x^u
        xiPower: N := qcoerce(positiveRemainder(v*x.k, mx))@N
        cx: CX := xi^xiPower
        cx := x.c * cx
        [u*x.k, cx]

    -- In the series s(q) replace q by q^u*xi^v, i.e., return s(q^u*xi^v).
    substitute(s: LC, u: P, v: N): LX ==
        stc: Stream RecC := terms s
        stx: Stream RecX := map(substituteVariable(u, v), stc)$SFCX
        series(stx)$LX

    squareRoot(fq: Q): CX ==
        rr: Record(rat: Q, rootOf: P) := rationalSquareRoot(fq)$QAuxMEQ
        ((rr.rat)::C::CX) * squareRoot(rr.rootOf)$GaussRoot(CX, xi, mx)

    etaQuotient(e: SymbolicSiftedEtaQuotientLambdaGamma, w: P): % ==
        -- w=width
        mm: P := level e
        divs: LP := divisors e
        m: P := multiplier e
        d: P := 24*m*w
        s: LX := 1
        for delta in divs for sd in exponents e | not zero? sd repeat
            etadelta: SymbolicSiftedEtaDeltaLambdaGamma := eta(e, delta)
            u: Q := d * udelta etadelta
            not one? denom u =>
                dbgPrint("delta, d", [delta, d]$List(P))
                dbgPrint("udelta", [udelta etadelta, u]$List(Q))
                error "SiftedEtaQuotientLambdaGamma: denominator does not vanish"
            v: N := qcoerce(numer(mx * vdelta(etadelta)))@N
            ep: LC := eulerFunctionPower sd
            s := s * substitute(ep, qcoerce(numer u)@P, v)
        q: Q := mx * unityPower e
        if not one? denom q then
            dbgPrint("mx * unityPower e", q)
            error "SiftedEtaQuotientLambdaGamma: denominator for xi does not vanish"
        n: N := qcoerce(positiveRemainder(numer q, mx))@N
        cx: CX := xi^n * squareRoot rationalPrefactor e -- leading coefficient
        p: Q := d/24 * qExponent e -- the "/24" is missing from qPower(e)
        if not one? denom p then
            error "SiftedEtaQuotientLambdaGamma: denominator for q does not vanish"
        per [d, monomial(cx, numer p)$LX * s] --$

    rationalPowerDenominator(x: %): P == xx.den
    expansion(x: %): LX ==
        dbgPrint("expansion lambda", x)
        xx.ser

    coerce(x: %): OutputForm == xx::OutputForm
    ((x: %) = (y: %)): Boolean == rep x = rep y

)if LiterateDoc
% $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SiftedEtaQuotientGamma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For $m, M\in\setN$, $s \in R(M)$, $t \in \Set{0,\ldots,m-1}$,
$\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right) \in
SL_2(\setZ)$, elements from the domain \code{SiftedEtaQuotientGamma}
represents the series expansion of
\begin{gather*}
  g_{s,m,t}(\gamma\tau)
  =\frac{1}{m} \sum_{\lambda=0}^{m-1} g_{s,m,t,\lambda}(\gamma\tau)
\end{gather*}
without the $(c\tau+d)$ part in \eqref{eq:g_s-m-t(gamma*tau)}.

)endif


-------------------------------------------------------------------
)abbrev domain SEQG SiftedEtaQuotientGamma
++ SiftedEtaQuotientGamma represents the sum (over all lambda) of elements
++ from SiftedEtaQuotientLambdaGamma. It holds the series
++ expansion of g_{s,m,t}(\gamma\tau).
++ See \eqref{eq:g_s-m-t(gamma*tau)}.}
SiftedEtaQuotientGamma(C, mx, CX, xi, LX): Exports == Implementation where
  C: Join(Algebra Q, IntegralDomain) -- basic coefficient domain
  mx: P -- mx-th root of unity needed.
  CX: Algebra C
  xi: CX --primitive mx-th root of unity.
  LX: UnivariateLaurentSeriesCategory CX -- building block for series expansions
  Exports ==> CoercibleTo OutputForm with
    etaQuotient: (P, LP, LZ, P, N, SL2Z, P) -> %
      ++ etaQuotient(mm, divs, s, m, t, gamma, w) represents the
      ++ z-expansion of g_{s,m,t}(\gamma\tau) at
      ++ \tau=i\infity where z = q^(1/24w).
    etaQuotientOrbitProduct: (P, LP, LZ, P, N, SL2Z, P) -> %
      ++ etaQuotientOrbitProduct(mm, divs, s, m, t, gamma, w)
      ++ returns the product over all
      ++ etaQuotient(mm, divs, s, m, t', gamma, w) for t' in
      ++ orbit(sigmaInfty, m, t) where
      ++ $sigmaInfty = \sum_{\delta|M} \delta s_\delta$.
    rationalPowerDenominator: % -> P
    expansion: % -> LX
      ++ expansion(x) returns the Puiseux series expansion of x
      ++ without the prefactor corresponding to (c\tau+d)
  Implementation ==> add
    Rep ==> Record(den: P, ser: LX)
    RecX ==> Record(k: Z, c: CX)
    xx ==> rep x
    YSEQLG ==> SymbolicSiftedEtaQuotientLambdaGamma
    SEQLG ==> SiftedEtaQuotientLambdaGamma(C, mx, CX, xi, LX)

    rationalPowerDenominator(x: %): P == xx.den
    expansion(x: %): LX == xx.ser

    coerce(x: %): OutputForm == xx::OutputForm
    ((x: %) = (y: %)): Boolean == rep x = rep y

    -- auxiliary function dividedBy
    divideBy(m: Z): RecX -> RecX == (x: RecX): RecX +->
        [(x.k exquo m)::Z, (1/m)$Q::C::CX * x.c]$RecX

    -- exported function etaQuotient
    etaQuotient(mm: P, divs: LP, s: LZ, m: P, t: N, gamma: SL2Z, w: P): % ==
        l: LX := 0
        m1: P := qcoerce(m::Z - 1)@P
        for lambda in 0..m1 repeat
            seq: YSEQLG := etaQuotient(mm, divs, s, m, t, lambda, gamma)
            l := l + expansion etaQuotient(seq, w)$SEQLG
        -- After summation only the coefficients with exponents divisible
        -- by m should be non-zero. We make a sanity check.
        for i in 1..m1 repeat
            if not zero? coefficient(l, i) then
                dbgPrint("expansion", l)
                error "m-lambda sum"
        per [24 * w, series(map(divideBy m, terms l))$LX]

    etaQuotientOrbitProduct(mm: P, divs: LP, s: LZ,
                            m: P, t: N, gamma: SL2Z, w: P): % ==
        shat: Z := 0 -- sigmaInfty
        for delta in divs for sdelta in s repeat
            shat := shat + delta * sdelta
        l: LX := 1
        for tt in orbit(shat, m, t)$QEtaKolberg repeat
            l := l * expansion etaQuotient(mm, divs, s, m, tt, gamma, w)
        per [24 * w, l]




)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
