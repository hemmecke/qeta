-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018, 2020-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
warnPrint(x,y) ==> tracePrint(x,y)
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Support for modularity of generalized eta-quotients}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The packages \qetatype{QEtaModularGamma0} and
  \qetatype{QEtaModularGamma1} provide functions for modularity with
  respect to some congruence subgroup in a common API as abstracted by
  \qetatype{QEtaModularCategory} in order to parametrize the other
  packages and algorithms for their depencence on a particular
  congruence subgroup.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu_RamanujanKolberg_2015} and also for
\cite[Sect.~10]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.

Assume that we are given a series
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M}\prod_{n=0}^\infty(1-q^{\delta n})^{r_\delta}
\end{gather*}
and want to express $\sum_{n=0}^\infty a(mn+t) q^n$ where $m$ and $M$
are a positive integers with $m|M$, $r\in R(M)$, and
$t\in\Set{0,\ldots,m-1}$ as a $\setQ$-linear combination of
eta-quotients and (maybe) an appropriate power of
$q^{1/24}=\unityPowerTau{\frac{1}{24}}=\unityPower{\frac{\tau}{24}}$.

For mathematical background see \PathName{qeta.tex}.

As an extensionn of the above problem, we assume that
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  g_{\bar{r}}(\tau)
\end{gather*}
is given by \ref{eq:g_rbar(tau)}.

By multiplication with a prefactor, we want to make
$\sum_{n=0}^\infty a(mn+t) q^n$ into a modular function for
$\Gamma_0(N)$ or $\Gamma_1(N)$ (for a suitable positive number $N$).
In case of $\Gamma_0(N)$, the sum might have to be multiplied with
similar sums in order to take care of the fact that by an arbitrary
transformation with a matrix from $\Gamma_0(N)$ we might come to a sum
with a different $t$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

PP ==> PositiveInteger
NN ==> NonNegativeInteger
ZZ ==> Integer
QQ ==> Fraction ZZ
MZZ ==> Matrix ZZ -- consider only 2x2 matricies
MQQ ==> Matrix QQ -- consider only 2x2 matricies
SL2Z ==> MZZ -- represents SL_2(ZZ), will be a 2x2 square matrix
LZZ ==> List ZZ
LLZZ ==> List LZZ
INDICES ==> LLZZ
SPEC ==> QEtaSpecification
CUSPS ==> List Cusp
QETAAUX ==> QEtaAuxiliaryPackage
GAMMA0 ==> CongruenceSubgroupGamma0
GAMMA1 ==> CongruenceSubgroupGamma1

asNN x ==> x pretend NN
asPP x ==> x pretend PP

VZZ ==> Vector ZZ
VQQ ==> Vector QQ
RELS ==> VZZ
LVZZ ==> List VZZ
QINPUT ==> Record(qmat: MQQ, zrels: RELS, qrhs: VQQ)
ZRESULT ==> Record(zinhom: LVZZ, zhom: LVZZ, zfree: LVZZ)

ECS ==> Record(indices:INDICES, particular:Union(VZZ,"failed"), basis:List VZZ)
--ECSS ==> Record(comatrix: MZZ, rhs: VZZ)
--SOL ==> Record(particular: Union(VZZ, "failed"), basis: List VZZ)

-- Note that in the following correspondence between programming variables
-- and notation in the mathematical description in qetaq.tex.
-- Variable   <--> mathematical notation
-- m               m
-- mm              M
-- nn              N
-- rhoInfty        \rho_\infty{r}
-- kappa(m)        \kappa

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C QEtaModularCategory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev category QMODCAT QEtaModularCategory
++ QEtaModularCategory provides functions to check
++ modularity conditions.
QEtaModularCategory: Category == with
    conditionCoEtaQuotient?: (PP, SPEC, PP, NN) -> Boolean
      ++ conditionCoEtaQuotient?(nn,rspec,m,t) returns true iff a
      ++ cofactor eta-quotient can be found such that the product of
      ++ the cofactor with the orbit product corresponding to the
      ++ dissection (m,t) gives a modular function in level nn.
    candidateLevelsCoEtaQuotient: (SPEC, PP, NN) -> List PP
      ++ candidateLevelsCoEtaQuotient(rspec,m,t) returns an
      ++ ascendingly sorted list of the nn up to 24*m*level(rspec)
      ++ such that conditionCoEtaQuotient?(nn,rspec,m,t) is true.
    matrixEtaOrder: (PP, CUSPS, INDICES) -> MQQ
      ++ matrixEtaOrder(nn,spitzen,idxs) returns the matrix given by
      ++ [matrixEtaOrderRow(nn,cusp,idxs) for cusp in spitzen] with
      ++ duplicate rows removed.
    matrixEtaOrderElement: (PP, Cusp, LZZ) -> QQ
      ++ z:=matrixEtaOrderElement(nn,cusp,idx). The parameter
      ++ corresponds to the index of a (generalized) eta-quotient,
      ++ i.e., it can be of the form idx=[delta,g] or of the form
      ++ idx=[delta] with g in the range 0..delta. Then z is the
      ++ coefficient of r_{delta,g} in
      ++ \cite[Thm.~4]{Robins_GeneralizedDedekindEtaProducts_1994},
      ++ except for the case nn=4, gcd(denom(cusp),nn)=2 (or
      ++ Gamma1(4)-equivalent) where we return half of this
      ++ coefficient. If idx=[delta] then
      ++ z=1/2*matrixEtaOrderElement(nn,cusp,[delta,0])/2. and thus
      ++ corresponds to the coefficient of $r_\delta$ in
      ++ \eqref{eq:order-rbar-non-adjusted} in
      ++ Theorem~\ref{thm:matrixEtaOrderRobins}. Note that Robins
      ++ refers to an expansion in the uniformizing variable
      ++ q^(gcd(c,nn)/nn) (where cusp=a/c). That is equal to
      ++ q^(1/width(c)$CongruenceSubgroupGamma1(nn)) except for the
      ++ case nn=4 and gcd(nn,c)=2. In that case the width of the cusp
      ++ 1/2 is 1 and not 2=4/gcd(4.2). For this case, we deviate from
      ++ Robins' coefficients and adapt to an expansion in q rather
      ++ than an expansion in q^(1/2).
    matrixEtaOrderFull: (PP, CUSPS, INDICES) -> MQQ
      ++ matrixEtaOrder(nn,spitzen,idxs) returns a matrix given by
      ++ [matrixEtaOrderRow(nn,cusp,idxs) for cusp in spitzen].
    matrixEtaOrderRow: (PP, Cusp, INDICES) -> List QQ
      ++ matrixEtaOrderRow(nn, cusp, idxs) returns
      ++ [matrixEtaOrderElement(nn,cusp,idx) for idx in idxs].
    matrixModular: (PP, INDICES) -> MQQ
      ++ matrixModular(nn, idxs) returns a matrix mat mat*v=0 for an
      ++ (extended) exponent vector where the exponents correspond to
      ++ idxs, i.e., #v=#idxs+k where k corresponds to additional
      ++ (slack) variables due to the modularity conditions. The rows
      ++ corresponding to slack variables have been normalized so that
      ++ the entry of the slack variable (there is only one) is 1.
    minimalLevelCoEtaQuotient: (SPEC, PP, NN) -> PP
      ++ minimalLevelCoEtaQuotient(rspec, m, t) returns the
      ++ smallest nn of candidateLevalsCoEtaQuotient(rspec,m,t).
    modular?: (SPEC, SPEC, PP, NN) -> Boolean
      ++ modular?(sspec,rspec,m,t) returns true iff (sspec,rspec,m,t)
      ++ specifies a modular function in level(sspec).
    modular?: SPEC -> Boolean
      ++ modular?(rspec) returns true iff spec specifies a modular
      ++ function in level(rspec).
    modularOrbit: (SPEC, PP, NN) -> List NN
      ++ modularOrbit(rspec, m, t) (for $\Gamma_0(N) where N is
      ++ level(rspec)) computes the elements of $\modularOrbit{r,m,t)$
      ++ as defined in qeta.tex,
      ++ \cite[Def.~42]{Radu_RamanujanKolberg_2015} and \cite[Lemma
      ++ 4.35]{Radu_PhD_2010} were r is pureExponents(rspec) and rspec
      ++ is expected to specify a pure eta-quotient.
      ++ For $\Gamma_1(N)$, modularOrbit(rspec, m, t) returns [t].

    etaQuotientMonoidSystem: (PP, CUSPS, INDICES) -> QINPUT
      ++ etaQuotientMonoidSystem(nn,polesat,idxs,rhs) returns
      ++ a record that can be given to zsolve$X4ti2 in order to find
      ++ the generators of the monoid of (generalized) eta-quotients
      ++ that are modular wrt. QMOD and have poles at most at the cusps
      ++ given by polesat. The indices of the eta-functions that may
      ++ appear is given by idxs.
    etaCofactorSpaceSystem: (PP, SPEC, PP, NN, INDICES) -> QINPUT
      ++ etaCofactorSpaceSystem(nn,rspec,m,t,idxs) returns a matrix
      ++ mat and a vector v such that for the integer solutions s of
      ++ the equation mat*s=v it holds modular?(sspec,rspec,m,t)
      ++ where sspec results from the list of the first #idxs entries
      ++ of s. With idxs one can specify what indexes should be
      ++ allowed in the solution space.
    etaCofactorSpace: (PP, SPEC, PP, NN, INDICES) -> ECS
      ++ etaCofactorSpace(nn,rspec,m,t,idxs) returns a vector v and the
      ++ basis of a space such that #v=#idxs  and
      ++ modular?(nn,members(s),rspec,m,t) is true for any
      ++ s = v + reduce(_+, [z.i * basis.i for i in 1..#basis])
      ++ and any sufficiently long list z of integers.
      ++ The function fails, if there is no such solution.
      ++ The indices part of the result is equal to idxs and
      ++ corresponds to the entries of the solution vectors.

    -- Functions connected to CongruenceSubGroup

    cusps: PP -> CUSPS
      ++ cusps(nn) returns representatives for all the (inequivalent)
      ++ cusps for the congruence subgroup that the respective package
      ++ represents. They are sorted by their size as rational numbers
      ++ with infinity being the biggest cusp. Note that
      ++ cusps()=[cusp(x(1,1),x(2,1)) for x in
      ++ doubleCosetRepresentatives()] where
      ++ doupleCosetRepresentatives() is from the respective
      ++ congruence subgroup that is connected to the package.
    cuspToMatrix: (PP, Cusp) -> SL2Z
      ++ For cusp=(a:c), cuspToMatrix(nn,cusp) returns a matrix
      ++ gamma=[[a,b],[c,d]] corresponding to the cusp (a:c) of this
      ++ domain. We assume that a/c is a normalized cusp, i.e.
      ++ cusp=normalizeCusp(cusp).
    genus: PP -> NN
      ++ genus(nn) returns the genus of the congruence subgroup
      ++ connected to the package (either Gamma_0(nn) or Gamma_1(nn).
    width: (PP, Cusp) -> PP
      ++ width(nn, cusp) returns the width of the cusp=(a:c) for G(nn)
      ++ where G is the congruence subgroup of SL_2(ZZ) connected to
      ++ this package.
    width: (PP, SL2Z) -> PP
      ++ width(nn, gamma) returns the width of the cusp=(a:c) for G(nn)
      ++ where G is the congruence subgroup of SL_2(ZZ) connected to
      ++ this package and gamma = matrix [[a,b],[c,d]].

  add

    matrixEtaOrderRow(nn: PP, cusp: Cusp, idxs: INDICES): List QQ ==
        [matrixEtaOrderElement(nn, cusp, idx) for idx in idxs]

    matrixEtaOrderFull(nn: PP, spitzen: CUSPS, idxs: INDICES): MQQ ==
        matrix [matrixEtaOrderRow(nn,cusp,idxs) for cusp in spitzen]

    matrixEtaOrder(nn: PP, spitzen: CUSPS, idxs: INDICES): MQQ ==
        ll := [matrixEtaOrderRow(nn,cusp,idxs) for cusp in spitzen]
        matrix removeDuplicates! ll

    modularOrbit(rspec: SPEC, m: PP, t: NN): List NN == [t]

    etaQuotientMonoidSystem(nn: PP, polesat: CUSPS, idxs: INDICES): QINPUT ==
        -- At the cusp infinity (=1/nn) the order must be an integer.
        -- That, however, is already taken care of in the
        -- matrixModular(nn)$QMOD part of the matrix. Therefore, we
        -- remove this cusp.
        spitzen: CUSPS := setDifference(cusps nn, polesat)
        matord := matrixEtaOrder(nn, spitzen, idxs)
        matmod := matrixModular(nn, idxs)
        mat: MQQ := verticalConcat(matord, matmod)$QETAAUX
        rels: VZZ := new(nrows mat, 0) -- all equations
        -- For the first rows we want a >= system. (no poles for other cusps)
        for i in 1..nrows matord repeat rels.i := 1 -- non-negative order
        [mat, rels, new(nrows mat, 0)]$QINPUT

    etaCofactorSpace(nn: PP, rspec: SPEC, m: PP, t: NN, idxs: INDICES): ECS ==
        qin: QINPUT := etaCofactorSpaceSystem(nn, rspec, m, t, idxs)
        -- Now we have a matrix mat and a right-hand side v and need to
        -- solve mat*x=v for x.
        -- sol := diophantineSystem(mat, v)$SmithNormalForm(ZZ, VZZ, VZZ, MZZ)
        z: ZRESULT := zsolve(qin)$X4ti2
        empty?(z.zinhom) => [idxs, "failed", []]
        n := #idxs
        part: VZZ := first(z.zinhom)(1..n)
        bas: List VZZ := [x(1..n) for x in z.zfree]
        [idxs, part, bas]



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev package QMOD0 QEtaModularGamma0
++ QEtaModularGamma0 provides functions to check modularity for Gamma0.
++
++ TODO:
++
++ conditionCoEtaQuotient?(nn,rspec,m,t) returns true iff all the
++ conditions for the parameters are fulfilled. This checks whether
++ (nn,rspec,m,t) is in \Delta^* as defined in
++ Definition~\ref{def:condition-co-eta-quotient-gamma0} in qeta.tex
++ and in Definition 35 of \cite{Radu_RamanujanKolberg_2015}
++
++ candidateLevelsCoEtaQuotient(rspec,m,t) returns an ascendingly
++ sorted list of the nn up to 24*m*level(rspec) such that
++ conditionCoEtaQuotient?(nn,rspec,m,t) is true, i.e. that
++ (nn,rspec,m,t) is an element of \Delta^* as defined in
++ Definition~\ref{def:condition-co-eta-quotient-gamma0}.
++
++ matrixEtaOrderElement(nn,cusp,idx)=a_nn(c,delta)/24 where
++ a_nn(di,dj) given by Notation 3.2.6 in
++ \cite{Ligozat_CourbesModulaires_1975} where di and dj run over all
++ positive divisors of nn. The Ligozat matrix is A_N as described
++ after Lemma 5.2 in \cite{HemmeckeRadu_EtaRelations_2019}. The
++ parameter idx corresponds to the index of a pure eta-quotient,
++ i.e., it is of the form idx=[delta] with delta a divisor of nn. We
++ assume that cusp=(a:c).
++
++ matrixModular(nn,idxs) returns part of the matrix matrixModular(nn)
++ corresponding to the divisors that are given through idxs (i.e.,
++ the order of the columns corresponds to what is given through
++ idxs). Irrelevant rows in the rows specifying the square condition
++ are removed. nn represents the level of $\Gamma_0(nn)$ and idxs has
++ the form [[d1],...,[dn]] where the di are (different) divisors of
++ nn. See description for matrixModular(nn) for more information.
++
++ minimalLevelCoEtaQuotient(rspec,m,t) returns the smallest nn of
++ candidateLevalsCoEtaQuotient(rspec,m,t). Note that one might have
++ to use a bigger nn, because the level might still be too small to
++ find a cofactor an example is for rspec=[[1,-1],[7,1]], m=9, t=5
++ where this function returns 21, but one would have to use 42.
++
++ modular?(sspec,rspec,m,t) returns true iff all the conditions of
++ Theorem~\ref{thm:RaduConditions} are fulfilled. Compare with
++ modularGamma0? from QEtaAuxiliaryPackage.
QEtaModularGamma0: Exports == Implementation where
  Exports ==> QEtaModularCategory with
    matrixLigozat: PP -> MZZ
      ++ matrixLigozat(n) returns the (n,n) matrix with entries
      ++ a_m(di,dj) given by Notation 3.2.6 in
      ++ \cite{Ligozat_CourbesModulaires_1975} where di and dj run
      ++ over all positive divisors of m. This matrix is A_N as
      ++ described after Lemma 5.2 in
      ++ \cite{HemmeckeRadu_EtaRelations_2019}.
    matrixLigozatElement: (PP, ZZ, ZZ) -> ZZ
      ++ matrixLigozatElement(nn, c, delta) computes an entry of the
      ++ matrix of Ligozat corresponding to the index (c, delta)
      ++ counted in divisors of nn.

  Implementation ==> add
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FL ==> List Record(flag: fUnion, factor: ZZ, exponent: NN)
    DIVISIBLEBY?(k, z) ==> zero?(z rem k)
    import from QEtaCofactorConditions

    -- local
    -- \cite[Def.~35]{Radu_RamanujanKolberg_2015}
    kappa(m: PP): PP == -- gcd(1-m^2, 24)
        (even? m => 1; 8) * (DIVISIBLEBY?(3, m) => 1; 3)

    -- local
    -- Return true iff \eqref{eq:Radu-productsquare} holds.
    checkSquare?(sspec: SPEC, rspec: SPEC, m: PP, orbitSize: ZZ): Boolean ==
        --assert(pure? sspec)
        --assert(pure? rspec)
        nn: PP := level sspec
        fl: FL := factorList factor nn
        -- By \eqref{eq:p|m=>p|N} and \eqref{eq:delta|M=>delta|mN}, it is
        -- enough to consider all prime divisors of N.
        for fe in fl repeat -- do for all primes dividing nn
            p: PP := asPP(fe.factor) -- extract prime factor
            -- Determine whether an even power of p divides
            -- \prod_{\delta|N}\delta^rdelta.
            e1: ZZ := 0
            for l in pureParts sspec | odd? specExponent l repeat
                e1 := e1 + primePower(specDelta l, p)$QETAAUX
            e2: ZZ := 0
            if odd? orbitSize then
                -- check 2nd prod in eq:Radu-productsquare
                em: NN := primePower(m, p)$QETAAUX
                -- for all divisors of mm > 1
                for l in pureParts rspec | odd? specExponent l repeat
                    -- mod 2, only odd sdelta is relevant.
                    e2 := e2 + em + primePower(specDelta l, p)$QETAAUX
            if odd?(e1 + e2) then return false
        return true

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------

    conditionCoEtaQuotient?(nn: PP, rspec: SPEC, m: PP, t: NN): Boolean ==
        not pure? rspec => false
        t >= m => error "0<=t<m is a necessary condition"
        not conditionMmN?(nn, rspec, m) => false -- \eqref{eq:delta|M=>delta|mN}
        not conditionPrimeDivisors?(nn, m) => false -- \eqref{eq:p|m=>p|N}
        not conditionSumExponentsPure?(nn, rspec, m) => false --\eqref{eq:sum-r}
        not conditionRho0Pure?(nn, rspec, m) => false -- \eqref{eq:rv24}
        not conditionNDivisor?(nn, rspec, m, t) => false -- \eqref{eq:w|N}
        conditionEvenMultiplier?(nn, rspec, m) -- \eqref{eq:even-m}

    candidateLevelsCoEtaQuotient(rspec: SPEC, m: PP, t: NN): List PP ==
        [asPP nn for nn in 1..24*m*level(rspec) | _
            conditionCoEtaQuotient?(asPP nn, rspec, m, t)]

    matrixEtaOrderElement(nn: PP, cusp: Cusp, idx: LZZ): QQ ==
        --assert(cusp=nomalizeCusp(cusp))
        --assert(#idx=1)
        #idx ~=1 or not((d:=first idx)>0 and denom(nn/d)=1) =>
          error "matrixEtaOrderElement: bad eta index"
        matrixLigozatElement(nn, denom cusp, first idx)/24

    matrixLigozat(nn: PP): MZZ ==
        divs: List ZZ := divisors(nn)$IntegerNumberTheoryFunctions
        n: NN := # divs
        mat: MZZ := new(n, n, 0)
        for i in 1..n for di in divs repeat
            for j in 1..n for dj in divs repeat
                qsetelt!(mat, i, j, matrixLigozatElement(nn, di, dj))
        mat

    -- Compute B_N and V_N as in
    -- \cite{HemmeckeRadu_EtaRelations_2019}.
    -- matrixLigozatElement(m,di,dj) here corresponds to a_m(di, dj)
    -- in \cite[Notation 3.2.6]{Ligozat_CourbesModulaires_1975}. Note
    -- that we can use any integer c here, including c=0.
    matrixLigozatElement(m: PP, c: ZZ, delta: ZZ): ZZ == -- di==c, dj==delta
        num: ZZ := m * gcd(c, delta)^2
        den: ZZ := gcd(c^2, m) * delta
        (num exquo den)::ZZ -- can prove that this cannot fail

    matrixModular(nn: PP, idxs: INDICES): MQQ ==
        -- check idxs
        n: NN := # idxs
        for j in 1..n for idx in idxs repeat
            if #idx ~= 1 then error "matrixModular-Gamma0: not pure index"
            d: ZZ := first idx
            if d < 1 or not zero?(nn rem d) then
                error "matrixModular-Gamma0: index not positive divisor"
        fl: List Record(factor: ZZ, exponent: NN) := factors factor nn
        -- product is rational square
        ll: LLZZ := [[primePower(asPP(idx.1), asPP(fe.factor))$QETAAUX _
                     for idx in idxs] _
                    for fe in fl]
        import from LZZ
        ll := removeDuplicates ll
        ll := [l for l in ll | removeDuplicates l ~= [0]] -- no 0-rows
        cols: PP := asPP(n + 2 + #ll)
        rows: PP := asPP(3 + #ll)
        mat: MQQ := new(rows, cols, 0)
        for j in 1..n for idx in idxs repeat
            d: ZZ := first idx
            -- sum(r(d.i), i=1..n)=0
            qsetelt!(mat, 1, j, 1)
            -- 1/24 * sum(d * r(d) for [d] in idxs) should be an integer
            qsetelt!(mat, 2, j, d/24)
            -- 1/24 * sum(nn/d * r(d) for [d] in idxs) should be an integer
            qsetelt!(mat, 3, j, nn/(24*d)) -- note that d divides nn
        for i in 1..#ll for l in ll repeat
            for j in 1..n for z in l repeat qsetelt!(mat, i+3, j, z/2)
            qsetelt!(mat, i+3, n+2+i, 1$QQ) -- additional variable for (mod 1)
        qsetelt!(mat, 2, n+1, 1$QQ) -- additional variable for (mod 1)
        qsetelt!(mat, 3, n+2, 1$QQ) -- additional variable for (mod 1)
        return mat

    minimalLevelCoEtaQuotient(rspec: SPEC, m: PP, t: NN): PP ==
        for nn in 1..24*m*level(rspec) repeat
            conditionCoEtaQuotient?(asPP nn, rspec, m, t) => return asPP nn
        error "minimalLevelCoEtaQuotient: should not be here"

    modular?(rspec: SPEC): Boolean == modularGamma0? rspec

    modular?(sspec: SPEC, rspec: SPEC, m: PP, t: NN): Boolean ==
        not pure? sspec => false
        nn: PP := level sspec; s: LZZ := pureExponents sspec
        mm: PP := level rspec; r: LZZ := pureExponents rspec

        not conditionCoEtaQuotient?(nn, rspec, m, t) => false

        orb: List NN := modularOrbit(rspec, m, t)
        orbitSize: ZZ := # orb

        --\eqref{eq:cofactor-weight}
        not zero?(reduce(_+, s, 0) + orbitSize * reduce(_+, r, 0)) =>
            warnPrint("eq:sum=0 sspec", sspec)
            warnPrint("eq:sum=0 rspec", rspec)
            warnPrint("eq:sum=0 orbitSize", orbitSize)
            false

        --\eqref{eq:cofactor-rho-infinity}
        shat: QQ := rhoInfinity sspec
        rhat: QQ := rhoInfinity rspec
        alpha: QQ := reduce(_+, orb, 0)::QQ + rhat * orbitSize
        z: QQ := shat + orbitSize * m * rhat + (1-m^2)/m*alpha
        not one? denom z =>
            warnPrint("eq:pure-rhoinfinity sspec", sspec)
            warnPrint("eq:pure-rhoinfinity rspec", rspec)
            warnPrint("eq:pure-rhoinfinity orbitSize", orbitSize)
            warnPrint("eq:pure-rhoinfinity alpha", alpha)
            false

        --\eqref{eq:cofactor-rho-zero}
        sv: QQ := rho0 sspec
        rv: QQ := rho0 rspec
        -- conditionCoEtaQuotientGamma0?(nn, rspec, m, t) implies that
        -- m*nn/mm is an integer. See conditionMmN?(nn, rspec, m).
        not one? denom(sv + orbitSize * m*nn/mm * rv) =>
            warnPrint("eq:Radu-rho0 sspec", sspec)
            warnPrint("eq:Radu-rho0 rspec", rspec)
            warnPrint("eq:Radu-rho0 orbitSize", orbitSize)
            false

        --\eqref{eq:Radu-productsquare}
        not checkSquare?(sspec, rspec, m, orbitSize) =>
            warnPrint("eq:Radu-productsquare sspec", sspec)
            warnPrint("eq:Radu-productsquare rspec", rspec)
            warnPrint("eq:Radu-productsquare orbitSize", orbitSize)
            false

        true

    -- local
    odotBar(a2: ZZ, rhoInfty: QQ, m: PP, t: NN): NN ==
        --assert(one? positiveRemainder(a2, 24))
        -- \cite[Def.~41]{Radu_RamanujanKolberg_2015}
        k: QQ := (a2-1)*rhoInfty
        not one? denom k => error "odotBar: not an integer"
        z: ZZ := positiveRemainder(t*a2+numer(k), m)
        asNN z

    -- The following function computes \modularOrbit{r, m, t} with the
    -- optimization given by Radu in \cite[Lemma 4.35]{Radu_PhD_2010},
    -- i.e., we do not need to check all entries of \setS_{24m}, but
    -- only those that are not equivalent mod w.
    modularOrbit(rspec: SPEC, m: PP, t: NN): List NN ==
        not pure? rspec => error "orbit computation only for pure eta-quotients"
        --assert(one?(denom(24*rhoInfinity(rspec))), because it is a pure EQ
        rhoInfty: QQ := rhoInfinity rspec
        rhoInfty24: ZZ := numer(24*rhoInfty)
        m24: ZZ := 24*m
        g := gcd(kappa(m)*(24*t + rhoInfty24), m24)
        w: PP := asPP((m24 exquo g)::ZZ)
        result: List NN := empty()
        for a in 0..w-1 | one? gcd(a, w) repeat
            y := a
            while y < m24 and not one? gcd(y, m24) repeat y := y + w
            -- Note that m24=g*w and gcd(a + k*w, m24) =
            -- gcd(a+k*w,g*w) = 1 for k chosen to be the product of
            -- all prime divisors of g that do not divide a and do not
            -- divide w. In other words, the above while loop also
            -- terminates without the "y < m24" condition.
            e := odotBar(positiveRemainder(y^2, m24), rhoInfty, m, t)
            if not member?(e, result) then result := cons(e, result)
        result

    etaCofactorSpaceSystem(nn:PP, rspec:SPEC, m:PP, t:NN, idxs:INDICES): QINPUT ==
        import from QEtaCofactorConditions
        not conditionCoEtaQuotient?(nn, rspec, m, t) =>
            error "conditionCoEtaQuotient?(Gaamma0) not met"

        mat: MQQ := matrixModular(nn, idxs)

        -- Setup right-hand side.
        v: VQQ := new(nrows mat, 0)

        -----------------------------------------------------------
        -- \eqref{eq:cofactor-weight}
        w: ZZ := reduce(_+, pureExponents rspec, 0)$List(ZZ)
        orb: List NN := modularOrbit(rspec, m, t)
        orbitSize: ZZ := # orb
        v.1 := (- orbitSize * w)::QQ

        -----------------------------------------------------------
        -- \eqref{eq:cofactor-rho-infinity}
        orhoI: QQ := orbitSize * rhoInfinity(rspec)
        beta: QQ := (1/m)*(reduce(_+, orb, 0)::QQ + orhoI) -- \eqref{eq:beta}
        v2: QQ := - (m * orhoI + (1-m^2)*beta)
        v.2 := fractionalPart(v2)$QETAAUX
        -----------------------------------------------------------
        -- \eqref{eq:rho-zero}
        mm: PP := level rspec
        v3: QQ := - (orbitSize * m * nn) / mm * rho0(rspec)
        v.3 := fractionalPart(v3)$QETAAUX
        -----------------------------------------------------------

        -- now the stuff connected to eq:Radu-productsquare
        fl: FL := factorList factor nn
        -- Determine the cofactor according to (37) of
        -- \cite{Radu_RamanujanKolberg_2015} for each prime separately.
        -- Or see \ref{eq:Radu-productsquare} in qeta.tex.
        if even? orbitSize then
            for i in 1..#fl repeat v(i+3) := 0
        else
            for i in 1..#fl for fe in fl repeat
                p: PP := asPP(fe.factor) -- extract prime factor
                em: NN := primePower(m, p)$QETAAUX
                e: ZZ := 0
                for l in pureParts rspec | odd? specExponent l repeat
                    e := e + em + primePower(specDelta l, p)$QETAAUX
                v(i+3) := fractionalPart(e/2)$QETAAUX

        return [mat, new(#v,0)$VZZ, v]

    ----------------------------------------------------
    -- Functions connected to congruence subgroup Gamma0
    ----------------------------------------------------

    cusps(nn: PP): CUSPS == cusps()$GAMMA0(nn)
    cuspToMatrix(nn: PP, cusp: Cusp): SL2Z == cuspToMatrix(cusp)$GAMMA0(nn)
    genus(nn: PP): NN == genus()$GAMMA0(nn)
    width(nn: PP, cusp: Cusp): PP == width(cusp)$GAMMA0(nn)
    width(nn: PP, gamma: SL2Z): PP == width(gamma)$GAMMA0(nn)

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaCModularGamma1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev package QMOD1 QEtaModularGamma1
++ QEtaModularGamma0 provides functions to check modularity for Gamma1.
++
++ TODO:
++
++ conditionCoEtaQuotient?(nn,rspec,m,t) returns true iff the
++ conditions in Chapter 10 of
++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019} just before
++ Theorem 10.1 are fulfilled. See
++ Definition~\ref{def:condition-co-eta-quotient-gamma1}. These are
++ conditions for the existence of a product of eta- and generalized
++ eta-quotient to exist as a cofactor for a disection of such a
++ quotient. The parameter rbar specifies the generalized eta-quotient
++ via etaQuotient(rbar). These are slight modifications of conditions
++ appearing in Definition 35 of \cite{Radu_RamanujanKolberg_2015} in
++ case the defining eta-quotient is not a generalized one.
++
++ candidateLevelsCoEtaQuotient(rspec,m,t) returns an ascendingly
++ sorted list of the nn up to 24*m*level(rspec) such that
++ conditionCoEtaQuotient?(nn,rspec,m,t) is true, i.e. that
++ (nn,mm,rbar m,t) fulfills the 10 conditions as defined in
++ Section 10 of
++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}. The
++ parameter rbar specifies the generalized eta-quotient via
++ etaQuotient(rbar).
++
++ z:=matrixEtaOrderElement(nn,cusp,idx). The parameter corresponds to
++ the index of a (generalized) eta-quotient, i.e., it can be of the
++ form idx=[delta,g] or of the form idx=[delta] with g in the range
++ 0..delta. Then z is the coefficient of r_{delta,g} in
++ \cite[Thm.~4]{Robins_GeneralizedDedekindEtaProducts_1994}, except
++ for the case nn=4, gcd(denom(cusp),nn)=2 (or Gamma1(4)-equivalent)
++ where we return half of this coefficient. If idx=[delta] then
++ z=1/2*matrixEtaOrderElement(nn,cusp,[delta,0])/2. and thus
++ corresponds to the coefficient of $r_\delta$ in
++ \eqref{eq:order-rbar-non-adjusted} in
++ Theorem~\ref{thm:matrixEtaOrderRobins}. Note that Robins refers to
++ an expansion in the uniformizing variable q^(gcd(c,nn)/nn) (where
++ cusp=a/c). That is equal to
++ q^(1/width(c)$CongruenceSubgroupGamma1(nn)) except for the case
++ nn=4 and gcd(nn,c)=2. In that case the width of the cusp 1/2 is 1
++ and not 2=4/gcd(4.2). For this case, we deviate from Robins'
++ coefficients and adapt to an expansion in q rather than an
++ expansion in q^(1/2).
++
++ matrixModular(nn,idxs) returns a matrix mat with 3 rows and n+2
++ colums (where n=#idxs such that mat*v=0 for an (extended) exponent
++ vector where the exponents correspond to
++ generalizedEtaFunctionIndices(nn). mat*v=0 encodes the conditions
++ \eqref{eq:generalized-weight},
++ \eqref{eq:generalized-sigmaInfinity}, and
++ \eqref{eq:generalized-sigma0}, but corresponding to the given
++ indices idxs. See also modularGamm1 and modularGamma1?. The first
++ row encodes that the some of the exponents of the pure part must be
++ zero. The second row encodes that order at infinity must be an
++ integer. The third row encodes that the order at 0 must be an
++ integer. For the last two rows, the "is-an-integer" property is
++ encoded by a 1 in the (n+1)-th and (n+2)-th column, respectively.
++ All other entries are 0.
++
++ modular?(sspec,rspec,m,t) returns true iff all the conditions of
++ Theorem~10.1 of
++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019} are
++ fulfilled. Here the parameter sspec stands for the exponents
++ $a_\delta$ and $a_{\delta,g}$. See also
++ Theorem~\ref{thm:condition-co-eta-quotient-gamma1}.
QEtaModularGamma1: Exports == Implementation where
  Exports ==> QEtaModularCategory
  Implementation ==> add
    DIVISIBLEBY?(k, z) ==> zero?(z rem k)
    import from QEtaCofactorConditions

    -- local
    alphaAux(rspec: SPEC, t: NN): QQ == t::QQ + rhoInfinity rspec

    -- local
    -- \cite[Def.~35]{Radu_RamanujanKolberg_2015}
    kappa(m: PP): PP == -- gcd(1-m^2, 24)
        (even? m => 1; 8) * (DIVISIBLEBY?(3, m) => 1; 3)

    -- local function
    -- return true if for some a in
    -- \cite[Thm~10.1(4)]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
    -- or in \eqref{eq:CDZ-productsquare}
    -- the condition is true.
    checkSquare?(sspec: SPEC, rspec: SPEC, m: PP, a: ZZ): Boolean ==
        --assert(one? gcd(a, d)) for every divisor of nn (and of mm).
        import from IntegerNumberTheoryFunctions
        z: ZZ := 1
        for l in pureParts sspec | odd? specExponent l repeat
            z := z * jacobi(  specDelta l, a)
        for l in pureParts rspec | odd? specExponent l repeat
            z := z * jacobi(m*specDelta l, a)
        zero? z => error "checkSquare?: zero jacobi symbol"

        expo: QQ := 0
        ll := concat(properGeneralizedParts sspec, properGeneralizedParts rspec)
        for l in ll repeat --assert(#l=3) -- l=[d,g,e], (g/d-1/2)*e
            d := specDelta l; g := specSubindex l; e := specExponent l
            expo := expo + (g/d - 1/2)*e
        expo := (a-1) * expo -- this should give an integer
        not one? denom expo => error "checkSquare?: expo not integral"

        (z > 0 and even? numer expo) or (z < 0 and odd? numer expo)

-------------------------------------------------------------------
-- exported functions
-------------------------------------------------------------------

    -- condition for the disection of mixed-generalized eta-quotients
    conditionCoEtaQuotient?(nn: PP, rspec: SPEC, m: PP, t: NN): Boolean ==
        t >= m => error "0<=t<m is a necessary condition"
        mm: PP := level rspec

        -- CDZ(1), condition 1 (p. 6), M|N,
        not zero?(nn rem mm) => false

        -- CDZ(2), condition 2, p. 6)
        -- qeta.tex {eq:p|m=>p|N}
        not conditionPrimeDivisors?(nn, m) => false

        -- CDZ(6), condition 3 (p. 6)
        -- qeta.tex {eq:sum-r},
        --          {eq:conditionSumPureExponents?(nn,rspec,m)
        not conditionSumExponentsPure?(nn, rspec, m) => false

        -- CDZ(4)
        -- qeta.tex {eq:conditionSumExponentsProperGeneralized?(nn,rspec,m)}
        not conditionSumExponentsProperGeneralized?(nn, rspec, m) => false

        -- CDZ(7)
        -- qeta.tex {eq:rv24}, {eq:conditionRho0Pure?(nn,rspec,m)}
        not conditionRho0Pure?(nn, rspec, m) => false

        -- CDZ(5)
        -- qeta.tex {eq:conditionRho0ProperGeneralized?(nn,rspec,m)}
        not conditionRho0ProperGeneralized?(nn, rspec, m) => false

        -- CDZ(3)
        -- qeta.tex {eq:conditionGSigma0?(nn,rspec,m)}
        not conditionGSigma0?(nn, rspec, m) => false

        -- CDZ(8)
        -- qeta.tex {eq:w|N}, {eq:conditionNDivisor?(nn,rspec,m,t)}
        not conditionNDivisor?(nn, rspec, m, t) => false

        -- CDZ(9)
        -- qeta.tex {eq:even-m}, {eq:conditionEvenMultiplier?(nn,rspec,m)}
        not conditionEvenMultiplier?(nn, rspec, m) => false

        -- CDZ(10)
        -- qeta.tex {eq:conditionOrbitLength?(nn,rspec,m,t)}
        conditionOrbitLength?(nn, rspec, m, t)

    candidateLevelsCoEtaQuotient(rspec: SPEC, m: PP, t: NN): List PP ==
        [asPP nn for nn in 1..24*m*level(rspec) | _
            conditionCoEtaQuotient?(asPP nn, rspec, m, t)]

    minimalLevelCoEtaQuotient(rspec: SPEC, m: PP, t: NN): PP ==
        for nn in 1..24*m*level(rspec) repeat
            conditionCoEtaQuotient?(asPP nn, rspec, m, t) => return asPP nn
        error "minimalLevelCoEtaQuotient: should not be here"

    -- matrixEtaOrderElement(nn, cusp, delta, g) returns the coefficient of
    -- r_{delta.g} in
    -- \cite[Thm.~4]{Robins_GeneralizedDedekindEtaProducts_1994}. See
    -- also Theorem~\ref{thm:matrixEtaOrderRobins}. Since we always
    -- want an expansion in $q^{1/w_\gamma}$ where $w_\gamma$ is the
    -- width of the respective cusp for $\Gamma_1(nn)$, we adjust the
    -- following function for the special case, so that if $A$ is the
    -- result of \code{matrixEtaOrder}$(N)$, then $A \bar{r}$ gives
    -- the order of $g_{\bar{r}}(\gamma\tau)$ in terms of
    -- $q^{1/w_\gamma}$.
    matrixEtaOrderElement(nn: PP, cusp: Cusp, idx: LZZ): QQ ==
        --assert(cusp>0) -- comes from cusps()$CongruenceSubgroupGamma1(nn)
        empty? idx =>
            errorPrint("idx", idx)
            error "matrixEtaOrderElement: index not allowed"
        entryFactor: QQ := 1
        delta: ZZ := idx.1
        g: ZZ := 0
        if #idx=1 then entryFactor := 1/2 else g := idx.2
        -- If cusp=a/c=lambda/(mu*epsilon), then we must have the
        -- condition: gcd(lambda,nn)=gcd(lambda,mu)=gcd(mu,nn)=1. So
        -- we try to find an equivalent cusp with this property.
        -- See function normalizeCusp in CongruenceSubgroupGamma1.
        delta <= 0 => error "matrixEtaOrderElement: delta not positive"
        g > delta => error "matrixEtaOrderElement: no such g allowed"
        c: ZZ := denom cusp
        l: ZZ := numer cusp -- \lambda
        -- Make cusp (0:1)=infinity a special case, i.e. treat it like
        -- (1:nn). See (11) of Robins.
        if infinity? cusp then
            c := nn
            l := 1
        e: ZZ := gcd(c, nn) -- \epsilon: divisor of nn (will not change)
        -- Note that nn/e = width(nn, c) (at least if (nn,c)~=(4,2)).
        -- Find a coprime (to nn) cofactor m such that m*e = c (mod nn).
        m: ZZ := (c exquo e)::ZZ
        n: ZZ := (nn exquo e)::ZZ
        while not one? gcd(m, nn) repeat m := m + n
        -- Find a coprime numerator l such that l/(m*e) is Gamma1(nn)
        -- equivalent to a/c.
        while not one? gcd(l, m) or not one? gcd(nn, l) repeat
            l := l + e
            if l >= nn then -- safety check -- should actually not happen
               errorPrint("[nn, numer cusp, denom cusp, c, m, e]",
                           [nn, numer cusp, denom cusp, c, m, e]$List(ZZ))
               error "matrixEtaOrder: lambda too big"

        h: ZZ := gcd(delta, e)
        f: QQ := fractionalBernoulli2(l*g/h)$QETAAUX
        z: QQ := entryFactor * (nn*h^2/(2*delta*e)) * f
        nn = 4 and e = 2 => 1/2*z
        z

    matrixModular(nn: PP, idxs: INDICES): MQQ ==
        spitzen: CUSPS := [infinity(), cusp(0,1)]
        rows: List List QQ := [matrixEtaOrderRow(nn, c, idxs) for c in spitzen]
        s: List QQ := [(#idx=1=>1;0) for idx in idxs]
        rows := cons(s, rows)
        n: NN := #idxs
        mat: MQQ := new(3, n+2, 0) -- 2 more for "is-an-integer" columns
        for i in 1..3 for row in rows repeat
            for j in 1..n for e in row repeat mat(i, j) := e
        qsetelt!(mat, 2, n+1, 1)
        qsetelt!(mat, 3, n+2, 1)
        return mat

    modular?(rspec: SPEC): Boolean == modularGamma1? rspec

    modular?(sspec: SPEC, rspec: SPEC, m: PP, t: NN): Boolean ==
        not conditionCoEtaQuotient?(level sspec, rspec, m, t) => false
        -- \cite[Thm~10.1]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
        -- Condition (1)
        -- Condition \eqref{eq:cofactor-weight}
        ws: ZZ := reduce(_+, pureExponents sspec, 0)$LZZ
        wr: ZZ := reduce(_+, pureExponents rspec, 0)$LZZ
        not zero?(ws + wr) =>
            warnPrint("Chen: Theorem 10.1(1) sspec", sspec)
            warnPrint("Chen: Theorem 10.1(1) rspec", rspec)
            false

        -- Condition (2)
        -- Condition \eqref{eq:cofactor-rho-zero}
        -- Note that the orbit size \mu=1 in \eqref{eq:cofactor-rho-zero}.
        rv: QQ := rho0 rspec
        sv: QQ := rho0 sspec
        nn: PP := level sspec
        mm: PP := level rspec
        z: QQ := sv + m*nn/mm*rv -- Note that mm divides nn.
        not one? denom z =>
            warnPrint("Chen: Theorem 10.1(2) sspec", sspec)
            warnPrint("Chen: Theorem 10.1(2) rspec", rspec)
            warnPrint("Chen: Theorem 10.1(2) z", z)
            false

        -- Condition (3)
        -- Condition \eqref{eq:cofactor-rho-infinity}
        rhat: QQ := rhoInfinity rspec
        shat: QQ := rhoInfinity sspec
        alpha: QQ := alphaAux(rspec, t)
        not one? denom(shat + m * rhat + (1-m^2)/m*alpha) => --shouldn't happen
            warnPrint("Chen: Theorem 10.1(3) sspec", sspec)
            warnPrint("Chen: Theorem 10.1(3) rspec", rspec)
            warnPrint("Chen: Theorem 10.1(3) alpha", alpha)
            false

        -- Condition (4)
        -- Condition \eqref{eq:CDZ-productsquare}
        for i in 1..11 repeat
            a: ZZ := nn*i+1
            one? gcd(a,6) and not checkSquare?(sspec, rspec, m, a) =>
                warnPrint("Chen: Theorem 10.1(4) sspec", sspec)
                warnPrint("Chen: Theorem 10.1(4) rspec", rspec)
                warnPrint("Chen: Theorem 10.1(4) a", a)
                return false

        true

    -- loccal
    productSquareElement(idx: LZZ, a: ZZ): ZZ ==
        import from IntegerNumberTheoryFunctions
        empty? idx => error "etaCofactorSpace1System: idx is empty"
        d := idx.1
        #idx=1 => if jacobi(d, a) < 0 then 1 else 0
        q := (a-1) * fractionalBernoulli1(idx.2/d)$QETAAUX
        not one? denom q =>
            error "etaCofactorSpace1System: e exponent not integral"
        if odd? numer q then 1 else 0

    -- The result is a list that consists of n row elements prepended
    -- by the respective element for the right-hand side.
    -- This corresponds to condition (4) in
    -- \cite[Thm~10.1]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.
    -- See also \eqref{eq:CDZ-productsquare}.
    -- local
    productSquareRhsRow(rspec: SPEC, m: NN, idxs: INDICES, a: ZZ): LZZ ==
        import from IntegerNumberTheoryFunctions
        row: LZZ := [productSquareElement(idx, a) for idx in idxs]
        -- prepend the entry for the right-hand side
        expo: QQ := 0
        for l in properGeneralizedParts rspec repeat --assert(#l=3) l=[d,g,e]
            d := specDelta l; g := specSubindex l; e := specExponent l
            expo := expo + e * fractionalBernoulli1(g/d)$QETAAUX
        expo := (a-1) * expo
        not one? denom expo =>
            error "etaCofactorSpace1System: exponent not integral"
        isOdd?: Boolean := odd? numer expo
        for l in pureParts rspec | odd? specExponent l
                                   and jacobi(m*specDelta(l),a) < 0 repeat
            isOdd? := not isOdd?
        if isOdd? then cons(1, row) else cons(0, row)

    -- Extend the matrix by the product rows (with slack variable conditions).
    -- local
    extendByProductSquareRows(_
      nn: PP, rspec: SPEC, m: NN, idxs: INDICES, qin: QINPUT): QINPUT ==
        rows: LLZZ := [productSquareRhsRow(rspec, m, idxs, a) _
                      for a in 1..11*nn+1 by nn | one? gcd(a, 6)]
        -- remove duplicate lines to reduce slack variables
        rows := [row for row in removeDuplicates rows | not every?(zero?, row)]
        n: NN := #rows
        nc: NN := ncols(qin.qmat)
        v: VQQ := qin.qrhs
        rels: VZZ := qin.zrels
        mat: MQQ := new(n, nc + n, 0)
        for i in 1..n for row in rows repeat
            v := concat(v, first(row)/2) -- normalize to slackvar=1
            rels := concat(rels, 0)
            for e in rest row for j in 1..nc repeat mat(i, j) := e/2
            mat(i, nc + i) := 1 -- for slack variable
        [verticalConcat(qin.qmat, mat)$QETAAUX, rels, v]

    etaCofactorSpaceSystem(nn:PP, rspec:SPEC, m:PP, t:NN, idxs:INDICES): QINPUT ==
        -- \cite[Thm~10.1]{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
        import from QEtaCofactorConditions
        not conditionCoEtaQuotient?(nn, rspec, m, t) =>
            error "conditionCoEtaQuotient?(Gaamma1) not met"

        mat: MQQ := matrixModular(nn, idxs)

        -- Setup right-hand side.
        v: VQQ := new(nrows mat, 0)

        nspec: SPEC := purify rspec -- we must normalize generalized eqSPECs!!!
        -----------------------------------------------------------
        -- CDZ Condition (1), \eqref{eq:cofactor-weight}
        -- Note that obitSize=1.
        orb: List NN := [t]
        orbitSize: ZZ := 1
        v.1 := (- reduce(_+, pureExponents nspec, 0))::QQ
        -----------------------------------------------------------
        -- CDZ Condition (3), \eqref{eq:cofactor-rho-infinity}
        orhoI: QQ := orbitSize * rhoInfinity(rspec)
        beta: QQ := (1/m)*(reduce(_+, orb, 0)::QQ + orhoI) -- \eqref{eq:beta}
        v2: QQ := - (m * orhoI + (1-m^2)*beta)
        v.2 := fractionalPart(v2)$QETAAUX
        -----------------------------------------------------------
        -- CDZ Condition (2), \eqref{eq:rho-zero}
        mm: PP := level rspec
        v3: QQ := - (orbitSize * m * nn) / mm * rho0(rspec)
        v.3 := fractionalPart(v3)$QETAAUX
        -----------------------------------------------------------
        -- CDZ condition (4), \eqref{eq:CDZ-productsquare}
        qin: QINPUT := [mat, new(#v, 0)$VZZ, v]
        extendByProductSquareRows(nn, nspec, m, idxs, qin)

    ----------------------------------------------------
    -- Functions connected to congruence subgroup Gamma1
    ----------------------------------------------------

    cusps(nn: PP): CUSPS == cusps()$GAMMA1(nn)
    cuspToMatrix(nn: PP, cusp: Cusp): SL2Z == cuspToMatrix(cusp)$GAMMA1(nn)
    genus(nn: PP): NN == genus()$GAMMA1(nn)
    width(nn: PP, cusp: Cusp): PP == width(cusp)$GAMMA1(nn)
    width(nn: PP, gamma: SL2Z): PP == width(gamma)$GAMMA1(nn)


)if LiterateDoc
\end{document}
)endif
