-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
--dbgPrint(x,y) ==> display(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 770)
xdbgPrint(x,y) ==> rhx:="42"

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer


)abbrev package QETAKOL QEtaKolberg
QEtaKolberg: Exports == Implementation where
  Exports ==> with
    kappa: P -> P
    chiExponent: (P, Z, List N) -> Z
    orbit: (P, Z, P, N) -> List N

  Implementation ==> add
    chiExponent(m: P, sigmaInfty: Z, orb: List N): Z ==
        s: Z := 0
        for t in orb repeat s := s + 24*t
        s := s + sigmaInfty * #orb
        positiveRemainder((1-m^2)*((s exquo m)::Z), 24)

    kappa(m: P): P == -- gcd(1-m^2, 24) -- m = level
        (even? m => 1; 8) * (zero? positiveRemainder(m, 3) => 1; 3)

    -- The following function computes P_{m,r}(t).
    orbit(level: P, sigmaInfty: Z, m: P, t: N): List N ==
        k: P := kappa m
        orb: List Z := empty()
        g := gcd(k*(24*t + sigmaInfty), 24*m)
        w: Z := qcoerce((24*m exquo g)::Z)@P
        dbgPrint("w", w)
        s: Set Z := set [positiveRemainder(a^2, w) for a in 0..w-1 | one? gcd(a, w)]
        dbgPrint("gcd(w,24)", gcd(w,24));
        for a in members s repeat
            b: Z := a
            while not one? positiveRemainder(b, 24) repeat b := b + w
            orb := cons(b, orb)
        dbgPrint("orb", sort orb)
        l: List Z := sort [positiveRemainder(t*a+(((a-1) exquo 24)::Z)*sigmaInfty, m) for a in orb]
        return (l pretend List N)

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
