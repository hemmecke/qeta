-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
--dbgPrint(x,y) ==> display(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 770)
xdbgPrint(x,y) ==> rhx:="42"

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer


)abbrev package QETAKOL QEtaKolberg
QEtaKolberg: Exports == Implementation where
  Exports ==> with
    kappa: P -> P
    chiExponent: (P, Z, List N) -> Z
    orbit: (Z, P, N) -> List N

  Implementation ==> add
    chiExponent(m: P, sigmaInfty: Z, orb: List N): Z ==
        s: Z := 0
        for t in orb repeat s := s + 24*t
        s := s + sigmaInfty * #orb
        positiveRemainder((1-m^2)*((s exquo m)::Z), 24)

    kappa(m: P): P == -- gcd(1-m^2, 24) -- m = level
        (even? m => 1; 8) * (zero? positiveRemainder(m, 3) => 1; 3)

    circleBar(a2: Z, sigmaInfty: Z, m: P, t: N): N ==
        --assert(one? positiveRemainder(a2, 24))
        z: Z := positiveRemainder(t*a2+(((a2-1) exquo 24)::Z)*sigmaInfty, m)
        qcoerce(z)@N

    -- The following function computes P_{m,r}(t).
    orbit(sigmaInfty: Z, m: P, t: N): List N ==
        k: P := kappa m
        g := gcd(k*(24*t + sigmaInfty), 24*m)
        w: Z := qcoerce((24*m exquo g)::Z)@P
        sw: List Z := empty()
        for a in 0..w-1 | one? gcd(a, w) repeat
            a2 := positiveRemainder(a^2, w)
            if not member?(a2, sw) then sw := cons(a2, sw)
        s: List Z := empty()
        --assert(one? gcd(w, 24)) -- proof
        --choose a representative (mod w) that is divisible by 24
        for a2 in sw repeat
            u: Z := a2
            while not one? positiveRemainder(u, 24) repeat u := u + w
            s := cons(u, s)
        sort [circleBar(a2, sigmaInfty, m, t) for a2 in s]

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif

)if false


    relationRamanujanKolberg(level: P, m: P, t: N, r: RVector):
--        Record(s: RVector, t: List(N), rhs: MonoidRing(C, MRVector))
        List N
      ==
        empty()

    -- See \cite[Thm.~45]{Radu:RamanujanKolberg:2015}.
    -- m = m, t=t, M=ilevel, N=level
    coFactorConditions(level: P, ilevel: P, m: P, t: Z, r: List Z): MZ ==
        --assert(#r=#divisors(ilevel))
        --assert(zero? postiveRemainder(level, ilevel))
        -- DeltaStar-Conditions
        -- \cite[Def.~34]{Radu:RamanujanKolberg:2015} must be fulfilled.
        p := orbit(level, sigmainfty, m, t, r)
        orbitSize := #p
        divs: List P := [qcoerce(d)@P for d in divisors(level)]
        k: P := kappa m
        c1 := orbitSize * reduce(_+, r)
        c2 := chiExponent(m, r, orb)
)endif
