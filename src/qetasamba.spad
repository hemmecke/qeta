-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2017, 2019-2020  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{The Samba Algorithm}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
  This code implements the \algoSamba{} algorithm from
  \cite{Hemmecke:DancingSambaRamanujan:2018} in simple and extended
  form.
  Additionally, there is a variant that aborts the computation if the
  number of gaps is equal to the genus of the respective curve.
  Furthermore, since some computations take too long, computation can
  be done with trace output.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on the article
\cite{Hemmecke:DancingSambaRamanujan:2018} by Ralf Hemmecke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))



rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
%$
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

asN x ==> x pretend N

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category QEtaAlgebraBasisCategory: Data structure for
\algoSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev category QABC QEtaAlgebraBasisCategory
++ QEtaAlgebraBasisCategory(C, F) is a category for a data
++ structure that can be used for reduction modulo an algebra basis
++ (samba basis).
QEtaAlgebraBasisCategory(C, F): Category == Exports where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  Exports ==> CoercibleTo OutputForm with
    multiplier: % -> F
      ++ multiplier(x) returns multiplier element.
    basis: % -> List F
      ++ basis(x) returns all basis elements.
    basis: (%, Z) -> List F
      ++ basis(x, d) returns the basis elements of grade d.
    numberOfGaps: % -> N
      ++ numberOfGaps(x) computes
      ++ reduce(+, [floor(x/n) for x in bas], 0)
      ++ where t=multiplier(x), n=qetaGrade(t) and bas=basis(x).
      ++ If #(basis(x,i)=1 for all i from 1 to n-1 then
      ++ numberOfGaps(x) is equal to the number of gaps
      ++ (see Weierstrass Gap Theorem) of the module generated
      ++ by bas over C[t].
   add -- default implementation
     numberOfGaps(x: %): N ==
         t: F := multiplier x
         n: P := qetaGrade(t)::P
         grades: List P := [qetaGrade(first basis(x, i))::P for i in 1..n-1]
         numberOfGaps(n, grades)$QEtaAuxiliaryPackage


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain QEtaAlgebraBasis: Data structure for \algoSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain QETAAB QEtaAlgebraBasis
++ QEtaAlgebraBasis(C, F) is a domain holding the special
++ structure of an algebra basis with elements that can be used during
++ a reduction.
QEtaAlgebraBasis(C, F): Exports == Implementation where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  H ==> XHashTable(Z, List F)
  Exports ==> QEtaAlgebraBasisCategory(C, F) with
    initialize: F -> %
      ++ initialize(t) creates an empty basis that contains only
      ++ the multiplier t.
    basisElements: % -> H
      ++ basisElements(x) returns the basis elements of all grades.
  Implementation ==> add
    Rep ==> Record(mul: F, be: H)
    xx ==> rep x
    import from Rep
    coerce(x: %): OutputForm == xx::OutputForm
    initialize(t: F): % == per [t, empty()]
    multiplier(x: %): F == xx.mul
    basisElements(x: %): H == xx.be
    basis(x: %): List F == concat entries xx.be
    basis(x: %, d: Z): List F == elt(xx.be, d, empty()$List(F))


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain QEtaExtendedAlgebraBasis: Data structure for an
extended \algoSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain QETAXAB QEtaExtendedAlgebraBasis
++ QEtaExtendedAlgebraBasis(C, L, F, AB) is a domain holding the
++ special structure of an algebra basis with elements that can be
++ used during a reduction. This structure is useful to access basis
++ elements as if they were from the domain L. The structure is just
++ another view on an element of QEtaAlgebraBasis(C, F) such that it
++ looks like QEtaAlgebraBasis(C, L) by always taking first(x) of any
++ element of F.
QEtaExtendedAlgebraBasis(C, L, F, AB): Exports == Implementation where
  C: EuclideanDomain
  L: QEtaGradedAlgebra C
  F: QEtaGradedAlgebra C with (first: % -> L)
  AB: QEtaAlgebraBasisCategory(C, F)
  Exports ==> QEtaAlgebraBasisCategory(C, L) with
    coerce: AB -> %
      ++ coerce(x) assumes that x is and algebra basis with extended
      ++ elements.
      ++ Consider x as an element of QEtaAlgebra(C, L).
  Implementation ==> add
    Rep ==> AB
    xx ==> rep x
    coerce(x: %): OutputForm == xx::OutputForm
    coerce(ab: AB): % == per ab
    multiplier(x: %): L == first multiplier xx
    basis(x: %): List L == [first f for f in basis xx]
    basis(x: %, d: Z): List L == [first f for f in basis(xx, d)]


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category QEtaComputationCategory: Common category for the
\algoSamba{} algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QETACC QEtaComputationCategory
++ QEtaComputationCategory(F, AB) provides the functions necessary for the
++ internal functioning of basis elements and critical elements.
++ This category is an abstraction of the functionality to implement
++ variants of the samba algorithm from an article of Ralf Hemmecke
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaComputationCategory(F, AB): Category == Exports where
  F: Type -- QEtaGradedAlgebra C
  AB: Type -- can be [QX]EtaAlgebraBasisCategory(C, F)
  Exports ==> CoercibleTo OutputForm with
    initialize: List F -> %
      ++ initialize(bas) creates a new structure ready to be processed.
      ++ Assume that the first element of bas has positive qetaGrade.
    criticalElements?: % -> Boolean
      ++ criticalElements?(x) returns true if x represents a structure that
      ++ still contains critical elements.
    algebraBasis: % -> AB
      ++ algebraBasis(x) returns the structure from x that holds the
      ++ algebra basis.
    postProcess!: % -> %
      ++ postProcess!(x) postprocesses the result. It might interreduce
      ++ the basis or do other kinds of cleanup.
    extractNext!: % -> F
      ++ extractNext!(x) chooses one of the critical elements and
      ++ returns it. At the same time this critical element is
      ++ (destructively) removed from the structure of critical elements.
      ++ extractNext!(x) can only be called if criticalElements?(x)
      ++ returns true.
      ++ This function implements a selection strategy.
    oneStepComputation!: (%, % -> F) -> %
      ++ oneStepComputation!(x, next!) computes one step of the
      ++ computation. It uses the function next! to extract and
      ++ destructively remove the the next element that is to be
      ++ considered in the computation. Then it reduces it
      ++ and updates the basis and the critical elements if the
      ++ reduction did not end with 0. It should hold
      ++ criticalElements?(x), otherwise the result is undefined.
    oneTracedStepComputation!: (% -> Void, _
      (F, AB) -> Void, F -> Void, F -> Void) -> (%, % -> F) -> %
      ++ oneTracedStepComputation!(x, trace, traceEnter, traceLoop,
      ++ traceReturn)(x) behaves like oneStepComputation!(x, next!)
      ++ except that trace(x) is called at the beginning of the
      ++ function and tracedReduce(traceEnter, traceLoop, traceReturn)
      ++ is used instead of the ordinary reduce function.
    oneStep!: % -> %
      ++ oneStep!(x) computes oneStepComputation!(x, extractNext!).
    oneTracedStep!: (%->Void, (F, AB)->Void, F->Void, F->Void) -> (% -> %)
      ++ oneTracedStep!(trace, trEnter, trLoop, trReturn)(x)
      ++ computes
      ++ oneTracedStepComputation!(trace, trEnter, trLoop, trReturn)(x, extractNext!).

-- Tracing functions support.

    noTrace: % -> Void
      ++ noTrace(x) just returns x without any side effect.
    trace: N -> % -> Void
      ++ trace(n)(x) returns x and depending on the value of n returns
      ++ more and more information. Where a higer version of n means
      ++ more information. trace(0) is equivalent with noTrace.

   add
    postProcess!(x: %): % == x
    noTrace(x: %): Void == void()
    noTraceEnter(f: F, ab: AB): Void == void()
    noTraceElement(f: F): Void == void()

    oneStepComputation!(x: %, next!: % -> F): % ==
        oneTracedStepComputation!(noTrace,
            noTraceEnter, noTraceElement, noTraceElement)(x, next!)

    oneStep!(x: %): % == oneStepComputation!(x, extractNext!)

    oneTracedStep!(tr: % -> Void, _
                   tr0: (F, AB) -> Void,_
                   trl: F -> Void,_
                   trr: F -> Void): % -> % ==
        (x: %): % +->
            oneTracedStepComputation!(tr, tr0, trl, trr)(x, extractNext!)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category QEtaReductionCategory: Restricted reduction
packages}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

According to \cite{Hemmecke:DancingSambaRamanujan:2018}, we use a
restricted reduction for the algorithm \algoSamba.

An element $x$ is not reducible by $b$ not only when its grade is
bigger than that of $b$, but also when the grades are equal and the
(Euclidean) size of the leading coefficient of $x$ is smaller than
that of $b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QREDCAT QEtaReductionCategory
++ QEtaReductionCategory lists the functions used in the restricted
++ reduction as described in "Dancing Samba with Ramanujan Partition
++ Congruences" (Journal of Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaReductionCategory(C, F, AB): Category == Exports where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: Type -- QEtaAlgebraBasisCategory(C, F)
  H ==> XHashTable(Z, List F)
  Exports ==> with
    topReducible?: (F, F) -> Boolean
      ++ topReducible?(u, b) returns true iff there exists f in F such that
      ++ for v = u - f*b, lc = qetaLeadingCoefficient, and
      ++ grade = qetaGrade:
      ++ (grade u > grade v or
      ++ (grade u = grade v and euclideanSize lc u > euclideanSize lc v))
    tailReducible?: (F, Z, F) -> Boolean
      ++ tailReducible?(u, n, b) returns true iff there exists f in F
      ++ such that for v = u - f*b,
      ++ c = qetaCoefficient(u, n), and
      ++ d = qetaCoefficient(v, n)
      ++ zero? d holds or euclideanSize c > euclideanSize d.
      ++ Initially it is assumed that not zero?(c).
    reducer: (F, AB) -> Union(F, "failed")
      ++ reducer(u, ab) returns an element b from basis(ab)
      ++ or b=1 such that grade u - grade b is divisible by
      ++ grade(multiplier ab) or returns "failed" if no such b exists.
      ++ This functions corresponds to the function
      ++ "select_{t,basis}(u)" as in Definition 2.6 of
      ++ \cite{Hemmecke:DancingSambaRamanujan:2018}. That reducer
      ++ yields the element with biggest possible grade is ensured by
      ++ the requirement that "basis" is appropriately sorted by
      ++ greaterGrade?.
    noTraceEnter: (F, AB) -> Void
      ++ A functions that does nothing.
    noTrace: F -> Void
      ++ A function that does nothing.
    traceEnter: N -> (F, AB) -> Void
      ++ traceEnter(n)(x, a) returns void() and depending on the value
      ++ of n returns more and more information. Where a higer version
      ++ of n means more information. trace(0) is equivalent with
      ++ noTraceEnter.
    traceLoop: N -> F -> Void
      ++ traceLoop(n)(x) just returns void() without any side
      ++ effect and depending on the value of n returns more and more
      ++ information. Where a higer version of n means more
      ++ information. trace(0) is equivalent with noTraceElement.
    traceReturn: N -> F -> Void
      ++ traceReturn(n)(x) just returns void() without any side
      ++ effect and depending on the value of n returns more and more
      ++ information. Where a higer version of n means more
      ++ information. trace(0) is equivalent with noTraceElement.
    tracedReduce: ((F, AB) -> Void, F -> Void, F -> Void) -> ((F, AB) -> F)
      ++ tracedReduce(traceEnter, traceLoop, traceReturn)(u, ab) behaves
      ++ identical to reduce(u, ab) except that at enter and exit
      ++ time the functions traceEnter(u, ab) and traceExit(w)
      ++ are called where w is the value that will be returned. Inside
      ++ the internal while loop the function traceLoop(v) is called
      ++ with v being the intermediately reduced u.
      ++ These hooks are provided to print a trace of the reduction.
    reduce: (F, AB) -> F
      ++ reduce(u, ab) returns an element v such that v is not
      ++ reducible modulo ab and "u reduces modulo t and basis to v"
      ++ where t = multiplier(ab) and basis is given by the lists of
      ++ basis(ab, d) for all grades. These element lists of ``ab``
      ++ are assumed to be sorted by greaterGrade?. We assume that
      ++ qetaLeadingCoefficient(t)=1 and no element of the basis has a
      ++ qetaGrade that is divisible by the qetaGrade of t.
      ++ We require qetaGrade(multiplier ab)>0,
      ++ one? leadingCoefficient multiplier ab,
      ++ qetaGrade(b)>0 for all b in basis(ab), and
      ++ not zero? positiveRemainder(qetaGrade(b), grade multiplier ab)
      ++ for all b in basis(ab).
      ++ Whether reduce performs only a top-reduction or an additional
      ++ tail-reduction, is an implementation detail of the package.
    tracedTopReduce: ((F, AB) -> Void, F -> Void, F -> Void) -> ((F, AB) -> F)
      ++ tracedTopReduce behaves like tracedReduce, but performing
      ++ only top-reductions.
    tracedTailReduce: ((F, AB) -> Void, F -> Void, F -> Void) -> ((F, AB) -> F)
      ++ tracedTailReduce behaves performs only tail-reductions, i.e.,
      ++ the qetaGrade of the result will be the same as the qetaGrade
      ++ of the input element.
      ++ Tail-reductions are reductions that are performed on the
      ++ non-leading terms of the input up to (and including) the
      ++ constant term of the series.
    topReduce: (F, AB) -> F
      ++ topReduce == tracedTopReduce(noTraceEnter, noTrace, noTrace)
    tailReduce: (F, AB) -> F
      ++ tailReduce == tracedTailReduce(noTraceEnter, noTrace, noTrace)

    greaterGrade?: (F, F) -> Boolean
      ++ greaterGrade?(x, y) returns qetaGrade(x)>qetaGrade(y).
   add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    greaterGrade?(x: F, y: F): Boolean == grade x > grade y
    topReducible?(u: F, b: F): Boolean ==
        --assert(not zero? b)
        --assert(not zero? u)
        grdu: Z := grade u
        grdb: Z := grade b
        grdu < grdb => false
        lcu: C := leadingCoefficient u
        lcb: C := leadingCoefficient b
        euclideanSize lcu >= euclideanSize lcb

    tailReducible?(u: F, n: Z, b: F): Boolean ==
        --assert(not zero? b)
        --assert(not zero? u)
        n < grade b => false
        lcu: C := qetaCoefficient(u, n)
        lcb: C := leadingCoefficient b
        euclideanSize lcu >= euclideanSize lcb

    -- For tracing the computation, other functions (that print
    -- something) could be used.
    noTraceEnter(u: F, ab: AB): Void == void()
    noTrace(u: F): Void == void()

    reduce(u: F, ab: AB): F ==
        tracedReduce(noTraceEnter, noTrace, noTrace)(u, ab)

    topReduce(u: F, ab: AB): F ==
        tracedTopReduce(noTraceEnter, noTrace, noTrace)(u, ab)

    tailReduce(u: F, ab: AB): F ==
        tracedTailReduce(noTraceEnter, noTrace, noTrace)(u, ab)

    traceEnter(verbosity: N): (F, AB) -> Void == (f: F, ab: AB): Void +->
        zero? verbosity => void() -- abort early
        tracePrint("-----------------------------red u", traceout(verbosity)(f))
        if verbosity > 1 and AB has QEtaAlgebraBasisCategory(C, F) then
            n: Z := qetaGrade multiplier ab - 1
            l: List List F := [basis(ab, i) for i in 1..n]
            gs: List List Z := [[qetaGrade x for x in bs] for bs in l]
            tracePrint("red gs", gs)

    traceLoop(verbosity: N): F -> Void == (f: F): Void +->
        zero? verbosity => void() -- abort early
        tracePrint("red loop", traceout(verbosity)(f))

    traceReturn(verbosity: N): F -> Void == (f: F): Void +->
        zero? verbosity => void() -- abort early
        tracePrint("redx", traceout(verbosity)(f))




)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaReduction: Restricted reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETARED QEtaReduction
++ QEtaReduction implements the restricted reduction as described in
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ Note that here we not only reduce the top term, but also the
++ remaining terms up to (and including) qetaGrade = 0.
QEtaReduction(C, F, AB): QEtaReductionCategory(C, F, AB) == Impl where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F)
  Impl ==> add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    reducer(u: F, ab: AB): Union(F, "failed") ==
        zero? u => "failed"
        grdt: Z := grade multiplier ab
        i: Z := positiveRemainder(grade u, grdt)
        -- if zero? i there is no corresponding element in basis, but
        -- we can use the element 1, i.e. we reduce u by a power of t.
        zero? i => return (1$F)::Union(F, "failed")
        candidates: List F := basis(ab, i)
            -- candidates contains all basis elements b with
            -- positiveRemainder(grade b, grdt) = i in the same order
            -- as given in basis.
        for b in candidates repeat
            if topReducible?(u, b) then return b::Union(F, "failed")
        "failed"

    tailReducer(u: F, n: Z, ab: AB): Union(F, "failed") ==
        zero? qetaCoefficient(u, n) => "failed"
        grdt: Z := grade multiplier ab
        i: Z := positiveRemainder(n, grdt)
        -- if zero? i there is no corresponding element in basis, but
        -- we can use the element 1, i.e. we reduce u by a power of t.
        zero? i => return (1$F)::Union(F, "failed")
        candidates: List F := basis(ab, i)
            -- candidates contains all basis elements b with
            -- positiveRemainder(grade b, grdt) = i in the same order
            -- as given in basis.
        for b in candidates repeat
            if tailReducible?(u, n, b) then return b::Union(F, "failed")
        "failed"

    tracedTopReduce(trEnter: (F, AB) -> Void,_
                    trLoop: F -> Void,_
                    trReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        trEnter(u, ab)
        t: F := multiplier ab
        grdt: Z := grade t
        while not ((r := reducer(u, ab)) case "failed") repeat
            trLoop u
            grdu: Z := grade u
            v: F := r :: F
            j: Z := ((grdu - grade v) exquo grdt) :: Z
            v := v*t^asN(j)
            -- cc: Record(quotient: C, remainder: C)
            cc := divide(leadingCoefficient u, leadingCoefficient v)
            u := u - (cc.quotient)*v
            uca := unitNormal leadingCoefficient u
            u := (uca.associate)*u
        uca := unitNormal leadingCoefficient u
        u := (uca.associate)*u
        trReturn u
        return u

    tracedTailReduce(trEnter: (F, AB) -> Void,_
                     trLoop: F -> Void,_
                     trReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        trEnter(u, ab)
        t: F := multiplier ab
        grdt: Z := grade t
        n := grade u -- non-top-reduction
        while n>0 repeat
            n := n-1
            while not ((r := tailReducer(u, n, ab)) case "failed") repeat
                v := r :: F
                j: Z := ((n - grade v) exquo grdt) :: Z
                v := v*t^asN(j)
                trLoop v
                -- cc: Record(quotient: C, remainder: C)
                cc := divide(qetaCoefficient(u, n), leadingCoefficient v)
                u := u - (cc.quotient)*v
        trReturn u
        return u

    tracedReduce(trEnter: (F, AB) -> Void,_
                 trLoop: F -> Void,_
                 trReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        u := tracedTopReduce(trEnter, trLoop, trReturn)(u, ab)
        tracedTailReduce(trEnter, trLoop, trReturn)(u, ab)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaTopReduction: Restricted top-reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETATRED QEtaTopReduction
++ QEtaTopReduction implements the restricted reduction as described in
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ Here reduce is the same as top-reduce.
QEtaTopReduction(C, F, AB): QEtaReductionCategory(C, F, AB) == Impl where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F)
  Impl ==> QEtaReduction(C, F, AB) add
    tracedReduce(trEnter: (F, AB) -> Void,_
                 trLoop: F -> Void,_
                 trReturn: F -> Void): (F, AB) -> F ==
        tracedTopReduce(trEnter, trLoop, trReturn)

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaExtendedReduction: Restricted reduction for
  extended elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETAXRED QEtaExtendedReduction
++ QEtaExtendedReduction implements the restricted reduction as
++ described in "Dancing Samba with Ramanujan Partition Congruences"
++ (Journal of Symbolic Computation). doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ It differs from QEtaReduction in that the reduction is first
++ performed on an element of L and only if non-zero repeated also on
++ the extended part.
QEtaExtendedReduction(C, L, F, AB): Exports == Implementation where
  C: EuclideanDomain
  L: QEtaGradedAlgebra C
  F: QEtaGradedAlgebra C with (first: % -> L)
  AB: QEtaAlgebraBasisCategory(C, F)
  XAB ==> QEtaExtendedAlgebraBasis(C, L, F, AB)
  Exports ==> QEtaReductionCategory(C, F, AB)
  Implementation ==> add
    tracedReduce(trEnter: (F, AB) -> Void,_
                 trLoop: F -> Void,_
                 trReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        --assert(grade(t)>0)
        --assert(one? leadingCoefficient t)
        --assert grade(b)>0 for all b in basis
        --assert(not zero? positiveRemainder(grade(b), grade t)
        --       for all b in basis)
        trEnter(u, ab)
        ul: L := reduce(first u, ab :: XAB)$QEtaReduction(C, L, XAB)
        zero? ul =>
            trReturn(0$F)
            return 0$F
        tReduce ==> tracedReduce $ QEtaReduction(C, F, AB)
        return tReduce(noTraceEnter, trLoop, trReturn)(u, ab)

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaExtendedTopReduction: Restricted top reduction
  for extended elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QXTOPRED QEtaExtendedTopReduction
++ QEtaExtendedTopReduction implements the restricted top-reduction as
++ described in "Dancing Samba with Ramanujan Partition Congruences"
++ (Journal of Symbolic Computation). doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ It differs from QEtaReduction in that the reduction is first
++ performed on an element of L and only if non-zero repeated also on
++ the extended part.
QEtaExtendedTopReduction(C, L, F, AB): Exports == Implementation where
  C: EuclideanDomain
  L: QEtaGradedAlgebra C
  F: QEtaGradedAlgebra C with (first: % -> L)
  AB: QEtaAlgebraBasisCategory(C, F)
  XAB ==> QEtaExtendedAlgebraBasis(C, L, F, AB)
  Exports ==> QEtaReductionCategory(C, F, AB)
  Implementation ==> add
    tracedReduce(trEnter: (F, AB) -> Void,_
                 trLoop: F -> Void,_
                 trReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        --assert(grade(t)>0)
        --assert(one? leadingCoefficient t)
        --assert grade(b)>0 for all b in basis
        --assert(not zero? positiveRemainder(grade(b), grade t)
        --       for all b in basis)
        trEnter(u, ab)
        ul: L := reduce(first u, ab :: XAB)$QEtaTopReduction(C, L, XAB)
        zero? ul =>
            trReturn(0$F)
            return 0$F
        tReduce ==> tracedReduce $ QEtaTopReduction(C, F, AB)
        return tReduce(noTraceEnter, trLoop, trReturn)(u, ab)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaSambaPackage: \underline{S}ub\underline{A}lgebra%
         \underline{M}odule\underline{B}asis%
         \underline{A}lgorithm}

See \cite{Hemmecke:DancingSambaRamanujan:2018} for the specification
of \algoSamba{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif
)abbrev package QSAMBA QEtaSambaPackage
++ QEtaSambaPackage implements the algorithm Samba from an
++ article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaSambaPackage(C, F, AB, Y): Exports == Implementation where
  H ==> XHashTable(Z, List F)
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F) with
      basisElements: % -> H
  Y: QEtaComputationCategory(F, AB)
  Exports ==> with
    samba: (F, List F) -> AB
      ++ samba(t, m) returns a list z such that
      ++ C[t, m] and the C[t]-module generated by 1 and z are equal as sets.
      ++ Assume that qetaGrade(t)>0.
    samba: (F, List F, Z) -> AB
      ++ samnba(t, m, g) returns a list z such that
      ++ C[t, m] and the C[t]-module generated by 1 and z are equal as sets.
      ++ Assume that qetaGrade(t)>0.
      ++ The computation is aborted if
      ++ numberOfGaps(qetaGrade t, [qetaGrade b for b in basis])
      ++ is smaller or equal to g. Here basis stands for an intermediate
      ++ basis that is order-complete, i.e., for each k in 1..qetaGrade(t)-1
      ++ it contain an element b with
      ++ k = positiveRemainder(qetaGrade b, qetaGrade t).
      ++ In case C is not a field, a basis only counts as
      ++ order-complete if among the b belonging to the same k the one
      ++ with the highest grade has a unit as leading coefficient.
      ++ WARNING!
      ++ If C is not a field it cannot be guaranteed that the
      ++ resulting basis is the same as if computing without the genus
      ++ = number of gaps criterion. One of the untreated elements
      ++ might lead to a basis element of smaller grade that does not
      ++ influence the number of gaps, but the property whether or not
      ++ an element reduces to zero modulo the resulting basis.
    samba: (F, List F, Z, Y -> Y) -> AB
      ++ samba(t, m, g, oneStep!) repeats oneStep! as long as
      ++ there are critical elements in the internal "computation"
      ++ data structure. It returns earlier if the number of gaps in
      ++ the basis is equal to g.

  Implementation ==> add
    smallerGrade?(x: F, y: F): Boolean == qetaGrade x < qetaGrade y
    samba(t: F, m: List F): AB ==
        --assert(not empty? m)
        --assert(qetaGrade t > 0)
        y: Y := initialize cons(t, m)
        while criticalElements? y repeat y := oneStep! y
        return algebraBasis y

    continue?(grdt: Z, g: Z, v: Vector Z, y: Y): Boolean ==
        ab: AB := algebraBasis y
        basis: H := basisElements ab
        for bas in entries basis | unit? qetaLeadingCoefficient last bas repeat
            -- bas can contain several element. We know that list
            -- is complete if the leading coefficient of the last
            -- element is a unit. Only then we count the grade of
            -- the first element of bas.
            grdb := qetaGrade first bas
            k: Z := positiveRemainder(grdb, grdt)
            if grdb < v.k then v.k := grdb
        numOfGaps: Z := 0
        for j in 1..grdt-1 repeat numOfGaps := numOfGaps + floor(v.j /$Q grdt)
        tracePrint("numOfGaps", numOfGaps)
        numOfGaps <= g => false
        criticalElements? y

    samba(t: F, m: List F, g: Z, oneStep!: Y -> Y): AB ==
        --assert(not empty? m)
        --assert(qetaGrade t > 0)
        grdt: Z := qetaGrade t
        l: List Z := [qetaGrade x for x in m]
        tooBig := 1 + g + reduce(_+, l, 0)
        -- make initial entries too big
        v: Vector Z := new(asN(grdt-1), grdt * tooBig)
        y: Y := initialize cons(t, m)
        while continue?(grdt, g, v, y) repeat y := oneStep! y
        return algebraBasis y

    samba(t: F, m: List F, g: Z): AB == samba(t, m, g, oneStep!)

)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain QEtaComputation: Computation using pairs as
  critical elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We recompute the set of critical elements after each extension of the
basis.

Basis elements that become reducible are put into a separate list of
critical elements that will not be discarded after each extension.
)endif

)abbrev domain QETAC QEtaComputation
++ QEtaComputation implements a variant of the algorithm Samba
++ from an article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ In this variant, the critical elements are the basis elements that
++ became reducible and products of basis elements. Products are kept as
++ pairs and will only be evaluated when the critical element is considered.

++ The pairs are only computed (and considered as critical elements)
++ when there are no reducible basis elements left to consider.
QEtaComputation(C, F, AB, R): Exports == Implementation where
  H ==> XHashTable(Z, List F)
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F) with
      initialize: F -> %
      basisElements: % -> H
  R: QEtaReductionCategory(C, F, AB)
  FF ==> Record(f1: F, f2: F)
  Products ==> XHashTable(Z, List FF)
  Exports ==> QEtaComputationCategory(F, AB) with
    basis: % -> List F
      ++ basis x returns basis(algebraBasis x).
    addPair!: (F, F, Products) -> Products
      ++ addPair!(f1, f2, p) adds the pair (f1,f2) to the list
      ++ corresponding to p.qetaGrade(f1*f2).
    addBasisElementPairs!: (F, List F, %) -> Void
      ++ addBasisElementPairs!(u, basis, x) adds all pairs (u, b) for
      ++ each element in the given list.
    addGapPair!: (F, F, F, Products) -> Products
      ++ addGapPair!(t, f1, f2, p) adds the pair (t^j, f1) to p
      ++ where the j>0 is chosen in such a way that
      ++ qetaGrade(t^j*f1) = qetaGrade(f2).
      ++ It is assumed that the input is such that j is an integer.
      ++ If j=0 then nothing is added.
    addGapPairs!: % -> Void
      ++ addGapPairs!(x) adds gap-pair for every pair in the current
      ++ basis that differ in qetaGrade by a multiple of qetaGrade(t)
      ++ where t = multiplier(algebraBasis x).
    computePairs!: % -> Void
      ++ computePairs!(x) discards all previously computed pairs and
      ++ then computes all the n*(n+1)/2 (commutative) pairs of the
      ++ current elements of the basis and additionally adds all the
      ++ gap-pairs where n is the number of basis elements.
    update!: (F, %) -> %
      ++ update!(u, x) adds a new basis element and updates the
      ++ critical elements accordingly. Note that older basis elements
      ++ might become critical elements in this process.

    oneVerboseStep!: (N, N, N, N) -> (% -> %)
      ++ oneVerboseStep!(ny, n0, nl, nr) is equivalent with
      ++ oneTracedStep!(trace ny, traceEnter(n0)$R, traceLoop(nl)$R, traceReturn(nr)$R).

  Implementation ==> add
    Rep ==> Record(ab: AB, cbe: List F, pairs: Products)
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    xx ==> rep x
    import from Rep
    coerce(x: %): OF == xx::OF
    smallerGrade?(x: F, y: F): Boolean == grade x < grade y

    algebraBasis(x: %): AB == xx.ab
    basis(x: %): List F == basis algebraBasis x

    -- Add the pair (f1, f2) to products.
    addPair!(f1: F, f2: F, products: Products): Products ==
        g := grade f1 + grade f2
        products.g := cons([f1, f2], elt(products, g, empty()))
        products

    -- Add pairs for a new basis element u that has just been
    -- added to the basis and has not made any other basis element
    -- become reducible by u.
    addBasisElementPairs!(u: F, basis: List F, x: %): Void ==
        grdu := grade u
        products: Products := xx.pairs
        for b in basis repeat addPair!(u, b, products)

    addGapPair!(t: F, b1: F, b2: F, products: Products): Products ==
        --assert(((grade b2 - grade b1) exquo grade t) case Z)
        g := grade b2
        j: Z := ((g - grade b1) exquo grade t) :: Z
        zero? j => products -- b2 anyway enters into cbe!!!
        tj: F := t^asN(j)
        products.g := cons([tj, b1], elt(products, g, empty()))
        products

    addGapPairs!(x: %): Void ==
        t: F := multiplier xx.ab
        products: Products := xx.pairs
        -- Additionally, we have to add products of the form t^j*b
        -- where qetaGrade(b)+j*d=qetaGrade(b') and b, b' are in the
        -- current list of basis elements of algebraBasis(x),
        -- b different from b' and j>0 is minimal with that property.
        -- That corresponds to the set S (line 13) in the algorithm samba
        -- as presented in \cite{doi:10.1016/j.jsc.2017.02.001}
        for bs in entries basisElements xx.ab repeat
            -- bs = all basis elements of same grade g (mod d)
            -- bs is non-empty and sorted by greaterGrade?
            b1 := first bs
            bas := rest bs
            while not empty? bas repeat
                b2 := first bas
                addGapPair!(t, b1, b2, products)
                bas := rest bas
                b1 := b2

    computePairs!(x: %): Void ==
        --assert(not empty?(xx.be)) -- so there is at least one product
        bas: List F := basis x
        xx.pairs := table()$Products
        while not empty? bas repeat
            addBasisElementPairs!(first bas, bas, x)
            bas := rest bas
        addGapPairs! x

    -- Destructively updates basis and critical elements
    update!(u: F, x: %): % ==
        t: F := multiplier xx.ab
        grdt: Z := grade t
        grdu: Z := grade u
        --assert(grade u > 0)
        --assert(grdt > 0)
        --assert(not zero?(positiveRemainder(grade u, grdt)
        --assert(not topReducible?(u, b) for all b in basis)
        -- update basis
        -- Since u is not top-reducible by any basis element, we can add
        -- u to the basis. We move elements that become top-reducible by u
        -- from the basis into the critical elements.
        i: Z := positiveRemainder(grdu, grdt) -- This is not zero!
        basis: H := basisElements(xx.ab)
        bas: List F := basis(xx.ab, i)
        red: List F := empty()
        irr: List F := empty()

        -- Assune that bas is sorted by greaterGrade?.
        while not empty? bas and greaterGrade?(u, first bas) repeat
            irr := cons(first bas, irr)
            bas := rest bas
        -- Now we know qetaGrade u <= qetaGrade first bas. We can add
        -- a gap-pair of the form (t^j, u) where grade(t^j*u)=grade(b).
        products: Products := xx.pairs
        if not empty? irr then addGapPair!(t, first irr, u, products)
        -- We include the new element here ...
        irr := cons(u, irr)
        -- ... and separate the remaining elements according to
        -- whether or not they are reducible.
        -- We add another gap-pair if bas is still not empty.
        -- We assume that all elements of bas will go to irr.
        -- If that is not the case the pairs will be recomputed anyway.
        if not empty? bas then addGapPair!(t, u, first bas, products)
        for b in bas repeat
            if topReducible?(b, u)$R then
                -- add b to criticalElements
                red := cons(b, red)
            else
                irr := cons(b, irr)
        basis.i := reverse! irr
        -- We don't need to redo reduction of pairs if no basis element
        -- has been removed.
        if empty? red then
            addBasisElementPairs!(u, basis x, x)
        else
            xx.cbe := sort(smallerGrade?, concat(red, xx.cbe))
            computePairs! x
        return x

    initialize(m: List F): % ==
        --assert(not empty? m)
        t: F := first m
        --assert(qetaGrade t > 0)
        per [initialize(t)$AB, sort(smallerGrade?, rest m), empty()]

    criticalElements?(x: %): Boolean ==
        not empty?(xx.cbe) or not empty?(xx.pairs)

    extractNext!(x: %): F ==
        p: Products := xx.pairs
        grdc: Z := -1
        grdp: Z := -1
        g := -1 -- dummy value
        if not empty? xx.cbe then grdc := grade first(xx.cbe)
        if not empty? p then
            g: Z := reduce(min, indices p)$List(Z) -- minimal grade
            r: FF := first(p.g) -- the element of this grade
            grdp := grade(r.f1) + grade(r.f2)
        grdp < 0 or (grdc >=0 and grdc <= grdp) =>
            f := first xx.cbe
            xx.cbe := rest xx.cbe
            f
        --assert(not empty? indices p)
        r: FF := first(p.g) -- the element of this grade
        l: List FF := rest(p.g) -- remove u
        if empty? l then remove!(g, p) else p.g := l
        r.f1 * r.f2

    oneTracedStepComputation!(tr: % -> Void, _
        trEnter: (F, AB) -> Void,_
        trLoop: F -> Void,_
        trReturn: F -> Void): (%, % -> F) -> % ==
      (x: %, next!: % -> F): % +->
        --assert(criticalElements? x)
        -- Selection process: Take the first element from cbe or
        -- products with smallest degree prefer cbe if equal degree.
        tr x
        f: F := next! x
        tReduce ==> tracedReduce $ R
        u := tReduce(trEnter, trLoop, trReturn)(f, algebraBasis x)
        if not zero? u then update!(u, x)
        return x

    trace(n: N): % -> Void == (x: %): Void +->
        zero? n => void() -- abort early
        tracePrint("==================================step(#cbe,#pairs)",_
            [#(xx.cbe), #(xx.pairs)]$List(Z))
        if n > 1 then tracePrint("+++ grades(cbe, pairs)",_
            [[qetaGrade b for b in xx.cbe], sort keys xx.pairs]$List(List Z))

    oneVerboseStep!(ny: N, n0: N, nl: N, nr: N): % -> % ==
        oneTracedStep!(trace ny, traceEnter(n0)$R,
                       traceLoop(nl)$R, traceReturn(nr)$R)



)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain QEtaComputationDelayedPairs: Computation with:
  delaying pairs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Critical elements are only the basis elements that become critical
(reducible by the new element). Only after all critical (basis)
elements have been considered, pairs are taken into account.

)endif


)abbrev domain QETACDP QEtaComputationDelayedPairs
++ QEtaComputationDelayedPairs implements a variant of the algorithm
++ Samba from an article of Ralf Hemmecke: "Dancing Samba with
++ Ramanujan Partition Congruences" (Journal of Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ In this variant, products of basis elements are computed if no
++ other critical elements are available.
QEtaComputationDelayedPairs(C, F, AB, R): Exports == Implementation where
  H ==> XHashTable(Z, List F)
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F) with
      initialize: F -> %
      basisElements: % -> H
  R: QEtaReductionCategory(C, F, AB)
  FF ==> Record(f1: F, f2: F)
  Products ==> XHashTable(Z, List FF)
  Exports ==> QEtaComputationCategory(F, AB) with
    oneVerboseStep!: (N, N, N, N) -> (% -> %)
      ++ oneVerboseStep!(ny, n0, nl, nr) is equivalent with
      ++ oneTracedStep!(trace ny, traceEnter(n0)$R, traceLoop(nl)$R, traceReturn(nr)$R).

  Implementation ==> QEtaComputation(C, F, AB, R) add
    Rep ==> QEtaComputation(C, F, AB, R)
    import from Rep
    Rec ==> Record(ab: AB, cbe: List F, pairs: Products)
    import from Rec
    criticalBasisElements x ==> (x pretend Rec).cbe
    products x ==> (x pretend Rec).pairs

    extractNext!(x: %): F ==
        not empty? criticalBasisElements x =>
            f := first criticalBasisElements x
            criticalBasisElements(x) := rest criticalBasisElements x
            f
        p: Products := products x
        grdc: Z := -1
        grdp: Z := -1
        g := -1 -- dummy value
        --assert(not empty? p)
        g: Z := reduce(min, indices p)$List(Z) -- minimal grade
        r: FF := first(p.g) -- the element of this grade
        l: List FF := rest(p.g) -- remove u
        if empty? l then remove!(g, p) else p.g := l
        r.f1 * r.f2


)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
