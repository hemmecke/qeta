-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2017, 2019  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{The Samba Algorithm}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
This code implements the \algoSamba{} algorithm from
\cite{Hemmecke:DancingSambaRamanujan:2018}.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on the article
\cite{Hemmecke:DancingSambaRamanujan:2018} by Ralf Hemmecke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

OF==>OutputForm
display77(x) ==> display((x::OF)::LinearOutputFormat, 77)
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))


rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Common category for the \algoSamba{} algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QETACAT QEtaComputationCategory
++ QEtaComputationCategory provides the functions necessary for the
++ internal functioning of basis elements and critical elements.
++ This category is an abstraction of the functionality to implement
++ variants of the samba algorithm from an article of Ralf Hemmecke
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaComputationCategory(C, F): Category == Exports where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  Exports ==> CoercibleTo OutputForm with
--    update!: (F, %) -> Void
--      ++ update!(u, x) adds u to the basis and updates the critical
--      ++ elements.
    initialize: (F, List F) -> %
      ++ initialize(t, basis) creates a new structure ready to be processed.
      ++ Assume that qetaGrade(t)>0.
    criticalElements?: % -> Boolean
      ++ criticalElements?(x) returns true if x represents a structure that
      ++ still contains critical elements.
    basisElements: % -> List F
      ++ basisElements(x) returns the basis elements that are stored
      ++ in the structure x.
    oneStepComputation!: % -> %
      ++ oneStepComputation!(x) computes one step of the computation.
      ++ It extracts a critical element and removes it from the list of
      ++ critical elements. Then it reduces it and updates the basis and
      ++ the critical elements if the reduction did not end with 0.
      ++ It should hold criticalElements?(x), otherwise the result is undefined.
    postProcess!: % -> %
      ++ postProcess!(x) postprocesses the result. It might interreduce
      ++ the basis or do other kinds of cleanup.

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category of restricted reduction packages}

According to \cite{Hemmecke:DancingSambaRamanujan:2018}, we use a
restricted reduction for the algorithm \algoSamba.

An element $x$ is not reducible by $b$ not only when its grade is
bigger than that of $b$, but also with the grades are equal and the
(Euclidean) size of the leading coefficient of $x$ is smaller than
that of $b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QREDCAT QEtaReductionCategory
++ QEtaReductionCategory implements the restricted reduction as
++ described in "Dancing Samba with Ramanujan Partition Congruences"
++ (Journal of Symbolic Computation). doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaReductionCategory(C, F): Category == Exports where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  H ==> XHashTable(Z, List F)
  Exports ==> with
    topReducible?: (F, F) -> Boolean
      ++ topReducible?(u, b) returns true iff there exists f in F such that
      ++ for v = u - f*b and lc = leadingCoefficient:
      ++ (grade u > grade v or
      ++ (grade u = grade v and euclideanSize lc u > euclideanSize lc v))
    reducer: (F, H, Z) -> Union(F, "failed")
      ++ reducer(u, basis, grdt) returns an element b from the basis
      ++ or b=1 such that grade u - grade b is divisible by grdt or
      ++ return "failed" if no such b exists.
      ++ This functions corresponds to the function
      ++ "select_{t,basis}(u)" as in Definition 2.6 of
      ++ \cite{Hemmecke:DancingSambaRamanujan:2018}. That reducer
      ++ yields the element with biggest possible grade is ensured by
      ++ the requirement that "basis" is appropriately sorted by
      ++ greaterGrade?.
    noTraceAtEnter: (F, F, H) -> Void
    noTraceInLoop: F -> Void
    noTraceAtReturn: F -> Void

    reduce: (F, F, H, (F, F, H) -> Void, F -> Void, F -> Void) -> F
      ++ reduce(u, t, h, traceEnter, traceLoop, traceReturn) behaves
      ++ identical to reduce(u, t, h) except that at enter and exit
      ++ time the functions traceEnter(u, t, basis) and traceExit(w)
      ++ are called where w is the value that will be returned. Inside
      ++ the internal while look the function traceLoop(v) is called
      ++ with v being the intermediately reduced u.
      ++ These hooks are provided to print a trace of the reduction.
    reduce: (F, F, List F) -> F
      ++ reduce(u, t, basis) returns an element v such that v is not reducible
      ++ modulo t and basis and "u reduces modulo t and basis to v".
      ++ We assume that qetaLeadingCoefficient(t)=1 and no element of the
      ++ basis has a qetaGrade that is divisible by the qetaGrade of t.
    reduce: (F, F, H) -> F
      ++ reduce(u, t, h) returns an element v such that v is not reducible
      ++ modulo t and basis and "u reduces modulo t and basis to v" where
      ++ basis is given by the lists of h. These element lists of h are
      ++ assumed to be sorted by greaterGrade?.
      ++ We assume that qetaLeadingCoefficient(t)=1 and no element of the
      ++ basis has a qetaGrade that is divisible by the qetaGrade of t.
    greaterGrade?: (F, F) -> Boolean
      ++ greaterGrade?(x, y) returns qetaGrade(x)>qetaGrade(y).
   add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    greaterGrade?(x: F, y: F): Boolean == grade x > grade y
    topReducible?(u: F, b: F): Boolean ==
        --assert(not zero? b)
        --assert(not zero? u)
        grdu: Z := grade u
        grdb: Z := grade b
        grdu < grdb => false
        lcu: C := leadingCoefficient u
        lcb: C := leadingCoefficient b
        euclideanSize lcu >= euclideanSize lcb

    reduce(u: F, t: F, bas: List F): F ==
        grdu: Z := grade u
        grdt: Z := grade t
        basis: H := table()
        for b in bas repeat -- fill the table
            i: Z := positiveRemainder(grade b, grdt) -- This is not zero!
            l: List F := elt(basis, i, empty())
            basis.i := sort(greaterGrade?, cons(b, l))
        reduce(u, t, basis)

    -- For tracing the computation, other functions (that print
    -- something) could be used.
    noTraceAtEnter(u: F, t: F, basis: H): Void == void()
    noTraceInLoop(u: F): Void == void()
    noTraceAtReturn(u: F): Void == void()

    reduce(u: F, t: F, basis: H): F ==
        reduce(u, t, basis, noTraceAtEnter, noTraceInLoop, noTraceAtReturn)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Restricted reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETARED QEtaReduction
++ QEtaReduction implements the restricted reduction as described in
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaReduction(C, F): QEtaReductionCategory(C, F) == Impl where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  H ==> XHashTable(Z, List F)
  Impl ==> add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    reducer(u: F, basis: H, grdt: Z): Union(F, "failed") ==
        zero? u => "failed"
        i: Z := positiveRemainder(grade u, grdt)
        -- if zero? i there is no corresponding element in basis, but
        -- we can use the element 1, i.e. we reduce u by a power of t.
        zero? i => return (1$F)::Union(F, "failed")
        candidates: List F := elt(basis, i, empty())
            -- candidates contains all basis elements b with
            -- positiveRemainder(grade b, grdt) = i in the same order
            -- as given in basis.
        for b in candidates repeat
            if topReducible?(u, b) then return b::Union(F, "failed")
        "failed"

    reduce(u: F, t: F, basis: H,_
           traceEnter: (F, F, H) -> Void,_
           traceLoop: F -> Void,_
           traceReturn: F -> Void): F ==
        --assert(grade(t)>0)
        --assert(one? leadingCoefficient t)
        --assert grade(b)>0 for all b in basis
        --assert(not zero? positiveRemainder(grade(b), grade t)
        --       for all b in basis)
        traceEnter(u, t, basis)
        grdt: Z := grade t
        while not ((r := reducer(u, basis, grdt)) case "failed") repeat
            traceLoop u
            grdu: Z := grade u
            v: F := r :: F
            j: Z := ((grdu - grade v) exquo grdt) :: Z
            v := v*t^(qcoerce(j)@N)
            -- cc: Record(quotient: C, remainder: C)
            cc := divide(leadingCoefficient u, leadingCoefficient v)
            u := u - (cc.quotient)*v
            uca := unitNormal leadingCoefficient u
            u := (uca.associate)*u
        uca := unitNormal leadingCoefficient u
        u := (uca.associate)*u
        traceReturn u
        return u

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Restricted reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETAXRED QEtaExtendedReduction
++ QEtaExtendedReduction implements the restricted reduction as
++ described in "Dancing Samba with Ramanujan Partition Congruences"
++ (Journal of Symbolic Computation). doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ It differs from QEtaReduction in that the reduction is first
++ performed on an element of L and only if non-zero repeated also on
++ the extended part.
QEtaExtendedReduction(C, L, F): QEtaReductionCategory(C, F) == Impl where
  C: EuclideanDomain
  L: QEtaGradedAlgebra C
  F: QEtaGradedAlgebra C with (first: % -> L)
  H ==> XHashTable(Z, List F)
  Impl ==> add
    topRed?(u, v) ==> topReducible?(u, v)$QEtaReduction(C, L)
    grade ==> qetaGrade
    leadingCoefficient ==> qetaLeadingCoefficient
    reducerL(u: L, basis: H, grdt: Z): Union(F, "failed") ==
        zero? u => "failed"
        i: Z := positiveRemainder(qetaGrade u, grdt)
        -- if zero? i there is no corresponding element in basis, but
        -- we can use the element 1, i.e. we reduce u by a power of t.
        zero? i => return (1$F)::Union(F, "failed")
        candidates: List F := elt(basis, i, empty())
            -- candidates contains all basis elements b with
            -- positiveRemainder(grade b, grdt) = i in the same order
            -- as given in basis.
        for b in candidates repeat
            if topRed?(u, first b) then return b::Union(F, "failed")
        "failed"

    -- First reduce in the first component and only if the result
    -- is nonzero, then redo the computation also with the attached
    -- part.
    reduce(u: F, t: F, basis: H): F ==
        --assert(grade(t)>0)
        --assert(one? leadingCoefficient t)
        --assert grade(b)>0 for all b in basis
        --assert(not zero? positiveRemainder(grade(b), grade t)
        --       for all b in basis)
        ul: L := first u
        tl: L := first t
        grdt: Z := qetaGrade tl
        while not ((r := reducerL(ul, basis, grdt)) case "failed") repeat
            grdu: Z := qetaGrade ul
            vl: L := first(r :: F)
            j: Z := ((grdu - qetaGrade vl) exquo grdt) :: Z
            vl := vl*tl^(qcoerce(j)@N)
            -- cc: Record(quotient: C, remainder: C)
            cc := divide(leadingCoefficient ul, leadingCoefficient vl)
            ul := ul - (cc.quotient)*vl
            uca := unitNormal leadingCoefficient ul
            ul := (uca.associate)*ul
        zero? ul => return 0$F
        return reduce(u, t, basis)$QEtaReduction(C, F)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\underline{S}ub\underline{A}lgebra%
         \underline{M}odule\underline{B}asis%
         \underline{A}lgorithm}

See \cite{Hemmecke:DancingSambaRamanujan:2018} for the specification
of \algoSamba{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif
)abbrev package QETAABAS QEtaAlgebraBasisPackage
++ QEtaAlgebraBasisPackage implements the algorithm Samba from an
++ article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaAlgebraBasisPackage(C, F, Y): Exports == Implementation where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  Y: QEtaComputationCategory(C, F)
  Exports ==> with
    algebraBasis: (F, List F) -> List F
      ++ algebraBasis(t, m) returns a list z such that
      ++ C[t, m] and the C[t]-module generated by 1 and z are equal as sets.
      ++ Assume that qetaGrade(t)>0.
    algebraBasis: (F, List F, Z) -> List F
      ++ algebraBasis(t, m, g) returns a list z such that
      ++ C[t, m] and the C[t]-module generated by 1 and z are equal as sets.
      ++ Assume that qetaGrade(t)>0.
      ++ The computation is aborted if
      ++ numberOfGaps(qetaGrade t, [qetaGrade b for b in basis])
      ++ is smaller or equal to g. Here basis stands for an intermediate
      ++ basis that is order-complete, i.e., for each k in 1..qetaGrade(t)-1
      ++ it contain an element b with
      ++ k = positiveRemainder(qetaGrade b, qetaGrade t).
      ++ If (in case C is not a field) there are several b with that
      ++ property, then the one with smallest qetaGrade is counted.
  Implementation ==> add
    import from QEtaReduction(C, F)
    smallerGrade?(x: F, y: F): Boolean == qetaGrade x < qetaGrade y
    algebraBasis(t: F, m: List F): List F ==
        --assert(not empty? m)
        --assert(qetaGrade t > 0)
        y: Y := initialize(t, m)
        while criticalElements? y repeat y := oneStepComputation! y
        return sort(smallerGrade?, basisElements y)

    continue?(grdt: Z, g: Z, v: Vector Z, y: Y): Boolean ==
        for b in basisElements y repeat
            grdb := qetaGrade b
            k: Z := positiveRemainder(grdb, grdt)
            if grdb < v.k then v.k := grdb
        numOfGaps: Z := 0
        for j in 1..grdt-1 repeat numOfGaps := numOfGaps + floor(v.j /$Q grdt)
        vPrint("numOfGaps", numOfGaps)
        numOfGaps <= g => false
        criticalElements? y

    algebraBasis(t: F, m: List F, g: Z): List F ==
        --assert(not empty? m)
        --assert(qetaGrade t > 0)
        grdt: Z := qetaGrade t
        l: List Z := [qetaGrade x for x in m]
        tooBig := 1 + g + reduce(_+, l, 0)
        -- make initial entries too big
        v: Vector Z := new(qcoerce(grdt-1)@N, grdt * tooBig)
        y: Y := initialize(t, m)
        while continue?(grdt, g, v, y) repeat y := oneStepComputation! y
        return sort(smallerGrade?, basisElements y)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algorithm \algoSamba: using pairs as critical elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We recompute the set of critical elements after each extension of the
basis.

Basis elements that become reducible are put into a separate list of
critical elements that will not be discarded after each extension.
)endif

)abbrev domain QETAC QEtaComputation
++ QEtaComputation implements a variant of the algorithm Samba
++ from an article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ In this variant, the critical elements are the basis elements that
++ became reducible and products of basis elements. Products are kept as
++ pairs and will only be evaluated when the critical element is considered.

++ The pairs are only computed (and considered as critical elements)
++ when there are no reducible basis elements left to consider.
QEtaComputation(C, F, R): Exports == Implementation where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  R: QEtaReductionCategory(C, F)
  Exports ==> Join(QEtaComputationCategory(C, F), CoercibleTo OutputForm)
  Implementation ==> add
    H ==> XHashTable(Z, List F)
    FF ==> Record(f1: F, f2: F)
    Products ==> XHashTable(Z, List FF)
    Rep ==> Record(mul: F, be: H, cbe: List F, pairs: Products)
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    xx ==> rep x
    import from Rep
    coerce(x: %): OF == xx::OF
    smallerGrade?(x: F, y: F): Boolean == grade x < grade y

    basisElements(x: %): List F == concat entries xx.be

    addPair!(f1: F, f2: F, products: Products): Products ==
        g := grade f1 + grade f2
        products.g := cons([f1, f2], elt(products, g, empty()))
        products

    -- Add pairs for a new basis element u that has just been
    -- added to the basis and has not made any other basis element
    -- become reducible by u.
    addBasisElementPairs!(u: F, basis: List F, x: %): Void ==
        grdu := grade u
        products: Products := xx.pairs
        for b in basis repeat addPair!(u, b, products)

    addNewBasisElementPairs!(u: F, x: %): Void ==
        addBasisElementPairs!(u, basisElements x, x)

    addGapPair!(t: F, b1: F, b2: F, products: Products): Products ==
        g := grade b2
        j: Z := ((g - grade b1) exquo grade t) :: Z
        zero? j => products -- b2 anyway enters into cbe!!!
        tj: F := t^(qcoerce(j)@N)
        products.g := cons([tj, b1], elt(products, g, empty()))
        products

    addGapPairs!(x: %): Void ==
        t: F := xx.mul
        products: Products := xx.pairs
        -- Additionally, we have to add products of the form t^j*b
        -- where qetaGrade(b)+j*d=qetaGrade(b') and b, b' in x.be
        -- b different from b' and j>0 is minimal with that property.
        -- That corresponds to the set S (line 13) in the algorithm samba
        -- as presented in \cite{doi:10.1016/j.jsc.2017.02.001}
        for bs in entries(xx.be) repeat
            -- bs = all basis elements of same grade g (mod d)
            -- bs is non-empty and sorted by greaterGrade?
            b1 := first bs
            bas := rest bs
            while not empty? bas repeat
                b2 := first bas
                addGapPair!(t, b1, b2, products)
                bas := rest bas
                b1 := b2

    computePairs!(x: %): Void ==
        --assert(not empty?(xx.be)) -- so there is at least one product
        basis: List F := basisElements x
        products: Products := table()
        while not empty? basis repeat
            addBasisElementPairs!(first basis, basis, x)
            basis := rest basis
        addGapPairs! x

    -- Destructively updates basis and critical elements
    update!(u: F, x: %): Void() ==
        t: F := xx.mul
        grdt: Z := grade t
        grdu: Z := grade u
        --assert(grade u > 0)
        --assert(grdt > 0)
        --assert(not zero?(positiveRemainder(grade u, grdt)
        --assert(not topReducible?(u, b) for all b in basis)
        -- update basis
        -- Since u is not top-reducible by any basis element, we can add
        -- u to the basis. We move elements that become top-reducible by u
        -- from the basis into the critical elements.
        i: Z := positiveRemainder(grdu, grdt) -- This is not zero!
        basis: H := xx.be
        bas: List F := elt(basis, i, empty())
        red: List F := empty()
        irr: List F := empty()

        -- Assune that bas is sorted by greaterGrade?.
        while not empty? bas and greaterGrade?(u, first bas) repeat
            irr := cons(first bas, irr)
            bas := rest bas
        -- Now we know qetaGrade u <= qetaGrade first bas. We can add
        -- a gap-pair of the form (t^j, u) where grade(t^j*u)=grade(b).
        products: Products := xx.pairs
        if not empty? irr then addGapPair!(t, first irr, u, products)
        -- We include the new element here ...
        irr := cons(u, irr)
        -- ... and separate the remaining elements according to
        -- whether or not they are reducible.
        -- We add another gap-pair if bas is still not empty.
        -- We assume that all elements of bas will go to irr.
        -- If that is not the case the pairs will be recomputed anyway.
        if not empty? bas then addGapPair!(t, u, first bas, products)
        for b in bas repeat
            if topReducible?(b, u)$R then
                -- add b to criticalElements
                red := cons(b, red)
            else
                irr := cons(b, irr)
        basis.i := reverse! irr
        -- We don't need to redo reduction of pairs if no basis element
        -- has been removed.
        if empty? red then
            addNewBasisElementPairs!(u, x)
        else
            xx.cbe := sort(smallerGrade?, concat(red, xx.cbe))
            computePairs! x
        return void()

    initialize(t: F, m: List F): % ==
        --assert(qetaGrade t > 0)
        per [t, table(), sort(smallerGrade?, m), empty()]

    criticalElements?(x: %): Boolean ==
        not empty?(xx.cbe) or not empty?(xx.pairs)

    selectNext!(x: %): F ==
        p: Products := xx.pairs
        grdc: Z := -1
        grdp: Z := -1
        g := -1 -- dummy value
        if not empty? xx.cbe then grdc := grade first(xx.cbe)
        if not empty? p then
            g: Z := reduce(min, indices p)$List(Z) -- minimal grade
            r: FF := first(p.g) -- the element of this grade
            grdp := grade(r.f1) + grade(r.f2)
        grdp < 0 or (grdc >=0 and grdc <= grdp) =>
            f := first xx.cbe
            xx.cbe := rest xx.cbe
            f
        --assert(not empty? indices p)
        r: FF := first(p.g) -- the element of this grade
        l: List FF := rest(p.g) -- remove u
        if empty? l then remove!(g, p) else p.g := l
        r.f1 * r.f2

    oneStepComputation!(x: %): % ==
        --assert(criticalElements? x)
        -- Selection process: Take the first element from cbe or
        -- products with smallest degree prefer cbe if equal degree.
        p: Products := xx.pairs
        f: F := selectNext! x
        if not zero?(u := reduce(f, xx.mul, xx.be)$R) then update!(u, x)
        return x

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
