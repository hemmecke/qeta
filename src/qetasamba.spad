-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2017, 2019  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{The Samba Algorithm}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
  This code implements the \algoSamba{} algorithm from
  \cite{Hemmecke:DancingSambaRamanujan:2018} in simple and extended
  form.
  Additionally, there is a variant that aborts the computation if the
  number of gaps is equal to the genus of the respective curve.
  Furthermore, since some computations take too long, computation can
  be done with trace output.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on the article
\cite{Hemmecke:DancingSambaRamanujan:2018} by Ralf Hemmecke.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

OF==>OutputForm
display77(x) ==> display((x::OF)::LinearOutputFormat, 77)
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))


rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
%$
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category for Data structure for \algoSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain QABC QEtaAlgebraBasisCategory
++ QEtaAlgebraBasisCategory(C, F) is a category for a data
++ structure that can be used for reduction modulo an algebra basis
++ (samba basis).
QEtaAlgebraBasisCategory(C, F): Category == Exports where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  Exports ==> CoercibleTo OutputForm with
    multiplier: % -> F
      ++ multiplier(x) returns multiplier element.
    basis: (%, Z) -> List F
      ++ basis(x, d) returns the basis elements of grade d.

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data structure for \algoSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain QETAAB QEtaAlgebraBasis
++ QEtaAlgebraBasis(C, F) is a domain holding the special
++ structure of a algebra basis with elements that can be used during
++ a reduction.
QEtaAlgebraBasis(C, F): Exports == Implementation where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  H ==> XHashTable(Z, List F)
  Exports ==> QEtaAlgebraBasisCategory(C, F) with
    initialize: F -> %
      ++ initialize(t) creates an empty basis that contains only
      ++ the multiplier t.
    basis: % -> List F
      ++ basis(x) returns all basis elements. It is equal to
      ++ concat(entries basisElements x).
    basisElements: % -> H
      ++ basisElements(x) returns the basis elements of all grades.
  Implementation ==> add
    Rep ==> Record(mul: F, be: H)
    xx ==> rep x
    import from Rep
    coerce(x: %): OutputForm == xx::OutputForm
    initialize(t: F): % == per [t, empty()]
    multiplier(x: %): F == xx.mul
    basisElements(x: %): H == xx.be
    basis(x: %): List F == concat entries xx.be
    basis(x: %, d: Z): List F == elt(xx.be, d, empty()$List(F))


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data structure for an extended \algoSamba}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif

)abbrev domain QETAXAB QEtaExtendedAlgebraBasis
++ QEtaExtendedAlgebraBasis(C, L, F, AB) is a domain holding the special
++ structure of a algebra basis with elements that can be used during
++ a reduction. This structure is useful to access basis elements
++ as if they were freom the domain L.
QEtaExtendedAlgebraBasis(C, L, F, AB): Exports == Implementation where
  C: EuclideanDomain
  L: QEtaGradedAlgebra C
  F: QEtaGradedAlgebra C with (first: % -> L)
  AB: QEtaAlgebraBasisCategory(C, F)
  Exports ==> QEtaAlgebraBasisCategory(C, L) with
    coerce: AB -> %
      ++ coerce(x) assumes that x is and algebra basis with extended
      ++ elements.
  Implementation ==> add
    Rep ==> AB
    xx ==> rep x
    coerce(x: %): OutputForm == xx::OutputForm
    coerce(ab: AB): % == per ab
    multiplier(x: %): L == first multiplier xx
    basis(x: %, d: Z): List L == [first f for f in basis(xx, d)]


)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Common category for the \algoSamba{} algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QETACC QEtaComputationCategory
++ QEtaComputationCategory(F, AB) provides the functions necessary for the
++ internal functioning of basis elements and critical elements.
++ This category is an abstraction of the functionality to implement
++ variants of the samba algorithm from an article of Ralf Hemmecke
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaComputationCategory(F, AB): Category == Exports where
  F: Type -- QEtaGradedAlgebra C
  AB: Type -- can be [QX]EtaAlgebraBasisCategory(C, F)
  Exports ==> CoercibleTo OutputForm with
    initialize: List F -> %
      ++ initialize(bas) creates a new structure ready to be processed.
      ++ Assume that the first element of bas has positive qetaGrade.
    criticalElements?: % -> Boolean
      ++ criticalElements?(x) returns true if x represents a structure that
      ++ still contains critical elements.
    algebraBasis: % -> AB
      ++ algebraBasis(x) returns the structure from x that holds the
      ++ algebra basis.
    oneStepComputation!: % -> %
      ++ oneStepComputation!(x) computes one step of the computation.
      ++ It extracts a critical element and removes it from the list
      ++ of critical elements. Then it reduces it and updates the
      ++ basis and the critical elements if the reduction did not end
      ++ with 0. It should hold criticalElements?(x), otherwise the
      ++ result is undefined.
    oneTracedStep!: (% -> Void, (F, AB) -> Void, F -> Void, F -> Void) _
                    -> (% -> %)
      ++ oneTracedStep!(x, trace, traceEnter, traceLoop, traceReturn)
      ++ behaves like oneStepComputation!(x) except that
      ++ trace(x) is called at the beginning of the function and
      ++ tracedReduce(traceEnter, traceLoop, traceReturn) is used
      ++ instead of the ordinary reduce function.
    postProcess!: % -> %
      ++ postProcess!(x) postprocesses the result. It might interreduce
      ++ the basis or do other kinds of cleanup.

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category of restricted reduction packages}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

According to \cite{Hemmecke:DancingSambaRamanujan:2018}, we use a
restricted reduction for the algorithm \algoSamba.

An element $x$ is not reducible by $b$ not only when its grade is
bigger than that of $b$, but also when the grades are equal and the
(Euclidean) size of the leading coefficient of $x$ is smaller than
that of $b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QREDCAT QEtaReductionCategory
++ QEtaReductionCategory lists the functions used in the restricted
++ reduction as described in "Dancing Samba with Ramanujan Partition
++ Congruences" (Journal of Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaReductionCategory(C, F, AB): Category == Exports where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F)
  H ==> XHashTable(Z, List F)
  Exports ==> with
    topReducible?: (F, F) -> Boolean
      ++ topReducible?(u, b) returns true iff there exists f in F such that
      ++ for v = u - f*b, lc = qetaLeadingCoefficient, and
      ++ grade = qetaGrade:
      ++ (grade u > grade v or
      ++ (grade u = grade v and euclideanSize lc u > euclideanSize lc v))
    reducer: (F, AB) -> Union(F, "failed")
      ++ reducer(u, basis, grdt) returns an element b from the basis
      ++ or b=1 such that grade u - grade b is divisible by grdt or
      ++ return "failed" if no such b exists.
      ++ This functions corresponds to the function
      ++ "select_{t,basis}(u)" as in Definition 2.6 of
      ++ \cite{Hemmecke:DancingSambaRamanujan:2018}. That reducer
      ++ yields the element with biggest possible grade is ensured by
      ++ the requirement that "basis" is appropriately sorted by
      ++ greaterGrade?.
    noTraceAtEnter: (F, AB) -> Void
      ++ A functions that does nothing.
    noTrace: F -> Void
      ++ A function that does nothing.
    tracedReduce: ((F, AB) -> Void, F -> Void, F -> Void) -> ((F, AB) -> F)
      ++ tracedReduce(traceEnter, traceLoop, traceReturn)(u, ab) behaves
      ++ identical to reduce(u, ab) except that at enter and exit
      ++ time the functions traceEnter(u, ab) and traceExit(w)
      ++ are called where w is the value that will be returned. Inside
      ++ the internal while loop the function traceLoop(v) is called
      ++ with v being the intermediately reduced u.
      ++ These hooks are provided to print a trace of the reduction.
    reduce: (F, AB) -> F
      ++ reduce(u, ab) returns an element v such that v is not
      ++ reducible modulo ab and "u reduces modulo t and basis to v"
      ++ where t = multiplier(ab) and basis is given by the lists of
      ++ basis(ab, d) for all grades. These element lists of ``ab``
      ++ are assumed to be sorted by greaterGrade?. We assume that
      ++ qetaLeadingCoefficient(t)=1 and no element of the basis has a
      ++ qetaGrade that is divisible by the qetaGrade of t.
    greaterGrade?: (F, F) -> Boolean
      ++ greaterGrade?(x, y) returns qetaGrade(x)>qetaGrade(y).
   add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    greaterGrade?(x: F, y: F): Boolean == grade x > grade y
    topReducible?(u: F, b: F): Boolean ==
        --assert(not zero? b)
        --assert(not zero? u)
        grdu: Z := grade u
        grdb: Z := grade b
        grdu < grdb => false
        lcu: C := leadingCoefficient u
        lcb: C := leadingCoefficient b
        euclideanSize lcu >= euclideanSize lcb

    -- For tracing the computation, other functions (that print
    -- something) could be used.
    noTraceAtEnter(u: F, ab: AB): Void == void()
    noTrace(u: F): Void == void()

    reduce(u: F, ab: AB): F ==
        tracedReduce(noTraceAtEnter, noTrace, noTrace)(u, ab)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Restricted reduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETARED QEtaReduction
++ QEtaReduction implements the restricted reduction as described in
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaReduction(C, F, AB): QEtaReductionCategory(C, F, AB) == Impl where
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F)
  Impl ==> add
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    reducer(u: F, ab: AB): Union(F, "failed") ==
        zero? u => "failed"
        grdt: Z := grade multiplier ab
        i: Z := positiveRemainder(grade u, grdt)
        -- if zero? i there is no corresponding element in basis, but
        -- we can use the element 1, i.e. we reduce u by a power of t.
        zero? i => return (1$F)::Union(F, "failed")
        candidates: List F := basis(ab, i)
            -- candidates contains all basis elements b with
            -- positiveRemainder(grade b, grdt) = i in the same order
            -- as given in basis.
        for b in candidates repeat
            if topReducible?(u, b) then return b::Union(F, "failed")
        "failed"

    tracedReduce(traceEnter: (F, AB) -> Void,_
                 traceLoop: F -> Void,_
                 traceReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        --assert(grade(t)>0)
        --assert(one? leadingCoefficient t)
        --assert grade(b)>0 for all b in basis
        --assert(not zero? positiveRemainder(grade(b), grade t)
        --       for all b in basis)
        traceEnter(u, ab)
        t: F := multiplier ab
        grdt: Z := grade t
        while not ((r := reducer(u, ab)) case "failed") repeat
            traceLoop u
            grdu: Z := grade u
            v: F := r :: F
            j: Z := ((grdu - grade v) exquo grdt) :: Z
            v := v*t^(qcoerce(j)@N)
            -- cc: Record(quotient: C, remainder: C)
            cc := divide(leadingCoefficient u, leadingCoefficient v)
            u := u - (cc.quotient)*v
            uca := unitNormal leadingCoefficient u
            u := (uca.associate)*u
        uca := unitNormal leadingCoefficient u
        u := (uca.associate)*u
        traceReturn u
        return u

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Restricted reduction for extended elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev package QETAXRED QEtaExtendedReduction
++ QEtaExtendedReduction implements the restricted reduction as
++ described in "Dancing Samba with Ramanujan Partition Congruences"
++ (Journal of Symbolic Computation). doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ It differs from QEtaReduction in that the reduction is first
++ performed on an element of L and only if non-zero repeated also on
++ the extended part.
QEtaExtendedReduction(C, L, F, AB): Exports == Implementation where
  C: EuclideanDomain
  L: QEtaGradedAlgebra C
  F: QEtaGradedAlgebra C with (first: % -> L)
  AB: QEtaAlgebraBasisCategory(C, F)
  XAB ==> QEtaExtendedAlgebraBasis(C, L, F, AB)
  Exports ==> QEtaReductionCategory(C, F, AB)
  Implementation ==> add
    tracedReduce(traceEnter: (F, AB) -> Void,_
                 traceLoop: F -> Void,_
                 traceReturn: F -> Void): (F, AB) -> F ==
      (u: F, ab: AB): F +->
        --assert(grade(t)>0)
        --assert(one? leadingCoefficient t)
        --assert grade(b)>0 for all b in basis
        --assert(not zero? positiveRemainder(grade(b), grade t)
        --       for all b in basis)
        ul: L := reduce(first u, ab :: XAB)$QEtaReduction(C, L, XAB)
        zero? ul =>
            traceReturn(0$F)
            return 0$F
        tReduce ==> tracedReduce $ QEtaReduction(C, F, AB)
        return tReduce(traceEnter, traceLoop, traceReturn)(u, ab)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\underline{S}ub\underline{A}lgebra%
         \underline{M}odule\underline{B}asis%
         \underline{A}lgorithm}

See \cite{Hemmecke:DancingSambaRamanujan:2018} for the specification
of \algoSamba{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif
)abbrev package QSAMBA QEtaSambaPackage
++ QEtaSambaPackage implements the algorithm Samba from an
++ article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
QEtaSambaPackage(C, F, AB, Y): Exports == Implementation where
  H ==> XHashTable(Z, List F)
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F) with
      basisElements: % -> H
  Y: QEtaComputationCategory(F, AB)
  Exports ==> with
    samba: (F, List F) -> AB
      ++ samba(t, m) returns a list z such that
      ++ C[t, m] and the C[t]-module generated by 1 and z are equal as sets.
      ++ Assume that qetaGrade(t)>0.
    samba: (F, List F, Z) -> AB
      ++ samnba(t, m, g) returns a list z such that
      ++ C[t, m] and the C[t]-module generated by 1 and z are equal as sets.
      ++ Assume that qetaGrade(t)>0.
      ++ The computation is aborted if
      ++ numberOfGaps(qetaGrade t, [qetaGrade b for b in basis])
      ++ is smaller or equal to g. Here basis stands for an intermediate
      ++ basis that is order-complete, i.e., for each k in 1..qetaGrade(t)-1
      ++ it contain an element b with
      ++ k = positiveRemainder(qetaGrade b, qetaGrade t).
      ++ In case C is not a field, a basis only counts as
      ++ order-complete if among the b belonging to the same k the one
      ++ with the highest grade has a unit as leading coefficient.
      ++ WARNING!
      ++ If C is not a field it cannot be guaranteed that the
      ++ resulting basis is the same as if computing without the genus
      ++ = number of gaps criterion. One of the untreated elements
      ++ might lead to a basis element of smaller grade that does not
      ++ influence the number of gaps, but the property whether or not
      ++ an element reduces to zero modulo the resulting basis.
    samba: (F, List F, Z, Y -> Y) -> AB
      ++ samba(t, m, g, oneStep!) repeats oneStep! as long as
      ++ there are critical elements in the internal "computation"
      ++ data structure. It returns earlier if the number of gaps in
      ++ the basis is equal to g.

  Implementation ==> add
    smallerGrade?(x: F, y: F): Boolean == qetaGrade x < qetaGrade y
    samba(t: F, m: List F): AB ==
        --assert(not empty? m)
        --assert(qetaGrade t > 0)
        y: Y := initialize cons(t, m)
        while criticalElements? y repeat y := oneStepComputation! y
        return algebraBasis y

    continue?(grdt: Z, g: Z, v: Vector Z, y: Y): Boolean ==
        ab: AB := algebraBasis y
        basis: H := basisElements ab
        for bas in entries basis | unit? qetaLeadingCoefficient last bas repeat
            -- bas can contain several element. We know that list
            -- is complete if the leading coefficient of the last
            -- element is a unit. Only then we count the grade of
            -- the first element of bas.
            grdb := qetaGrade first bas
            k: Z := positiveRemainder(grdb, grdt)
            if grdb < v.k then v.k := grdb
        numOfGaps: Z := 0
        for j in 1..grdt-1 repeat numOfGaps := numOfGaps + floor(v.j /$Q grdt)
        vPrint("numOfGaps", numOfGaps)
        numOfGaps <= g => false
        criticalElements? y

    samba(t: F, m: List F, g: Z, oneStep!: Y -> Y): AB ==
        --assert(not empty? m)
        --assert(qetaGrade t > 0)
        grdt: Z := qetaGrade t
        l: List Z := [qetaGrade x for x in m]
        tooBig := 1 + g + reduce(_+, l, 0)
        -- make initial entries too big
        v: Vector Z := new(qcoerce(grdt-1)@N, grdt * tooBig)
        y: Y := initialize cons(t, m)
        while continue?(grdt, g, v, y) repeat y := oneStep! y
        return algebraBasis y

    samba(t: F, m: List F, g: Z): AB ==
        samba(t, m, g, oneStepComputation!)

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algorithm \algoSamba: using pairs as critical elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We recompute the set of critical elements after each extension of the
basis.

Basis elements that become reducible are put into a separate list of
critical elements that will not be discarded after each extension.
)endif

)abbrev domain QETAC QEtaComputation
++ QEtaComputation implements a variant of the algorithm Samba
++ from an article of Ralf Hemmecke:
++ "Dancing Samba with Ramanujan Partition Congruences" (Journal of
++ Symbolic Computation).
++ doi:10.1016/j.jsc.2017.02.001
++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
++ In this variant, the critical elements are the basis elements that
++ became reducible and products of basis elements. Products are kept as
++ pairs and will only be evaluated when the critical element is considered.

++ The pairs are only computed (and considered as critical elements)
++ when there are no reducible basis elements left to consider.
QEtaComputation(C, F, AB, R): Exports == Implementation where
  H ==> XHashTable(Z, List F)
  C: EuclideanDomain
  F: QEtaGradedAlgebra C
  AB: QEtaAlgebraBasisCategory(C, F) with
      initialize: F -> %
      basisElements: % -> H
  R: QEtaReductionCategory(C, F, AB)
  Exports ==> Join(QEtaComputationCategory(F, AB), CoercibleTo OutputForm)
  Implementation ==> add
    FF ==> Record(f1: F, f2: F)
    Products ==> XHashTable(Z, List FF)
    Rep ==> Record(ab: AB, cbe: List F, pairs: Products)
    grade ==> qetaGrade$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    xx ==> rep x
    import from Rep
    coerce(x: %): OF == xx::OF
    smallerGrade?(x: F, y: F): Boolean == grade x < grade y

    algebraBasis(x: %): AB == xx.ab
    basisList(x: %): List F == concat entries basisElements xx.ab

    addPair!(f1: F, f2: F, products: Products): Products ==
        g := grade f1 + grade f2
        products.g := cons([f1, f2], elt(products, g, empty()))
        products

    -- Add pairs for a new basis element u that has just been
    -- added to the basis and has not made any other basis element
    -- become reducible by u.
    addBasisElementPairs!(u: F, basis: List F, x: %): Void ==
        grdu := grade u
        products: Products := xx.pairs
        for b in basis repeat addPair!(u, b, products)

    addNewBasisElementPairs!(u: F, x: %): Void ==
        addBasisElementPairs!(u, basisList x, x)

    addGapPair!(t: F, b1: F, b2: F, products: Products): Products ==
        g := grade b2
        j: Z := ((g - grade b1) exquo grade t) :: Z
        zero? j => products -- b2 anyway enters into cbe!!!
        tj: F := t^(qcoerce(j)@N)
        products.g := cons([tj, b1], elt(products, g, empty()))
        products

    addGapPairs!(x: %): Void ==
        t: F := multiplier xx.ab
        products: Products := xx.pairs
        -- Additionally, we have to add products of the form t^j*b
        -- where qetaGrade(b)+j*d=qetaGrade(b') and b, b' in x.be
        -- b different from b' and j>0 is minimal with that property.
        -- That corresponds to the set S (line 13) in the algorithm samba
        -- as presented in \cite{doi:10.1016/j.jsc.2017.02.001}
        for bs in entries basisElements xx.ab repeat
            -- bs = all basis elements of same grade g (mod d)
            -- bs is non-empty and sorted by greaterGrade?
            b1 := first bs
            bas := rest bs
            while not empty? bas repeat
                b2 := first bas
                addGapPair!(t, b1, b2, products)
                bas := rest bas
                b1 := b2

    computePairs!(x: %): Void ==
        --assert(not empty?(xx.be)) -- so there is at least one product
        bas: List F := basisList x
        xx.pairs := table()$Products
        while not empty? bas repeat
            addBasisElementPairs!(first bas, bas, x)
            bas := rest bas
        addGapPairs! x

    -- Destructively updates basis and critical elements
    update!(u: F, x: %): Void() ==
        t: F := multiplier xx.ab
        grdt: Z := grade t
        grdu: Z := grade u
        --assert(grade u > 0)
        --assert(grdt > 0)
        --assert(not zero?(positiveRemainder(grade u, grdt)
        --assert(not topReducible?(u, b) for all b in basis)
        -- update basis
        -- Since u is not top-reducible by any basis element, we can add
        -- u to the basis. We move elements that become top-reducible by u
        -- from the basis into the critical elements.
        i: Z := positiveRemainder(grdu, grdt) -- This is not zero!
        basis: H := basisElements(xx.ab)
        bas: List F := basis(xx.ab, i)
        red: List F := empty()
        irr: List F := empty()

        -- Assune that bas is sorted by greaterGrade?.
        while not empty? bas and greaterGrade?(u, first bas) repeat
            irr := cons(first bas, irr)
            bas := rest bas
        -- Now we know qetaGrade u <= qetaGrade first bas. We can add
        -- a gap-pair of the form (t^j, u) where grade(t^j*u)=grade(b).
        products: Products := xx.pairs
        if not empty? irr then addGapPair!(t, first irr, u, products)
        -- We include the new element here ...
        irr := cons(u, irr)
        -- ... and separate the remaining elements according to
        -- whether or not they are reducible.
        -- We add another gap-pair if bas is still not empty.
        -- We assume that all elements of bas will go to irr.
        -- If that is not the case the pairs will be recomputed anyway.
        if not empty? bas then addGapPair!(t, u, first bas, products)
        for b in bas repeat
            if topReducible?(b, u)$R then
                -- add b to criticalElements
                red := cons(b, red)
            else
                irr := cons(b, irr)
        basis.i := reverse! irr
        -- We don't need to redo reduction of pairs if no basis element
        -- has been removed.
        if empty? red then
            addNewBasisElementPairs!(u, x)
        else
            xx.cbe := sort(smallerGrade?, concat(red, xx.cbe))
            computePairs! x
        return void()

    initialize(m: List F): % ==
        --assert(not empty? m)
        t: F := first m
        --assert(qetaGrade t > 0)
        per [initialize(t)$AB, sort(smallerGrade?, rest m), empty()]

    criticalElements?(x: %): Boolean ==
        not empty?(xx.cbe) or not empty?(xx.pairs)

    selectNext!(x: %): F ==
        p: Products := xx.pairs
        grdc: Z := -1
        grdp: Z := -1
        g := -1 -- dummy value
        if not empty? xx.cbe then grdc := grade first(xx.cbe)
        if not empty? p then
            g: Z := reduce(min, indices p)$List(Z) -- minimal grade
            r: FF := first(p.g) -- the element of this grade
            grdp := grade(r.f1) + grade(r.f2)
        grdp < 0 or (grdc >=0 and grdc <= grdp) =>
            f := first xx.cbe
            xx.cbe := rest xx.cbe
            f
        --assert(not empty? indices p)
        r: FF := first(p.g) -- the element of this grade
        l: List FF := rest(p.g) -- remove u
        if empty? l then remove!(g, p) else p.g := l
        r.f1 * r.f2

    oneStepComputation!(x: %): % ==
        --assert(criticalElements? x)
        -- Selection process: Take the first element from cbe or
        -- products with smallest degree prefer cbe if equal degree.
        f: F := selectNext! x
        if not zero?(u := reduce(f, xx.ab)$R) then update!(u, x)
        return x

    oneTracedStep!(trace: % -> Void, _
                   traceEnter: (F, AB) -> Void,_
                   traceLoop: F -> Void,_
                   traceReturn: F -> Void): (% -> %) ==
      (x: %): % +->
        --assert(criticalElements? x)
        -- Selection process: Take the first element from cbe or
        -- products with smallest degree prefer cbe if equal degree.
        trace x
        f: F := selectNext! x
        tReduce ==> tracedReduce $ R
        u := tReduce(traceEnter, traceLoop, traceReturn)(f, xx.ab)
        if not zero? u then update!(u, x)
        return x


)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
