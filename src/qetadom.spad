-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2020  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Computing with (generalized) Dedekind Eta Functions as $q$-series}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
  We implement functionality to compute with Dedekind
  $\eta$-functions and generalized Dedekind $\eta$-functions.

  The code below deals with a expansions of $\eta$-quotients at
  infinity in terms of $q$-series. These (generalized)
  $\eta$-quotients generate an algebra over some ring $C$
  (\code{QEtaGradedAlgebra(C)}).

\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on the article \cite{Radu:RamanujanKolberg:2015} by
Silviu Radu.

It implements prerequisite domains for the computation of relations
among $\eta$-functions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

display77(x) ==> display((x::OF)::Formatter(Format1D))
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
LSym ==> List Symbol
OF ==> OutputForm

asN x ==> x pretend N
asP x ==> x pretend P
asZ x ==> x pretend Z

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Eta quotient expansions at infity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The domain \texttt{EtaQuotient} implements a representation for $\eta$
functions (in terms of $q$) and products and quotients of $\eta$
functions.

\begin{Hemmecke}
Since in general $\eta$ functions can be expressed as Laurent series in
$q^{\frac1{24}}$, they also can be added.
However, for efficiency reasons (and since it is enough for our purpose),
we express an $\eta$-quotient as a Laurent series in $q$ with a prefactor
that is a power of $q^{\frac1{24}}$, we only can add $\eta$-quotient
that have the same prefactor. So, we implement only a partial addition.
This partial addition is completely sufficient in our context, since we
know in advance that summands have the same prefactor.
\end{Hemmecke}
)endif

)abbrev domain ETAQUOT EtaQuotient
++ EtaQuotient implements the (multiplicative) group of eta-functions
++ in their expansion at infinity.
++ Elements can be represented as Laurent series in q with a prefactor
++ of q^(n/24), (n=0,...,23).
++ Note that this domain keeps the "fractional part" always separate from
++ the "series part" even when the fractional part is an integer.
EtaQuotient(C): Exports == Implementation where
  C: IntegralDomain
  L ==> QEtaLaurentSeries C
  Exports ==> Join(Group, CoercibleTo OutputForm) with
    -- Note that e = \prod_{k=1}^\infty (1-q^{kn}) has integer coefficients
    -- and that the inverse of this series has integer coefficients, as well.
    -- Therefore, it is not a lie that we assert "Group".
    eta: P -> %
      ++ eta(n) returns q^(n/24)*\prod_{k=1}^\infty (1-q^{kn}).
    q24: Z -> %
      ++ q24(n) returns q^(n/24).
    prefactor: % -> N
      ++ prefactor(x) returns the exponent times 24 of the fractional q
      ++ power of x where q is the variable of L. The returned value is
      ++ in the range 0..23, because integer powers of q are moved to the
      ++ series part.
    etaQuotient: (List Z, List Z) -> %
      ++ etaQuotient(divs, r) returns the $\eta$-quotient
      ++ product(eta(divs.i)^(r.i),i=1..#divs).
      ++ It is assumed that the lengths of the input lists are equal.
    etaQuotient: (P, List Z) -> %
      ++ etaQuotient(m, r) returns the $\eta$-quotient
      ++ product(eta(divs.i)^(r.i),i=1..#divs) where divs=divisors(m).
      ++ It returns etaQuotient(divisors m, r).
      ++ It is assumed that #r = #divisors(m).
    seriesPart: % -> L
      ++ seriesPart(x) returns the Laurent series part of x.
      ++ x = q24(prefactor x)*seriesPart(x)
    eulerExpansion: % -> L
      ++ eulerExpansion(x) returns the power series (with constant
      ++ coefficient 1 that results from just considering the product of
      ++ Euler function powers (q-Pochhammer symbols) connected to the
      ++ creation via etaQuotient(divs, r).
    eulerExpansion: (List Z, List Z) -> L
      ++ eulerExpansion(divs, r) returns the product over all elements
      ++ d of divs of eulerFunction(d)^{rd} where rd is the respective
      ++ entry of r corresponding to d and eulerFunction is defined in
      ++ QFunctions in the file qfunct.spad. See also
      ++ https://en.wikipedia.org/wiki/Euler_function .
      ++ eulerExpansion(divs, r) == eulerExpansion etaQuotient(divs, r).
    eulerExponent: % -> Q
      ++ If x is a (generalized) eta-quotient, then eulerExponent(x) is
      ++ the fractional exponent e of q such that q^e*eulerExpansion(x) is
      ++ equal to the Puiseux series expansion of x.
    eulerExpansion: (P, List Z) -> L
      ++ eulerExpansion(m, r) returns eulerExpansion(divisors m, r)
      ++ which is also the same as eulerExpansion(etaQuotient(m, r)).
    sigmaInfinity: % -> Z
      ++ If x = etaQuotient(divs, r) then sigmaInfinity(x) is equal to
      ++ reduce(_+, [d*rd for d in divs for rd in r], 0). Dividing
      ++ sigmaInfinity(x) by 24 gives the q-exponent that must be
      ++ multiplied to the eulerExpansion, to turn the whole object
      ++ into an eta-quotient.
    expansion: % -> L
      ++ expansion(x) aborts with error if eulerExponent(x) is not am
      ++ integer. Otherwise it returns q^r*seriesPart(x) where
      ++ r=prefactor(x)/24 and q is the variable of L. It is the same
      ++ as q^e*eulerExpansion(x) where e=eulerExponent(x).
    etaPower: (P, Z) -> %
      ++ etaPower(d, e) returns eta(d)^e.

    new: (Q, L) -> %
      ++ Only for internal use.

    -- This function (toEta) is for checking and actually does not
    -- necessarily yield an element of %.
    -- For example, E2 + E3 would mean to add Laurent series with different
    -- prefactors which is not supported by our "+" function and also not
    -- by the chosen representation of the domain. We expect the polynomial
    -- p to have the property that each monomial leads to Laurent series with
    -- the same prefactor.
    -- In this sense the function is only partial.
    -- However, we intend only to use it to check whether
    -- zero?(seriesPart toEta p).
    -- Furthermore, toEta(p) aborts with error if Laurent series with
    -- different prefactor are about to be added, since that cannot be
    -- represented in %.
    polynomialToEta: Polynomial C -> %
      ++ polynomialToEta(p) assumes that all variables are of the form
      ++ Ei with the letter E and a positive number i. In the
      ++ polynomial p the powers Ei^ni will be replaced by eta(i)^ni.
      ++ If l is the leading monomial p, then it is assumed that
      ++ prefactor(toEta(l))=prefactor(polynomialToEta(m)) for every
      ++ monomial m of p.
  Implementation ==> add
    -- The series part is always a power series with constant 1, in
    -- fact, it is a product/quotient of Euler functions. The
    -- eulerexpo must be divided by 24 to get the correct fractional
    -- exponent of q.
    Rep ==> Record(eulerexpo: Q, eulerquot: L)

    new(e: Q, s: L): % == per [e, s]
    eulerExponent(x: %): Q == rep(x).eulerexpo
    eulerExpansion(x: %): L == rep(x).eulerquot

    hashUpdate!(h: HashState, x: %): HashState ==
        hashUpdate!(hashUpdate!(h, eulerExponent x), eulerExpansion x)
    coerce(x: %): OutputForm ==
        q: OutputForm := (variable(0$L)$L)::OutputForm
        r: Q := eulerExponent x
        zero? r => (eulerExpansion x)::OutputForm
        e: OutputForm := r::OutputForm
        q^e * (eulerExpansion x)::OutputForm

    sigmaInfinity(x: %): Z == numer(24*eulerExponent(x))

    -- We maintain a cache of expansions of powers of the Euler function.
    ef: L := eulerFunction(1)$QFunctions(C, L)
    ef1: C := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower L := ef :: CachedPower(L)
    ps: L := partitionSeries(1)$QFunctions(C, L)
    ps1: C := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower L := ps :: CachedPower(L)

    -- eulerFunctionPower(u, rd) returns eulerFunction(u)^rd. Internally,
    -- it is, however implemented via CachedPower(L) using only
    -- expansions of eulerFunction(1) and partitionSeries(1).
    eulerFunctionPower(d: P, rd: Z): L ==
        zero? rd => 1$L
        rd < 0 => multiplyExponents(power!(psc, -rd)$CachedPower(L), d)
        multiplyExponents(power!(efc, rd)$CachedPower(L), d)

    prefactor(x: %): N ==
        e: Q := eulerExponent x
        n: Z := 24 * numer e -- for eta-quotients 24 is the biggest denominator
        asN(positiveRemainder(n, 24))
    seriesPart(x: %): L ==
        e: Q := eulerExponent x
        n: Z := numer e
        d: Z := denom e
        r: Z := positiveRemainder(n, d)
        q: Z := ((n-r) exquo d)::Z
        return monomial(1, q) * eulerExpansion(x)

    1: % == new(0, 1$L)
    expansion(x: %): L ==
        e: Q := eulerExponent x
        not one? denom e =>  error "eta-quotient has fractional expansion"
        return monomial(1, numer e) * eulerExpansion x

    eta(n: P): % == new(n/24, eulerFunctionPower(n, 1))
    etaPower(n: P, e: Z): % == new(n*e/24, eulerFunctionPower(n, e))
    q24(n: Z): % == new(n/24, 1$L)

    ((x: %) * (y: %)): % == new(eulerExponent x + eulerExponent y,
                                eulerExpansion x * eulerExpansion y)

    inv(x: %): % == new(- eulerExponent x, recip(eulerExpansion x)::L)
    etaQuotient(divs: List Z, r: List Z): % ==
        import from List %
        reduce(_*, [etaPower(d::P, e) for d in divs for e in r], 1)
    etaQuotient(level: P, r: List Z): % ==
        divs: List Z := divisors(level)$IntegerNumberTheoryFunctions
        etaQuotient(divs, r)

    eulerExpansion(divs: List Z, r: List Z): L ==
        eulerExpansion etaQuotient(divs, r)

    eulerExpansion(level: P, r: List Z): L ==
        eulerExpansion etaQuotient(level, r)

    -- The following functions are convenience functions and not really used.
    --:TODO: Move the functions below into a separate package.
    -- These functions should not be used otherwise. In fact,
    -- toEta: Polynomial(C) -> % should not be exported, but rather live
    -- in a separate package.

    -- Given a symbol of the form Ei, delete the letter E and parse i
    -- as a positive integer.
    idx(x: Symbol): P ==
        s: String := delete(string x, 1)
        asP(integer(parse(s)@InputForm)$InputForm)

    -- toEtaMonomial. polynomialToEta amd addition are only service
    -- functions and should actually live somewhere else, because they
    -- break the assumption that the series part is a Taylor series
    -- with constant coefficient 1.
    toEtaMonomial(m: Polynomial C): % ==
        --assert(not zero? m)
        --assert(zero? reductum m)
        syms: LSym := variables m
        l: List N := degree(m, syms)
        e: % := 1
        for s in syms for x in l repeat e := e*etaPower(idx s, x)
        new(prefactor(e)/24, leadingCoefficient(m) * seriesPart(e))
    ((x: %) + (y: %)): % == -- This is a partial function!!!
        prefactor x ~= prefactor y => error "Cannot add. Unequal prefactor."
        new(prefactor(x)/24, seriesPart x + seriesPart y)
    polynomialToEta(p: Polynomial C): % ==
        --assert(all variables are of the form En where n is some integer)
        zero? p => new(0, 0$L)
        -- To get the correct prefactor we cannot start with r:=0.
        r: % := toEtaMonomial leadingMonomial p
        while not zero?(p := reductum p) repeat
            r := r + toEtaMonomial leadingMonomial p
        return r




















)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generalized eta quotient expansions at infity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\delta$ be a positive natural number and $g$ be a residue class
(mod $\delta$).
%
We consider the generalized eta-quotient which is given by
\begin{gather}
  \label{eq:generalized-eta-quotient}
  \eta_{\delta,g}(\tau) = q^{\frac{\delta}{2}P_2(\frac{g}{\delta})}
  %
  \prod_{\substack{n>0\\n\equiv g\ (\mathrm{mod}\ \delta)}} (1-q^n)
  \prod_{\substack{n>0\\n\equiv -g\ (\mathrm{mod}\ \delta)}} (1-q^n)
\end{gather}
where $q = e^{2\pi i \tau}$ and
\begin{gather}
  P_2(t) = \{t\}^2 - \{t\} + \frac{1}{6}
\end{gather}
is the second Bernoulli function and $\{t\}$ denotes the fractional
part of $t$, see
\cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generalized eta quotient expansions at infity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The domain \texttt{GeneralizeEtaQuotient} implements a representation
for generalized $\eta$ functions (in terms of $q$) and products and
quotients of generalized $\eta$ functions.

)endif

)abbrev domain GETAQUOT GeneralizedEtaQuotient
++ GeneralizedEtaQuotient implements the (multiplicative) group of
++ generalized eta-functions in their expansion at infinity. Elements
++ can be represented as Laurent series in q with a prefactor of
++ q^e where e is a rational number.
++ This domain is a generalization of EtaQuotient(C, L)
GeneralizedEtaQuotient(C: IntegralDomain): Exports == Implementation where
  T ==> QEtaTaylorSeries C
  L ==> QEtaLaurentSeries C
  Exports ==> Join(Group, CoercibleTo OutputForm) with
    -- Note that a generalized eta-quotient has integer coefficients
    -- and that the inverse of this series has integer coefficients,
    -- as well. Therefore, it is not a lie that we assert "Group".
    generalizedEtaQuotient: (P, P, Z) -> %
      ++ generalizedEtaQuotient(delta,g,rdg) returns the generalized
      ++ eta-quotient given by \eqref{eq:generalized-eta-quotient} and
      ++ formula (1.11) in
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
      ++ raised to the power rdg.
      ++ Condition: 0 < g < \delta/2.
--      ++ Since $\eta_{\delta,0}(\tau)=\eta(\delta\tau)^2$ and
--      ++ $\eta_{\delta,\delta/2}(\tau) =
--      ++ \frac{\eta(\frac{\delta}{2}\tau)^2}{\eta(\delta\tau)^2}$ are
--      ++ squares, we define
--      ++ generalizedEtaQuotient(delta,0,e):=$\eta(\delta\tau)^e$ and
--      ++ generalizedEtaQuotient(delta,g,e):=
--      ++ $\frac{\eta(g\tau)^e}{\eta(2g\tau)^e}}$ if $g=\delta/2$.

    generalizedEtaQuotient: (P, P, Z) -> %
      ++ generalizedEtaQuotient(delta, g, rdg) returns the generalized
      ++ eta-quotient given by \eqref{eq:generalized-eta-quotient} and
      ++ formula (1.11) in
      ++ \cite{Chen+Du+Zhao:FindingModularFunctionsRamanujan:2019}
      ++ raised to the power rdg.

    generalizedEtaQuotient: (P, List P, List Z) -> %
      ++ generalizedEtaQuotient(delta, gs, rd) returns the product of
      ++ generalized eta-quotients for each g in gs and rdg in rd.

    generalizedEtaQuotient: (List P, List List P, List List Z) -> %
      ++ generalizedEtaQuotient(delta, gs, rd) returns the product of
      ++ generalized eta-quotients for each g in gs and rdg in rd.

    eulerExpansion: % -> L
      ++ eulerExpansion(x) returns the power series (with constant
      ++ coefficient 1 that results from just considering the product of
      ++ Euler function powers (q-Pochhammer symbols) connected to the
      ++ creation via etaQuotient(divs, r).
    eulerExponent: % -> Q
      ++ If x is a generalized eta-quotient, then eulerExponent(x) is
      ++ the fractional exponent e of q such that q^e*eulerExpansion(x) is
      ++ equal to the Puiseux series expansion of x.
    expansion: % -> L
      ++ expansion(x) aborts with error if eulerExponent(x) is not an
      ++ integer. Otherwise it returns q^e where e=eulerExponent(x)
      ++ and q is the variable of L.

  Implementation ==> EtaQuotient C add
    -- The series part is always a power series with constant 1, in
    -- fact, it is a product/quotient of (generalized) Euler
    -- functions.
    Rep ==> EtaQuotient C
    Rec ==> Record(eulerexpo: Q, eulerquot: L)

    -- We maintain a cache of expansions of powers of the generalized
    -- Euler functions. One cache for each delta and each 0<g<delta/2.
    gef: XHashTable(P, XHashTable(P, CachedPower T)) := empty()

    -- local function
    generalizedEulerFunction(d: P, g: P): L ==
        import from QFunctions(C, L)
        qPochhammer(1, g, d) * qPochhammer(1, d-g, d)
        -- $(q^g, q^d)_\infty (q^{(d-g)}, q^d)_\infty$

    -- eulerFunctionPower(u, rd) returns eulerFunction(u)^rd. Internally,
    -- it is, however implemented via CachedPower(L) using only
    -- expansions of eulerFunction(1) and partitionSeries(1).
    generalizedEulerFunctionPower(d: P, g: P, rd: Z): T ==
        zero? rd => 1$T
        2*g = d =>
            vPrint("d", d)
            vPrint("g", g)
            error "generalizedEtaQuotient: use etaQuotient([g,d],[2*rd,2*rd])"
        if 2*g > d then g := asP(d-g)
        -- First make sure that the initial entry gef.d.g exists.
        gefd := elt(gef, d, empty()$XHashTable(P, CachedPower T))
        if not key?(g, gefd) then
            t: T := qetaTaylorRep generalizedEulerFunction(d, g)
            gefd.g := t::CachedPower(T)
        cachedPower := gefd.g
        t: T := power!(cachedPower, abs rd)$CachedPower(T)
        if rd > 0 then t else recip(t)::T

    generalizedEtaQuotient(d: P, g: P, rd: Z): % ==
        zero? rd => 1
        t: T := generalizedEulerFunctionPower(d, g, rd)
        -- Since 0<g<delte, g/d is already the fractional part.
        q: Q := g/d
        e: Q := g^2/(2*d) - g/2 + d/12 --=d/2*((g/d)^2-g/d+1/6)
        per new(rd*e, laurent(0, t)$L)

    generalizedEtaQuotient(d: P, gs: List P, r: List Z): % ==
        --assert(#gs=#rgens)
        empty? gs => 1
        z: % := generalizedEtaQuotient(d, first gs, first r)
        for g in rest gs for rd in rest r repeat
            z := z * generalizedEtaQuotient(d, g, rd)
        z


)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
