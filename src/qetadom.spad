-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2019  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Computing with Dedekind Eta Functions as $q$-series}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
  We implement functionality to compute with Dedekind
  $\eta$-functions.

  The code below deals with a expansions of $\eta$-quotients at
  infinity in terms of $q$-series. These $\eta$-quotients generate an
  algebra over some ring $C$ (\code{QEtaGradedAlgebra(C)}).

  An auxiliary domain \code{Monomials} is introduced that adds
  variable names so that an element of a \code{DirectProduct} can be
  shown as a product of variables raised to some power.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on the article \cite{Radu:RamanujanKolberg:2015} by
Silviu Radu.

It implements prerequisite domains for the computation of relations
among $\eta$-functions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
LSym ==> List Symbol
OF ==> OutputForm

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Eta quotient expansions at infity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The domain \texttt{EtaQuotient} implements a representation for $\eta$
functions (in terms of $q$) and products and quotients of $\eta$
functions.

\begin{Hemmecke}
Since in general $\eta$ functions can be expressed as Laurent series in
$q^{\frac1{24}}$, they also can be added.
However, for efficiency reasons (and since it is enough for our purpose),
we express an $\eta$-quotient as a Laurent series in $q$ with a prefactor
that is a power of $q^{\frac1{24}}$, we only can add $\eta$-quotient
that have the same prefactor. So, we implement only a partial addition.
This partial addition is completely sufficient in our context, since we
know in advance that summands have the same prefactor.
\end{Hemmecke}
)endif

)abbrev domain ETAQUOT EtaQuotient
++ EtaQuotient implements the (multiplicative) group of eta-functions
++ in their expansion at infinity.
++ Elements can be represented as Laurent series in q with a prefactor
++ of q^(n/24), (n=0,...,23).
++ Note that this domain keeps the "fractional part" always separate from
++ the "series part" even when the fractional part is an integer.
EtaQuotient(C: IntegralDomain, L: QEtaLaurentSeriesCategory C): _
  Join(Group, CoercibleTo OutputForm) with
    -- Note that e = \prod_{k=1}^\infty (1-q^{kn}) has integer coefficients
    -- and that the inverse of this series has integer coefficients, as well.
    -- Therefore, it is not a lie that we assert "Group".
    eta: P -> %
      ++ eta(n) returns q^(n/24)*\prod_{k=1}^\infty (1-q^{kn}).
    q24: Z -> %
      ++ q24(n) returns q^(n/24).
    prefactor: % -> N
      ++ prefactor(x) returns the exponent times 24 of the fractional q
      ++ power of x where q is the variable of L. The returned value is
      ++ in the range 0..23, because integer powers of q are moved to the
      ++ series part.
    etaQuotient: (List Z, List Z) -> %
      ++ etaQuotient(divs, r) returns the $\eta$-quotient
      ++ product(eta(divs.i)^(r.i),i=1..#divs).
      ++ It is assumed that the lengths of the input lists are equal.
    etaQuotient: (P, List Z) -> %
      ++ etaQuotient(m, r) returns the $\eta$-quotient
      ++ product(eta(divs.i)^(r.i),i=1..#divs) where divs=divisors(m).
      ++ It returns etaQuotient(divisors m, r).
      ++ It is assumed that #r = #divisors(m).
    seriesPart: % -> L
      ++ seriesPart(x) returns the Laurent series part of x.
      ++ x = q24(prefactor x)*seriesPart(x)
    eulerExpansion: % -> L
      ++ eulerExpansion(x) returns the power series (with constant
      ++ coefficient 1 that results from just considering the product of
      ++ Euler function powers (q-Pochhammer symbols) connected to the
      ++ creation via etaQuotient(divs, r).
    eulerExpansion: (List Z, List Z) -> L
      ++ eulerExpansion(divs, r) returns the product over all elements
      ++ d of divs of eulerFunction(d)^{rd} where rd is the respective
      ++ entry of r corresponding to d and eulerFunction is defined in
      ++ QFunctions in the file qfunct.spad. See also
      ++ https://en.wikipedia.org/wiki/Euler_function .
      ++ eulerExpansion(divs, r) == eulerExpansion etaQuotient(divs, r).
    eulerExpansion: (P, List Z) -> L
      ++ eulerExpansion(m, r) returns eulerExpansion(divisors m, r)
      ++ which is also the same as eulerExpansion(etaQuotient(m, r)).
    eulerExponent: % -> Z
      ++ If x = etaQuotient(divs, r) then eulerExponent(x) is equal to
      ++ reduce(_+, [d*rd for d in divs for rd in r], 0). Dividing
      ++ eulerExponent(x) by 24 gives the q-exponent that must be
      ++ multiplied to the eulerExpansion, to turn the whole object
      ++ into an eta-quotient.
    expansion: % -> L
      ++ expansion(x) aborts with error if prefactor is not divisible
      ++ by 24. Otherwise it returns q^r*seriesPart(x) where
      ++ r=prefactor(x)/24 and q is the variable of L.
      ++ It is the same as q^e*eulerExponent(x) where e=eulerExponent(x)/24.
    etaPower: (P, Z) -> %
      ++ etaPower(d, e) returns eta(d)^e.

    -- This function (toEta) is for checking and actually does not
    -- necessarily yield an element of %.
    -- For example, E2 + E3 would mean to add Laurent series with different
    -- prefactors which is not supported by our "+" function and also not
    -- by the chosen representation of the domain. We expect the polynomial
    -- p to have the property that each monomial leads to Laurent series with
    -- the same prefactor.
    -- In this sense the function is only partial.
    -- However, we intend only to use it to check whether
    -- zero?(seriesPart toEta p).
    -- Furthermore, toEta(p) aborts with error if Laurent series with
    -- different prefactor are about to be added, since that cannot be
    -- represented in %.
    polynomialToEta: Polynomial C -> %
      ++ polynomialToEta(p) assumes that all variables are of the form
      ++ Ei with the letter E and a positive number i. In the
      ++ polynomial p the powers Ei^ni will be replaced by eta(i)^ni.
      ++ If l is the leading monomial p, then it is assumed that
      ++ prefactor(toEta(l))=prefactor(polynomialToEta(m)) for every
      ++ monomial m of p.
  == add
    -- The series part is always a power series with constant 1, in
    -- fact, it is a product/quotient of Euler functions. The
    -- eulerexpo must be divided by 24 to get the correct fractional
    -- exponent of q.
    Rep ==> Record(eulerexpo: Z, eulerquot: L)

    -- We maintain a cache of expansions of powers of the Euler function.
    ef: L := eulerFunction(1)$QFunctions(C, L)
    ef1: C := coefficient(ef, 1) -- avoid null pointer by expansion
    efc: CachedPower L := ef :: CachedPower(L)
    ps: L := partitionSeries(1)$QFunctions(C, L)
    ps1: C := coefficient(ps, 1) -- avoid null pointer by expansion
    psc: CachedPower L := ps :: CachedPower(L)

    -- eulerFunctionPower(u, rd) returns eulerFunction(u)^rd. Internally,
    -- it is, however implemented via CachedPower(L) using only
    -- expansions of eulerFunction(1) and partitionSeries(1).
    eulerFunctionPower(d: P, rd: Z): L ==
        zero? rd => 1$L
        rd < 0 => multiplyExponents(power!(psc, -rd)$CachedPower(L), d)
        multiplyExponents(power!(efc, rd)$CachedPower(L), d)

    new(n: Z, s: L): % == per [n, s]
    eulerExponent(x: %): Z == rep(x).eulerexpo
    eulerExpansion(x: %): L == rep(x).eulerquot

    prefactor(x: %): N == qcoerce(positiveRemainder(eulerExponent x, 24))@N
    seriesPart(x: %): L ==
        n: Z := eulerExponent x
        r: Z := positiveRemainder(n, 24)
        q: Z := ((n-r) exquo 24)::Z
        return monomial(1, q) * eulerExpansion(x)

    1: % == new(0, 1$L)
    expansion(x: %): L ==
        e: Z := prefactor x
        not zero? e => error "eta-quotient has fractional expansion"
        return seriesPart x
    eta(n: P): % == new(n, eulerFunctionPower(n, 1))
    etaPower(n: P, e: Z): % == new(n*e, eulerFunctionPower(n, e))
    q24(n: Z): % == new(n, 1$L)

    ((x: %) * (y: %)): % == new(eulerExponent x + eulerExponent y,
                                eulerExpansion x * eulerExpansion y)

    inv(x: %): % == new(- eulerExponent x, recip(eulerExpansion x)::L)
    etaQuotient(divs: List Z, r: List Z): % ==
        import from List %
        reduce(_*, [etaPower(d::P, e) for d in divs for e in r], 1)
    etaQuotient(level: P, r: List Z): % ==
        divs: List Z := divisors(level)$IntegerNumberTheoryFunctions
        etaQuotient(divs, r)

    eulerExpansion(divs: List Z, r: List Z): L ==
        eulerExpansion etaQuotient(divs, r)

    eulerExpansion(level: P, r: List Z): L ==
        eulerExpansion etaQuotient(level, r)

    hashUpdate!(h: HashState, x: %): HashState ==
        hashUpdate!(hashUpdate!(h, prefactor x), seriesPart x)
    coerce(x: %): OutputForm ==
        q: OutputForm := (variable(0$L)$L)::OutputForm
        r: Q := eulerExponent(x)/24
        zero? r => (eulerExpansion x)::OutputForm
        e: OutputForm := r::OutputForm
        q^e * (eulerExpansion x)::OutputForm

    -- The following functions are convenience functions and not really used.
    --:TODO: Move the functions below into a separate package.
    -- These functions should not be used otherwise. In fact,
    -- toEta: Polynomial(C) -> % should not be exported, but rather live
    -- in a separate package.

    -- Given a symbol of the form Ei, delete the letter E and parse i
    -- as a positive integer.
    idx(x: Symbol): P ==
        s: String := delete(string x, 1)
        qcoerce(integer(parse(s)@InputForm)$InputForm)@P

    -- toEtaMonomial. polynomialToEta amd addition are only service
    -- functions and should actually live somewhere else, because they
    -- break the assumption that the series part is a Taylor series
    -- with constant coefficient 1.
    toEtaMonomial(m: Polynomial C): % ==
        --assert(not zero? m)
        --assert(zero? reductum m)
        syms: LSym := variables m
        l: List N := degree(m, syms)
        e: % := 1
        for s in syms for x in l repeat e := e*etaPower(idx s, x)
        new(prefactor e, leadingCoefficient(m) * seriesPart(e))
    ((x: %) + (y: %)): % == -- This is a partial function!!!
        prefactor x ~= prefactor y => error "Cannot add. Unequal prefactor."
        new(prefactor x, seriesPart x + seriesPart y)
    polynomialToEta(p: Polynomial C): % ==
        --assert(all variables are of the form En where n is some integer)
        zero? p => new(0, 0$L)
        -- To get the correct prefactor we cannot start with r:=0.
        r: % := toEtaMonomial leadingMonomial p
        while not zero?(p := reductum p) repeat
            r := r + toEtaMonomial leadingMonomial p
        return r

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{An exponent domain that comes with variable names}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Turn various kinds of direct products into something that prints as
powerproducts with exponent vectors being the entries of the direct
product element.
)endif

)abbrev domain MONOMS Monomials
++ Monomials(dim, D, vl) behaves exactly like D, i.e. is an
++ AbelianMonoid, but prints its elements in a multiplicative form.
++ For example, if dim = 2, vl = [A,B] and x::Vector(NNI) = [2,3],
++ then the element x (coerced to OutputForm) looks like A^2*B^3.
Monomials(_
  dim: N,_
  R: OrderedAbelianMonoid,
  D: DirectProductCategory(dim, R),_
  vl: LSym_
 ): DirectProductCategory(dim, R) == D add
    --assert(dim = # vl)
    noOneTest? := not (R has one?: R -> Boolean)
    notOne? x ==> noOneTest? or not one? x
    coerce(x: %): OutputForm ==
        vs: LSym := vl
        zero? x => (1$Integer)::OutputForm
        fst: Boolean := true
        k: N := 1
        while zero?(x.k) repeat
            vs := rest vs
            k := k + 1
        --assert(k<=dim)
        o: OutputForm := (first vs)::OutputForm
        if notOne? x.k then o := o ^ ((x.k)::OutputForm)
        for i in k+1..dim for v in rest vs | not zero?(x.i) repeat
            oo: OutputForm := v::OutputForm
            if notOne? x.i then oo := oo ^ ((x.i)::OutputForm)
            o := o * oo
        return o


)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
