-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2017  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Radu's algorithms}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle
\begin{abstract}
The algorithms from \cite{Radu:RamanujanKolberg:2015},
are implemented in particular, the algorithms
MC (membership check),
MW (membership witness),
MB (module basis), and
AB (algebra basis).
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

N ==> NonNegativeInteger
Z ==> Integer
LSym ==> List Symbol

asN x ==> x pretend N

)abbrev package QETARADU QEtaRaduAlgorithms
++ QEtaRaduAlgorithms implements algorithms from an article of Siliu Radu.
++ "An Algorithmic Approach to Ramanujan-Kolberg Identities" (Journal of
++ Symbolic Computation).
++ http://www.risc.jku.at/publications/download/risc_5069/zzz3.pdf
++ doi:10.1016/j.jsc.2014.09.018
QEtaRaduAlgorithms(C: EuclideanDomain, F: QEtaGradedAlgebra C): with
    member?: (F, F, List F) -> Boolean
      ++ member?(u, t, z) returns true if u is a member of the module
      ++ generated by 1 and the elements of z over C[t].
      ++ z must be t-reduced.
    membershipWitness: (F, F, List F) -> Record(pol: Polynomial C, mult: C)
      ++ membershipWitness(u, t, z) is only defined for nonzero u and z
      ++ that are t-reduced. It returns [0, 0] if member?(u, t, z) is false.
      ++ Otherwise, it returns a polynomial p(T,Z1,...,Zn) in
      ++ T and Z1,...,Zn where n=#z together with a multiplier f
      ++ such that f*u = p(t,z), i.e., when the
      ++ variables in p are replaced by the respective, series.
    vectorSpaceTransformation: Vector F -> Matrix C
      ++ vectorSpaceTransformation(v) returns a matrix m such that
      ++ m*v gives a vector space basis for the vector space generated
      ++ by the entries of v. The returned matrix m will be such that
      ++ the grade of the entries in m*v decreases as the index increases.
    moduleBasis: List F -> List F
      ++ moduleBasis(m) returns a list z such that
      ++ m and z' generate the same C[t] module where t=z.1, z'
      ++ is z with z.1 replaced by 1. z' is t-reduced.
    algebraBasis: List F -> List F
      ++ algebraBasis(m) returns a list z such that with t=z.1 the
      ++ polynomial ring C[m] and the C[t]-module generated by 1 and rest(z)
      ++ are equal as sets.
      ++ The input m must be a non-empty list whose first entry has grade > 0.

    -- local functions
    mult: (Matrix C, Vector F) -> Vector F
    moduleBasisReduce!: Vector F -> N
    algebraBasisSaturate: List F -> List F
  == add
    grade ==> qetaGrade$F
    coefficient ==> qetaCoefficient$F
    leadingCoefficient ==> qetaLeadingCoefficient$F
    Pol ==> Polynomial C
    PolMult ==> Record(pol: Polynomial C, mult: C)
    H ==> XHashTable(Z, List F)
    member?(u: F, t: F, z: List F): Boolean ==
      --assert(not zero? u)
      --assert(grade(t)>0)
      --assert 0<grade(z.i)<grade(z(i+1)) for all i in 1..#z-1.
      --assert not zero? grade(z.i) for all i in 1..#z
      --assert not zero? positiveRemainder(grade(z.i), grade t) for all i.
      zero? u => error "Warning first argument is (considered to be) zero."
      z0: F := 1
      grdt: Z := grade t
      zh: XHashTable(Z, F) := table()
      -- add element 1 to the linear generators
      z := cons(z0, z)
      for w in z repeat zh.(positiveRemainder(grade w, grdt)) := w
      while not zero? u repeat
          grdu: Z := grade u
          i: Z := positiveRemainder(grdu, grdt)
          if not key?(i, zh) then return false
          zi: F := zh.i
          j: Z := grdu - grade zi
          -- note that in our case the grade(t) is positive
          if j < 0 then return false
          j := (j exquo grdt) :: Z
          v: F := zi*t^asN(j))
          l := lcmCoef(leadingCoefficient u, leadingCoefficient v)
          u := (l.coeff1)*u - (l.coeff2)*v
          uca := unitNormal leadingCoefficient u
          u := (uca.associate)*u
      return true

    membershipWitness(u: F, t: F, z: List F): PolMult ==
      --assert(not zero? u)
      --assert(grade(t)>0)
      --assert 0<grade(z.i)<grade(z(i+1)) for all i in 1..#z-1.
      --assert not zero? grade(z.i) for all i in 1..#z
      --assert not zero? positiveRemainder(grade(z.i), grade t) for all i.
      zero? u => error "Warning first argument is (considered to be) zero."
      import from QAuxiliaryTools
      zsyms: LSym := indexedSymbols("Z", #z)
      tsym: Symbol := "T"::Symbol

      z0: F := 1
      grdt: Z := grade t
      zh: XHashTable(Z, F) := table()
      ph: XHashTable(Z, Pol) := table()
      -- add element 1 to the linear generators
      z := cons(z0, z)
      for w in z repeat
          i: Z := positiveRemainder(grade w, grdt)
          zh.i := w
          ph.i := 0
      m: C := 1 -- prefactor
      while not zero? u repeat
          grdu: Z := grade u
          i: Z := positiveRemainder(grdu, grdt)
          if not key?(i, zh) then return [0, 0]
          zi: F := zh.i
          j: Z := grdu - grade zi
          -- note that in our case the grade(t) is positive
          if j < 0 then return [0, 0] -- no membership
          j := (j exquo grdt) :: Z
          v: F := zi*t^asN(j)
          l := lcmCoef(leadingCoefficient u, leadingCoefficient v)
          c1: C := l.coeff1
          c2: C := l.coeff2
          u := c1*u - c2*v
          -- We normalize the leading coefficient.
          uca := unitNormal leadingCoefficient u
          u := (uca.associate)*u
          c1 := (uca.associate)*c1
          c2 := (uca.associate)*c2
          m := c1*m
          -- We must lift the relations part to match with the new
          -- multiplier.
          if not one? c1 then
              for k in keys ph repeat ph.k := c1 * ph.k
          -- Now add the new monomial to the relations part.
          ph.i := ph.i + monomial(c2::Pol, tsym, asN j)$Pol

      -- put everything together
      p: Pol := ph.0 -- corresponds to z0
      for w in rest z for zi in zsyms repeat
          p := p + (ph.positiveRemainder(grade w, grdt)) * zi::Pol
      -- divide out common gcd
      g: C := gcd(gcd(coefficients p), m)
      m := (m exquo g)::C
      p := (p exquo g)::Pol
      -- normalize the multiplicator
      a := unitNormal(m).associate
      [a*p, a*m]

    vectorSpaceTransformation(v: Vector F): Matrix C ==
        n: N := #v
        m: Z := grade(v.1)
        for i in 2..n repeat m := max(m, grade(v.i))
        m := m + 1
        k: N := asN m
        --assert(n <= k), i.e we have got at most as many rows as columns.
        t: Matrix C := qnew(n, n+k)
        -- We attach an (n,n)-unit matrix to the (n, k)-matrix of
        -- coefficients.
        for i in 1..n repeat
            for j in 1..k repeat qsetelt!(t, i, j, coefficient(v.i, m-(j::Z)))
            for j in 1..n repeat qsetelt!(t, i, j+k, 0)
            qsetelt!(t, i, i+k, 1)
        u: Matrix C := rowEchelon t
        h: List Matrix C := horizSplit(u, [k,n]) -- return transformation matrix
        h.2

    -- local function for "moduleBasis"
    -- moduleBasisReduce(z) returns the index of the element that has
    -- been top-reduced or 0 if no element has been reduced.
    moduleBasisReduce!(z: Vector F): N ==
        --assert(grade(z.i) > grade(z.(i+1)) for i in 1..#z-1)
        n: N := #z
        --assert(n>0)
        t: F := z.n -- the element with minimal grade
        grdt: Z := grade t
        --assert(grdt > 0)
        lct: C := leadingCoefficient t
        for i in 1..n-1 repeat -- We just consider i<j.
            zi: F := z.i
            grdi: Z := grade zi
            lci: C := leadingCoefficient zi
            for j in i+1..n repeat
                zj := z.j
                k: Z := grdi - grade zj -- k > 0
                r: Z := positiveRemainder(k, grdt)
                if zero? r then
                    k := (k exquo grdt) :: Z -- k > 0
                    e: N := asN k
                    zz: F := zj*t^e
                    l := lcmCoef(lci, leadingCoefficient zz)
                    zi := (l.coeff1)*zi - (l.coeff2)*zz
                    a := unitNormal(leadingCoefficient zi).associate
                    z.i := a*zi
                    return i
        return 0

    -- local function for "moduleBasis"
    -- Compute matrix multiplication m*v and remove constants if possible.
    mult(m: Matrix C, v: Vector F): Vector F ==
        --assert(ncols(m) = #v)
        -- constant entries will be removed from the result
        k: N := nrows m
        u: Vector F := new(k, 0$F)
        n: N := #v
        ii: N := 0
        for i in 1..k repeat -- fill u only with non-constants
            f: F := qelt(m, i, 1) * qelt(v, 1)
            for j in 2..n repeat f := f + qelt(m, i, j) * qelt(v, j)
            if grade f > 0 then -- f is not constant
                ii := ii + 1
                qsetelt!(u, ii, f)
        if ii=k then return u
        -- remove trailing zeros (unused entries)
        w: Vector F := new(ii, 0$F)
        for i in 1..ii repeat w.i := u.i
        return w

    moduleBasis(v: List F): List F ==
        z: Vector F := vector v
        m: Matrix C := vectorSpaceTransformation z
        z := mult(m, z)
        --assert(grade(z.i) > grade(z.i+1) for i in 1..#z-1)
        while not zero? moduleBasisReduce! z repeat
            z := mult(vectorSpaceTransformation z, z) -- z might become shorter
        return reverse! members z
        -- Note that z.1 = t.

    -- local function for "algebraBasis"
    -- algebraBasisProducts(z) returns all products of elements of z.
    -- The resulting list is sorted by increasing grade.
    -- Note that all grades are positive.
    FF ==> Record(f1: F, f2: F)
    smallerFF(x: FF, y: FF): Boolean == -- helper function
        grade(x.f1)+grade(x.f2)<grade(y.f1)+grade(y.f2)
    algebraBasisProducts(z: List F): List FF ==
        --assert grade(z.i)>0 for all i in 1..#z
        result: List FF := empty()
        li: List F := z
        while not empty? li repeat
            zi: F := first li
            result := concat([[zi, zj]$FF for zj in li]$List(FF), result)
            li := rest li
        return sort(smallerFF, result)

    -- algebraBasisSaturate(z) returns the empty list if all products
    -- of elements of z' are members of the module generated by
    -- z' over Q[t] where t=first(z), z'=rest(z).
    -- Otherwise it returns a product of minimal degree appended at the
    -- end of z.
    algebraBasisSaturate(z: List F): List F ==
        --assert 0<grade(z.i)<grade(z(i+1)) for all i in 1..#z-1.
        --assert not zero? grade(z.i) for all i in 1..#z
        t: F := first z
        l: List F := rest z
        p: List FF := algebraBasisProducts l
        while not empty? p repeat
            ff: FF := first p
            u: F := ff.f1 * ff.f2
            if not member?(u, t, l) then return concat(z, u)
            p := rest p
        return empty()

    algebraBasis(m: List F): List F ==
        --assert(not empty? m)
        --assert(grade first m > 0)
        z: List F := moduleBasis m
        while not empty?(m := algebraBasisSaturate z) repeat
            z := moduleBasis reverse m -- reverse is not really necessary
        return z

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
