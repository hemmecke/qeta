-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> display(([x::Symbol::OF, y::OF]$List(OF)::OF)::LinearOutputFormat, 77)

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Eta Quotients}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
We compute a monoid basis for the set of $\eta$-quotients that are
modular functions and have a (multiple) pole, if any, at infinity
only.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indroduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $N$ be a positive natural number and define a $\Gamma_0(N)$ as a
subgroup of the special linear group $SL_2(\setZ)$ as follows.
\begin{gather*}
\Gamma_0(N) := \SetDef{  \begin{pmatrix}
    a & b\\
    c & d
  \end{pmatrix} \in SL_2(\setZ)}{N|c}
\end{gather*}
As in \cite{Radu:RamanujanKolberg:2015}, let $K(N)$ denote the set of
modular functions for $\Gamma_0(N)$ and $K^\infty(N)$ the set of
modular functions have a (multiple) pole, if any, at infinity only.
Furthermore, let $E(N)$ be the set of $\eta$-quotients that are
modular functions, and let $E^\infty(N) := E(N)\cap K^\infty(N)$.

This file contains code to compute a (finite) monoid basis for
$E^\infty(N)$ in two variants.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Representing square roots by roots of unity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
According to \cite[Section~IV.3]{Lang:AlgebraicNumberTheory:1986} we
have
\begin{gather*}
  \sum_{k=0}^{m-1} \unityPower{\frac{k^2}{m}}
  =
  \begin{cases}
    (1+i)\sqrt{m} & \text{if $m \equiv 0 \pmod{4}$},\\
    \sqrt{m}      & \text{if $m \equiv 1 \pmod{4}$},\\
    0             & \text{if $m \equiv 2 \pmod{4}$},\\
    i\sqrt{m}     & \text{if $m \equiv 3 \pmod{4}$},
  \end{cases}
\end{gather*}
where $\unityPower{x} := \exp(2\pi i x)$.
%
Note that
$2=\left(\unityPower{\frac{1}{8}}+\unityPower{-\frac{1}{8}}\right)^2$.

If $m\equiv 2 \pmod{4}$, then $m=2m'$ with $m'\not\equiv 2 \pmod{4}$.
Then, we can compute $\sqrt{m}$ by computing $\sqrt{m'}$ and
multiplying by
$\sqrt{2}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

First of all for debugging.
)endif
OF==>OutputForm
display77(x) ==> display((x::OF)::LinearOutputFormat, 77)
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, _
                                   ":="::Symbol::OF, y::OF]$List(OF)))

)if LiterateDoc
These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- will be a square matrix
Z24 ==> IntegerMod 24
EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)
Rec ==> Record(red: MZ, triang: MZ)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Auxiliary package to check modularity of $\eta$ quotients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we mainly deal with the sets $R^*(N)$ and $R^\infty(N)$ from
\cite{Hemmecke+Radu:EtaRelations:2018}.

The function \code{matrixLigozat} computes the respective matrix $A_N$
whereas \code{rStarConditions} checks which of the conditions for an
$r$ vector to correspond to a modular $\eta$-quotient is violated.

width of a cusp \cite[Lemma~2.37]{Radu:PhD:2010} and
\cite[Definition~2.9]{Radu:PhD:2010}


)endif

)abbrev package GAUSSR GaussRoot
GaussRoot(R: Ring): with
    squareRoot: (P, R) -> R
        ++ x is a radical integer (squarefree)
  == add
      -- gaussSumm corresponds to G(1, x) in
    -- \cite[Section~IV.3]{Lang:AlgebraicNumberTheory:1986}.
    gaussSum(a: Z, b: Z, g: R): R ==
        z: R := 1
        for k in 1 .. b-1 repeat z := z + g^(qcoerce(a*k^2)@P)
        return z

    squareRoot(x: P, g: R): R ==
        -- x>2 is a radical integer (squarefree)
        even? x => -- R is a cyclotomic field of order 4*x (for sqrt(2))
            n: Z := 4*x
            r: R := (gaussSum(1, n, g)*(1-g^x))
            dbgPrint("r", r)
            dbgPrint("r^2", r*r)
            return r
        -- otherwise we either positiveRemainder(x, 4) is either 1 or 3.
        positiveRemainder(x, 4)=1 => -- R is a cyclotomic field of order x
            return gaussSum(1, x, g)
        -- R is a cyclotomic field of order 4*x (for imaginary i)
        return - g^x * gaussSum(4, x, g) -- G(4, x)/i



)abbrev package QAUXMEQ QAuxiliaryModularEtaQuotientPackage
++ QModularEtaQuotientAux helps to do computations with
++ eta quotients that are modular functions and have a pole only
++ at infinity.
QAuxiliaryModularEtaQuotientPackage: with
    aLigozat: (P, Z, Z) -> Z
      ++ aLigozat(m, c, delta) computes an entry of the matrix of
      ++ Ligozat corresponding to the index (c, delta) counted in
      ++ divisors.
    matrixLigozat: P -> MZ
      ++ matrixLigozat(m) returns the (n,n) matrix with entries a_m(di,dj)
      ++ given by Notation 3.2.6 in \cite{Ligozat:CourbesModulaires:1975}
      ++ where di and dj run over all positive divisors of m.
      ++ This matrix is A_N as described after Theorem 5.2 in
      ++ \cite{Hemmecke+Radu:EtaRelations:2018}.
    rStarConditions: (P, List Z) -> Z
      ++ rStarConditions returns 0 if all conditions are fulfilled.
      ++ Otherwise it returns a positive number in the range 1 to 4 that
      ++ corresponds to the condition that is not met.
    upsilonExponent: (Z, Z, Z, Z) -> Z24
      ++ upsilonExponent(a,b,c,d) returns z \in {0..23} such that
      ++ exp(\pi*i*z/12) is a multiplier in the transformation of an
      ++ eta function by the matrix [[a,b],[c,d]] from SL_2(Z).
      ++ A definition can be found in \cite[Lemma~2.27]{Radu:PhD:2010}.
    upsilonExponent: MZ -> Z24
      ++ upsilonExponent(m) for a matrix m from SL_2(Z) returns
      ++ upsilonExponent(m(1,1), m(1,2), m(2,1), m(2,2)).
    width: (P, Z) -> Z
      ++ width(m, c) returns the width of the cusp a/c for Gamma_0(m)
      ++ and some a. The width is independent of a and given by
      ++ m/gcd(c^2,m).
      ++ \cite[Lemma~2.37]{Radu:PhD:2010}
    cusps2OfGamma0: P -> List Q
      ++ According to
      ++ \cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016},
      ++ there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
      ++ $\Gamma_0(N)$ that correspond to a divisor $c$ of $N$.
      ++ cusps(m) returns all the cusps for Gamma_0(m)$
    cuspsOfGamma0: P -> List Q
      ++ According to
      ++ \cite[Lemma~2.45]{Radu:PhD:2010},
      ++ there are $\eulerphi(\gcd(N/c, c))$ different cusps $\frac{a}{c}$ of
      ++ $\Gamma_0(N)$ that correspond to a divisor $c$ of $N$.
      ++ cusps(m) returns all the cusps for Gamma_0(m)$
    splitMatrix: (MZ, Z) -> Rec
      ++ splitMatrix(mat, delta) returns a record rec that contains
      ++ two matrices rec.red=m1 and rec.triang=m2 such that mat=m1*m2
      ++ according to \cide[Lemma~4.8]{Radu:PhD:2010}, but in a variation
      ++ as described in qetafun.spad, i.e., such that 0<=m2(1,2)<delta/g
      ++ where g = gcd(mat(1,1), mat(2,1)).
    cuspToMatrix: (P, Q) -> MZ
      ++ cuspToMatrix(m, a/c) returns a matrix gamma=[[a,b],[c,d]] such
      ++ that splitMatrix(gamma, m) returns two matrices [m1, m2] with
      ++ m1*m2 = [[m*a, c], m*b, d]] and m1 being in SL_2(Z) and m2 being
      ++ a triangular matrix with 0 <= m2(1,2) < m/c.
    rationalSquareRoot: Q -> Record(rat: Q, rootOf: Z)
      ++ if z = rationalSquareRoot(x) then x = (z.rat)^2 * z.root
    squareRoot: P -> Record(root: P, elem: List Q)
      -- numer elem = coefficient
      -- denom elem = exponent for "root"-th root of unity
    square: Record(root: Z, elem: List Q) -> Vector Z
-------------------------------------------------------------------
-- Temporarily exported
-------------------------------------------------------------------
    jacobiUpperStar: (Z, Z) -> Z
    jacobiLowerStar: (Z, Z) -> Z
    vv: (P, P, MZ) -> Q
    coprimePart: (Z, Z) -> Z

  == add
    -- Auxiliary functions
    coprimePart(n: Z, c: Z): Z ==
       -- coPrime(n, c) splits n into u*v such that gcd(u,c)=1 and returns u.
       -- We assume that all input numbers are positive.
       u := n
       while (g := gcd(u, c)) > 1 repeat u := (u exquo g)::Z
       u

    -- Compute B_N and V_N as in \cite{Hemmecke+Radu:EtaRelations:2018}.
    -- aLigozat(m, di, dj) here corresponds to a_m(di, dj) in
    -- \cite[Notation 3.2.6]{Ligozat:CourbesModulaires:1975}.
    aLigozat(m: P, di: Z, dj: Z): Z == -- di==c, dj==delta
        diprime: Z := (m exquo di)::Z
        num: Z := diprime * (gcd(di, dj)^2)
        den: Z := dj * gcd(diprime, di)
        (num exquo den)::Z -- can prove that this cannot fail

    matrixLigozat(m: P): MZ ==
        divs: List Z := divisors(m)$IntegerNumberTheoryFunctions
        n: N := # divs
        mat: MZ := new(n, n, 0)
        for i in 1..n for di in divs repeat -- do not include row for d.j=m
            for j in 1..n for dj in divs repeat
              qsetelt!(mat, i, j, aLigozat(m, di, dj))
        mat

--    order(r: List Z, c: Z)

    -- These are the conditions (1) to (4) of
    -- \cite{Hemmecke+Radu:EtaRelations:2018} that have to be fulfilled
    -- by a vector r to lie in R^*(N).
    rStarConditions(m: P, r: List Z): Z ==
        divs: List Z := divisors(m)$IntegerNumberTheoryFunctions
        rdivs: List Z := reverse divs
        s: Z := 0
        a: Z := 0
        b: Z := 0
        c: Factored Z := 1
        for ri in r for d in divs for rd in rdivs repeat
            s := s + ri
            a := a + ri * d  -- sigma_\infty
            b := b + ri * rd -- sigma_0
            c := c * factor(d)^(qcoerce(abs(ri))@N)
        -- Check conditions 1, 2, 3, 4.
        not zero? s => 1
        not zero? positiveRemainder(a, 24) => 2
        not zero? positiveRemainder(b, 24) => 3
        for fe in factors c repeat if odd?(fe.exponent) then return 4
        return 0

    jacobiLowerStar(c: Z, d: Z): Z == -- result either 1 or -1
        --assert(one? gcd(c,d))
        --aaawer(odd? d)
        -- See \cite[Def.~2.26]{Radu:PhD:2010}.
        -- \left(\frac{c}{d}\right)_* =
        -- \begin{cases}
        -- \left(\frac{c}{\lvert d \rvert}\right) (-1)^{m_c m_d},
        --   & \text{if $c\ne0$},\\
        -- \sign{d}, & \text{otherwise}
        -- \end{cases}
        -- where $m x=\frac{\sign{x}-1}{2}$.
        zero? c => sign(d) -- note that d ~= 0 in this case
        j: Z := jacobi(c, abs(d))$IntegerNumberTheoryFunctions
        if c>0 or d>0 then j else -j -- c=0 or d=0 does not happen

    jacobiUpperStar(c: Z, d: Z): Z == -- result either 1 or -1
        --assert(one? gcd(c,d))
        --aaawer(odd? d)
        -- See \cite[Def.~2.26]{Radu:PhD:2010}.
        -- \left(\frac{c}{d}\right)^* =
        -- \begin{cases}
        -- \left(\frac{c}{\lvert d \rvert}\right), & \text{if $c\ne0$},\\
        -- 1, & \text{otherwise}
        -- \end{cases}
        zero? c => 1
        jacobi(c, abs(d))$IntegerNumberTheoryFunctions

    upsilonExponent(a: Z, b: Z, c: Z, d: Z): Z24 ==
        u: Z := c*(a+d)-b*d*(c^2-1)-3*c
        v: Z := 3*(d-1)*(c-1)
        r(x) ==> x :: Z24
        -- Note that we exp(2*\pi*i*n/24)=exp(\pi*i)=-1 for n=12.
        odd? c => if jacobiUpperStar(d, c) > 0 then r(u) else r(u+12)
        if jacobiLowerStar(c, d) > 0 then r(u-v) else r(u-v+12)

    upsilonExponent(mat: MZ): Z24 ==
        upsilonExponent(mat(1,1), mat(1,2), mat(2,1), mat(2,2))

    width(m: P, c: Z): Z == (m exquo gcd(c^2, m)) :: Z

    splitMatrix(mat: MZ, delta: Z): Rec ==
        LZ ==> List Z
        LLZ ==> List LZ
        a: Z := mat(1,1) * delta
        b: Z := mat(1,2) * delta
        c: Z := mat(2,1)
        d: Z := mat(2,2)
        exgcd: EXGCD := extendedEuclidean(a, c)
        g: Z := exgcd.generator
        d0: Z :=  exgcd.coef1 -- initial value for d1
        b0: Z := -exgcd.coef2 -- initial value for b1
        a1: Z := (a exquo g) :: Z
        c1: Z := (c exquo g) :: Z
        a2: Z := g
        d2: Z := (delta exquo g)::Z
        -- Now try to find s such that 0 <= b*d1 - d*b1 - s*d2 < d2.
        b2init: Z := b*d0 - d*b0
        b2: Z := positiveRemainder(b2init, d2)
        s: Z := ((b2init - b2) exquo d2) :: Z
        b1: Z := b0 + s * a1
        d1: Z := d0 + s * c1
        m1: MZ := matrix([[a1, b1], [c1, d1]]$LLZ)
        m2: MZ := matrix([[g, b2], [0, d2]]$LLZ)
        [m1, m2]$Rec

    cuspToMatrix(m: P, cusp: Q): MZ ==
        a: Z := numer cusp
        c: Z := denom cusp
        exgcd: EXGCD := extendedEuclidean(a, c)
        g: Z := exgcd.generator
        dprime: Z :=  exgcd.coef1
        -- bprime: Z := -exgcd.coef2 -- ((not needed ))
        mc: Z := (m exquo c) :: Z
        u: Z := coprimePart(mc, c)
        -- v: Z := (mc exquo u) :: Z -- ((not meeded here))
        t: Z := mulmod(dprime, invmod(u, c), c)
        d: Z := t*u
        -- s: Z := ((t*u - dprime) exquo c) :: Z
        b := ((a*d -1) exquo c) :: Z -- instead of s we use that det=1
        matrix [[a, b], [c, d]]

)if LiterateDoc

We use \cite[Lemma~2.45]{Radu:PhD:2010} to compute the cusps of
$\Gamma_0(N)$ as the set of all $\frac{a}{c}$ such that $c|N$ and
$a\in X_c$.

)endif
    smallerCusp(x: Q, y: Q): Boolean ==
      denom x < denom y => true
      denom x > denom y => false
      numer x < numer y

    cuspsOfGamma0(level: P): List Q ==
        -- We use \cite[Lemma~2.45]{Radu:PhD:2010} with \delta replaced by
        -- c and N replaced by level.
        divs: List Z := divisors(level)$IntegerNumberTheoryFunctions
        result: List Q := empty()
        for c in divs repeat
            -- Let's compute the list corresponding to $X_c$.
            g: Z := gcd(c, (level exquo c)::Z)
            for x in 1..g | one? gcd(x, g) repeat
                a: Z := x
                while not one? gcd(a, c) repeat a := a + g;
                -- The variable a corresponds to an element of X_\delta
                -- from \cite[Lemma~2.45]{Radu:PhD:2010}.
--                exgcd: EXGCD := extendedEuclidean(a, c)
--                d: Z := exgcd.coef1
--                b: Z := -exgcd.coef2

                result := cons(a/c, result)
        sort!(smallerCusp, result)


    cusps2OfGamma0(level: P): List Q ==
        -- We use
        -- \cite[Lemma~5.3]{Radu:AlgebraicRelationsInvolvingEtaQuotients:2016}
        divs: List Z := divisors(level)$IntegerNumberTheoryFunctions
        result: List Q := empty()
        for c in divs repeat
            g: Z := gcd(c, (level exquo c)::Z)
            candidates: List Z := [a for a in 1..c | one? gcd(a, c)]
            for y in 1..g | one? gcd(y, g) repeat
                a: Z := -1 -- not yet assigned
                for t in candidates | zero? positiveRemainder(t-y, g) repeat
                    a := t
                    break
                if a<0 then error "cusps: no candidates"
                -- now compute other two matrix entries (b and d)
--                exgcd: EXGCD := extendedEuclidean(a, c)
--                d: Z := exgcd.coef1
--                b: Z := -exgcd.coef2
--                m: MZ := matrix [[a, b], [c, d]]
                result := cons(a/c, result)
        sort!(smallerCusp, result)

    vv(m: P, delta: P, mat: MZ): Q ==
        c: Z := mat(2, 1)
        h: Z := gcd(delta, c)
        r: Rec := splitMatrix(mat, delta)
        t := r.triang
        width(m, mat(2,1)) * h * t(1, 2) / delta

    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FL ==> Record(flg: fUnion, fctr: Z, xpnt: Z)
    squarePart(fl: List FL): Z ==
        -- if fl = factorList factor x and z=squarePart(fl) then
        -- z^2*r=expand(fl) for some squarefree r.
        z: Z := 1
        for x in fl repeat
            e: P := qcoerce(shift(x.xpnt, -1))@P
            z := (x.fctr)^e * z
        return z

    rationalSquareRoot(x: Q): Record(rat: Q, rootOf: Z) ==
        import from FL
        fden: Factored Z := factor denom x
        fnum: Factored Z := factor numer x
        fl: List FL := factorList fden
        for x in fl | odd?(x.xpnt) repeat
            fnum := x.fctr * fnum
            fden := x.fctr * fden
        fl := factorList fnum
        r: Z := 1
        for x in fl | odd? (x.xpnt) repeat r := x.fctr * r
        return [squarePart(fl)/squarePart(factorList fden), r]

    square(x: Record(root: Z, elem: List Q)): Vector Z ==
        Pol ==> SparseUnivariatePolynomial(Z)
        pol: Pol := cyclotomic(x.root)$CyclotomicPolynomialPackage
        C ==> SimpleAlgebraicExtension(Z, Pol, pol)
        g: C := generator()$C
        z: C := 0
        for e in x.elem repeat
            n: P := qcoerce(denom e)@P
            z := z + numer(e)*g^n
        dbgPrint("elem", z)
        dbgPrint("square", z*z)
        convert(z*z)@Vector(Z)

    squareRoot(x: P): Record(root: P, elem: List Q) ==
        -- x is a radical integer (squarefree)
        Pol ==> SparseUnivariatePolynomial(Z)
        -- x is a radical integer (squarefree)
        x = 2 => [8, [-1/3, 1/1]]
        n: P := x
        if even? x or positiveRemainder(x, 4)=3 then n := 4*n
        pol: Pol := (cyclotomic(n)$CyclotomicPolynomialPackage)
        S ==> SimpleAlgebraicExtension(Z, Pol, pol)
        sr: S := squareRoot(x, generator()$S)$GaussRoot(S)
        dbgPrint("sr", sr)
        p: Pol := convert(sr)@Pol
        dbgPrint("p", p)
        if even? x then p := (p exquo 4)::Pol
        z: S := convert(p)@S
        dbgPrint("s2", sr*sr)
        dbgPrint("z2", z*z)
        [n, [1/7, 1/2]]




)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
