-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Expanding (sifted) Dedekind Eta Functions into $q$-series at
  various cusps}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The code in this file deals the computation of a cofactor to a
  sifted (generalized) eta-quotient such that the result is a modular
  function.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- consider only 2x2 matricies
SL2Z ==> MZ -- matrices with determinant = 1
LP ==> List P
LZ ==> List Z
LLZ ==> List LZ
LQ ==> List Q
VZ ==> Vector Z
GAMMA0 ==> CongruenceSubgroupGamma0
QETAAUX ==> QEtaAuxiliaryPackage

asN x ==> x pretend N
asP x ==> x pretend P
WIDTH0(nn, c) ==> asP(width(nn, c)$GAMMA0)

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0}
\label{sec:QEtaModularGamma0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta-quotient
in order to make it a modular function for
$\Gamma_0(N)$ having a pole only at infinity or to make the (positive)
orders at all cusps (\code{qetaGrades}) small in total sum.

)endif

)abbrev package QETAMG0 QEtaModularGamma0
QEtaModularGamma0: Exports == Implementation where
  Exports ==> with
    qetaGrades: SymbolicModularGamma0SiftedEtaQuotient -> XHashTable(Q, Z)
      ++ qetaGrades(y) returns the qetaGrades of the modular
      ++ function corresponding to y.
    qetaGrades: (P, LZ, P, LZ, P, N) -> XHashTable(Q, Z)
      ++ qetaGrades(nn, s, mm, r, m, t) returns
      ++ qetaGrades(y) where
      ++ y=etaQuotient(nn,s,mm,r,m,t)$SymbolicModularGamma0SiftedEtaQuotient.
    etaCoFactorInfinity: (P, P, LZ, P, N) -> LZ
      ++ etaCoFactorInfinity(nn,mm,r,m,t) returns a list s such that
      ++ modularGamma0?(nn,s,mm,r,m,t)$QEtaCoFactorSpace and
      ++ etaQuotient(nn,s,mm,r,m,t)$SymbolicModularGamma0SiftedEtaQuotient
      ++ corresponds to a modular function with poles only at infinity
      ++ and with smallest pole order.

    -- temporarily exported
    minimizeVector: (VZ, List VZ) -> VZ

  Implementation ==> add
    LVZ ==> List VZ
    ZRESULT ==> Record(zinhom: LVZ, zhom: LVZ, zfree: LVZ) -- zsolve$X4ti2
    ECFS ==> Record(particular: Union(VZ, "failed"), basis: List VZ)
    C ==> Q
    lift2C x ==> map(coerce, x)$SparseUnivariatePolynomialFunctions2(Z, C)
    SUPC ==> SparseUnivariatePolynomial C
    CX ==> SimpleAlgebraicExtension(C, SUPC, supc)
    TX ==> QEtaTaylorSeries CX
    LX ==> QEtaLaurentSeries CX
    YM0SEQ ==> SymbolicModularGamma0SiftedEtaQuotient
    M0SEQ ==> ModularGamma0SiftedEtaQuotient(C, mx, CX, xi)
    a ==> aLigozat $ QETAAUX

    -- order of eta^r at cusp a/c.
    grade(nn: P, divs: LP, c: Z, r: LZ): Z ==
        l: LZ := [rdelta * a(nn, c, delta) for delta in divs for rdelta in r]
        -(reduce(_+, l, 0) exquo 24)::Z

    -- orders at cusps of Gamma0(nn) different from infinity
    grades(nn: P, divs: LP, cusps: LQ, r: LZ): LZ ==
        [grade(nn, divs, denom cusp, r) for cusp in cusps]

    qetaGrades(y: YM0SEQ): XHashTable(Q, Z) ==
        mx: P := minimalRootOfUnity y
        supc: SUPC := lift2C(cyclotomic(mx)$CyclotomicPolynomialPackage);
        xi := generator()$CX;
        xsym: Symbol := "x"::Symbol;
        msetaq := y::M0SEQ
        e: XHashTable(Q, LX) := expansions(msetaq)
        ht: XHashTable(Q, Z) := empty()
        for cusp in keys e repeat ht.cusp := -order(e.cusp)
        ht

    qetaGrades(nn: P, s: LZ, mm: P, r: LZ, m: P, t: N): XHashTable(Q, Z) ==
        y: YM0SEQ := etaQuotient(nn, s, mm, r, m, t);
        qetaGrades y


    -- local function
    -- By adding interger multiples of elements of b we try to
    -- make the length of sinitial as small as possible in a cheap way.
    -- It is not completely necessary to find the minimal vector, since
    -- there is a second optimization step in minimalGrades that makes
    -- the order at the cusps relatively small.
    -- We try to achieve small length by a simple algorithm.
    --
    -- Let b be a vector of bas. Compute v1:=v+b, v2:=v-b. If v1 is
    -- strictly shorter than v, then set v to v1 and iterate. Similar
    -- if v2 is strictly shorter. If neither v1 nor v2 are not
    -- strictly shorter than v continue with the next vector from bas.
    minimizeVector(v: VZ, basis: LVZ): VZ ==
        empty? basis => v
        reduced?: Boolean := true -- to start the loop
        lv := dot(v, v)
        while reduced? repeat
            bas := basis
            reduced? := false
            while not empty? bas and not reduced? repeat
                b := first bas
                bas := rest bas
                u := v + b
                while (lu := dot(u, u)) < lv repeat
                    lv := lu
                    v := u
                    u := v + b
                    reduced? := true
                reduced? => break
                u := v - b
                while (lu := dot(u, u)) < lv repeat
                    lv := lu
                    v := u
                    u := v - b
                    reduced? := true
        v


    -- local function
    -- It might happen that the particular solution of etaCoFactorSpace0
    -- has entries that are very big. That would lead to a very heavy
    -- computation when we determine the grades of the respective
    -- eta-quotient at all cusps. We therefore try to "reduce" the vector
    -- by elements of the basis such that the length of the vector becomes
    -- small.
    -- Here we do it by applying the LLL algorithm and trying to reconstruct
    -- a relavtively small vector s such that s = r + dot(c, bas) for some
    -- integer vector c.
    minimizeVectorLLL(rinitial: VZ, b: LVZ): VZ ==
        -- The rinitial vector might have very big numbers in it. We
        -- make them smaller by applying LLL to the system.
        -- Note that the elements of b correspond to exponent vectors that
        -- yield eta-quotients that are modular functions.
        mat: MZ := matrix cons(members rinitial, [members v for v in b])
        el: Record(lll: MZ, trf: MZ) := extendedLLL(mat)$LLLReduction
        -- Now look for 1 or -1 in the first entry of the transformation
        -- matrix.
        tmat: MZ := el.trf
        z: Z := 0
        i: N := 1
        n: N := nrows(tmat)
        while i <= n and not one? abs(z := tmat(i, 1)) repeat i := i+1
        one? abs z => z*row(tmat, i)*mat

        -- Here we were unlucky. No 1 or -1 in the first component found.
        -- Thus we try to construct a 1 by successive gcd computation.
        i := 1
        while i <= n and zero?(z := tmat(i, 1)) repeat i := i + 1
        i > n => rinitial
        -- We know that there is no 1 or -1 in the first position, so
        -- abs(tmat(i, 1)) is not equal to one. If i=n then we have no
        -- chance to change that into a 1.
        i = n => rinitial

        v: VZ := row(tmat, i)
        i := i + 1
        CCG ==> Record(coef1: Z, coef2: Z, generator: Z)
        while i <= n and not one? z repeat
            ccg: CCG := extendedEuclidean(z, tmat(i, 1))
            v := ccg(coef1) * v + ccg(coef2) * row(tmat, i)
            z := ccg.generator
            i := i + 1
        one? z => v*mat
        rinitial


    -- local function
    -- What actually counts is that the grade of eta-quotient corresponding
    -- to sinitial is small.
    -- The initial minimizeVector is only here, because the computation of
    -- qetaGrades involves the actual computation of the Laurent series
    -- expansion of the respective eta-quotient at all cusps. So we
    -- shouldn't have too high exponents.
    minimizeGrades(nn: P, mm: P, r: LZ, m: P, t: N, rinitial: VZ, b: LVZ): LZ ==
        sinitial := minimizeVector(rinitial, b)
        -- Compute the poleorders/grades (at all cusps) for the
        -- particular solution rinitial.
        g: XHashTable(Q, Z) := qetaGrades(nn, members sinitial, mm, r, m, t);
        -- Exclude order at the cusp infinity.
        cusps: LQ := [cusp for cusp in cusps(nn)$GAMMA0 | cusp~=1/nn]
        rhs: LZ := [g.cusp for cusp in cusps]

        -- For the vectors in the basis, we don't need to compute the
        -- series explicitly, since these vectors correspond to
        -- modular eta-quotients and thus we can use the matrix of
        -- Ligozat to compute the order vectors.
        nndivs: List P := DIVISORS nn
        bas: List LZ := [grades(nn, nndivs, cusps, members r) for r in b]
        mat: MZ := transpose matrix bas
        rels: VZ := vector [1 for x in 1..#cusps]
        zresult: ZRESULT := zsolve(mat, rels, vector rhs)$X4ti2
        adjustment := members first zresult.zinhom
        members(sinitial - reduce(_+, [x*bb for x in adjustment for bb in b]))

    etaCoFactorInfinity(nn: P, mm: P, r: LZ, m: P, t: N): LZ ==
        ecfs: ECFS := etaCoFactorSpace0(nn, mm, r, m, t)$QEtaCoFactorSpace
        n: Z := numberOfDivisors(nn)$INTF
        sinitial: VZ := ((ecfs.particular)::VZ)(1..n)
        b: LVZ := [x(1..n) for x in ecfs.basis]
        members minimizeGrades(nn, mm, r, m, t, sinitial, b)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P QEtaModularGamma0Infinity}
\label{sec:QEtaModularGamma0Infinity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Compute a vector that must be multiplied to the (sifted) eta-quotient
in order to make it a modular function having a pole only at infinity
or to make the (positive) orders at all cusps (\code{qetaGrades})
small in total sum.

)endif

)abbrev package QETAMG0I QEtaModularGamma0Infinity
QEtaModularGamma0Infinity(C: IntegralDomain): Exports == Implementation where
  T1 C  ==> QEtaTaylorSeries C
  L1 C  ==> QEtaLaurentSeries C
  A1 C ==> Finite0Series C
  EQI C  ==> EtaQuotientInfinity C
  Exports ==> with
    modularEtaQuotientInfinity: (P, LZ, P, LZ, P, N) -> A1 C
      ++ modularEtaQuotientInfinity(nn, s, mm, r, m, t) returns
      ++ the series expansion of
      ++ etaQuotient(nn,s,mm,r,m,t)$SymbolicModularGamma0SiftedEtaQuotient
      ++ at the cusp infinity.
    modularEtaQuotientInfinity: (P, P, LZ, P, N) -> A1 C
      ++ modularEtaQuotientInfinity(nn, mm, r, m, t) returns
      ++ modularEtaQuotientInfinity(nn, s, mm, r, m, t) for s
      ++ equal to etaCoFactorInfinity(nn, mm, r, m, t).
  Implementation ==> add
    -- generating series for a(m*n+t) with cofactor eta-quotient and
    -- the fractional q power where \sum_{k=0}^\infty a(k)q^k is
    -- defined by an eta-quotient with exponent vector r.

    modularEtaQuotientInfinity(nn:P, s:LZ, mm:P, r:LZ, m:P, t:N): A1 C ==
        -- First compute the expansion of the orbit product.
        eulerquo: T1 C := qetaTaylorRep(eulerExpansion(mm, r)$EQI(C))

        orb: List N := orbit(mm, r, m, t)$QEtaCoFactorSpace
        tt := first orb
        p: T1 C := multisect(m-tt, tt, eulerquo)
        -- Now multiply the series selecting sum_{n=0}^\infty a(m*n+k)q^n.
        for k in rest orb repeat p := p * multisect(m-k, k, eulerquo)

        -- The expansion of the coFactor is here.
        -- We take care of the right q-order through alphaInfinity.
        cofact: T1 C := qetaTaylorRep(eulerExpansion(nn, s)$EQI(C))

        -- We multiply both things together to get (nearly) a modular
        -- function.
        tf: T1 C := cofact * p

        -- We have to multiply by some q-power to get the expansion of
        -- a modular function f.
        alpha: Z := alphaInfinity(nn, s, mm, r, m, t)$QEtaCoFactorSpace
        laurent(alpha, tf)$A1(C)

    modularEtaQuotientInfinity(nn: P, mm: P, r: LZ, m: P, t: N): A1 C ==
        orb: List N := orbit(mm, r, m, t)$QEtaCoFactorSpace
        tracePrint("orbit", sort orb)
        s: List Z := etaCoFactorInfinity(nn, mm, r, m, t)$QEtaModularGamma0
        tracePrint("cofactor", s)
        modularEtaQuotientInfinity(nn, s, mm, r, m, t)


)if LiterateDoc
\bibliography{qeta}
\printindex
\end{document}
)endif
