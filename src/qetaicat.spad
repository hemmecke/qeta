-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2015-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Computation of Polynomial Relations among Dedekind Eta
  Functions}
\author{Ralf Hemmecke}
\date{10-Dec-2015}
\maketitle

\begin{abstract}
  Based on articles by Hemmecke and Radu, we compute relations among
  eta-functions of a given level $N$. We provide several variants
  of this computation. The category \code{QEtaIdealCategory} is an
  attempt to abstract identical code. The main difference of the
  variants is in the computation of generators of the ideal of
  relations among eta-quotients. The variants in the files
  \PathName{qetair.spad} and \PathName{qetais.spad} are no longer maintained

  The code implements (as a default package of the category) the
  computation of polynomial relations among eta-functions as
  described in \cite{Hemmecke+Radu:EtaRelations:2019}. The computation
  is done in various sub-steps building upon the known generators of
  the monoid of all eta-quotients of a certain level, see file
  \PathName{qetaqmev.spad}.
  \begin{itemize}
  \item \code{etaQuotientIdealGenerators} computes generators of the
    ideal of all relations among eta-quotients. The result
    corresponds to $H^{(M)}$ from
    \cite[Chapter~7]{Hemmecke+Radu:EtaRelations:2019}.
  \item \code{etaLaurentIdealGenerators} substitutes the $E_\delta$
    and $Y_\delta$ variables into the relations obtained from the
    previous step, this function returns $\chi'(H^L)\cup U$ as
    described in \cite[Chapter~7]{Hemmecke+Radu:EtaRelations:2019}
  \item \code{etaRelations} computes a \GB{} of the polynomials from
    the previous step and returns the polynomial that are only in the
    $E$ variables.
  \end{itemize}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This code is based on \cite{Hemmecke+Radu:EtaRelations:2019}. In fact,
the following code was used to develop the results of this article.

The code here is very close to what is written in
\cite{Hemmecke+Radu:EtaRelations:2019}, \ie, from a list of generators
of $R^\infty(N)$ we compute generators of the ideal $J^{(M)}$ by the
function \code{etaQuotientIdealGenerators}.

Then \code{etaLaurentIdealGenerators} substitutes the $M$ variables by
the $E$ and $Y$ variables so that eventually we have $\chi'(H^L)\cup
U$ in the notation of \cite{Hemmecke+Radu:EtaRelations:2019}.

Eventually, the function, \code{etaRelations} takes the output of
\code{etaLaurentIdealGenerators} and eliminates the $Y$ variables by
computing a \GB{} with respect to block order, separately degrevlex in
the $Y$ and $E$ variables.

The variants to compute the generators of $J^{(M)}$ are abstracted
into the function \code{relationsIdealGenerators}, which is
implemented in the respective package.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
LSym ==> List Symbol
LZ ==> List Z
LLZ ==> List LZ
INDICES ==> LLZ

asN x ==> x pretend N

mSPECS0 ==> etaQuotientMonoidSpecifications $ QEtaQuotientSpecifications4ti2
mSPECS1 ==> generalizedEtaQuotientMonoidSpecifications $ QEtaQuotientSpecifications4ti2

specM0A1 C ==> modularEtaQuotientInfinity $ QEtaModularGamma0Infinity(C)
specM1A1 C ==> modularGeneralizedEtaQuotientInfinity $ QEtaModularGamma1Infinity(C)

)if LiterateDoc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category QEtaIdealCategory: Relations among Dedekind
  eta-functions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
)endif

)abbrev category QETAIDC QEtaIdealCategory
++ QEtaIdealCategory(C) is a category that implements a number of
++ functions connected to relations among Dedekind eta-functions. It
++ allows for differend implementation of the function
++ relationsIdealGenerator, which does the main job of computing the
++ generators of the ideal of relations of modular eta-quotients
++ having a pole at most at infinity.
QEtaIdealCategory(C): Category == Exports where
  C: EuclideanDomain
  A1 C ==> Finite0Series C --: Join(QEtaLaurentSeriesCategory C, QEtaAlgebra C)
  Pol ==> Polynomial C
  LPol ==> List Pol
  SPEC ==> QEtaSpecification
  SPECS ==> List SPEC
  Exports ==> with
    relationsIdealGenerators: List A1 C -> LPol
        ++ relationsIdealGenerators(qseries) returns
        ++ a set of generators in the variables M_i of the ideal
        ++ of all relations among the given qseries.
        ++ The initial series correspond to the variables M_i in the output
        ++ of this function.
        ++ We assume that qseries is a list of Laurent series in q that
        ++ correspond to modular functions for $\Gamma_0(N)$ having a pole
        ++ (if any) at infinity only.
        ++ The samba algorithm can be used in its extended form in order to
        ++ also get a representation of resulting algebra basis in terms
        ++ of the original elements.
        ++ Algoritm samba is described in: Ralf Hemmecke,
        ++ "Dancing Samba with Ramanujan Partition Congruences",
        ++ Journal of Symbolic Computation, 84, 2018.
        ++ See \cite{Hemmecke+Radu:EtaRelations:2019} for more detail
        ++ and the package \spadtype{QEtaIdealHemmecke}.
    etaQuotientIdealGenerators: SPECS -> LPol
        ++ etaQuotientIdealGenerators(mspecs) returns polynomials in
        ++ the variables M_i (where i runs from 1 to #mspecs) that
        ++ generate the ideal of all relations of the eta-quotients
        ++ given by mspecs. Originally it was intended that mspecs is
        ++ the specifications of the eta-quotients given by
        ++ etaQuotientMonoidSpecifications(level) from the package
        ++ \spadtype{QEtaQuotientSpecifications4ti2}. This function
        ++ just sets up a the q-series and then calls
        ++ relationsIdealGenerators on these series.
    etaQuotientIdealGenerators: P -> LPol
        ++ etaQuotientIdealGenerators(level) returns
        ++ etaQuotientIdealGenerators(mspecs) where mspecs is given by
        ++ mspecs := etaQuotientMonoidSpecifications(level) from the
        ++ package \spadtype{QEtaQuotientSpecifications4ti2}.
    etaLaurentIdealGenerators: (P, SPECS, LPol) -> LPol
        ++ etaLaurentIdealGenerators(level, mspecs, eqigens) assumes
        ++ that epigens is a list of polynomials in the variables M_i,
        ++ for example, eqigens = etaQuotientIdealGenerators(level, mspecs)
        ++ and replaces each of the M_i by the corresponding
        ++ product of E_d and Y_d variables given by mspecs.i. Positive
        ++ entries in mspecs.i correspond to E variables and negative
        ++ entries to Y variables, the Y variables correspond to
        ++ inverses of eta-functions. The generators E_d*Y_d-1 for
        ++ each divisor of level are also added to the resulting
        ++ polynomials from above.
    etaLaurentIdealGenerators: P -> LPol
        ++ etaLaurentIdealGenerators(level) returns
        ++ etaLaurentIdealGenerators(level, mspecs, eqigens) for
        ++ mspecs := etaQuotientMonoidSpecifications(level) and
        ++ eqigens := etaQuotientIdealGenerators(mspecs)
    etaRelations: (P, LPol) -> LPol
        ++ etaRelations(level, eligens) eliminates the Y variables from the
        ++ input and returns the resulting Groebner basis.
    etaRelations: P -> LPol
        ++ etaRelations(n) returns
        ++ etaRelations(n, etaLaurentIdealGenerators(n)).
        ++ The result describes the ideal of all relations among the
        ++ eta-functions of level n where the variable E_d stands for
        ++ the eta-function $\eta(d*\tau)$.
    laurentRelations: (LSym, LSym) -> LPol
        ++ laurentRelations(esyms, ysyms) returns
        ++ [e*y-1 for e in esyms for y in ysyms].

    generalizedEtaQuotientIdealGenerators: SPECS -> LPol
    generalizedEtaQuotientIdealGenerators: P -> LPol
    generalizedEtaLaurentIdealGenerators: (INDICES, SPECS, LPol) -> LPol
    generalizedEtaLaurentIdealGenerators: (P, INDICES) -> LPol
    generalizedEtaRelations: (INDICES, LPol) -> LPol
    generalizedEtaRelations: (P, INDICES) -> LPol
    generalizedEtaRelations: P -> LPol

   add
    -- auxiliary functions
    -- Return the "quotient" for the respective r vector where "quotient"
    -- is to be understood as using E for positive and Y for negative r entries.
    etaQuotientMonomial(mspec: SPEC): Pol ==
        iSY ==> indexedSymbol $ QAuxiliaryTools
        p: Pol := 1
        for l in concat(purePart mspec, properGeneralizedPart mspec) repeat
            r := reverse l
            e := first r
            i: List Z := reverse rest r
            e > 0 => p := p * monomial(1$Pol, iSY("E", i), asN e)
            e < 0 => p := p * monomial(1$Pol, iSY("Y", i), asN abs e)
        return p

    laurentRelations(esyms: LSym, ysyms: LSym): LPol ==
        [monomial(1$Pol, [e, y], [1, 1]) - 1$Pol for e in esyms for y in ysyms]

    -- exported functions
    etaQuotientIdealGenerators(mspecs: SPECS): LPol ==
        egens: List A1 C := [specM0A1(C) spec for spec in mspecs]
        relationsIdealGenerators egens

    etaQuotientIdealGenerators(level: P): LPol ==
        etaQuotientIdealGenerators(level, mSPECS0 level)

    etaLaurentIdealGenerators(nn: P, mspecs: SPECS, eqigens: LPol): LPol ==
        divs: List Z := divisors(nn)$IntegerNumberTheoryFunctions
        idxs: INDICES := [[d] for d in  divs]
        generalizedEtaLaurentIdealGenerators(idxs, mspecs, eqigens)

    etaLaurentIdealGenerators(nn: P): LPol ==
        mspecs: SPECS := mSPECS0 nn
        eqigens: LPol := etaQuotientIdealGenerators mspecs
        etaLaurentIdealGenerators(nn, mspecs, eqigens)

    etaRelations(level: P, eligens: LPol): LPol ==
        -- We only need to eliminate the Y_d variables from the
        -- etaLaurentIdealGenerators.
        divs: List Z := divisors(level)$IntegerNumberTheoryFunctions
        ysyms: LSym := indexedSymbols("Y", divs)$QAuxiliaryTools
        esyms: LSym := indexedSymbols("E", divs)$QAuxiliaryTools
        syms: LSym := concat(ysyms, esyms)
        dim: N := # syms
        dim1: N := # ysyms
        E ==> SplitHomogeneousDirectProduct(dim, dim1, N)
        gb := groebner(eligens, syms)$QEtaGroebner(C, E)
        -- take only the polys that do not invole any Y variable
        xPolynomials(gb, char "E")$PolynomialTool(C)

    etaRelations(level: P): LPol ==
        eligens: LPol := etaLaurentIdealGenerators(level)
        etaRelations(level, eligens)

-------------------------------------------------------------------
-- relations of generalized eta-functions
-------------------------------------------------------------------

    -- exported functions
    generalizedEtaQuotientIdealGenerators(mspecs: SPECS): LPol ==
        egens: List A1 C := [specM1A1(C) spec for spec in mspecs]
        relationsIdealGenerators egens

    generalizedEtaQuotientIdealGenerators(nn: P): LPol ==
        mspecs: SPECS := mSPECS1 nn
        generalizedEtaQuotientIdealGenerators mSPECS1 nn

    generalizedEtaLaurentIdealGenerators(_
      idxs: INDICES, mspecs: SPECS, eqigens: LPol): LPol ==
        -- substitute the yemPolynomial for the respective M_i variable
        PE ==> PolynomialEvaluation(C, Pol)
        etaQuotientMonomials := [etaQuotientMonomial mspec for mspec in mspecs]
        msyms: LSym := indexedSymbols("M", #mspecs)$QAuxiliaryTools
        fc(c: C): Pol == c::Pol
        gens: LPol := _
            [eval(x, fc, msyms, etaQuotientMonomials)$PE for x in eqigens]
        -- now reduce modulo E*Y=1.
        ysyms: LSym := indexedSymbols("Y", idxs)$QAuxiliaryTools
        esyms: LSym := indexedSymbols("E", idxs)$QAuxiliaryTools
        yerels: LPol := laurentRelations(esyms, ysyms)
        syms: LSym := concat(ysyms, esyms)
        dim: N := # syms
        dim1: N := # ysyms
        E ==> SplitHomogeneousDirectProduct(dim, dim1, N)
        nfs: LPol := normalForms(gens, yerels, syms)$QEtaGroebner(C, E)
        concat(yerels, nfs)

    generalizedEtaLaurentIdealGenerators(nn: P, idxs: INDICES): LPol ==
        mspecs: SPECS := mSPECS1(nn, idxs)
        eqigens: LPol := generalizedEtaQuotientIdealGenerators mspecs
        generalizedEtaLaurentIdealGenerators(idxs, mspecs, eqigens)

    generalizedEtaRelations(idxs: INDICES, eligens: LPol): LPol ==
        -- We only need to eliminate the Y_d variables from the
        -- etaLaurentIdealGenerators.
        ysyms: LSym := indexedSymbols("Y", idxs)$QAuxiliaryTools
        esyms: LSym := indexedSymbols("E", idxs)$QAuxiliaryTools
        syms: LSym := concat(ysyms, esyms)
        dim: N := # syms
        dim1: N := # ysyms
        E ==> SplitHomogeneousDirectProduct(dim, dim1, N)
        gb := groebner(eligens, syms)$QEtaGroebner(C, E)
        -- take only the polys that do not invole any Y variable
        xPolynomials(gb, char "E")$PolynomialTool(C)

    generalizedEtaRelations(nn: P, idxs: INDICES): LPol ==
        eligens: LPol := generalizedEtaLaurentIdealGenerators(nn, idxs)
        generalizedEtaRelations(idxs, eligens)

    generalizedEtaRelations(nn: P): LPol ==
        aidxs: INDICES := generalizedEtaFunctionIndices(nn)$QEtaAuxiliaryPackage
        generalizedEtaRelations(nn, aidxs)

)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
