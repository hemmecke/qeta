-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2020  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
display77(x) ==> display((x::OF)::Formatter(Format1D))
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Using the QEta package to find Ramanujan-Kolberg identities}
\author{Ralf Hemmecke}
\date{29-Oct-2020}
\maketitle
\begin{abstract}
  The package \code{QEtaRamanujanKolberg} implements functions to help
  finding Ramanujan-Kolberg identities.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu:RamanujanKolberg:2015}.

Let $M$ be a positive integer and $s=(s_\delta)_{\delta|M}$ be a
sequence of integers indexed by the positive divisors of $M$. Define a
sequence $a(n)$ by
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M} \prod_{n=1}^\infty (1-q^{\delta n})^{s_\delta}
  =
  \prod_{\delta|M} (q^\delta; q^\delta)_\infty^{s_\delta}
\end{gather*}
where
\begin{gather*}
(u; q)_\infty = \prod_{n=0}^\infty (1-uq^n)
\end{gather*}
is the $q$-Pochhammer symbol.

Given $N$, $m$, and $t \in \{0,\ldots,m-1\}$, we want to compute a
sequence $r=(r_\delta)_{\delta|N}$ of integers, a set
$\mathcal{O}_{r,m,t}\subseteq\{0,\ldots,m=1\}$, $\eta$-quotients
$b_i \in M^\infty(N)$, and numbers $c_i\in \mathbb{Q}$ uch that
\begin{gather*}
q^\alpha \prod_{\delta|N} \prod_{n=1}^\infty (1-q^{\delta n})^{r_\delta}
\times
\prod_{t'\in \mathcal{O}(r,m,t)} \sum_{n=0}^\infty a(mn+t')q^n
=
\sum_{i=1}^k c_i b_i
\end{gather*}
where
\begin{gather*}
\alpha = \sum_{\delta|N} \frac{\delta r_\delta}{24}
         +
         \sum_{t'\in \mathcal{O}(r,m,t)}
             \frac{24 t' + \sum_{\delta|N} \delta s_\delta}{24m}
\end{gather*}
and $M^\infty(N)$ is the set of modular functions on $\Gamma_0(N)$
with a pole at most at infinity.

Each of the $\eta$-quotients is given through a sequence
$r^{(i)}=\left(r^{(i)}_\delta\right)_{\delta|N}$ of integers in its
$q$-expansion at infinity.
\begin{gather*}
  b_i
  = q^{\beta_i} \prod_{\delta|N}
                      \prod_{n=1}^\infty (1-q^{\delta n})^{r^{(i)}_\delta}
  =
  q^{\beta_i} \prod_{\delta|N} (q^\delta, q^\delta)_\infty^{r^{(i)}_\delta}.
\end{gather*}
with
\begin{gather*}
  \beta_i = \sum_{\delta|N} \frac{\delta r^{(i)}_\delta}{24}
\end{gather*}


For mathematical background see \PathName{qetafun.spad}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

Pol ==> Polynomial
SUP ==> SparseUnivariatePolynomial
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage;

T1 C  ==> UnivariateTaylorSeries(C, 'q, 0);
L1 C  ==> UnivariateLaurentSeries(C, 'q, 0);
A1 C ==> Finite0Series(C, 'q, 0)
ETA C ==> EtaQuotient(C, A1 C)
CA1 C ==> QEtaAlgebraCachedPower(C, A1 C) -- computation domain (cached)
CPol C ==> QEtaAlgebraCachedPower(C, Pol C) -- computation pols in (cached)
X1 C ==> QEtaExtendedAlgebra(C, CA1 C, CPol C)
toX1(C, a, b) ==> embed(a::CA1(C), b::CPol(C))$X1(C)

QXAB1 C ==> QEtaAlgebraBasis(C, X1 C)
QXTOPRED1 C ==> QEtaTopReduction(C, X1 C, QXAB1 C)
QXTOPCOMP1 C ==> QEtaComputation(C, X1 C, QXAB1 C, QXTOPRED1 C)
QXTOPSAMBA1 C ==> QEtaSambaPackage(C, X1 C, QXAB1 C, QXTOPCOMP1 C)

QEQEV ==> QEtaQuotientExponentVectors4ti2


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolbergIdentity}
\label{sec:QEtaRamanujanKolbergIdentity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We provide here a domain that prints nicely as an identity and has
enough acces functions to extract various components of the identity
for easier manipulation.


)endif


)abbrev domain QETARKI QEtaRamanujanKolbergIdentity
QEtaRamanujanKolbergIdentity(C): Exports == Implementation where
  C: EntireRing -- basic coefficient domain
  L ==> List
  EX ==> Expression Z
  Exports ==> CoercibleTo OutputForm with
    identity: (P, List Z, P, L Z, P, N, L L Z, Pol C) -> %
      ++ identity(nn, mm, s, m, t, c, rel, rgens) returns a
      ++ structure that represents all information about the (the q)
      ++ expansion of $F_{r,s,m,t}$ at infinity, see Definition of
      ++ $F_{r,s,m,t}$ in qetafun.spad,
      ++ Equation~\eqref{eq:F_r-s-m-t(tau)}. The relations is then
      ++ c*F=sum_{i}(rel(i)*etaQuotient(nn,rgens(i))) where F
      ++ corresponds to the modular function $F_{r,s,m,t}$ in
      ++ question.
    alphaInfinity: % -> Z
      ++ alphaInfinity(x) returns the q exponent that corresponds to
      ++ the orbit product and the respective co-exponent in order to
      ++ make the whole produce a modular function. It is defined
      ++ already in the abstract of \cite{Radu:RamanujanKolberg:2015}.
    orbit: % -> List N
      ++ orbit(x) returns the orbit of the sifted series.
    level: % -> P
      ++ level(x) returns nn if x represents a modular function for
      ++ Gamma_0(nn).
    definingLevel: % -> P
      ++ definingLevel(x) returns mm. This is the level of the
      ++ eta-quotient from which the sifted version is taken.
    definingExponents: % -> List Z
      ++ definingExponents(x) returns the exponents
      ++ $s=(s_\delta)_{\delta|M}$ (where $M$ is the defining level)
      ++ for the defining series of the coefficients a(n), i.e.,
      ++ \sum_{n=0}^\infty a(n)q^n = \prod_{\delta|M} (q^{\delta},
      ++ q^{\delta})_\infty^{s_\delta}$.
    multiplier: % -> P
      ++ multiplier(x) returns factor m to select a certain
      ++ subsequence a(m*n+k) of the defining series (where k is one
      ++ number out of orbit(x).
    offset: % -> N
      ++ offset(x) returns the offset k to select a certain
      ++ subsequence a(m*n+k) of the defining series (where k was the
      ++ value used during creation of x via a call to the identity
      ++ function, i.e., offset(x) is a member of orbit(x).
    coefficient: % -> C
      ++ coefficient(x) is the coefficient that results from a
      ++ reduction process in case it cannot be inverted. For a
      ++ coefficient field, it will give 1.
    coExponents: % -> List Z
      ++ coExponent(x) returns the exponent vector r of an eta
      ++ quotient that must be muliplied to the orbit product in order
      ++ to obtain a modular function.
    moduleCoefficients: % -> List SUP C
      ++ moduleCoefficients(x) gives the list of coefficients that
      ++ correspond to the eta-quotients given by
      ++ etaQuotientMonoidExponentVectors(x). And form the relation
      ++ that that was computed. note that the first entry of
      ++ etaQuotientMonoidExponentVectors(x) must be replaced by 0 in
      ++ order to make this relation a true relation.
    etaQuotientMonoidExponentVectors: % -> List List Z
      ++ etaQuotientMonoidExponentVectors(%) returns the exponent
      ++ vectors of the eta-quotients that generate the monoid of all
      ++ eta-quotients.
    identityPolynomial: % -> Pol C
      ++ identityPolynomial(x) gives the representation of the
      ++ identity as a polynomial (which equates to zero. This
      ++ polynomial is in terms of the variables F and Mi where F
      ++ corresponds to the orbit product together with a prefactor to
      ++ turn this orbit product into a modular function and the Mi
      ++ correspond to eta-quotients given by
      ++ etaQuotientMonoidExponentVectors(x).
    orbitProduct: % -> OutputForm
      ++ orbitProduct(x) returns the orbit product as an OutputForm.

-------------------------------------------------------------------

    -- The var-functions are helper functions for printing etaQuotients.
    -- They print the i-th variable.
    var: Symbol -> Z -> OutputForm
    varsub: Symbol -> Z -> OutputForm
    varEta: Z -> OutputForm
    varPochhammer: Z -> OutputForm

    varPower: (Z, Z, Z -> OutputForm) -> OutputForm
    monomial: (List Z, List Z, Z -> OutputForm) -> OutputForm
    monomialQuotient: (List Z, List Z, Z -> OutputForm) -> OutputForm

    etaQuotient: (P, List Z, Z -> OutputForm) -> OutputForm
      ++ etaQuotient(n, r, v) returns the eta-quotient of level n
      ++ connected to the exponent vector r where each part is
      ++ formatted by the function v.
    qQuotient: (P, List Z, Z -> OutputForm, Q) -> OutputForm
      ++ qQuotient(n, r, v, e) returns the eta-quotient of level n
      ++ connected to the exponent vector r where each part is
      ++ formatted by the function v. The whole eta-quatient comes
      ++ multiplied with a q power with exponent e.
    qEtaQuotient: (P, List Z, Z -> OutputForm) -> OutputForm
      ++ qEtauotient(n, r, v) returns qQuotient(n, r, v, e) with
      ++ e=(sigmaInfinity(n, r)$QEtaKolberg)/24.

    f:  (%, Z -> OutputForm, Z, C, Q, List Z) -> OutputForm

    etaRelationMonomial: (P, SUP C, L Z, Z -> OutputForm, Z, Q) -> OutputForm
      ++ etaRelationMonomial(n, ci, ri, v, style, e) return an
      ++ eta-quoatient of level n with exponent vector ri and
      ++ coefficient ci which is multiplied by q^e with variables
      ++ given through v and in a form given by style.

    etaRelation: (P, List SUP C, List List Z, Z -> OutputForm, Z, C, Q, List Z)
        -> OutputForm
      ++ etaRelation(n, cis, bas, v, style, c, e, r) returns the
      ++ eta-relation part multiplied by c*q^e*etaQuotient(n,r).

    pretty: (%, Z -> OutputForm, Z, C, Q, List Z) -> OutputForm
      ++ pretty(x, v, style, c, e, r) outputs x as computed in
      ++ eta-quotients, but multiplied by c*q^e*etaQuotient(n,r).

    pretty: (%, Z -> OutputForm, Z) -> OutputForm
      ++ pretty(x, v, style) outputs x as computed with respect to a
      ++ style given by the style parameter. If the lowest bit is set
      ++ in style then, the q factor is shown. If the first bit is
      ++ set, then the t parameter is replaces by the respective
      ++ eta-quotient, so that the coefficients will just be elements
      ++ of the coefficient domain.

    pretty: (%, Z -> OutputForm) -> OutputForm
      ++ pretty(x, v) returns pretty(x, v, 0)

    nice: (%, Z -> OutputForm, Z) -> OutputForm
      ++ nice(x, v, style) outputs x as computed with respect to a
      ++ style given by the style parameter, but with the eta-quotient
      ++ and the coefficient divided through. If the lowest bit is set
      ++ in style then, the q factor is shown. If the first bit is
      ++ set, then the t parameter is replaces by the respective
      ++ eta-quotient, so that the coefficients will just be elements
      ++ of the coefficient domain.

    nice: (%, Z -> OutputForm) -> OutputForm
      ++ nice(x, v) returns nice(x, v, 0)

-------------------------------------------------------------------

    sumX: (BasicOperator, Symbol, P, N) -> EX
    orbitProductX: % -> EX
    monomialX: (List Symbol, List Z) -> Pol C
    monomialQuotientX: (List Symbol, List Z) -> Fraction Pol C
    etaQuotientX: (P, List Z, String) -> Fraction Pol C
    coFactorX: % -> Fraction Pol C
    qcoFactorX:% -> Fraction Pol C

  Implementation ==> add
    Rep ==> Record(fnn: P,_
                   fr: List Z,_
                   fmm: P,_
                   fs: List Z,_
                   fmultiplier: P,_
                   foffset: N,_
                   frgens: List List Z,_
                   fpol: Pol C,_
                   fcf: C,_
                   fcis: List SUP C)

    xx ==> rep x

    pol2sup(pol: Pol C, sym: Symbol): SUP C ==
        z: SUP C := 0
        for m in reverse monomials pol repeat
            mon: SUP C := monomial(- leadingCoefficient m, degree(m, sym))
            z := mon + z
        z

    identity(nn: P, r: List Z, mm: P, s: List Z, m: P, t: N, _
             rgens: List List Z, pol: Pol C): % ==

        fsym: Symbol := "F"::Symbol
        msyms: List Symbol := indexedSymbols("M", #rgens)$QAuxiliaryTools

        cf: C := ground coefficient(pol, fsym, 1)
        modrel: Pol C := coefficient(pol, fsym, 0)

        cis: List Pol C := [coefficient(modrel, msym, 1) for msym in rest msyms]
        c1: Pol C := coefficient(modrel, rest msyms, [0 for i in rest msyms])
        cis := cons(c1, cis) -- These are univariate polynomials in M1.

        tsym: Symbol := first msyms
        rel: List SUP C := [pol2sup(c, tsym) for c in cis]

        per [nn, r, mm, s, m, t, rgens, pol, cf, rel]

    level(x: %): P == xx.fnn
    definingLevel(x: %): P == xx.fmm
    definingExponents(x: %): List Z == xx.fs
    coExponents(x: %): List Z == xx.fr
    multiplier(x: %): P == xx.fmultiplier
    offset(x: %): N == xx.foffset
    coefficient(x: %): C == xx.fcf
    moduleCoefficients(x: %): List SUP C == xx.fcis
    etaQuotientMonoidExponentVectors(x: %): List List Z == xx.frgens
    identityPolynomial(x: %): Pol C == xx.fpol

    alphaInfinity(x: %): Z ==
        m: P := multiplier x
        k: N := offset x
        mm: P := definingLevel x
        s: List Z := definingExponents x
        alphaInfinity(level x, coExponents x, mm, s, m, k)$QEtaKolberg

    alphaEtaInfinity(x: %): Q ==
        rhat: Z := sigmaInfinity(level x, coExponents x)$QEtaKolberg
        alphaInfinity(x)::Q - rhat/24

    orbit(x: %): List N == orbit(definingLevel x, definingExponents x,
                                 multiplier x, offset x)$QEtaKolberg

    oeq(x, y) ==> ((concat(x,"(x)")$String)::Symbol::OF) = (y::OF)
    coerce(x: %): OutputForm ==
        lvl: OF := oeq("level", level x)
        deflvl: OF := oeq("definingLevel", definingLevel x)
        defex: OF := oeq("definingExponents", definingExponents x)
        coex: OF := oeq("coExponents", coExponents x)
        m: OF := oeq("multiplier", multiplier x)
        orb: OF := oeq("orbit", orbit x)
        cf: OF := oeq("coefficient", coefficient x)
        alpha: OF := oeq("alphaInfinity", alphaInfinity x)
        rgens: OF :=  oeq("etaQuotientMonoidExponentVectors",
                          etaQuotientMonoidExponentVectors x)
        idpol: OF := oeq("identityPolynomial", identityPolynomial x)
        vconcat [lvl, coex, deflvl, defex, m, orb, cf, alpha, rgens, idpol]

    sum(a: OF, n: OF, m: P, t: N): OF ==
        out: OF := m::OF * n
        if not zero? t then out := out + t::OF
        q: OF := "q"::Symbol::OF
        out := prefix(a, [out]) -- builds a(m*n+t)
        sum(out*q^n, n=0::OF, "infinity"::Symbol::OF)

    orbitProduct(x: %): OF ==
        n: OF := "n"::Symbol::OF
        a: OF := "a"::Symbol::OF
        orb: List N := sort orbit x
        t := first orb
        out: OF := sum(a, n, multiplier x, t)
        for k in rest orb repeat out := out * sum(a, n, multiplier x, k)
        out

-------------------------------------------------------------------

    var(sy: Symbol): Z -> OF == (d: Z): OF +->
        concat(string sy, convert(d)@String)::Symbol::OF

    varsub(sy: Symbol): Z -> OF == (d: Z): OF +-> sub(sy::OF, d::OF)$OF

    varEta(d: Z): OF ==
        tau := "τ"::Symbol::OF
        eta := "η"::Symbol::OF
        one? d => prefix(eta, [tau])$OF
        prefix(eta, [(d::OF)*tau])$OF

    varPochhammer(d: Z): OF ==
        q := "q"::Symbol::OF
        one? d => sub(paren([q, q]$List(OF)), "%Infinity"::Symbol::OF)
        l := [q^(d::OF), q^(d::OF)]$List(OF)
        sub(paren l, "%Infinity"::Symbol::OF)

    varPower(d: Z, rd: Z, v: Z -> OF): OF ==
        --assert(not zero? rd)
        one? rd => v(d)
        v(d)^(rd::OF)

    monomial(divs: List Z, r: List Z, v: Z -> OF): OF ==
        zero?(vector(r)$Vector(Z)) => (1$Z)::OF
        l := [varPower(d,rd,v) for d in divs for rd in r|not zero? rd]$List(OF)
        reduce(_*, l)$List(OF)

    monomialQuotient(divs: List Z, r: List Z, v: Z -> OF): OF ==
        num: OF := monomial(divs, [max(0,  rd) for rd in r], v)
        neg: List Z := [max(0, -rd) for rd in r]
        zero?(vector(neg)$Vector(Z)) => num
        num / monomial(divs, neg, v)

    etaQuotient(n: P, r: List Z, v: Z -> OF): OF ==
        divs: List Z := divisors(n)$IntegerNumberTheoryFunctions
        monomialQuotient(divs, r, v)

    qQuotient(n: P, r: List Z, v: Z -> OF, e: Q): OF ==
        eq := etaQuotient(n, r, v)
        zero? e => eq
        q: OF := "q"::Symbol::OF
        one? e => q * eq
        q^(e::OF) * eq

-------------------------------------------------------------------
    -- local function
    withQFactor?(style: Z): Boolean == odd? style
    expand?(style: Z): Boolean == bit?(style, 1)
    plus(la: List Z, lb: List Z): List Z == [a + b for a in la for b in lb]
    times(z: Z, r: List Z): List Z == [z*rd for rd in r]

    zeroExponents(nn: P): List Z ==
        n: Z := numberOfDivisors(nn)$IntegerNumberTheoryFunctions
        [0 for i in 1..n]

    -- replace first exponent vector by 0 (basis of the module)
    basis(x: %): List List Z ==
        rgens: List List Z := etaQuotientMonoidExponentVectors x
        cons([0 for rd in first rgens], rest rgens)

-------------------------------------------------------------------

    f(x: %, v: Z -> OF, style: Z, c: C, e: Q, r: List Z): OF ==
        e := e + alphaEtaInfinity x
        r := plus(r, coExponents x)
        if withQFactor? style then
            e: Q := e + (sigmaInfinity(level x, r)$QEtaKolberg)/24
        cofact: OF := qQuotient(level x, r, v, e)
        out: OF := orbitProduct x
        if not(zero? e and every?(zero?, r)) then out := cofact * out
        cf: C := c * coefficient x
        one? cf => out
        one?(-cf) => - out
        cf::OF * out

-------------------------------------------------------------------

    etaRelationMonomial(nn: P, c: SUP C, r: List Z,
                        v: Z -> OF, style: Z, e: Q): OF ==
        pol: OF := outputForm(c, "t"::Symbol::OF)
        if withQFactor? style then
            e := e + (sigmaInfinity(nn, r)$QEtaKolberg)/24
        eq: OF := qQuotient(nn, r, v, e)
        one? c => eq
        zero?(vector(r)$Vector(Z)) => pol
        pol * eq

    etaRelation(nn: P, cis: List SUP C, rgens: List List Z, v: Z -> OF,
                style: Z, c: C, e: Q, r: List Z): OF ==
        l := [etaRelationMonomial(nn, c*ci, plus(r, rr), v, style, e)
              for ci in cis for rr in rgens | not zero? ci]
        empty? l => (0$Z)::OF
        reduce(_+, l)

-------------------------------------------------------------------

    pretty(x: %, v: Z -> OF, style: Z, c: C, e: Q, r: List Z): OF ==
        cis: List SUP C := moduleCoefficients x
        bas: List List Z := basis x
        if expand? style then
            t: List Z := first etaQuotientMonoidExponentVectors x
            lots: List List Record(k: N, c: C) := [listOfTerms ci for ci in cis]
            --assert(#bas=#cis)
            --assert(#bas=#lots)
            cis := concat [[(rec.c)::SUP(C) for rec in lot] for lot in lots]
            bas := concat [[plus(times(rec.k, t), b) for rec in lot]
                           for lot in lots for b in bas]
        er: OF := etaRelation(level x, cis, bas, v, style, c, e, r)
        (f(x, v, style, c, e, r) = er)$OF

    pretty(x: %, v: Z -> OF, style: Z): OF ==
        pretty(x, v, style, 1, 0, zeroExponents level x)

    pretty(x: %, v: Z -> OF): OF == pretty(x, v, 0)

    nice(x: %, v: Z -> OF, style: Z): OF ==
        cf: C := coefficient x
        invcf: Union(C, "failed") := 1$C exquo cf
        icf: C := if invcf case "failed" then 1$C else invcf::C
        r: List Z := [- rd for rd in coExponents x]
        pretty(x, v, style, icf, - alphaEtaInfinity x, r)

    nice(x: %, v: Z -> OF): OF == nice(x, v, 0)

-------------------------------------------------------------------
-- Return parts as expressions, polynomial, or rational functions.

    sumX(a: BasicOperator, n: Symbol, m: P, t: N): EX ==
        ex: EX := m * (n::EX)
        if not zero? t then ex := ex + t::EX
        ex := a(ex) -- builds a(m*n+t)
        infty: EX := "%Infinity"::Symbol::EX
        summation(ex, equation(n, segment(0, infty)))$EX

    orbitProductX(x: %): EX ==
        n: Symbol := "n"::Symbol
        a: BasicOperator := operator("a"::Symbol)
        orb: List N := sort orbit x
        ex: EX := sumX(a, n, multiplier x, first orb)
        for k in rest orb repeat ex := ex * sumX(a, n, multiplier x, k)
        ex

    monomialX(vars: List Symbol, r: List Z): Pol C ==
        l: List Pol C := [(v::Pol(C))^(rd::N) for v in vars for rd in r]
        reduce(_*, l, 1)

    monomialQuotientX(vars: List Symbol, r: List Z): Fraction Pol C ==
        num: Pol C := monomialX(vars, [max(0,  rd) for rd in r])
        neg: List Z := [max(0, -rd) for rd in r]
        den: Pol C := monomialX(vars, neg)
        num / den

    etaQuotientX(n: P, r: List Z, var: String): Fraction Pol C ==
        divs: List Z := divisors(n)$IntegerNumberTheoryFunctions
        vsyms: List Symbol := indexedSymbols(var, divs)$QAuxiliaryTools
        monomialQuotientX(vsyms, r)

    coFactorX(x: %): Fraction Pol C ==
        nn: P := level x
        eq: Fraction Pol C := etaQuotientX(nn, coExponents x, "E")
        e: Z := numer(24*alphaEtaInfinity(x))
        zero? e => eq
        xvar: Fraction Pol(C) := "x"::Symbol::Pol(C)::Fraction(Pol C)
        xvar^e * eq

    qcoFactorX(x: %): Fraction Pol C ==
        eq: Fraction Pol C := etaQuotientX(level x, coExponents x, "u")
        alpha: Z := alphaInfinity x
        zero? alpha => eq
        q: Fraction Pol(C) := "q"::Symbol::Pol(C)::Fraction(Pol C)
        q^alpha * eq

    -- unused
    qEtaQuotient(n: P, r: List Z, v: Z -> OF): OF ==
        qQuotient(n, r, v, (sigmaInfinity(n, r)$QEtaKolberg)/24)



)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolberg}
\label{sec:QEtaRamanujanKolberg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



)endif

)abbrev package QETARK QEtaRamanujanKolberg
++ QEtaRamanujanKolberg provides functions to compute
++ Ramanujan-Kolberg identities by an algorithm that was developed by
++ Radu in \cite{Radu:RamanujanKolberg:2015}
++ (`DOI=10.1016/j.jsc.2014.09.018
++ <https://doi.org/10.1016/j.jsc.2014.09.018>`_), see `RISC Report
++ 16-06
++ <https://www.risc.jku.at/publications/download/risc_5069/zzz3.pdf>`_.
++ See also at the top of the qetark.spad file where this package is
++ implemented.
QEtaRamanujanKolberg(C): Exports == Implementation where
  C: EuclideanDomain -- basic coefficient domain
  IDENTITY ==> QEtaRamanujanKolbergIdentity C
  Exports ==> with
    findIdentity: (P, List Z, P, List Z, P, N, List List Z) -> IDENTITY
      ++ findIdentity(nn, r, mm, s, m, k, rgens) returns all data for a
      ++ Ramanujan-Kolberg identity.
    findIdentity: (P, List Z, P, List Z, P, N) -> IDENTITY
      ++ findIdentity(nn, r, mm, s, m, k) returns all data for a
      ++ Ramanujan-Kolberg identity.
    findIdentity: (P, P, List Z, P, N, List List Z) -> IDENTITY
      ++ findIdentity(nn, mm, s, m, k, rgens) returns all data for a
      ++ Ramanujan-Kolberg identity.
    findIdentity: (P, P, List Z, P, N) -> IDENTITY
      ++ findIdentity(nn, mm, s, m, k) returns all data for a
      ++ Ramanujan-Kolberg identity.
  Implementation ==> add
    findIdentity(nn: P, r: List Z, mm: P, s: List Z, m: P, t: N,_
                 rgens: List List Z): IDENTITY ==

        -- First compute the expansion of the orbit product.
        eulerquo: T1 C := taylorRep(eulerQuotient(mm, s)$ETA(C))

        orb: List N := orbit(mm, s, m, t)$QEtaKolberg
        tt := first orb
        p: T1 C := multisect(m-tt, tt, eulerquo)
        -- Now multiply the series selecting sum_{n=0}^\infty a(m*n+k)q^n.
        for k in rest orb repeat p := p * multisect(m-k, k, eulerquo)

        -- The expansion of the coFactor is here.
        -- We take care of the right q-order through alphaInfinity.
        cofact: T1 C := taylorRep(eulerQuotient(nn, r)$ETA(C))

        -- We multiply both things together to get (nearly) a modular
        -- function.
        tf: T1 C := cofact * p

        -- We have to multiply by some q-power to get the expansion of
        -- a modular function f.
        alpha: Z := alphaInfinity(nn, r, mm, s, m, t)$QEtaKolberg
        f: A1 C := laurent(alpha, tf)$A1(C)

        -- For the following computation we attach a marker to the
        -- series.
        fsym: Symbol := "F"::Symbol
        xf: X1 C := toX1(C, f, fsym::Pol(C))

        eqgens: List ETA(C) := [etaQuotient(nn, rv)$ETA(C) for rv in rgens]
        egens: List A1(C) := [expansion e for e in eqgens]

        -- We attach some identifiers also to those eta-quotients.
        msyms: List Symbol := indexedSymbols("M", #rgens)$QAuxiliaryTools
        xgens := [toX1(C, x, sym::Pol(C)) for x in egens for sym in msyms]

        -- Eventualle, we apply the samba algorithm to obtain an
        -- order-complete basis.
        import from QXTOPRED1(C) -- necessary, because the next wouldn't compile
        xab: QXAB1(C) := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

        -- We look of a representation of our original modular function f in
        -- the respective module of eta-quotients that is represented by
        -- the algebra-basis xab.
        xz: X1(C) := reduce(xf, xab)$QXTOPRED1(C)

        -- If xz is non-zero, then no relation has been found.
        not zero? xz => identity(nn, r, mm, s, m, t, rgens, 0$Pol(C))

        pol := second(xz)::Pol(C)

        identity(nn, r, mm, s, m, t, rgens, pol)

    findIdentity(nn: P, r: List Z, mm: P, s: List Z, m: P, t: N): IDENTITY ==
        -- We compute the basis for the modular eta-quotients of level nn.
        rgens: List List Z := etaQuotientMonoidExponentVectors(nn)$QEQEV
        findIdentity(nn, r, mm, s, m, t, rgens)

    findIdentity(nn: P, mm: P, s: List Z, m: P, t: N,
                 rgens: List List Z): IDENTITY ==
        import from QEtaModularFunctionTools
        r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)
        findIdentity(nn, r, mm, s, m, t, rgens)

    findIdentity(nn: P, mm: P, s: List Z, m: P, t: N): IDENTITY ==
        import from QEtaModularFunctionTools
        r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)
        findIdentity(nn, r, mm, s, m, t)




)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
