-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2020-2021  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

\lstset{literate=%
  {τ}{{$\tau$}}1%
  {η}{{$\eta$}}1%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Using the QEta package to find Ramanujan-Kolberg identities}
\author{Ralf Hemmecke}
\date{29-Oct-2020}
\maketitle
\begin{abstract}
  The package \qetatype{QEtaRamanujanKolberg} implements functions to
  help finding Ramanujan-Kolberg identities. The found identities and
  accompanying data is stored in the
  \qetatype{QEtaRamanujanKolbergIdentity} data structure.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu_RamanujanKolberg_2015}.

Let $M$ be a positive integer and $r=(r_\delta)_{\delta|M}$ be a
sequence of integers indexed by the positive divisors of $M$. Define a
sequence $a(n)$ by
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M} \prod_{n=1}^\infty (1-q^{\delta n})^{r_\delta}
  =
  \prod_{\delta|M} (q^\delta; q^\delta)_\infty^{r_\delta}
\end{gather*}
where
\begin{gather*}
(u; q)_\infty = \prod_{n=0}^\infty (1-uq^n)
\end{gather*}
is the $q$-Pochhammer symbol.

Given $N$, $m$, and $t \in \{0,\ldots,m-1\}$, we want to compute a
sequence $s=(s_\delta)_{\delta|N}$ of integers, a set
$\mathcal{O}_{r,m,t}\subseteq\{0,\ldots,m=1\}$, eta-quotients
$b_i \in M^\infty(N)$, and numbers $c_i\in \mathbb{Q}$ uch that
\begin{gather*}
q^\alpha \prod_{\delta|N} \prod_{n=1}^\infty (1-q^{\delta n})^{s_\delta}
\times
\prod_{t'\in \mathcal{O}(r,m,t)} \sum_{n=0}^\infty a(mn+t')q^n
=
\sum_{i=1}^k c_i b_i
\end{gather*}
where
\begin{gather*}
\alpha = \sum_{\delta|N} \frac{\delta s_\delta}{24}
         +
         \sum_{t'\in \mathcal{O}(r,m,t)}
             \frac{24 t' + \sum_{\delta|M} \delta r_\delta}{24m}
\end{gather*}
and $M^\infty(N)$ is the set of modular functions on $\Gamma_0(N)$
with a pole at most at infinity.

Each of the eta-quotients is given through a sequence
$r^{(i)}=\left(r^{(i)}_\delta\right)_{\delta|N}$ of integers in its
$q$-expansion at infinity.
\begin{gather*}
  b_i
  = q^{\beta_i} \prod_{\delta|N}
                      \prod_{n=1}^\infty (1-q^{\delta n})^{r^{(i)}_\delta}
  =
  q^{\beta_i} \prod_{\delta|N} (q^\delta, q^\delta)_\infty^{r^{(i)}_\delta}.
\end{gather*}
with
\begin{gather*}
  \beta_i = \sum_{\delta|N} \frac{\delta r^{(i)}_\delta}{24}
\end{gather*}


For mathematical background see \PathName{qeta.tex}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

PP ==> PositiveInteger
NN ==> NonNegativeInteger
ZZ ==> Integer
QQ ==> Fraction ZZ
LZZ ==> List ZZ
INDICES ==> List LZZ

Pol ==> Polynomial
SUP ==> SparseUnivariatePolynomial
QETAAUX ==> QEtaAuxiliaryPackage;

asPP x ==> x pretend PP

T1 C ==> QEtaTaylorSeries C
L1 C ==> QEtaLaurentSeries C
A1 C ==> Finite0Series C
CA1 C ==> QEtaAlgebraCachedPower(C, A1 C) -- computation domain (cached)
CPol C ==> QEtaAlgebraCachedPower(C, Pol C) -- computation pols in (cached)
X1 C ==> QEtaExtendedAlgebra(C, CA1 C, CPol C)
toX1(C, a, b) ==> embed(a::CA1(C), b::CPol(C))$X1(C)

QXAB1 C ==> QEtaAlgebraBasis(C, X1 C)
QXTOPRED1 C ==> QEtaTopReduction(C, X1 C, QXAB1 C)
QXTOPCOMP1 C ==> QEtaComputation(C, X1 C, QXAB1 C, QXTOPRED1 C)
QXTOPSAMBA1 C ==> QEtaSambaPackage(C, X1 C, QXAB1 C, QXTOPCOMP1 C)

SPEC ==> QEtaSpecification
SPECS ==> List SPEC

specMODA1 C ==> _
  modularEtaQuotientInfinity $ QEtaModularInfinityExpansion(C, QMOD)

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain QEtaRamanujanKolbergIdentity}
\label{sec:QEtaRamanujanKolbergIdentity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We provide here a domain that prints nicely as an identity and has
enough access functions to extract various components of the identity
for easier manipulation.


)endif


)abbrev domain QETARKI QEtaRamanujanKolbergIdentity
++ QEtaRamanujanKolbergIdentity is a container that holds all relevant
++ data describing a Ramanujan-Kolberg identity.
QEtaRamanujanKolbergIdentity(C): Exports == Implementation where
  C: EuclideanDomain -- basic coefficient domain (EntireRing if without xab)
  L ==> List
  EX ==> Expression C
  Exports ==> CoercibleTo OutputForm with
    -- constructor
    identity: (SPEC, SPEC, PP, List NN, SPECS, Pol C, QXAB1(C)) -> %
      ++ identity(sspec, rspec, m, orb, bspecss, rel, xab) returns a
      ++ structure that represents all information about the
      ++ q-expansion of $F_{s,r,m,t}$ at infinity, see Definition of
      ++ $F_{s,r,m,t}$ in qeta.tex,
      ++ Equation~\eqref{eq:F_s-r-m-t(tau)}. The relations is then
      ++ c*F=sum_{i}(rel(i)*etaQuotient(bspecs(i))) where F
      ++ corresponds to the modular function $F_{s,r,m,t}$ in
      ++ question. t is an element of orb.
      ++ At the same time this data structure serves as a container
      ++ for a generalized eta-quotient identity for
      ++ $F_{\bar{s},\bar{r},m,t}(\tau)$.

    -- accessor functions
    coSpecification: % -> SPEC
      ++ coExponent(x) returns the specification for the cofactor
      ++ (generalized) eta-quotient that must be muliplied to the
      ++ orbit product in order to obtain a modular function.
    definingSpecification: % -> SPEC
      ++ definingSpecification(x) returns the specification of
      ++ (generalized) eta-quotient that forms the generating series
      ++ of the coefficients a(n), i.e., \sum_{n=0}^\infty a(n)q^n =
      ++
    multiplier: % -> PP
      ++ multiplier(x) returns factor m to select a certain
      ++ subsequence a(m*n+k) of the defining series (where k is one
      ++ number out of orbit(x).
    orbit: % -> List NN
      ++ orbit(x) returns the orbit, i.e., only a product of the
      ++ generating series for $a(m*n+k)$ for all k in the orbit can
      ++ be turned into a modular function (for Gamma0) by multiplying
      ++ it with an eta-quotient.
    monoidSpecifications: % -> SPECS
      ++ monoidSpecifications(x) returns the specifications of the
      ++ (generalized) eta-quotients that form the combination of the
      ++ identity. The first non-constant element of this basis is the
      ++ special element t so that the relation is actually formed by
      ++ the module over C[t] generated by 1 and rest
      ++ monoidSpecifications(x).
    nonConstantMonoidSpecifications: % -> SPECS
      ++ monoidSpecifications(x) returns specifications for modular
      ++ (generalized) eta-quotients with a pole only at infinity.
      ++ nonConstantMonoidSpecifications(x) returns those elements of
      ++ monoidSpecifications(x) whose pole order at infinity is
      ++ positive.
    identityPolynomial: % -> Pol C
      ++ identityPolynomial(x) gives the representation of the
      ++ identity as a polynomial (which equates to zero. This
      ++ polynomial is in terms of the variables F and Mi where F
      ++ corresponds to the orbit product together with a prefactor to
      ++ turn this orbit product into a modular function and the Mi
      ++ correspond to eta-quotients given by
      ++ etaQuotientMonoidSpecifications(x).
    coefficient: % -> C
      ++ coefficient(x) is the coefficient of F in
      ++ identityPolynomial(x) that results from a reduction process
      ++ in case it cannot be inverted. For a coefficient field, it
      ++ will give 1.
    moduleCoefficients: % -> List SUP C
      ++ moduleCoefficients(x) gives the list of coefficients that
      ++ correspond to the (generalized) eta-quotients given by
      ++ nonConstantMonoidSpecifications(x) and form the relation that
      ++ that was computed. Note that the first entry of
      ++ nonConstantMonoidSpecifications(x) must be replaced by 1 in
      ++ order to make this relation a true relation.

    alphaInfinity: % -> ZZ
      ++ alphaInfinity(x) returns the q exponent that corresponds to
      ++ the orbit product and the respective co-exponent in order to
      ++ make the whole product a modular function. It is defined
      ++ already in the abstract of \cite{Radu_RamanujanKolberg_2015}.
    alphaOrbitInfinity: % -> QQ
      ++ alphaOrbitInfinity(x)=
      ++ alphaInfinity-(1/24)*sigmaInfinity(coSpecification(x))
    orbitProduct: % -> OutputForm
      ++ orbitProduct(x) returns the orbit product as an OutputForm.

    algebraBasis: % -> QXAB1(C)
      ++ algebraBasis(x) returns the algebra basis that was given at
      ++ creation time.

-------------------------------------------------------------------

    -- The var-functions are helper functions for printing etaQuotients.
    -- They print the i-th variable.
    var: Symbol -> (ZZ, ZZ) -> OutputForm
    varsub: Symbol -> (ZZ, ZZ) -> OutputForm
    varEta: (ZZ, ZZ) -> OutputForm
    varPochhammer: (ZZ, ZZ) -> OutputForm

    varPower: (LZZ, (ZZ, ZZ) -> OutputForm) -> OutputForm
    monomial: (SPEC, (ZZ, ZZ) -> OutputForm) -> OutputForm
    monomialQuotient: (SPEC,  (ZZ, ZZ) -> OutputForm) -> OutputForm

    etaQuotient: (SPEC, (ZZ, ZZ) -> OutputForm) -> OutputForm
      ++ etaQuotient(rspec, v, e) returns the generalized eta-quotient
      ++ given by rspec where each part is
      ++ formatted by the function v.
    qQuotient: (SPEC, (ZZ, ZZ) -> OutputForm, QQ) -> OutputForm
      ++ qQuotient(rspec, v, e) returns the generalized eta-quotient
      ++ given by rspec where each part is
      ++ formatted by the function v. The whole eta-quatient comes
      ++ multiplied with a q power with exponent e.
    qEtaQuotient: (SPEC, (ZZ, ZZ) -> OutputForm) -> OutputForm
      ++ qEtauotient(rspec, v) returns qQuotient(rspec, v, e) with
      ++ e=sigmaInfinity(rspec)/24.

    f: (%, ZZ, (ZZ, ZZ) -> OutputForm, C, QQ, SPEC) -> OutputForm

    etaRelationMonomial: (SUP C, SPEC, ZZ, (ZZ, ZZ) -> OF, QQ) -> OF
      ++ etaRelationMonomial(ci, rspec, fmt, v, e) return an
      ++ eta-quoatient given by rspec and coefficient ci which is
      ++ multiplied by q^e with variables given through v and in a
      ++ form given by fmt.

    etaRelation: (List SUP C, SPECS, ZZ, (ZZ, ZZ) -> OF, C, QQ, SPEC) -> OutputForm
      ++ etaRelation(cis, bas, fmt, v, c, e, sspec) returns the
      ++ eta-relation part multiplied by c*q^e*etaQuotient(sspec).

    pretty: (%, ZZ, (ZZ, ZZ) -> OF, C, QQ, SPEC) -> Equation OutputForm
      ++ pretty(x, fmt, v, c, e, sspec) outputs x as computed in
      ++ eta-quotients, but multiplied by c*q^e*etaQuotient(sspec).

    pretty: (%, ZZ, (ZZ, ZZ) -> OutputForm) -> Equation OutputForm
      ++ pretty(x, fmt, v) outputs x as computed with respect to a
      ++ style given by the fmt parameter. If the lowest bit is set
      ++ in fmt then, the q factor is shown. If the bit 1 is
      ++ set, then the t parameter is replaces by the respective
      ++ eta-quotient, so that the coefficients will just be elements
      ++ of the coefficient domain.

    pretty: (%, ZZ) -> Equation OutputForm
      ++ pretty(x, fmt) returns pretty(x, fmt, v) where v is a
      ++ variable indexing function chosen by bit 3 and 4 of fmt
      ++ according to the rules. If bit3=0, then variables are used.
      ++ If bit0=0, then the variable is "E" otherwise it is "u". If
      ++ bit4=0, then no subscripts are uses, bit4=1 means subscripts.
      ++ If bit3=1, then expressions are used. If bit0=0, then
      ++ v=varEta. If bit0=1, then v=varPochhammer.

-------------------------------------------------------------------

    -- Functions with X at their end give expressions or polynomial
    -- representations of the data.

    if C has Comparable then
        monomialX: (SPEC, Symbol) -> EX
        monomialQuotientX: (SPEC, Symbol) -> EX
        etaQuotientX: (SPEC, Symbol) -> EX
        sumX: (BasicOperator, Symbol, PP, NN) -> EX
        orbitProductX: % -> EX
        orbitProductX: (%, Symbol) -> EX
        cofactorX: % -> EX
        qcofactorX: % -> EX
        equationX: (%, Symbol) -> Equation EX
        equationX: % -> Equation EX
        qequationX: (%, Symbol) -> Equation EX
        qequationX: % -> Equation EX

    -- some auxiliary functions that might have to be moved elsewhere
    nonConstantMonoidSpecifications: SPECS -> SPECS
      ++ monoidSpecifications(x) returns specifications for modular
      ++ (generalized) eta-quotients with a pole only at infinity.
      ++ nonConstantMonoidSpecifications(x) returns those elements of
      ++ monoidSpecifications(x) whose pole order at infinity is
      ++ positive.

  Implementation ==> add
    Rep ==> Record(fsspec: SPEC,_
                   frspec: SPEC,_
                   fmultiplier: PP,_
                   forbit: List NN,_
                   fbasis: SPECS,_
                   fpol: Pol C,_
                   fcf: C,_
                   fcis: List SUP C,
                   fab: QXAB1 C)

    xx ==> rep x

    -- local for the implementation of "identity"
    pol2sup(pol: Pol C, sym: Symbol): SUP C ==
        z: SUP C := 0
        for m in reverse monomials pol repeat
            mon: SUP C := monomial(- leadingCoefficient m, degree(m, sym))
            z := mon + z
        z

    -- constructor
    identity(sspec: SPEC, rspec: SPEC, m: PP, orb: List NN, _
             bspecs: SPECS, pol: Pol C, xab: QXAB1 C): % ==

        fsym: Symbol := "F"::Symbol
        msyms: List Symbol := indexedSymbols("M", #bspecs)$QAuxiliaryTools

        cf: C := ground coefficient(pol, fsym, 1)
        modrel: Pol C := coefficient(pol, fsym, 0)

        cis: List Pol C := [coefficient(modrel, msym, 1) for msym in rest msyms]
        c1: Pol C := coefficient(modrel, rest msyms, [0 for i in rest msyms])
        cis := cons(c1, cis) -- These are univariate polynomials in M1.

        tsym: Symbol := first msyms
        rel: List SUP C := [pol2sup(c, tsym) for c in cis]

        per [sspec, rspec, m, orb, bspecs, pol, cf, rel, xab]

    -- accessor functions
    coSpecification(x: %): SPEC == xx.fsspec
    definingSpecification(x: %): SPEC == xx.frspec
    multiplier(x: %): PP == xx.fmultiplier
    orbit(x: %): List NN == xx.forbit
    monoidSpecifications(x: %): SPECS == xx.fbasis
    identityPolynomial(x: %): Pol C == xx.fpol
    coefficient(x: %): C == xx.fcf
    moduleCoefficients(x: %): List SUP C == xx.fcis
    algebraBasis(x: %): QXAB1(C) == xx.fab

    -- local
    constant?(spec: SPEC): Boolean ==
        --assume that spec represents a modular eta-quotient with
        --a pole at most at infinity
        sigmaInfinity spec >= 0

    nonConstantMonoidSpecifications(mspecs: SPECS): SPECS ==
        [mspec for mspec in mspecs | not constant? mspec]

    nonConstantMonoidSpecifications(x: %): SPECS ==
        nonConstantMonoidSpecifications monoidSpecifications x

    -- auxiliary stuff
    alphaInfinity(x: %): ZZ ==
        ai ==> alphaInfinity $ SPEC
        ai(coSpecification x, definingSpecification x, multiplier x, orbit x)

    -- exponent without the cofactor
    alphaOrbitInfinity(x: %): QQ ==
        sbarhat: QQ := sigmaInfinity coSpecification x
        alphaInfinity(x)::QQ - (1/24)*sbarhat

    -- output stuff
    oeq(x, y) ==> ((concat(x,"(x)")$String)::Symbol::OF) = (y::OF)
    coerce(x: %): OutputForm ==
        cospec: OF := oeq("coSpecification", coSpecification x)
        defspec: OF := oeq("definingSpecification", definingSpecification x)
        m: OF := oeq("multiplier", multiplier x)
        orb: OF := oeq("orbit", orbit x)
        bas: OF :=  oeq("monoidSpecifications", monoidSpecifications x)
        idpol: OF := oeq("identityPolynomial", identityPolynomial x)
        cf: OF := oeq("coefficient", coefficient x)
        alpha: OF := oeq("alphaInfinity", alphaInfinity x)
        vconcat [cospec, defspec, m, orb, bas, idpol, cf, alpha]

    -- local
    -- sum_{n=0}^\infty a(mn+t) q^n
    sum(a: OF, n: OF, m: PP, t: NN): OF ==
        out: OF := m::OF * n
        if not zero? t then out := out + t::OF
        q: OF := "q"::Symbol::OF
        out := prefix(a, [out]) -- builds a(m*n+t)
        sum(out*q^n, n=0::OF, "%Infinity"::Symbol::OF)

    -- \prod_{k\in orb} {sum_{n=0}^\infty a(mn+k) q^n
    orbitProduct(x: %): OF ==
        n: OF := "n"::Symbol::OF
        a: OF := "a"::Symbol::OF
        orb: List NN := sort orbit x
        t := first orb
        out: OF := sum(a, n, multiplier x, t)
        for k in rest orb repeat out := out * sum(a, n, multiplier x, k)
        out

-------------------------------------------------------------------

    -- generalized case
    var(sy: Symbol): (ZZ, ZZ) -> OF == (d: ZZ, g: ZZ): OF +->
        s: String := concat(string sy, convert(d)@String)
        g = -1 => s::Symbol::OF
        concat([s, "__", convert(g)@String])::Symbol::OF

    varsub(sy: Symbol): (ZZ, ZZ) -> OF == (d: ZZ, g: ZZ): OF +->
        g = -1 => sub(sy::OF, d::OF)$OF
        sub(sy::OF, commaSeparate[d::OF,g::OF])$OF

    varEta(d: ZZ, g: ZZ): OF ==
        tau := "τ"::Symbol::OF
        eta := "η"::Symbol::OF
        g = -1 =>
            one? d => prefix(eta, [tau]$List(OF))$OF
            prefix(eta, [(d::OF)*tau])$OF
        prefix(sub(eta, commaSeparate[d::OF,g::OF])$OF, [tau])$OF

    varPochhammer(d: ZZ, g: ZZ): OF ==
        q := "q"::Symbol::OF
        if 2*g>=d then g = d-g
        zero? g => varPochhammer(d,-1)^(2::OF)
        g = -1 =>
            one? d => sub(paren([q, q]$List(OF)), "%Infinity"::Symbol::OF)
            l := semicolonSeparate[q^(d::OF), q^(d::OF)]$List(OF)
            sub(paren l, "%Infinity"::Symbol::OF)
        a := if one? g then q else q^(g::OF)
        o := commaSeparate([a, q^((d-g)::OF)]$List(OF))
        o := semicolonSeparate[o, q^(d::OF)]
        sub(paren o, "%Infinity"::Symbol::OF)

    varPower(l: LZZ, v: (ZZ, ZZ) -> OF): OF ==
        import from QEtaSpecification
        d: ZZ := (specDelta l)::ZZ
        g: ZZ := specSubindex l
        e: ZZ := specExponent l
        --assert(not zero? e)
        one? e => v(d, g)
        v(d, g)^(e::OF)

    monomial(rspec: SPEC, v: (ZZ, ZZ) -> OF): OF ==
        one? rspec => (1$ZZ)::OF
        vs: List OF := [varPower(l, v) for l in parts rspec]
        reduce(_*, vs)$List(OF)

    monomialQuotient(rspec: SPEC, v: (ZZ, ZZ) -> OF): OF ==
        mm: PP := level rspec
        num: OF := monomial(numer rspec, v)
        one?(rspecden := denom rspec) => num
        num / monomial(rspecden, v)

    etaQuotient(rspec: SPEC, v: (ZZ, ZZ) -> OF): OF ==
        monomialQuotient(rspec, v)

    qQuotient(rspec: SPEC, v: (ZZ, ZZ) -> OF, e: QQ): OF ==
        eq := etaQuotient(rspec, v)
        zero? e => eq
        q: OF := "q"::Symbol::OF
        one? e => q * eq
        q^(e::OF) * eq

    qEtaQuotient(rspec: SPEC, v: (ZZ, ZZ) -> OF): OF ==
        qQuotient(rspec, v, (1/24)*sigmaInfinity(rspec))



-------------------------------------------------------------------
    -- local function
    withQFactor?(fmt: ZZ): Boolean == odd? fmt
    expand?(fmt: ZZ): Boolean == bit?(fmt, 1)
    modularFunctionIdentity?(fmt: ZZ): Boolean == not bit?(fmt, 2)
    asExpression?(fmt: ZZ): Boolean == bit?(fmt, 3)
    varsubscript?(fmt: ZZ): Boolean == bit?(fmt, 4)

    -- local
    -- replace first element 1 (basis of the module)
    moduleBasis(x: %): SPECS ==
        bas: SPECS := monoidSpecifications x
        mm: PP := level first bas
        cons(etaQuotientSpecification(mm, empty()), rest bas)

-------------------------------------------------------------------

    f(x: %, fmt: ZZ, v: (ZZ, ZZ) -> OF, c: C, e: QQ, rspec: SPEC): OF ==
        e := e + alphaOrbitInfinity x
        rspec := rspec * coSpecification x
        if withQFactor? fmt then e: QQ := e + (1/24)*sigmaInfinity(rspec)
        cofact: OF := qQuotient(rspec, v, e)
        out: OF := orbitProduct x
        if not(zero? e and one? rspec) then out := cofact * out
        cf: C := c * coefficient x
        one? cf => out
        one?(-cf) => - out
        cf::OF * out

-------------------------------------------------------------------

    etaRelationMonomial(c: SUP C, rspec: SPEC,
                        fmt: ZZ, v: (ZZ, ZZ) -> OF, e: QQ): OF ==
        pol: OF := outputForm(c, "t"::Symbol::OF)
        if withQFactor? fmt then e := e + (1/24)*sigmaInfinity(rspec)
        eq: OF := qQuotient(rspec, v, e)
        one? c => eq
        one? rspec => pol
        pol * eq

    etaRelation(cis: List SUP C, mspecs: SPECS,
                fmt: ZZ, v: (ZZ, ZZ) -> OF, c: C, e: QQ, sspec: SPEC): OF ==
        l := [etaRelationMonomial(c*ci, mspec * sspec, fmt, v, e)
              for ci in cis for mspec in mspecs | not zero? ci]
        empty? l => (0$ZZ)::OF
        reduce(_+, l)

-------------------------------------------------------------------

    -- fmt is divided in several bits
    -- bit 0: 0 = eta format,  1 = q format
    -- bit 1: 0 = format with t, 1 = expand t into eta-quotient
    pretty(x: %, fmt: ZZ, v: (ZZ,ZZ)->OF, cf: C, e: QQ, sspec: SPEC): Equation OF ==
        cis: List SUP C := moduleCoefficients x
        bas: SPECS := moduleBasis x
        if expand? fmt then
            t: SPEC := first monoidSpecifications x
            lots: List List Record(k: NN, c: C) := [listOfTerms ci for ci in cis]
            --assert(#bas=#cis)
            --assert(#bas=#lots)
            cis := concat [[(rec.c)::SUP(C) for rec in lot] for lot in lots]
            bas := concat [[b * t^(rec.k) for rec in lot]
                           for lot in lots for b in bas]
        er: OF := etaRelation(cis, bas, fmt, v, cf, e, sspec)
        (f(x, fmt, v, cf, e, sspec) = er)$Equation(OF)

    -- format is divided in several bits
    -- bit 0: 0 = eta format,  1 = q format
    -- bit 1: 0 = format with t, 1 = expand t into eta-quotient
    -- bit 2: 0 = modular function identity, 1 = only orbit product on LHS
    pretty(x: %, fmt: ZZ, v: (ZZ, ZZ) -> OF): Equation OF ==
        modularFunctionIdentity? fmt =>
            pretty(x, fmt, v, 1, 0, etaQuotientSpecification(1,[]))
        invcf: Union(C, "failed") := 1$C exquo coefficient(x)
        icf: C := if invcf case "failed" then 1$C else invcf::C
        pretty(x, fmt, v, icf, - alphaOrbitInfinity x, inv coSpecification x)

    -- format is divided in several bits
    -- bit 0: 0 = eta format,  1 = q format
    -- bit 1: 0 = format with t, 1 = expand t into eta-quotient
    -- bit 2: 0 = modular function identity, 1 = only orbit product on LHS
    -- bit 3: 0 = variables, 1 = expression
    -- bit 4: 0 = normal indexed variables, 1 = subscripted variables
    pretty(x: %, fmt: ZZ): Equation OF ==
        v: (ZZ, ZZ) -> OF :=
            withQFactor? fmt =>
                asExpression? fmt => varPochhammer @ ((ZZ,ZZ)->OF)
                varsubscript? fmt => varsub("u"::Symbol)
                var("u"::Symbol)
            asExpression? fmt => varEta @ ((ZZ,ZZ)->OF)
            varsubscript? fmt => varsub("E"::Symbol)
            var("E"::Symbol)
        pretty(x, fmt, v)

-------------------------------------------------------------------
-- Return parts as expressions, polynomial, or rational functions.

    if C has Comparable then

        -- local
        sub(v: Symbol, d: ZZ, g: ZZ): Symbol ==
            g = -1 => subscript(v, [d::OF]$List(OF))
            subscript(v, [d::OF, g::OF]$List(OF))

        -- local
        vPower(v: Symbol, l: LZZ): Pol C ==
            d: ZZ := specDelta l
            g: ZZ := specSubindex l
            e: NN := specExponent(l)::NN
            (sub(v, d, g)::Pol(C))^e

        monomialX(rspec: SPEC, v: Symbol): EX ==
            one? rspec => 1$EX
            vs: List Pol C := [vPower(v, l) for l in parts rspec]
            reduce(_*, vs)::EX

        monomialQuotientX(rspec: SPEC, v: Symbol): EX ==
            monomialX(numer rspec, v) / monomialX(denom rspec, v)

        etaQuotientX(rspec: SPEC, v: Symbol): EX ==
            monomialQuotientX(rspec, v)

        sumX(a: BasicOperator, n: Symbol, m: PP, t: NN): EX ==
            ex: EX := m * (n::EX)
            if not zero? t then ex := ex + t::EX
            ex := a(ex) -- builds a(m*n+t)
            infty: EX := "%Infinity"::Symbol::EX
            q: EX := "q"::Symbol::EX
            summation(ex*q^(n::EX), equation(n, segment(0, infty)))$EX

        orbitProductX(x: %, s: Symbol): EX ==
            n: Symbol := "n"::Symbol
            a: BasicOperator := operator(s)
            orb: List NN := sort orbit x
            ex: EX := sumX(a, n, multiplier x, first orb)
            for k in rest orb repeat ex := ex * sumX(a, n, multiplier x, k)
            ex
        orbitProductX(x: %): EX == orbitProductX(x, "a"::Symbol)

        cofactorX(x: %): EX ==
            eq: EX := etaQuotientX(coSpecification x, "E"::Symbol)
            e: QQ := alphaOrbitInfinity(x)
            zero? e => eq
            qvar: EX := "q"::Symbol::EX
            qvar^e * eq

        qcofactorX(x: %): EX ==
            eq: EX := etaQuotientX(coSpecification x, "u"::Symbol)
            alpha: ZZ := alphaInfinity x
            zero? alpha => eq
            q: EX := "q"::Symbol::EX
            q^alpha * eq

        equationX(x: %, s: Symbol): Equation EX ==
            l := coefficient(x)::EX * cofactorX(x)::EX * orbitProductX(x, s)
            l = - coefficient(identityPolynomial(x), 'F, 0)::EX

        equationX(x: %): Equation EX == equationX(x, "a"::Symbol)

        qequationX(x: %, s: Symbol): Equation EX ==
            l := coefficient(x)::EX * qcofactorX(x)::EX * orbitProductX(x, s)
            l = - coefficient(identityPolynomial(x), 'F, 0)::EX

        qequationX(x: %): Equation EX == qequationX(x, "a"::Symbol)


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolberg}
\label{sec:QEtaRamanujanKolberg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

)endif


)abbrev package QETARK QEtaRamanujanKolberg
++ QEtaRamanujanKolberg provides functions to compute
++ Ramanujan-Kolberg identities by an algorithm that was developed by
++ Radu in \cite{Radu_RamanujanKolberg_2015}
++ (`DOI=10.1016/j.jsc.2014.09.018
++ <https://doi.org/10.1016/j.jsc.2014.09.018>`_), see `RISC Report
++ 16-06
++ <https://www.risc.jku.at/publications/download/risc_5069/zzz3.pdf>`_.
++ See also at the top of the qetark.spad file where this package is
++ implemented.
++ This package builds on the work of
++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019} and finds
++ identities with generalized eta-quotients.
QEtaRamanujanKolberg(C,QMOD): Exports == Implementation where
  C: EuclideanDomain -- basic coefficient domain
  QMOD: QEtaModularCategory
  IDENTITY ==> QEtaRamanujanKolbergIdentity C
  Exports ==> with
    findIdentity: (SPEC, SPEC, PP, NN, SPECS, QXAB1 C) -> IDENTITY
      ++ findIdentity(sspec, rspec, m, k, mspecs, xab) returns all
      ++ data for a Ramanujan-Kolberg identity. It is assumed that
      ++ mspecs describe the Mi variables in xab in the same order.
    findIdentity: (SPEC, SPEC, PP, NN, SPECS) -> IDENTITY
      ++ findIdentity(sspec, rspec, m, k, mspecs) returns all data for
      ++ a Ramanujan-Kolberg identity.
      ++ Note that elements from mspecs that specify constant
      ++ generalized eta-quotients will be removed.
    findIdentity: (SPEC, SPEC, PP, NN, INDICES) -> IDENTITY
      ++ findIdentity(sspec, rspec, m, k, idxs) returns all data for a
      ++ Ramanujan-Kolberg identity where the right-hand side may
      ++ only involve generalized eta-quotients that are given through
      ++ the indices idxs.
    findIdentity: (SPEC, SPEC, PP, NN, IDENTITY) -> IDENTITY
      ++ findIdentity(sspec, rspec, m, k, id) returns all data for a
      ++ Ramanujan-Kolberg identity. The basis elements are taken
      ++ from a previously computed identity, if possible.
    findIdentity: (PP, INDICES, SPEC, PP, NN, SPECS) -> IDENTITY
      ++ findIdentity(nn, idxs, rspec, m, k, mgens) returns all data
      ++ for a Ramanujan-Kolberg identity where the cofactor may
      ++ only involve generalized eta-functions given through the
      ++ indices idxs.
      ++ Note that elements from mspecs that specify constant
      ++ generalized eta-quotients will be removed.
    findIdentity: (PP, INDICES, SPEC, PP, NN, INDICES) -> IDENTITY
      ++ findIdentity(nn, sidxs, rspec, m, k, bidxs) returns all data
      ++ for a Ramanujan-Kolberg identity where the indices for
      ++ the cofactor and the generalized eta-quotients on the
      ++ right-hand side are given by sidxs and bidxs, respectively.
    findIdentity: (PP, SPEC, PP, NN, INDICES) -> IDENTITY
      ++ findIdentity(nn,rspec,m,k,idxs) returns
      ++ findIdentity(nn,idxs,rspec,m,k,idxs)
    findIdentity: (PP, INDICES, SPEC, PP, NN, IDENTITY) -> IDENTITY
      ++ findIdentity(nn, sidxs, rspec, m, k, id) returns all data for
      ++ a Ramanujan-Kolberg identity. The basis elements are
      ++ taken from a previously computed identity, if possible.
  Implementation ==> add
    cofactInf ==> etaCofactorInfinity $ QEtaModularPackage(QMOD)

    findIdentity(sspec: SPEC, rspec: SPEC, m: PP, t: NN,_
                 mspecs: SPECS, xab: QXAB1 C): IDENTITY ==
        import from QEtaModularInfinityExpansion(C, QMOD)
        f: A1 C := modularEtaQuotientInfinity(sspec, rspec, m, t)
        -- For the following computation we attach a marker to the series.
        xf: X1 C := toX1(C, f, "F"::Symbol::Pol(C))
        -- We look of a representation of our original modular function f in
        -- the respective module of eta-quotients that is represented by
        -- the algebra-basis xab.
        xz: X1 C := reduce(xf, xab)$QXTOPRED1(C)
        -- If xz is non-zero, then no relation has been found.
        orb: List NN := modularOrbit(rspec, m, t)$QMOD
        not zero? xz => identity(sspec, rspec, m, orb, mspecs, 0$Pol(C), xab)
        identity(sspec, rspec, m, orb, mspecs, second(xz)::Pol(C), xab)

    findIdentityAux(nn: PP,
      sspec: SPEC, rspec: SPEC, m: PP, t: NN, mspecs: SPECS): IDENTITY ==
        -- For finding an algebra basis we must remove the
        -- specifications, that represent constant modular functions.
        egens: List A1(C) := [specMODA1(C) mspec for mspec in mspecs]
        ncegens := [x for x in egens | not zero? qetaGrade x]
        -- We attach some identifiers also to those eta-quotients.
        msyms: List Symbol := indexedSymbols("M", #ncegens)$QAuxiliaryTools
        xgens := [toX1(C, x, sym::Pol(C)) for x in ncegens for sym in msyms]
        -- Eventualle, we apply the samba algorithm to obtain an
        -- order-complete basis.
        gen := genus(nn)$QMOD
        import from QXTOPRED1(C) -- necessary, because the next wouldn't compile
        xab: QXAB1(C) := samba(xgens.1, xgens, gen)$QXTOPSAMBA1(C)
        findIdentity(sspec, rspec, m, t, mspecs, xab)

    findIdentity(sspec: SPEC, rspec: SPEC, m: PP, t: NN,_
                 mspecs: SPECS): IDENTITY ==
        findIdentityAux(level sspec, sspec, rspec, m, t, mspecs)

    findIdentity(sspec: SPEC, rspec: SPEC, m: PP, t: NN,
                 bidxs: INDICES): IDENTITY ==
        -- We compute the basis for the modular generalized
        -- eta-quotients and take only the non-constants eta-quotients.
        import from QEtaQuotientSpecifications4ti2(QMOD)
        ncmSPECSInfMOD ==> nonConstantEtaQuotientMonoidInfinitySpecifications
        findIdentity(sspec, rspec, m, t, ncmSPECSInfMOD(level sspec, bidxs))

    findIdentity(sspec: SPEC, rspec: SPEC, m: PP, t: NN,
                 id: IDENTITY): IDENTITY ==
        (nn := level sspec) ~= (lvl := level coSpecification id) =>
            errorPrint("cannot use previous identity", [nn, lvl]$LZZ)
            error "specify selected indices instead"
        findIdentity(sspec, rspec, m, t,_
                     monoidSpecifications id, algebraBasis id)

    findIdentity(nn: PP, sidxs: INDICES, rspec: SPEC, m: PP, t: NN,
                 mspecs: SPECS): IDENTITY ==
        sspec: SPEC := cofactInf(nn, rspec, m, t, sidxs)
        findIdentity(sspec, rspec, m, t, mspecs)

    findIdentity(nn: PP, sidxs: INDICES, rspec: SPEC, m: PP, t: NN,
                 bidxs: INDICES): IDENTITY ==
        sspec: SPEC := cofactInf(nn, rspec, m, t, sidxs)
        findIdentity(sspec, rspec, m, t, bidxs)

    findIdentity(nn: PP, rspec: SPEC, m: PP, t: NN, idxs: INDICES): IDENTITY ==
        findIdentity(nn, idxs, rspec, m, t, idxs)

    findIdentity(nn: PP, sidxs: INDICES, rspec: SPEC, m: PP, t: NN,
                 id: IDENTITY): IDENTITY ==
        nn ~= (lvl := level coSpecification id) =>
            errorPrint("cannot use previous identity", [nn, lvl]$LZZ)
            error "specify selected indices instead"
        sspec: SPEC := cofactInf(nn, rspec, m, t, sidxs)
        findIdentity(sspec, rspec, m, t,_
                     monoidSpecifications id, algebraBasis id)



)if LiterateDoc
\end{document}
)endif
