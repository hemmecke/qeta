-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
display77(x) ==> display((x::OF)::Formatter(Format1D))
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Using the QEta package to find Ramanujan-Kolberg identities}
\author{Ralf Hemmecke}
\date{29-Oct-2020}
\maketitle
\begin{abstract}
  The package \code{QEtaRamanujanKolberg} implements functions to help7
  finding Ramanujan-Kolberg identities.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu:RamanujanKolberg:2015}.

Let $M$ be a positive integer and $s=(s_\delta)_{\delta|M}$ be a sequence of integers indexed by the positive divisors of $M$. Define a sequence $a(n)$ by
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M} \prod_{n=1}^\infty (1-q^{\delta n})^{s_\delta}
  =
  \prod_{\delta|M} (q^\delta; q^\delta)_\infty^{s_\delta}
\end{gather*}
where
\begin{gather*}
(u; q)_\infty = \prod_{n=0}^\infty (1-uq^n)
\end{gather*}
is the $q$-Pochhammer symbol.

Given $N$, $m$, and $t \in \{0,\ldots,m-1\}$, we wabt to compute a
sequence $r=(r_\delta)_{\delta|N}$ of integers, a set
$\mathcal{O}_{r,m,t}\subseteq\{0,\ldots,m=1\}$, $\eta$-quotients
$b_i \in M^\infty(N)$, and numbers $c_i\in \mathbb{Q}$ uch that
\begin{gather*}
q^\alpha \prod_{\delta|N} \prod_{n=1}^\infty (1-q^{\delta n})^{r_\delta}
\times
\prod_{t'\in \mathcal{O}(r,m,t)} \sum_{n=0}^\infty a(mn+t')q^n
=
\sum_{i=1}^k c_i b_i
\end{gather*}
where
\begin{gather*}
\alpha = \sum_{\delta|N} \frac{\delta r_\delta}{24}
         +
         \sum_{t'\in \mathcal{O}(r,m,t)}
             \frac{24 t' + \sum_{\delta|N} \delta s_\delta}{24m}
\end{gather*}
and $M^\infty(N)$ is the set of modular functions on $\Gamma_0(N)$
with a pole at most at infinity.

Each of the $\eta$-quotients is given through a sequence
$r^{(i)}=\left(r^{(i)}_\delta\right)_{\delta|N}$ of integers in its
$q$-expansion at infinity.
\begin{gather*}
  b_i
  = q^{\beta_i} \prod_{\delta|N}
                      \prod_{n=1}^\infty (1-q^{\delta n})^{r^{(i)}_\delta}
  =
  q^{\beta_i} \prod_{\delta|N} (q^\delta, q^\delta)_\infty^{r^{(i)}_\delta}.
\end{gather*}
with
\begin{gather*}
  \beta_i = \sum_{\delta|N} \frac{\delta r^{(i)}_\delta}{24}
\end{gather*}


For mathematical background see \PathName{qetafun.spad}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

--VZ ==> Vector Z
--MZ ==> Matrix Z
--Rec ==> Record(red: SL2Z, lg: N)
--EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)
--LP ==> List P
--LZ ==> List Z
--QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [qcoerce(d)@P for d in divisors(m)$INTF]

Pol C  ==> Polynomial C

QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage;
WIDTH(nn, c) ==> qcoerce(width(nn, c)$QAuxMEQ)@P

T1 C  ==> UnivariateTaylorSeries(C, 'q, 0);
L1 C  ==> UnivariateLaurentSeries(C, 'q, 0);
A1 C ==> Finite0Series(C, 'q, 0)
ETA C ==> EtaQuotient(C, A1 C)
CA1 C ==> QEtaAlgebraCachedPower(C, A1 C) -- computation domain (cached)
CPol C ==> QEtaAlgebraCachedPower(C, Pol C) -- computation pols in (cached)
X1 C ==> QEtaExtendedAlgebra(C, CA1 C, CPol C)
toX1(C, a, b) ==> embed(a::CA1(C), b::CPol(C))$X1(C)

QXAB1 C ==> QEtaAlgebraBasis(C, X1 C)
QXTOPRED1 C ==> QEtaTopReduction(C, X1 C, QXAB1 C)
QXTOPCOMP1 C ==> QEtaComputation(C, X1 C, QXAB1 C, QXTOPRED1 C)
QXTOPSAMBA1 C ==> QEtaSambaPackage(C, X1 C, QXAB1 C, QXTOPCOMP1 C)

SUPZ2SUP(C, x) ==> map(coerce, x)$SparseUnivariatePolynomialFunctions2(Z, C)

-- minimal polynomial for n-th root of unity
MINROOTPOL(C, n) ==> SUPZ2SUP(C, cyclotomic(n)$CyclotomicPolynomialPackage)

SUP ==> SparseUnivariatePolynomial
QEQEV ==> QEtaQuotientExponentVectors4ti2
YMSETAQG ==> SymbolicModularSiftedEtaQuotientGamma
ETARELPART ==> Record(ci: C, qei: Z, ri: List Z)
EQ ==> Equation
RELTYPE ==> Record(ymsetaqg: YMSETAQG, rgens: List List Z, rel: Pol C)
IDENTITYTYPE ==> Record(_
    falpha: Z,_
    fr: List Z,_
    forb: List Z,_
    frel: List ETARELPART)


-- Note that in the following correspondence between programming variables
-- and notation in the mathematical description in qetafun.spad.
-- Variable   <--> mathematical notation
-- m               m
-- mm              M
-- nn              N
-- sigmaInfty      \sumdelta{r}
-- kappa(m)        \kappa

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Auxiliary Package QEtaRamanujanKolbergAux}
\label{sec:QEtaRamanujanKolbergAux}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For the case that we need more than just a second root of unity, we
provied another domain that computes with the respective extension of
the coefficient domain.

)endif

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolberg}
\label{sec:QEtaRamanujanKolberg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



)endif

)abbrev package QETARX QEtaRamanujanKolberg
QEtaRamanujanKolberg(C): Exports == Implementation where
  C: Join(Algebra Q, EuclideanDomain) -- basic coefficient domain
  Exports ==> with
    findIdentity: (P, P, List Z, P, N) -> RELTYPE
      ++ findIdentity(nn, mm, s, m, t) returns all date for a
      ++ Ramanujan-Kolberg identity.
    findRelation: YMSETAQG -> RELTYPE
  Implementation ==> add
    -- auxiliary functions
    sigmaInfinity(nn: P, r: List Z): Z ==
        divs: List Z := divisors(nn)$IntegerNumberTheoryFunctions
        reduce(_+, [d*rd for d in divs for rd in r], 0)$List(Z)

    findIdentity(nn: P, mm: P, s: List Z, m: P, t: N): RELTYPE ==
        import from QEtaModularFunctionTools
        r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)
        rhat: Z := sigmaInfinity(nn, r)
        shat: Z := sigmaInfinity(mm, s)
        orb: List N := orbit(shat, m, t)$QEtaKolberg
        alpha: Q := rhat/24 + reduce(_+, [24*k+shat for k in orb], 0)/(24*m)
        not one? denom alpha => error "alpha not an integer"
        cofact: ETA(C) := etaQuotient(nn, r)$ETA(C)
        etaquo: ETA(C) := etaQuotient(mm, s)$ETA(C)
        expectedGrade := qetaGrades(nn, r, m, s, m, t).(1/nn)
        dbgPrint("expectedGrade", expectedGrade)
        eulerquo: T1 C := taylorRep eulerQuotient etaquo
        tt := first orb
        p: T1 C := multisect(m-tt, tt, eulerquo)
        -- Now multiply the series selecting sum_{n=0}^\infty a(m*n+k)q^n.
        for k in rest orb repeat p := p * multisect(m-k, k, eulerquo)
        f: T1 C := p * taylorRep eulerQuotient cofact
        laurent(numer alpha, f)

-------------------------------------------------------------------
)fin
-- The stuff below compiles, but does not work, see
-- https://groups.google.com/d/msg/fricas-devel/xlHMEC_j_OY/teirAAbmBAAJ
-- for why the code is postponed.
-------------------------------------------------------------------


)abbrev package QETARKA QEtaRamanujanKolbergAux
QEtaRamanujanKolbergAux(C, CX): Exports == Implementation where
  C: Join(Algebra Q, EuclideanDomain)
  CX: Join(Algebra C, CommutativeRing, RetractableTo C) -- C extended by a needed root of unity
  Exports ==> with
    findRelation: (YMSETAQG, P, CX) -> RELTYPE
      ++ findRelation(y) returns all date for a Ramanujan-Kolberg
      ++ identity.
  SETAQG(C, CX) ==> SiftedEtaQuotientGamma(C, xiord, CX, xi, T1 CX, L1 CX)
  Implementation ==> add
    findRelation(y: YMSETAQG, xiord: P, xi: CX): RELTYPE ==
        cofac: SymbolicSiftedEtaQuotientGamma := cofactor y
        dbgPrint("cofac", cofac)
        nn: P := level cofac
        w: P := WIDTH(nn, nn) -- the width of the cusp infinity
        dbgPrint("fr w0", w)
        p := puiseux(y, w)$SETAQG(C, CX)
        dbgPrint("fr w", w)
        dbgPrint("p", p)
        fx  := laurent(p)$SETAQG(C, CX)
        d := rationalPowerDenominator p
        dbgPrint("d", d)
        dbgPrint("fx", fx)
        error "vvv"

)if false
        import from UnivariateLaurentSeriesFunctions2(CX, C, 'q, 'q, 0, 0)
        l: L1(C) := map(retract, fx)
        f: A1(C) := l :: A1(C)
        xf: X1(C) := toX1(C, f, "F"::Symbol::Pol(C))
        dbgPrint("xf", xf)

        rgens: List List Z := etaQuotientMonoidExponentVectors(nn)$QEQEV
        nndivs: List Z := [delta::Z for delta in divisors cofac]
        eqgens: List ETA(C) := [etaQuotient(nndivs, r)$ETA(C) for r in rgens]
        egens: List A1(C) := [expansion e for e in eqgens]
        msyms: List Symbol := indexedSymbols("M", #rgens)$QAuxiliaryTools
        mxgens: List X1 C := [toX1(C, x, sym::Pol(C)) for x in egens for sym in msyms];
        xgens: List X1 C := cons(toX1(C, egens.1, "T"::Symbol::Pol(C)), rest mxgens);
        import from QXTOPRED1(C) -- necessary, because the next wouldn't compile
        xab: QXAB1(C) := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

        xz: X1(C) := reduce(xf, xab)$QXTOPRED1(C)
        not zero? xz => error "no relation found"

        [y, rgens, second(xz)::Pol(C)]
)endif


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolberg}
\label{sec:QEtaRamanujanKolberg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


)endif
)abbrev package QETARKX QEtaRamanujanKolbergX
QEtaRamanujanKolbergX(C): Exports == Implementation where
  C: Join(Algebra Q, EuclideanDomain) -- basic coefficient domain
  Exports ==> with
    findIdentity: (P, P, List Z, P, N) -> RELTYPE
      ++ findIdentity(nn, mm, s, m, t) returns all date for a
      ++ Ramanujan-Kolberg identity.
    findRelation: YMSETAQG -> RELTYPE
  Implementation ==> add

    fr(y: YMSETAQG, xiord: P, minrootpol: SUP C): RELTYPE ==
        CX ==> SimpleAlgebraicExtension(C, SUP C, minrootpol)
        findRelation(y, xiord, generator()$CX)$QEtaRamanujanKolbergAux(C, CX)

    findIdentity(nn: P, mm: P, s: List Z, m: P, t: N): RELTYPE ==
        r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)$QEtaModularFunctionTools
        cusp: Q := 1/nn -- cusp corresponding to infinity
        gamma := cuspToMatrix(nn, cusp)$QAuxiliaryModularEtaQuotientPackage -- the matrix corresponding to cusp
        y := etaQuotient(nn, r, mm, s, m, t, gamma)$YMSETAQG;
        xiord: P := minimalRootOfUnity y
        xiord = 2 => findRelation y

        minrootpol ==> MINROOTPOL(C, xiord)
        dbgPrint("xiord", xiord)
        dbgPrint("minrootpol", minrootpol)
        fr(y, xiord,  minrootpol)


    findRelation(y: YMSETAQG): RELTYPE ==
        xiord: P := 2
        xi: C := -1
        cofac: SymbolicSiftedEtaQuotientGamma := cofactor y
        nn: P := level cofac
        w: P := WIDTH(nn, nn) -- the width of the cusp infinity
        p := puiseux(y, w)$SiftedEtaQuotientGamma(C, xiord, C, xi, A1 C)
        f := expansion(p)$SiftedEtaQuotientGamma(C, xiord, C, xi, A1 C)
        xf: X1(C) := toX1(C, f, "F"::Symbol::Pol(C))

        rgens: List List Z := etaQuotientMonoidExponentVectors(nn)$QEQEV
        nndivs: List Z := [delta::Z for delta in divisors cofac]
        eqgens: List ETA(C) := [etaQuotient(nndivs, r)$ETA(C) for r in rgens]
        egens: List A1(C) := [expansion e for e in eqgens]
        msyms: List Symbol := indexedSymbols("M", #rgens)$QAuxiliaryTools
        mxgens: List X1 C := [toX1(C, x, sym::Pol(C)) for x in egens for sym in msyms];
        xgens: List X1 C := cons(toX1(C, egens.1, "T"::Symbol::Pol(C)), rest mxgens);
        import from QXTOPRED1(C) -- necessary, because the next wouldn't compile
        xab: QXAB1(C) := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

        xz: X1(C) := reduce(xf, xab)$QXTOPRED1(C)
        not zero? xz => error "no relation found"

        [y, rgens, second(xz)::Pol(C)]

)if false

        -- Computing the result
        orb: List N := orbit orbitProduct y
        [alpha, rgens, orb, rel]
        --[falpha: Z, fr: List Z, forb: List Z, frel: List ETARELPART)


)endif


)fin
-------------------------------------------------------------------

-- from Hemmecke_DancingSambaRamanujan_2018.input-test
modularSiftedPartitionSeries(nn: P, m: P, t: N): A1 Z == (_
  mmdivs: List P := DIVISORS m;_
  s: List Z := cons(-1, rest [0 for i in mmdivs]);_
  r: List Z := etaCoFactorInfinity(nn, m, s, m, t)$QEtaModularFunctionTools;_
  vPrint("-- cofactor", r);_
  shat: Z := sigmaInfinity(mmdivs, s);_
  orbs := [orb for tt in 0..m-1 | (orb := orbit(shat, m, tt::N); one? # orb)];_
  if not(one? # orbs and one? # first orbs and t = first first orbs) then _
    error "not a single element orbit";_
  expectedGrade := qetaGrades(nn, r, m, s, m, t).(1/nn);_
  cofact := etaQuotient(DIVISORS nn, r)$ETA(Z);_
  e := ((qetaGrade seriesPart cofact)-expectedGrade)*24 - prefactor cofact;_
  vPrint("-- fractional exponent", e);_
  fcf := expansion(q24(e)$ETA(Z) * cofact);_
  fzf := fcf*siftedPartitionSeries(m, t));


-------------------------------------------------------------------
-- ### $F_{r,s,m,t}(\gamma\tau) \in M^\infty(N)$ --- Expansion at cusp $\infty$

cusp := 1/nn; gamma := cuspToMatrix(nn, cusp); w := width(nn, denom cusp)
r := etaCoFactorInfinity(nn, mm, s, m, t)$QEtaModularFunctionTools
)clear prop y
y := etaQuotient(nn, r, mm, s, m, t, gamma)$YMSETAQG;
xiord: P := minimalRootOfUnity y
CX := UnityRootExtension(C, xiord)
xi := generator()$CX
puiseux(y, w)$SETAQG(C, CX)





        X ==> X1 C
        xiord := 2;
        xi := -1;
        CX := Q;
        nndivs := DIVISORS nn;
        etaQ(x) == expansion(etaQuotient(nndivs, x)$ETA(C))
        smallerR?(x: List Z, y: List Z): Boolean == smallerGrade?(etaQ x, etaQ y)@Boolean
        rgens := sort(smallerR?,etaQuotientMonoidExponentVectors(nn)$QEQEV)$List(List Z)
        eqgens := [etaQ r for r in rgens];
        msyms := indexedSymbols("M", #rgens)
        mxgens := [toX1(C, x, sym) for x in eqgens for sym in msyms];
        xgens := cons(toX1(C, eqgens.1, 'T), rest mxgens);
        xt := xgens.1



)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
