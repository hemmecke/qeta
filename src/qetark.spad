-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

OF==>OutputForm
dbgPrint(x,y) ==> print(([":> "::Symbol::OF, x::Symbol::OF, y::OF]$List(OF)::OF))
display77(x) ==> display((x::OF)::Formatter(Format1D))
vPrint(x,y) ==> display77(hconcat(["-- "::Symbol::OF, x::Symbol::OF, ":="::Symbol::OF, y::OF]$List(OF)))

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\usepackage{showlabels}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Using the QEta package to find Ramanujan-Kolberg identities}
\author{Ralf Hemmecke}
\date{29-Oct-2020}
\maketitle
\begin{abstract}
  The package \code{QEtaRamanujanKolberg} implements functions to help7
  finding Ramanujan-Kolberg identities.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We try to find all missing parts to find a Ramanujan-Kolberg relation
as defined in \cite[p.~227]{Radu:RamanujanKolberg:2015}.

Let $M$ be a positive integer and $s=(s_\delta)_{\delta|M}$ be a sequence of integers indexed by the positive divisors of $M$. Define a sequence $a(n)$ by
\begin{gather*}
  \sum_{n=0}^\infty a(n) q^n
  =
  \prod_{\delta|M} \prod_{n=1}^\infty (1-q^{\delta n})^{s_\delta}
  =
  \prod_{\delta|M} (q^\delta; q^\delta)_\infty^{s_\delta}
\end{gather*}
where
\begin{gather*}
(u; q)_\infty = \prod_{n=0}^\infty (1-uq^n)
\end{gather*}
is the $q$-Pochhammer symbol.

Given $N$, $m$, and $t \in \{0,\ldots,m-1\}$, we wabt to compute a
sequence $r=(r_\delta)_{\delta|N}$ of integers, a set
$\mathcal{O}_{r,m,t}\subseteq\{0,\ldots,m=1\}$, $\eta$-quotients
$b_i \in M^\infty(N)$, and numbers $c_i\in \mathbb{Q}$ uch that
\begin{gather*}
q^\alpha \prod_{\delta|N} \prod_{n=1}^\infty (1-q^{\delta n})^{r_\delta}
\times
\prod_{t'\in \mathcal{O}(r,m,t)} \sum_{n=0}^\infty a(mn+t')q^n
=
\sum_{i=1}^k c_i b_i
\end{gather*}
where
\begin{gather*}
\alpha = \sum_{\delta|N} \frac{\delta r_\delta}{24}
         +
         \sum_{t'\in \mathcal{O}(r,m,t)}
             \frac{24 t' + \sum_{\delta|N} \delta s_\delta}{24m}
\end{gather*}
and $M^\infty(N)$ is the set of modular functions on $\Gamma_0(N)$
with a pole at most at infinity.

Each of the $\eta$-quotients is given through a sequence
$r^{(i)}=\left(r^{(i)}_\delta\right)_{\delta|N}$ of integers in its
$q$-expansion at infinity.
\begin{gather*}
  b_i
  = q^{\beta_i} \prod_{\delta|N}
                      \prod_{n=1}^\infty (1-q^{\delta n})^{r^{(i)}_\delta}
  =
  q^{\beta_i} \prod_{\delta|N} (q^\delta, q^\delta)_\infty^{r^{(i)}_\delta}.
\end{gather*}
with
\begin{gather*}
  \beta_i = \sum_{\delta|N} \frac{\delta r^{(i)}_\delta}{24}
\end{gather*}


For mathematical background see \PathName{qetafun.spad}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us start with a few common macros.

These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z

Pol ==> Polynomial
SUP ==> SparseUnivariatePolynomial
QAuxMEQ ==> QAuxiliaryModularEtaQuotientPackage;

T1 C  ==> UnivariateTaylorSeries(C, 'q, 0);
L1 C  ==> UnivariateLaurentSeries(C, 'q, 0);
A1 C ==> Finite0Series(C, 'q, 0)
ETA C ==> EtaQuotient(C, A1 C)
CA1 C ==> QEtaAlgebraCachedPower(C, A1 C) -- computation domain (cached)
CPol C ==> QEtaAlgebraCachedPower(C, Pol C) -- computation pols in (cached)
X1 C ==> QEtaExtendedAlgebra(C, CA1 C, CPol C)
toX1(C, a, b) ==> embed(a::CA1(C), b::CPol(C))$X1(C)

QXAB1 C ==> QEtaAlgebraBasis(C, X1 C)
QXTOPRED1 C ==> QEtaTopReduction(C, X1 C, QXAB1 C)
QXTOPCOMP1 C ==> QEtaComputation(C, X1 C, QXAB1 C, QXTOPRED1 C)
QXTOPSAMBA1 C ==> QEtaSambaPackage(C, X1 C, QXAB1 C, QXTOPCOMP1 C)

QEQEV ==> QEtaQuotientExponentVectors4ti2


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolbergIdentity}
\label{sec:QEtaRamanujanKolbergIdentity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We provide here a domain that prints nicely as an identity and has
enough acces functions to extract various components of the identity
for easier manipulation.


)endif


)abbrev domain QETARKI QEtaRamanujanKolbergIdentity
QEtaRamanujanKolbergIdentity(C): Exports == Implementation where
  C: Join(Algebra Q, EuclideanDomain) -- basic coefficient domain
--  ETARELELT ==> Record(fci: SUP C, fqei: Z, fri: Vector Z)
--  ETAREL ==> List ETARELELT
  L ==> List
  Exports ==> CoercibleTo OutputForm with
    identity: (P, List Z, P, L Z, P, N, C, L SUP C, L L Z) -> %
      ++ identity(nn, mm, s, m, t, c, rel, rgens) returns a structure
      ++ that represents all information about the (the q) expansion
      ++ of $F_{r,s,m,t}$ at infinity, see Definition of $F_{r,s,m,t}$
      ++ in qetafun.spad, Equation~\eqref{eq:F_r-s-m-t(tau)}. The
      ++ relations is then
      ++ c*F=sum_{i}(rel(i)*etaQuotient(nn,rgens(i))) where F
      ++ corresponds to the modular function $F_{r,s,m,t}$ in
      ++ question.
    alphaInfinity: % -> Z
    orbit: % -> List N
    level: % -> P
      ++ level(x) returns nn if x represents a modular function for
      ++ Gamma_0(nn).
    definitionLevel: % -> P
      ++ definitionLevel(x) returns mm. This is the level of the
      ++ eta-quotient from which the sifted version is taken.

  Implementation ==> add
    Rep ==> Record(fnn: P,_
                   fr: List Z,_
                   fmm: P,_
                   fs: List Z,_
                   fmultiplier: P,_
                   foffset: N,_
                   fcf: C,_ -- coeficient corresponding to F
                   frel: List SUP C,_ -- coeffs corrresponding to rgens
                   frgens: List List Z) -- eta-quotients (rgens.1 is special)

    xx ==> rep x

    identity(nn: P, r: List Z, mm: P, s: List Z, m: P, t: N,_
             c: C, rel: List SUP C, rgens: List List Z): % ==
        per [nn, r, mm, s, m, t, c, rel, rgens]

    alphaInfinity(x: %): Z ==
        m: P := xx.fmultiplier
        t: N := xx.foffset
        alphaInfinity(xx.fnn, xx.fr, xx.fmm, xx.fs, m, t)$QEtaKolberg

    orbit(x: %): List N ==
        orbit(xx.fmm, xx.fs, xx.fmultiplier, xx.foffset)$QEtaKolberg

    coerce(x: %): OutputForm == rep(x)::OutputForm




)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaRamanujanKolberg}
\label{sec:QEtaRamanujanKolberg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



)endif

)abbrev package QETARK QEtaRamanujanKolberg
QEtaRamanujanKolberg(C): Exports == Implementation where
  C: Join(Algebra Q, EuclideanDomain) -- basic coefficient domain
  IDENTITY ==> QEtaRamanujanKolbergIdentity C
  Exports ==> with
    findIdentity: (P, List Z, P, List Z, P, N) -> IDENTITY
    findIdentity: (P, P, List Z, P, N) -> IDENTITY
      ++ findIdentity(nn, mm, s, m, t) returns all date for a
      ++ Ramanujan-Kolberg identity.
  Implementation ==> add
    pol2sup(pol: Pol C, sym: Symbol): SUP C ==
        z: SUP C := 0
        for m in reverse monomials pol repeat
            mon: SUP C := monomial(- leadingCoefficient m, degree(m, sym))
            z := mon + z
        z

    findIdentity(nn: P, r: List Z, mm: P, s: List Z, m: P, t: N): IDENTITY ==
--        import from QEtaModularFunctionTools

        -- First compute the expansion of the orbit product.
        eulerquo: T1 C := taylorRep(eulerQuotient(mm, s)$ETA(C))

        orb: List N := orbit(mm, s, m, t)$QEtaKolberg
        tt := first orb
        p: T1 C := multisect(m-tt, tt, eulerquo)
        -- Now multiply the series selecting sum_{n=0}^\infty a(m*n+k)q^n.
        for k in rest orb repeat p := p * multisect(m-k, k, eulerquo)

        -- The expansion of the cofactor is here.
        -- We take care of the right q-order through alphaInfinity.
        cofact: T1 C := taylorRep(eulerQuotient(nn, r)$ETA(C))

        -- We multiply both things together to get (nearly) a modular
        -- function.
        tf: T1 C := cofact * p

        -- We have to multiply by some q-power to get the expansion of
        -- a modular function f.
        alpha: Z := alphaInfinity(nn, r, mm, s, m, t)$QEtaKolberg
        f: A1 C := laurent(alpha, tf)$A1(C)

        -- For the following computation we attach a marker to the
        -- series.
        fsym: Symbol := "F"::Symbol
        xf: X1 C := toX1(C, f, fsym::Pol(C))

        -- We compute the basis for the modular eta-quotients of level nn.
        rgens: List List Z := etaQuotientMonoidExponentVectors(nn)$QEQEV
        eqgens: List ETA(C) := [etaQuotient(nn, rv)$ETA(C) for rv in rgens]
        egens: List A1(C) := [expansion e for e in eqgens]

        -- We attach some identifiers also to those eta-quotients.
        msyms: List Symbol := indexedSymbols("M", #rgens)$QAuxiliaryTools
        xgens := [toX1(C, x, sym::Pol(C)) for x in egens for sym in msyms]

        -- Eventualle, we apply the samba algorithm to obtain an
        -- order-complete basis.
        import from QXTOPRED1(C) -- necessary, because the next wouldn't compile
        xab: QXAB1(C) := samba(xgens.1, xgens)$QXTOPSAMBA1(C)

        -- We look of a representation of our original modular function f in
        -- the respective module of eta-quotients that is represented by
        -- the algebra-basis xab.
        xz: X1(C) := reduce(xf, xab)$QXTOPRED1(C)

        -- If xz is non-zero, then no relation has been found.
        not zero? xz => identity(nn, r, mm, s, m, t, 0, [], rgens)

        pol := second(xz)::Pol(C)
        cf: C := ground coefficient(pol, fsym, 1)
        rel: Pol C := coefficient(pol, fsym, 0)

        cis: List Pol C := [coefficient(rel, msym, 1) for msym in rest msyms]
        c1: Pol C := coefficient(rel, rest msyms, [0 for i in rest msyms])
        cis := cons(c1, cis) -- These are univariate polynomials in M1.

        tsym: Symbol := first msyms
        rel: List SUP C := [pol2sup(c, tsym) for c in cis]

        identity(nn, r, mm, s, m, t, cf, rel, rgens)


    findIdentity(nn: P, mm: P, s: List Z, m: P, t: N): IDENTITY ==
        import from QEtaModularFunctionTools
        r: List Z := etaCoFactorInfinity(nn, mm, s, m, t)
        findIdentity(nn, r, mm, s, m, t)




)if LiterateDoc
\bibliography{qeta}
\end{document}
)endif
