-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Common interface to specify (generalized) eta-quotients}
\author{Ralf Hemmecke}
\date{26-Jul-2021}
\maketitle
\begin{abstract}
  The domain \code{QEtaSpecification} contains functions to specify an
  eta-quotient or a generalized eta-quotient. The emphasis here is on
  allowing for a simple user interface and a common API to use that
  data for the algorithms.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indroduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The domains \code{QEtaSpecification} does not do any serious
computations. Rather it transforms various kinds of user input into a
common format that is easy to use for the other algorithms of the QEta
package.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

First of all for debugging.
)endif
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))

)if LiterateDoc
%$
These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
LZ ==> List Z
LLZ ==> List LZ
INDICES ==> LLZ

DIVISORS m ==>  [asP d for d in divisors(m)$IntegerNumberTheoryFunctions]

asN x ==> x pretend N
asP x ==> x pretend P


)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D QEtaSpecification}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We declare \code{QEtaSpecification} to be a commutative group.
Note, however, that there can be elements $x$ with \code{not(one?(x))}
that lead to 1 when considered as a $q$-series.

)endif

)abbrev domain QETASPEC QEtaSpecification
++ QEtaSpecification helps translate various formats of user data
++ into a common format that specifies a (generalized) eta-quotient.
QEtaSpecification: Exports == Implementation where
  Exports ==> Join(Group, CommutativeStar) with
    -- creation functions
    etaQuotientSpecification: (P, LZ) -> %
      ++ etaQuotientSpecification(mm, r) returns the specification for
      ++ the eta-quotient $\prod_{d} \eta(d*\tau)^{r_d}$ where d runs
      ++ over all divisors of mm.
    etaQuotientSpecification: (List P, LZ) -> %
      ++ etaQuotientSpecification(divs, r) returns the specification for
      ++ the eta-quotient $\prod_{d} \eta(d*\tau)^{r_d}$ where d runs
      ++ over divs.
      ++ The two input lists are supposed to be of the same length.
    etaQuotientSpecification: (P, LLZ) -> %
      ++ etaQuotientSpecification(mm, rbar) returns the
      ++ specification of a generalized eta-quotient given by a list
      ++ of (index, exponent) pairs where an index can be either a
      ++ divisor of mm or a pair (d,g) of a divisor d and a number g
      ++ (0<g<d/2).
      ++ In more detail an element l of rbar can have the following form:
      ++ a) [d[     -- this is equivalent to [d,1],
      ++ b) [d,e]   -- stands for $\eta(d*\tau)^e$,
      ++ c) [d,g,e] -- stands for $\eta_{d,g}^{[R]}(\tau)^e$.
    etaQuotientSpecification: LLZ -> %
      ++ etaQuotientSpecification(rbar) returns
      ++ eaQuotientSpecification(mm, rbar) for
      ++ mm=lcm[first l for l in rbar].
      ++ mm is 1 if rbar is empty.
    etaQuotientSpecification: (P, INDICES, LZ) -> %
      ++ etaQuotientSpecification(mm,idxs,le) returns
      ++ etaQuotientSpecification(mm, rbar) where rbar is
      ++ [concat(i,e) for e in le for i in idxs] without the entries
      ++ whose corresponding exponent e is zero.

    purify: % -> %
      ++ Some generalized eta-functions can be expressed as pure
      ++ eta-quotients. This function translates
      ++ [2*g,g,e] into the pair [[g,2*e],[2*g,-2*e]]
      ++ and [d,0,e] int [d,2*e].

    -- accessor functions
    level: % -> P
      ++ level(x) returns either the level that was given at
      ++ specification time or the lcm of all the indices.
    parts: % -> LLZ
      ++ pureParts(x) returns a list of triples of the form
      ++ [delta,g,e] for the specification of a power of a
      ++ (generalized) eta-function [d,-1,e] that specifies
      ++ $\eta(d*\tau)^e$ whereas [d,g,e] for g~=-1 specifies
      ++ $\eta_{d,g}(\tau)^e$.
    pureParts: % -> LLZ
      ++ pureParts(x) returns the part of the (generalized)
      ++ eta-quotient that corresponds to pure eta-functions. Each
      ++ element of the result is a three-element list [d,-1,e] that
      ++ stands for $\eta(d*\tau)^e$.
    properGeneralizedParts: % -> LLZ
      ++ properGeneralizedParts(x) returns the list of indicies and
      ++ exponents of the proper generalized part of the (generalized)
      ++ eta-quotient. Each element is a 3-element list of the form
      ++ [d, g, e] that stands for $\eta_{d,g}^{[R]}(\tau)^e$.
--    divisors: % -> List P
--      ++ divisors(x) returns divisors(level(x)). This data is
--      ++ precomputed and stored inside the structure.
    pureExponents: % -> LZ
      ++ pureExponents returns the exponents of the pure eta-quotient
      ++ part of the specification. Zeros at the end of the list are
      ++ removed.
    allPureExponents: % -> LZ
      ++ allPureExponents(x) returns the exponents of the pure
      ++ eta-quotient part of the specification. The resulting list
      ++ has as many entries as divisors(x).
    pure?: % -> Boolean
      ++ pure?(x) returns true if x contains no proper generalized
      ++ eta-functions, i.e., if empty?(generalizedParts(x)).

    sigmaInfinity: % -> Q
      ++ sigmaInfinity(x) returns the value corresponding to
      ++ \eqref{eq:sigmainftybar} in qeta.tex or to
      ++ \eqref{eq:sigmainfty} for the pure eta-quotient case.
    sigma0: % -> Z
      ++ sigma0(x) returns the value corresponding to
      ++ \eqref{eq:sigmazerobar} in qeta.tex or to
      ++ \eqref{eq:sigmazero} for the pure eta-quotient case.
    sigmaInfinityPure: % -> Z
      ++ sigmaInfinityPure(x) returns the value of sigmaInfinity(x)
      ++ considering onlyt the pureParts of x.
      ++ See \eqref{eq:sigmainfty} in qeta.tex.
    sigma0Pure: % -> Z
      ++ sigma0Pure(x) returns the value of sigma0(x)
      ++ considering onlyt the pureParts of x.
      ++ See \eqref{eq:sigmazero} in qeta.tex.
    sigmaInfinityProperGeneralized: % -> Q
      ++ sigmaInfinityProperGeneralize(x) returns the value of sigmaInfinity(x)
      ++ considering onlyt the pureParts of x.
      ++ See \eqref{eq:sigmainftytilde} in qeta.tex.
    sigma0ProperGeneralized: % -> Z
      ++ sigma0ProperGeneralized(x) returns the value of sigma0(x)
      ++ considering only the properGeneralizedParts of x.
      ++ See \eqref{eq:sigmazerotilde} in qeta.tex.

    modularGamma0: % -> Z
      ++ modularGamma0(x) returns 0 if all conditions are fulfilled
      ++ that x specifies a modular function for Gamma0(level(x)).
      ++ Otherwise it returns a positive number in the range 1 to 4
      ++ that corresponds to the condition that is not met. This
      ++ corresponds to the conditions given for R(N,i,j,k,l) on page
      ++ 226 of \cite{Radu_RamanujanKolberg_2015} and to the
      ++ conditions \eqref{eq:sum=0}, \eqref{eq:sigmainfinity},
      ++ \eqref{eq:sigma0}, and \eqref{eq:productsquare} in qeta.tex.
      ++ It is an error if pure?(x) is false.
    modularGamma0?: % -> Boolean
      ++ modularGamma0?(x) returns true iff x corresponds to a
      ++ eta-quotient that is a modular function for
      ++ Gamma_0(level(x)). It is equivalent to
      ++ zero?(modularGamma0(x)).
    modularGamma1: % -> Z
      ++ modularGamma1(x) returns 0 if the parameters specify a
      ++ generalized eta-quotient that is modular for
      ++ Gamma1(level(x)). It returns 1, if condition
      ++ \eqref{eq:generalized-weight} is not met, 2, if condition
      ++ \eqref{eq:generalized-sigmaInfinity} is not met, and 3 if
      ++ condition \eqref{eq:generalized-sigma0} does not hold.
    modularGamma1?: % -> Boolean
      ++ modularGamma1?(x) returns true iff the generalized
      ++ eta-quotient corresponding to x is a modular function for
      ++ Gamma_1(level(x)). It is equivalent to
      ++ zero?(modularGamma1(x)).

    numer: % -> %
      ++ numer(x) returns the part of the specification that
      ++ corresponds to positive exponents.
    denom: % -> %
      ++ denom(x) returns the part of the specification that
      ++ corresponds to negative exponents. It holds:
      ++ x=numer(x)/denom(x).

    dilate: (%, P) -> %
      ++ dilate(x,n) is the respective operation of replacing q by
      ++ q^n. At the same time the level of the specification in
      ++ multiplied by n.

    -- helper functions
    specExponent: LZ -> Z
      ++ If x is a specification and l=[d,g,e] is an element of
      ++ parts(x), then specExponent(l) returns e.
    specIndex: LZ -> LZ
      ++ If x is a specification and l=[d,g,e] is an element of
      ++ parts(x), then specIndex(l) returns [d] if g=-1, and returns
      ++ [d,g] otherwise.
    specDelta: LZ -> P
      ++ If x is a specification and l=[d,g,e] is an element of
      ++ parts(x), then specDelta(l) returns d.
    specSubindex: LZ -> Z
      ++ If x is a specification and l=[d,g,e] is an element of
      ++ parts(x), then specSubindex(l) returns g.

    etaFunctionIndices: P -> INDICES
      ++ etaFunctionIndices(nn) returns the divisors of n as
      ++ indices in the form [[d] for d in divisors nn].
    properGeneralizedEtaFunctionIndices: P -> INDICES
      ++ properGeneralizedEtaFunctionIndices(nn) returns the indices
      ++ of a proper generalized eta-quotient of level nn. The first
      ++ entries of the indices are always nn, i.e, it returns
      ++ [[nn,1],...,[nn,floor(nn/2)]].
    allGeneralizedEtaFunctionIndices: P -> INDICES
      ++ allGeneralizedEtaFunctionIndices(nn) returns all indices that
      ++ can be used. In fact it is the union of
      ++ etaFunctionIndices(nn) and
      ++ properGeneralizedEtaFunctionIndices(d) where d runs over all
      ++ divisors of nn.
    generalizedEtaFunctionIndices: P -> INDICES
      ++ generalizedEtaFunctionIndices(nn) returns all the indices of
      ++ a generalized eta-quotient of level nn (without exponents),
      ++ i.e., it return the list in \eqref{eq:sorted-indices} where
      ++ the 0 in the second argument is removed. To be precise, it
      ++ returns
      ++ [[d1],[d2],...,[dn],[d2,1],...,[d2,f2],...,[dn,1],...,[dn,fn]]
      ++ where di is the i-th positive divisor of nn and
      ++ fi=ceiling(di/2)-1.

    alphaInfinity: (%, %, P, List N) -> Z
      ++ alphaInfinity(sspec,rspec,m,orb) implements the definition
      ++ \eqref{eq:alphabarInfinity} and \eqref{eq:alphaInfinity},
      ++ i.e., the definition of Radu in
      ++ \cite{Radu_RamanujanKolberg_2015},
      ++ DOI=10.1016/j.jsc.2017.02.001,
      ++ http://www.risc.jku.at/publications/download/risc_5338/DancingSambaRamanujan.pdf
      ++ and can also be extracted from from formula (10.4) of
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}
      ++ when the respective cofactor part is taken into account. Note
      ++ that it does not agree with \alpha(t) as defined in
      ++ \cite{ChenDuZhao_FindingModularFunctionsRamanujan_2019}.

  Implementation ==> add
    -- The representation is basically rbar in the form of a sorted
    -- list of [delta,g,e] triples where g=-1 for a specification of a
    -- pure eta-function power specification.
    Rep ==> Record(flevel: P, frpure: LLZ, frtilde: LLZ)
    xx ==> rep x
    yy ==> rep y
    DIVISIBLEBY?(k, z) ==> zero?(z rem k)

    -- creation functions
    etaQuotientSpecification(divs: List P, r: LZ): % ==
        rpure: LLZ := [[d::Z,-1,e] for d in divs for e in r | not zero? e]
        rpure := sort((x:LZ,y:LZ):Boolean +-> x<y, rpure)
        mm: P := asP lcm [specDelta l for l in rpure]
        per [mm, rpure, []]

    etaQuotientSpecification(mm: P, r: LZ): % ==
        divs: List P := DIVISORS mm
        rpure: LLZ := [[d::Z,-1,e] for d in divs for e in r | not zero? e]
        rpure := sort((x:LZ,y:LZ):Boolean +-> x<y, rpure)
        per [mm, rpure, []]

    etaQuotientSpecification(mm: P, rbar: LLZ): % ==
        h: XHashTable(List Z, Z) := table() -- to store index,exponent pairs
        for l in rbar | not empty? l repeat
            d: Z := first l
            d <= 0 or not DIVISIBLEBY?(d, mm) => error "d does not divide level"
            if #l>3 then
                error "etaQuotientSpecification: list length > 3"
            e: Z := 1
            g: Z := -1
            if #l=2 then e := l.2
            if #l=3 then
                g := l.2
                e := l.3
                if g < -1 then error "g<-1 not allowed"
            if 2*g>d then g := d-g
            setelt!(h, [d, g], e + elt(h, [d, g], 0))
        -- Now extract the data from the hashtable.
        rpure: LLZ := empty() -- pure part
        rtilde: LLZ := empty() -- generalized part
        for key in keys h | not zero?(e := h.key) repeat
            d := key.1
            g := key.2
            if g = -1 then
                rpure := cons([d, g, e], rpure)
              else
                rtilde := cons([d, g, e], rtilde)
        rpure  := sort((x:LZ,y:LZ):Boolean +-> x<y, rpure)
        rtilde := sort((x:LZ,y:LZ):Boolean +-> x<y, rtilde)
        per [mm, rpure, rtilde]

    purify(x: %): % ==
        mm: P := level x
        h: XHashTable(LZ, Z) := table() -- to store index,exponent pairs
        for l in parts x | not empty? l repeat
            d: Z := specDelta l
            d <= 0 or not DIVISIBLEBY?(d, mm) => error "d does not divide level"
            g := specSubindex l -- = -1 for in the pure case
            e := specExponent l
            g = -1 => h.[d,g] := elt(h, [d,g], 0) + e -- iterate
            g := positiveRemainder(g, d)
            if 2*g > d then g := d - g
            --Note that \eta_{2g,g}(t)=\eta(g*t)^2/\eta(2*g*t)^2.
            d = 2*g => -- iterate
                h.[d,-1] := elt(h, [d,-1], 0) - 2*e -- Note that here i=mm*2*g.
                h.[g,-1] := elt(h, [g,-1], 0) + 2*e
            -- Note that \eta_{\delta,0}(\tau)=\eta(\delta\tau)^2.
            zero? g => h.[d,-1] := elt(h, [d,-1], 0) + 2*e
            h.[d,g] := elt(h, [d,g], 0) + e
        -- Now extract the data from the hashtable.
        for idx in keys h repeat
            if not zero?(z := h.idx) then
                l: LZ := concat(idx,z)
                if idx.2 = -1 then rpure: LLZ  := cons(l, rpure)
                              else rtilde: LLZ := cons(l, rtilde)
        rpure  := sort((a:LZ,b:LZ):Boolean +-> a<b, rpure)
        rtilde := sort((a:LZ,b:LZ):Boolean +-> a<b, rtilde)
        per [mm, rpure, rtilde]

    etaQuotientSpecification(rbar: LLZ): % ==
        empty? rbar => 1
        mm: P := asP lcm [first l for l in rbar]
        etaQuotientSpecification(mm, rbar)

    etaQuotientSpecification(mm: P, idxs: INDICES, le: LZ): % ==
        #idxs < #le => --
            error "etaQuotientSpecification: exponent list too long"
        rbar: LLZ := empty()
        for e in le for i in idxs repeat
            if not zero? e then rbar := cons(concat(i, e), rbar)
        etaQuotientSpecification(mm, rbar)

    -- accessor functions
    level(x: %): P == xx.flevel
    -- divisors(x: %): List P == xx.fdivisors
    pureParts(x: %): LLZ == xx.frpure
    properGeneralizedParts(x: %): LLZ == xx.frtilde
    parts(x: %): LLZ == concat(xx.frpure, xx.frtilde)

    allPureExponents(x: %): List Z ==
       divs: List P := DIVISORS level x
       h: XHashTable(Z, Z) := table()
       for l in pureParts x repeat h(specDelta l) := specExponent l
       [elt(h, d, 0) for d in divs]

    pureExponents(x: %): List Z == -- remove zero entries from the end
       r: LZ := reverse! allPureExponents x
       while not empty? r and zero? first r repeat r := rest r
       reverse! r

    pure?(x: %): Boolean == empty? properGeneralizedParts x

    -- SetCategory functions
    coerce(x: %): OutputForm ==
        rpure: LLZ :=[[specDelta(l)::Z, specExponent l] for l in pureParts x]
        concat(rpure, properGeneralizedParts x)::OutputForm
    hashUpdate!(h: HashState, x: %): HashState ==
        import from Z, LZ, LLZ
        h := hashUpdate!(h, xx.flevel)
        h := hashUpdate!(h, xx.frpure)
        h := hashUpdate!(h, xx.frtilde)
        h
    ((x: %) = (y: %)): Boolean ==
        xx.flevel ~= yy.flevel => false
        xx.frpure ~= yy.frpure => false
        xx.frtilde = yy.frtilde

    -- local
    fractionalPart(x: Q): Q == -- local function
        d: Z := denom x
        positiveRemainder(numer x, d)/d

    -- local
    fractionalBernoulli2(x: Q): Q ==
        t: Q := fractionalPart x
        t^2 - t + 1/6

    sigmaInfinityPure(x: %): Z ==
        res: Z := 0
        for l in pureParts x repeat res := res + specDelta(l) * specExponent(l)
        res

    sigmaInfinityProperGeneralized(x: %): Q ==
        res: Q := 0
        for l in properGeneralizedParts x repeat --assert(#l=3)
            d := specDelta l; g := specSubindex l; e := specExponent l
            res := res + d * e * fractionalBernoulli2(g/d)
        res

    sigmaInfinity(x: %): Q ==
        sigmaInfinityPure(x)::Q + 12*sigmaInfinityProperGeneralized x

    sigma0Pure(x: %): Z ==
        mm: Z := level x
        res: Z := 0
        for l in pureParts x repeat
            res := res + specExponent(l) * ((mm exquo specDelta(l))::Z)
        res

    sigma0ProperGeneralized(x): Z ==
        mm: Z := level x
        res: Z := 0
        for l in properGeneralizedParts x repeat --assert(#l=3)
            res := res + specExponent(l) * ((mm exquo specDelta(l))::Z)
        res

    sigma0(x: %): Z == sigma0Pure x + 2*sigma0ProperGeneralized x

    -- These are the conditions (1) to (4) of
    -- \cite{HemmeckeRadu_EtaRelations_2019} that have to be fulfilled
    -- by a vector r to lie in R^*(N).
    modularGamma0(x: %): Z ==
        not pure? x => error "specification is not for a pure eta-quotient"
        -- conditions in modularGamma1 are identical
        z: Z := modularGamma1 x -- sic!
        not zero? z => z
        -- Test condition (4) or \eqref{eq:productsquare}
        c: Factored Z := 1
        for l in pureParts x repeat
            c := c * factor(specDelta l)^asN(abs specExponent l)
        for fe in factors c repeat if odd?(fe.exponent) then return 4
        return 0

    modularGamma0?(x: %): Boolean == zero? modularGamma0 x

    modularGamma1(x: %): Z ==
        w: Z := 0
        for l in pureParts x repeat w := w + specExponent l
        not zero? w => 1 -- non-zero weight
        -- order at inifinity is an integer
        rhat: Q := sigmaInfinity x
        not one? denom rhat or not DIVISIBLEBY?(24, numer rhat) => 2
        -- order at 0 is an integer
        not DIVISIBLEBY?(24, sigma0 x) => 3
        return 0 -- modular function for Gamma1(nn)

    modularGamma1?(x: %): Boolean == zero? modularGamma1 x

    -- SemiGroup functions
    1: % == per [1, [], []]
    one?(x: %): Boolean == empty? xx.frpure and empty? xx.frtilde
    ((x: %) * (y: %)): % ==
        mm: P := asP lcm(level x, level y)
        rbar: LLZ := concat(parts x, parts y)
        etaQuotientSpecification(mm, rbar)
    ((x: %) ^ (z: Z)): % ==
        mm: P := level x
        rbar: LLZ := [[specDelta(l)::Z, specSubindex l, z*specExponent l]_
                      for l in parts x]
        etaQuotientSpecification(mm, rbar)
    inv(x: %): % ==
        mm: P := level x
        rbar: LLZ := [[specDelta(l)::Z, specSubindex l, - specExponent l]_
                      for l in parts x]
        etaQuotientSpecification(mm, rbar)

    numer(x: %): % ==
        mm: P := level x
        rbar: LLZ := [[specDelta(l)::Z, specSubindex l, e]_
                      for l in parts x | (e := specExponent l) > 0]
        etaQuotientSpecification(mm, rbar)

    denom(x: %): % == -- numer(x)/x
        mm: P := level x
        rbar: LLZ := [[specDelta(l)::Z, specSubindex l, - e]_
                      for l in parts x | (e := specExponent l) < 0]
        etaQuotientSpecification(mm, rbar)

    dilate(x: %, n: P): % ==
        rbar: LLZ := [(g:=specSubindex l; if g>0 then g:=n*g;_
                       [n*specDelta l, g, specExponent l])_
                      for l in parts x]
        etaQuotientSpecification(n*level x, rbar)

    specExponent(l: LZ): Z == last l
    specIndex(l: LZ): LZ == if specSubindex l = -1 then [l.1] else [l.1, l.2]
    specDelta(l: LZ): P == asP first l
    specSubindex(l: LZ): Z == l.2

    etaFunctionIndices(nn: P): INDICES == [[d::Z] for d in DIVISORS(nn)]
    properGeneralizedEtaFunctionIndices(nn: P): INDICES ==
        [[nn,i] for i in 0.. floor(nn /$Q 2)]
    allGeneralizedEtaFunctionIndices(nn: P): INDICES ==
        ll := [properGeneralizedEtaFunctionIndices d for d in DIVISORS nn]
        concat cons(etaFunctionIndices nn, ll)
    generalizedEtaFunctionIndices(nn: P): LLZ ==
        nndivs: List P := DIVISORS nn
        indices: List List Z := empty()
        for d in nndivs repeat indices := cons([d], indices)
        for d in nndivs repeat
            for g in 1..ceiling(d/2)$Q-1 repeat indices := cons([d, g], indices)
        reverse! indices

    alphaInfinity(sspec: %, rspec: %, m: P, orb: List N): Z ==
        sbarhat: Q := sigmaInfinity sspec
        rbarhat: Q := sigmaInfinity rspec
        l: List Q := [24*k::Q + rbarhat for k in orb]
        orbsumrbarhat: Q := reduce(_+, l, 0)
        alpha: Q := (1/24)*(sbarhat + (1/m)*orbsumrbarhat)
        not one? denom alpha => error "alpha not an integer"
        return numer alpha




)if LiterateDoc
%$
\bibliography{qeta}
\end{document}
)endif
