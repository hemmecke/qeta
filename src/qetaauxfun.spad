-------------------------------------------------------------------
---
--- FriCAS QEta
--- Copyright (C) 2018-2022  Ralf Hemmecke <ralf@hemmecke.org>
---
-------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------

)if LiterateDoc
\documentclass{article}
\usepackage{qeta}
\externaldocument{qeta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Auxiliary functions for modular functions}
\author{Ralf Hemmecke}
\date{26-Jan-2018}
\maketitle
\begin{abstract}
  The packages \code{QEtaAuxiliaryFunctions} contains helper functions
  for transformations of eta-quotients.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indroduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $N$ be a positive natural number and $\Gamma_0(N)$ be as defined
in \eqref{eq:Gamma0}.

This file contains code to compute a (finite) monoid basis for
$E^\infty(N)$.

This file contains code to compute a (finite) monoid basis for
$GE^\infty(N)$ (the generalized eta-quotients that are modular for
$\Gamma_1(N)$).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Helper macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us start with a few common macros.

First of all for debugging.
)endif
OF==>OutputForm
display77(x) ==> display((x::OF)::Formatter(Format1D))
yof x ==> x :: Symbol :: OF
dbgPrint(x,y) ==> display77([yof ":> ", yof x, y::OF]$List(OF))
tracePrint(x,y) ==> display77(hconcat([yof"-- ",yof x,yof":=",y::OF]$List(OF)))
errorPrint(x,y) ==> tracePrint(x,y)

)if LiterateDoc
%$
These two technical macros are necessary to distinguish between Rep
and \%.
)endif

rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)if LiterateDoc
Now some abbreviations for common domains.
)endif

P ==> PositiveInteger
N ==> NonNegativeInteger
Z ==> Integer
Q ==> Fraction Z
MZ ==> Matrix Z -- will be a square matrix
MQ ==> Matrix Q -- matrixEtaOrder
SL2Z ==> MZ -- represents SL_2(Z)
EXGCD ==> Record(coef1: Z, coef2: Z, generator: Z)
Rec ==> Record(red: SL2Z, triang: MZ)
Pol ==> SparseUnivariatePolynomial Z
LZ ==> List Z
LLZ ==> List LZ
INDICES ==> LLZ
SPEC ==> QEtaSpecification
CUSPS1 nn ==> cusps()$CongruenceSubgroupGamma1(nn)
QCONDM0 ==> QEtaConditionsModularGamma0
QCONDM1 ==> QEtaConditionsModularGamma1

INTF ==> IntegerNumberTheoryFunctions
DIVISORS m ==>  [asP d for d in divisors(m)$INTF]

asN x ==> x pretend N
asP x ==> x pretend P

)if LiterateDoc
%$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Package QEtaAuxiliaryPackage: Check modularity of
  eta-quotients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we mainly deal with the sets $R^*(N)$ and $R^\infty(N)$ from
\cite{HemmeckeRadu_EtaRelations_2019}.

The function \code{matrixLigozat} computes the respective matrix $A_N$
whereas \code{modularGamma0} checks which of the conditions for an $r$
vector to correspond to a modular eta-quotient is violated.


)endif

)abbrev package QETAAF QEtaAuxiliaryFunctions
++ QEtaAuxiliaryFunction is an additional helper package for modular
++ functions. In knows about specifications (qetaspec), cusps
++ (qetacusp), GAMMAx (qetagamma), and modular conditions
++ (qetacondmod).
QEtaAuxiliaryFunctions: with
    matrixModularGamma0: P -> MZ
      ++ matrixModularGamma0(nn) returns a matrix mat such that if
      ++ divs:=divisors(nn), n=#divisors(nn) and v is such that
      ++ mat*v=0 then v(1..n) is in R^*(nn), in other words, the
      ++ nullspace of mat "generates" R^*(nn). The first row of mat
      ++ corresponds sum(r.i, i=1..n). The second row of mat
      ++ corresponds to the sum(divs.i*r.i,i=1..n)+24*r(n+1). The
      ++ third row of mat corresponds to the
      ++ sum((nn/divs.i)*r.i,i=1..n)+24*r(n+2). The function computes
      ++ matrix B_N (equation (8) from
      ++ \cite{HemmeckeRadu_EtaRelations_2019}
      ++ \url{http://www.risc.jku.at/publications/download/risc_5561/etarelations.pdf}
      ++ (DOI:10.1016/j.jsc.2018.10.001). matrixModularGamma0(nn)
      ++ returns a
      ++ matrixModularGamma0(nn,idxs)$QEtaConditionsModularGamma0 for
      ++ idxs:=etaFunctionIndices(nn).
    matrixModularGamma1: P -> MQ
      ++ matrixModularGamma1(nn) returns
      ++ matrixModular(nn,idxs)$QEtaConditionsModularGamma1 for
      ++ idxs:=generalizedEtaFunctionIndices(nn).
    matrixLigozatModularGamma0: (P, List Z) -> MZ
      ++ matrixLigozatModularGamma0(nn, idivs) returns a matrix mat which
      ++ is a vertical concatenation (a part of) matrixLigozat(nn)
      ++ whose rowindices correspond to idivs and
      ++ matrixModularGamma0(nn).
      ++ It computes matrix B_N equation (8) in
      ++ \cite{HemmeckeRadu_EtaRelations_2019}
      ++ (DOI:10.1016/j.jsc.2018.10.001) put below the respective rows
      ++ of matrix A_N from the same article.
    matrixEtaOrder: P -> MQ
      ++ matrixEtaOrder(nn) returns matrixEtaOrder(nn,spitzen,idxs)
      ++ where spitzen:=cusps()$CongruenceSubgroupGamma1(nn) and
      ++ idxs:=generalizedEtaFunctionIndices(nn).
    matrixEtaOrderModularGamma1: (P, List Cusp, INDICES) -> MQ
      ++ matrixEtaOrderModularGamma1(nn,spitzen,idxs) returns the
      ++ vertical concatenation of matrixEtaOrder(nn,spitzen,idxs) and
      ++ matrixModularGamma1(nn,idxs) so that there will be #spitzen+3
      ++ rows and ncols(matrixModularGamma1 nn) columns.
    matrixEtaOrderModularGamma1: (P, List Cusp) -> MQ
      ++ matrixEtaOrderModularGamma1(nn, spitzen) returns
      ++ matrixEtaOrderModularGamma1(nn, spitzen, idxs) where
      ++ idxs:=generalizedEtaFunctionIndices(nn).
  == add

    matrixModularGamma0(nn: P): MZ ==
        matQ := matrixModular(nn, etaFunctionIndices(nn)$SPEC)$QCONDM0
        mat: MZ := new(nrows matQ, ncols matQ, 0)
        for i in 1..nrows matQ repeat for j in 1..ncols matQ repeat
            qsetelt!(mat, i, j, numer qelt(matQ, i, j))
        mat

    matrixModularGamma1(nn: P): MQ ==
        matrixModular(nn, generalizedEtaFunctionIndices(nn)$SPEC)$QCONDM1

    matrixLigozatModularGamma0(nn: P, idivs: List Z): MZ ==
        matmod0Q: MQ := matrixModular(nn, etaFunctionIndices(nn)$SPEC)$QCONDM0
        matLigozat: MZ := matrixLigozat(nn)$QCONDM0 -- is a square matrix
        l: N := ncols matLigozat
        n: N := # idivs
        rows: N := nrows matmod0Q
        cols: N := ncols matmod0Q
        mat: MZ := new(rows + n, cols, 0)
        for i in idivs for k in 1..n repeat for j in 1..l repeat
            qsetelt!(mat, k, j, qelt(matLigozat, i, j))
        for i in 1..rows repeat for j in 1..cols repeat
            qsetelt!(mat, n+i, j, numer qelt(matmod0Q, i, j))
        return mat

    matrixEtaOrder(nn: P): MQ ==
        idxs: INDICES := generalizedEtaFunctionIndices(nn)$SPEC
        matrixEtaOrder(nn, CUSPS1 nn, idxs)$QCONDM1

    matrixEtaOrderModularGamma1(nn: P, spitzen: List Cusp, idxs: INDICES): MQ ==
        matmod1 := matrixModular(nn, idxs)$QCONDM1
        matord := matrixEtaOrder(nn, spitzen, idxs)$QCONDM1
        m := nrows matord
        mat: MQ := new(m+3, ncols matmod1, 0)
        --assert(nrows(matmod1)=3)
        --assert(ncols matord + 2 = ncols matmod1)
        for i in 1..m repeat
            for j in 1..ncols matord repeat
                qsetelt!(mat, i, j, matord(i, j))
        for i in 1..3 repeat
            for j in 1..ncols matmod1 repeat
                qsetelt!(mat, m+i, j, matmod1(i, j))
        return mat

    matrixEtaOrderModularGamma1(nn: P, spitzen: List Cusp): MQ ==
        idxs := generalizedEtaFunctionIndices(nn)$SPEC
        matrixEtaOrderModularGamma1(nn, spitzen, idxs)































)if LiterateDoc
%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unused Package QAuxiliaryModularPackage: Annihilate
leading coefficients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Add $p$-multiples of original generators in order to reduce the
order of the series. Return the respective (adjustment) polynomial.

)endif

)if UNUSED

--)abbrev package QAUXMOD QAuxiliaryModularPackage
QAuxiliaryModularPackage(L): Exports == Implementation where
  L: QEtaLaurentSeriesCategory Z
  ZX ==> Polynomial Z
  VZ ==> Vector Z
  term x ==> monomial(1, degree x)$ZX
  lc x ==> leadingCoefficient x
  Exports ==> with
    annihilateCoefficients: (P, List ZX, ZX -> L) -> ZX -> ZX
    annihilateLeadingCoefficients: (P, ZX -> L) -> ZX -> ZX
      ++ annihilateLeadingCoefficients(p, ev)(pol) adds a p-multiple
      ++ to any monomial of pol and returns a polynomial z such that
      ++ the evaluation order ev(z) >= order ev(pol) and the order
      ++ of ev(z) is as big as it can be made by varying each of the
      ++ monomials, i.e. we expect
      ++ order(ev z) = order(ev pol) + #monomials(pol) - 1.
      ++ The polynomial pol is assumed to be nonzero.
  Implementation ==> add
    annihilateCoefficients(p: P, mons: List ZX, ev: ZX -> L): ZX -> ZX ==
      (pol: ZX): ZX +->
        --assert(not zero? pol)
        ll: L := ev pol
        zero? ll => primitivePart pol
        ls: List L := [ev term x for x in mons]
        ords: List Z := [order(l, 1) for l in ls]
        o: Z := min ords
        nmons: N := # mons      -- number of variables
        for neqs in nmons..1 by -1 repeat
            mat: MZ := new(neqs, nmons, 0)
            v: VZ := new(neqs, 0)
            for i in 1..neqs repeat -- number of equations
                v.i := - coefficient(ll, o+i-1)
                for j in 1..nmons for l in ls repeat -- number of coefficients
                    mat(i, j) := p*coefficient(l, o+i-1)
            sol := diophantineSystem(mat, v)$SmithNormalForm(Z, VZ, VZ, MZ)
            if sol.particular case VZ then
                s := (sol.particular) :: VZ
                adjust := [p*c*term(x) for c in members s for x in mons]
                z := pol + reduce(_+, adjust, 0)
                ll := ev z
                c: Z := coefficient(ll, 0) quo p
                z := z - p*c*1$ZX
                zero? ev z => return primitivePart z
                -- divide by primes not in p
                c := content z
                primesp := [x.factor for x in factorList factor p]
                for x in primesp repeat
                    while zero? positiveRemainder(c, x) repeat
                        c := (c exquo x)::Z
                return (z exquo c)::ZX
        tracePrint("annihilateLeadingCoefficients", "nothing annihilated"::Symbol)
        return primitivePart pol

    annihilateLeadingCoefficients(p: P, ev: ZX -> L): ZX -> ZX ==
      (pol: ZX): ZX +->
        --assert(not zero? pol)
        mons: List ZX := monomials pol
        tracePrint("mons", [term(x) for x in mons])
        annihilateCoefficients(p, mons, ev)(pol)

)endif


)if LiterateDoc
%$
\bibliography{qeta}
\end{document}
)endif
